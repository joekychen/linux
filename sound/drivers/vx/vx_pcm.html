<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › drivers › vx › vx_pcm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vx_pcm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for Digigram VX soundcards</span>
<span class="cm"> *</span>
<span class="cm"> * PCM part</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002,2003 by Takashi Iwai &lt;tiwai@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * STRATEGY</span>
<span class="cm"> *  for playback, we send series of &quot;chunks&quot;, which size is equal with the</span>
<span class="cm"> *  IBL size, typically 126 samples.  at each end of chunk, the end-of-buffer</span>
<span class="cm"> *  interrupt is notified, and the interrupt handler will feed the next chunk.</span>
<span class="cm"> *</span>
<span class="cm"> *  the current position is calculated from the sample count RMH.</span>
<span class="cm"> *  pipe-&gt;transferred is the counter of data which has been already transferred.</span>
<span class="cm"> *  if this counter reaches to the period size, snd_pcm_period_elapsed() will</span>
<span class="cm"> *  be issued.</span>
<span class="cm"> *</span>
<span class="cm"> *  for capture, the situation is much easier.</span>
<span class="cm"> *  to get a low latency response, we&#39;ll check the capture streams at each</span>
<span class="cm"> *  interrupt (capture stream has no EOB notification).  if the pending</span>
<span class="cm"> *  data is accumulated to the period size, snd_pcm_period_elapsed() is</span>
<span class="cm"> *  called and the pointer is updated.</span>
<span class="cm"> *</span>
<span class="cm"> *  the current point of read buffer is kept in pipe-&gt;hw_ptr.  note that</span>
<span class="cm"> *  this is in bytes.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * TODO</span>
<span class="cm"> *  - linked trigger for full-duplex mode.</span>
<span class="cm"> *  - scheduled action on the stream.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/asoundef.h&gt;</span>
<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/vx_core.h&gt;</span>
<span class="cp">#include &quot;vx_cmd.h&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * read three pending pcm bytes via inb()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_pcm_read_per_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffer_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffer_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffer_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_set_pcx_time - convert from the PC time to the RMH status time.</span>
<span class="cm"> * @pc_time: the pointer for the PC-time to set</span>
<span class="cm"> * @dsp_time: the pointer for RMH status time array</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_set_pcx_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">pcx_time_t</span> <span class="o">*</span><span class="n">pc_time</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dsp_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dsp_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="o">*</span><span class="n">pc_time</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PCX_TIME_HI_MASK</span><span class="p">;</span>
	<span class="n">dsp_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">pc_time</span><span class="p">)</span> <span class="o">&amp;</span>  <span class="n">MASK_DSP_WORD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_set_differed_time - set the differed time if specified</span>
<span class="cm"> * @rmh: the rmh record to modify</span>
<span class="cm"> * @pipe: the pipe to be checked</span>
<span class="cm"> *</span>
<span class="cm"> * if the pipe is programmed with the differed time, set the DSP time</span>
<span class="cm"> * on the rmh and changes its command length.</span>
<span class="cm"> *</span>
<span class="cm"> * returns the increase of the command length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_set_differed_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_rmh</span> <span class="o">*</span><span class="n">rmh</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Update The length added to the RMH command by the timestamp */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">differed_type</span> <span class="o">&amp;</span> <span class="n">DC_DIFFERED_DELAY</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		
	<span class="cm">/* Set the T bit */</span>
	<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">DSP_DIFFERED_COMMAND_MASK</span><span class="p">;</span>

	<span class="cm">/* Time stamp is the 1st following parameter */</span>
	<span class="n">vx_set_pcx_time</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">pcx_time</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="cm">/* Add the flags to a notified differed command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">differed_type</span> <span class="o">&amp;</span> <span class="n">DC_NOTIFY_DELAY</span><span class="p">)</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">NOTIFY_MASK_TIME_HIGH</span> <span class="p">;</span>

	<span class="cm">/* Add the flags to a multiple differed command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">differed_type</span> <span class="o">&amp;</span> <span class="n">DC_MULTIPLE_DELAY</span><span class="p">)</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">MULTIPLE_MASK_TIME_HIGH</span><span class="p">;</span>

	<span class="cm">/* Add the flags to a stream-time differed command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">differed_type</span> <span class="o">&amp;</span> <span class="n">DC_STREAM_TIME_DELAY</span><span class="p">)</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">STREAM_MASK_TIME_HIGH</span><span class="p">;</span>
		
	<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">LgCmd</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_set_stream_format - send the stream format command</span>
<span class="cm"> * @pipe: the affected pipe</span>
<span class="cm"> * @data: format bitmask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_set_stream_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span> <span class="o">?</span>
		    <span class="n">CMD_FORMAT_STREAM_IN</span> <span class="o">:</span> <span class="n">CMD_FORMAT_STREAM_OUT</span><span class="p">);</span>
	<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="n">FIELD_SIZE</span><span class="p">;</span>

        <span class="cm">/* Command might be longer since we may have to add a timestamp */</span>
	<span class="n">vx_set_differed_time</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>

	<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="n">rmh</span><span class="p">.</span><span class="n">LgCmd</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="n">rmh</span><span class="p">.</span><span class="n">LgCmd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="cm">/*| (datal &amp; 0xFFFF00) &gt;&gt; 8*/</span><span class="p">;</span>
	<span class="n">rmh</span><span class="p">.</span><span class="n">LgCmd</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    
	<span class="k">return</span> <span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_set_format - set the format of a pipe</span>
<span class="cm"> * @pipe: the affected pipe</span>
<span class="cm"> * @runtime: pcm runtime instance to be referred</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_set_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header</span> <span class="o">=</span> <span class="n">HEADER_FMT_BASE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">header</span> <span class="o">|=</span> <span class="n">HEADER_FMT_MONO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_pcm_format_little_endian</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">))</span>
		<span class="n">header</span> <span class="o">|=</span> <span class="n">HEADER_FMT_INTEL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">&lt;</span> <span class="mi">32000</span> <span class="o">&amp;&amp;</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">11025</span><span class="p">)</span>
		<span class="n">header</span> <span class="o">|=</span> <span class="n">HEADER_FMT_UPTO32</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">&lt;=</span> <span class="mi">11025</span><span class="p">)</span>
		<span class="n">header</span> <span class="o">|=</span> <span class="n">HEADER_FMT_UPTO11</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">snd_pcm_format_physical_width</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>case 8: break;</p></td><td class="code"><div class="highlight"><pre>	<span class="k">case</span> <span class="mi">16</span>: <span class="n">header</span> <span class="o">|=</span> <span class="n">HEADER_FMT_16BITS</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">24</span>: <span class="n">header</span> <span class="o">|=</span> <span class="n">HEADER_FMT_24BITS</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">default</span> <span class="o">:</span> 
		<span class="n">snd_BUG</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="p">};</span>

	<span class="k">return</span> <span class="n">vx_set_stream_format</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set / query the IBL size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_set_ibl</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_ibl_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_IBL</span><span class="p">);</span>
	<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="mh">0x03ffff</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">max_size</span> <span class="o">=</span> <span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">min_size</span> <span class="o">=</span> <span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">granularity</span> <span class="o">=</span> <span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_set_ibl: size = %d, max = %d, min = %d, gran = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">min_size</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">granularity</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_get_pipe_state - get the state of a pipe</span>
<span class="cm"> * @pipe: the pipe to be checked</span>
<span class="cm"> * @state: the pointer for the returned state</span>
<span class="cm"> *</span>
<span class="cm"> * checks the state of a given pipe, and stores the state (1 = running,</span>
<span class="cm"> * 0 = paused) on the given pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * called from trigger callback only</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_get_pipe_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_PIPE_STATE</span><span class="p">);</span>
	<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span> <span class="cm">/* no lock needed for trigger */</span> 
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">err</span><span class="p">)</span>
		<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_query_hbuffer_size - query available h-buffer size in bytes</span>
<span class="cm"> * @pipe: the pipe to be checked</span>
<span class="cm"> *</span>
<span class="cm"> * return the available size on h-buffer in bytes,</span>
<span class="cm"> * or a negative error code.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: calling this function always switches to the stream mode.</span>
<span class="cm"> *       you&#39;ll need to disconnect the host to get back to the</span>
<span class="cm"> *       normal mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_query_hbuffer_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_SIZE_HBUFFER</span><span class="p">);</span>
	<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">)</span>
		<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x00000001</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">result</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_pipe_can_start - query whether a pipe is ready for start</span>
<span class="cm"> * @pipe: the pipe to be checked</span>
<span class="cm"> *</span>
<span class="cm"> * return 1 if ready, 0 if not ready, and negative value on error.</span>
<span class="cm"> *</span>
<span class="cm"> * called from trigger callback only</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pipe_can_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>
        
	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_CAN_START_PIPE</span><span class="p">);</span>
	<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span> <span class="cm">/* no lock needed for trigger */</span> 
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_conf_pipe - tell the pipe to stand by and wait for IRQA.</span>
<span class="cm"> * @pipe: the pipe to be configured</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_conf_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_CONF_PIPE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">)</span>
		<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">COMMAND_RECORD_MASK</span><span class="p">;</span>
	<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span> <span class="cm">/* no lock needed for trigger */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_send_irqa - trigger IRQA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_send_irqa</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_SEND_IRQA</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span> <span class="cm">/* no lock needed for trigger */</span> 
<span class="p">}</span>


<span class="cp">#define MAX_WAIT_FOR_DSP        250</span>
<span class="cm">/*</span>
<span class="cm"> * vx boards do not support inter-card sync, besides</span>
<span class="cm"> * only 126 samples require to be prepared before a pipe can start</span>
<span class="cm"> */</span>
<span class="cp">#define CAN_START_DELAY         2	</span><span class="cm">/* wait 2ms only before asking if the pipe is ready*/</span><span class="cp"></span>
<span class="cp">#define WAIT_STATE_DELAY        2	</span><span class="cm">/* wait 2ms after irqA was requested and check if the pipe state toggled*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * vx_toggle_pipe - start / pause a pipe</span>
<span class="cm"> * @pipe: the pipe to be triggered</span>
<span class="cm"> * @state: start = 1, pause = 0</span>
<span class="cm"> *</span>
<span class="cm"> * called from trigger callback only</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_toggle_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cur_state</span><span class="p">;</span>

	<span class="cm">/* Check the pipe is not already in the requested state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vx_get_pipe_state</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_state</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">cur_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If a start is requested, ask the DSP to get prepared</span>
<span class="cm">	 * and wait for a positive acknowledge (when there are</span>
<span class="cm">	 * enough sound buffer for this pipe)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_WAIT_FOR_DSP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">vx_pipe_can_start</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* Wait for a few, before asking again</span>
<span class="cm">			 * to avoid flooding the DSP with our requests</span>
<span class="cm">			 */</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
    
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_conf_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_irqa</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    
	<span class="cm">/* If it completes successfully, wait for the pipes</span>
<span class="cm">	 * reaching the expected state before returning</span>
<span class="cm">	 * Check one pipe only (since they are synchronous)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_WAIT_FOR_DSP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vx_get_pipe_state</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_state</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cur_state</span> <span class="o">==</span> <span class="n">state</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

    
<span class="cm">/*</span>
<span class="cm"> * vx_stop_pipe - stop a pipe</span>
<span class="cm"> * @pipe: the pipe to be stopped</span>
<span class="cm"> *</span>
<span class="cm"> * called from trigger callback only</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_stop_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>
	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_STOP_PIPE</span><span class="p">);</span>
	<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span> <span class="cm">/* no lock needed for trigger */</span> 
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_alloc_pipe - allocate a pipe and initialize the pipe instance</span>
<span class="cm"> * @capture: 0 = playback, 1 = capture operation</span>
<span class="cm"> * @audioid: the audio id to be assigned</span>
<span class="cm"> * @num_audio: number of audio channels</span>
<span class="cm"> * @pipep: the returned pipe instance</span>
<span class="cm"> *</span>
<span class="cm"> * return 0 on success, or a negative error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_alloc_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">capture</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">audioid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_audio</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">**</span><span class="n">pipep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_mode</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pipep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_RES_PIPE</span><span class="p">);</span>
	<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">capture</span><span class="p">,</span> <span class="n">audioid</span><span class="p">,</span> <span class="n">num_audio</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c">	// NYI</span>
<span class="c">	if (underrun_skip_sound)</span>
<span class="c">		rmh.Cmd[0] |= BIT_SKIP_SOUND;</span>
<span class="cp">#endif	// NYI</span>
	<span class="n">data_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">uer_bits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_NONAUDIO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">capture</span> <span class="o">&amp;&amp;</span> <span class="n">data_mode</span><span class="p">)</span>
		<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">BIT_DATA_MODE</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* initialize the pipe record */</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pipe</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">pipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* release the pipe */</span>
		<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_FREE_PIPE</span><span class="p">);</span>
		<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">capture</span><span class="p">,</span> <span class="n">audioid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the pipe index should be identical with the audio index */</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">audioid</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span> <span class="o">=</span> <span class="n">capture</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">=</span> <span class="n">num_audio</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">differed_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">pcx_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">data_mode</span> <span class="o">=</span> <span class="n">data_mode</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pipep</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_free_pipe - release a pipe</span>
<span class="cm"> * @pipe: pipe to be released</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_free_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_FREE_PIPE</span><span class="p">);</span>
	<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_start_stream - start the stream</span>
<span class="cm"> *</span>
<span class="cm"> * called from trigger callback only</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_start_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_START_ONE_STREAM</span><span class="p">);</span>
	<span class="n">vx_set_stream_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">vx_set_differed_time</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span> <span class="cm">/* no lock needed for trigger */</span> 
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_stop_stream - stop the stream</span>
<span class="cm"> *</span>
<span class="cm"> * called from trigger callback only</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_stop_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_STOP_STREAM</span><span class="p">);</span>
	<span class="n">vx_set_stream_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span> <span class="cm">/* no lock needed for trigger */</span> 
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * playback hw information</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="n">vx_pcm_playback_hw</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>			<span class="p">(</span><span class="n">SNDRV_PCM_INFO_MMAP</span> <span class="o">|</span> <span class="n">SNDRV_PCM_INFO_INTERLEAVED</span> <span class="o">|</span>
				 <span class="n">SNDRV_PCM_INFO_PAUSE</span> <span class="o">|</span> <span class="n">SNDRV_PCM_INFO_MMAP_VALID</span> <span class="cm">/*|*/</span>
				 <span class="cm">/*SNDRV_PCM_INFO_RESUME*/</span><span class="p">),</span>
	<span class="p">.</span><span class="n">formats</span> <span class="o">=</span>		<span class="p">(</span><span class="cm">/*SNDRV_PCM_FMTBIT_U8 |*/</span>
				 <span class="n">SNDRV_PCM_FMTBIT_S16_LE</span> <span class="o">|</span> <span class="n">SNDRV_PCM_FMTBIT_S24_3LE</span><span class="p">),</span>
	<span class="p">.</span><span class="n">rates</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_RATE_CONTINUOUS</span> <span class="o">|</span> <span class="n">SNDRV_PCM_RATE_8000_48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_min</span> <span class="o">=</span>		<span class="mi">5000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_max</span> <span class="o">=</span>		<span class="mi">48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buffer_bytes_max</span> <span class="o">=</span>	<span class="p">(</span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">),</span>
	<span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span>	<span class="mi">126</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span>	<span class="p">(</span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">),</span>
	<span class="p">.</span><span class="n">periods_min</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_max</span> <span class="o">=</span>		<span class="n">VX_MAX_PERIODS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_size</span> <span class="o">=</span>		<span class="mi">126</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">vx_pcm_delayed_start</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_playback_open - open callback for playback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_playback_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">audio</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">audio</span> <span class="o">&gt;=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_outs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	
	<span class="cm">/* playback pipe may have been already allocated for monitoring */</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">[</span><span class="n">audio</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">pipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not allocated yet */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vx_alloc_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="p">);</span> <span class="cm">/* stereo playback */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">[</span><span class="n">audio</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* open for playback */</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">references</span><span class="o">++</span><span class="p">;</span>

	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="n">subs</span><span class="p">;</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">start_tq</span><span class="p">,</span> <span class="n">vx_pcm_delayed_start</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">subs</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">[</span><span class="n">audio</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">vx_pcm_playback_hw</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="cm">/* align to 4 bytes (otherwise will be problematic when 24bit is used) */</span> 
	<span class="n">snd_pcm_hw_constraint_step</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_BUFFER_BYTES</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">snd_pcm_hw_constraint_step</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_BYTES</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_playback_close - close callback for playback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_playback_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pipe</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">references</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">[</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">vx_free_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_notify_end_of_buffer - send &quot;end-of-buffer&quot; notifier at the given pipe</span>
<span class="cm"> * @pipe: the pipe to notify</span>
<span class="cm"> *</span>
<span class="cm"> * NB: call with a certain lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_notify_end_of_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>  <span class="cm">/* use a temporary rmh here */</span>

	<span class="cm">/* Toggle Dsp Host Interface into Message mode */</span>
	<span class="n">vx_send_rih_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_PAUSE_START_CONNECT</span><span class="p">);</span>
	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_NOTIFY_END_OF_BUFFER</span><span class="p">);</span>
	<span class="n">vx_set_stream_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* Toggle Dsp Host Interface back to sound transfer mode */</span>
	<span class="n">vx_send_rih_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_PAUSE_START_CONNECT</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_playback_transfer_chunk - transfer a single chunk</span>
<span class="cm"> * @subs: substream</span>
<span class="cm"> * @pipe: the pipe to transfer</span>
<span class="cm"> * @size: chunk size in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * transfer a single buffer chunk.  EOB notificaton is added after that.</span>
<span class="cm"> * called from the interrupt handler, too.</span>
<span class="cm"> *</span>
<span class="cm"> * return 0 if ok.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_playback_transfer_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">space</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">space</span> <span class="o">=</span> <span class="n">vx_query_hbuffer_size</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* disconnect the host, SIZE_HBUF command always switches to the stream mode */</span>
		<span class="n">vx_send_rih</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_CONNECT_STREAM_NEXT</span><span class="p">);</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;error hbuffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">space</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vx_send_rih</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_CONNECT_STREAM_NEXT</span><span class="p">);</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="s">&quot;no enough hbuffer space %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">space</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span> <span class="cm">/* XRUN */</span>
	<span class="p">}</span>
		
	<span class="cm">/* we don&#39;t need irqsave here, because this function</span>
<span class="cm">	 * is called from either trigger callback or irq handler</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> 
	<span class="n">vx_pseudo_dma_write</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_notify_end_of_buffer</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="cm">/* disconnect the host, SIZE_HBUF command always switches to the stream mode */</span>
	<span class="n">vx_send_rih_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_CONNECT_STREAM_NEXT</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update the position of the given pipe.</span>
<span class="cm"> * pipe-&gt;position is updated and wrapped within the buffer size.</span>
<span class="cm"> * pipe-&gt;transferred is updated, too, but the size is not wrapped,</span>
<span class="cm"> * so that the caller can check the total transferred size later</span>
<span class="cm"> * (to call snd_pcm_period_elapsed).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_update_pipe_position</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">update</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_STREAM_SAMPLE_COUNT</span><span class="p">);</span>
	<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xfffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">update</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">count</span> <span class="o">-</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">cur_count</span><span class="p">);</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">cur_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">+=</span> <span class="n">update</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">)</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">%=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">transferred</span> <span class="o">+=</span> <span class="n">update</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * transfer the pending playback buffer data to DSP</span>
<span class="cm"> * called from interrupt handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_pcm_playback_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nchunks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">prepared</span> <span class="o">||</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchunks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_pcm_playback_transfer_chunk</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span>
							  <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update the playback position and call snd_pcm_period_elapsed() if necessary</span>
<span class="cm"> * called from interrupt handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_pcm_playback_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_update_pipe_position</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">transferred</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">transferred</span> <span class="o">%=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">;</span>
			<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * start the stream and pipe.</span>
<span class="cm"> * this function is called from tasklet, which is invoked by the trigger</span>
<span class="cm"> * START callback.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_pcm_delayed_start</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*  printk( KERN_DEBUG &quot;DDDD tasklet delayed start jiffies = %ld\n&quot;, jiffies);*/</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_start_stream</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vx: cannot start stream</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_toggle_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vx: cannot start pipe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*   printk( KERN_DEBUG &quot;dddd tasklet delayed start jiffies = %ld \n&quot;, jiffies);*/</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_playback_trigger - trigger callback for playback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_RESUME</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">)</span>
			<span class="n">vx_pcm_playback_transfer</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="cm">/* FIXME:</span>
<span class="cm">		 * we trigger the pipe using tasklet, so that the interrupts are</span>
<span class="cm">		 * issued surely after the trigger is completed.</span>
<span class="cm">		 */</span> 
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">start_tq</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm_running</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_SUSPEND</span>:
		<span class="n">vx_toggle_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">vx_stop_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
		<span class="n">vx_stop_stream</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm_running</span><span class="o">--</span><span class="p">;</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_PUSH</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_toggle_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_RELEASE</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_toggle_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_playback_pointer - pointer callback for playback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">snd_pcm_uframes_t</span> <span class="nf">vx_pcm_playback_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_hw_params - hw_params callback for playback and capture</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_hw_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">hw_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_pcm_lib_alloc_vmalloc_32_buffer</span>
					<span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">params_buffer_bytes</span><span class="p">(</span><span class="n">hw_params</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_hw_free - hw_free callback for playback and capture</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_hw_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_pcm_lib_free_vmalloc_buffer</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_prepare - prepare callback for playback and capture</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">data_mode</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>int max_size, nchunks;</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">data_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">uer_bits</span> <span class="o">&amp;</span> <span class="n">IEC958_AES0_NONAUDIO</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_mode</span> <span class="o">!=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">data_mode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">is_capture</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* IEC958 status (raw-mode) was changed */</span>
		<span class="cm">/* we reopen the pipe */</span>
		<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>
		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;reopen the pipe with data_mode = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data_mode</span><span class="p">);</span>
		<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_FREE_PIPE</span><span class="p">);</span>
		<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_RES_PIPE</span><span class="p">);</span>
		<span class="n">vx_set_pipe_cmd_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_mode</span><span class="p">)</span>
			<span class="n">rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">BIT_DATA_MODE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">data_mode</span> <span class="o">=</span> <span class="n">data_mode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm_running</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">!=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vx: cannot set different clock %d &quot;</span>
			   <span class="s">&quot;from the current %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vx_set_clock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_set_format</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">runtime</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vx_is_pcmcia</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">align</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* 16bit word */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">align</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* 32bit word */</span>
	<span class="p">}</span>

	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">buffer_bytes</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">);</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">);</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set the timestamp */</span>
	<span class="n">vx_update_pipe_position</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="cm">/* clear again */</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">transferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">prepared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * operators for PCM playback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">vx_pcm_playback_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">vx_pcm_playback_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">vx_pcm_playback_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">vx_pcm_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_free</span> <span class="o">=</span>	<span class="n">vx_pcm_hw_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">vx_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">vx_pcm_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">vx_pcm_playback_pointer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_get_vmalloc_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_mmap_vmalloc</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * playback hw information</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="n">vx_pcm_capture_hw</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>			<span class="p">(</span><span class="n">SNDRV_PCM_INFO_MMAP</span> <span class="o">|</span> <span class="n">SNDRV_PCM_INFO_INTERLEAVED</span> <span class="o">|</span>
				 <span class="n">SNDRV_PCM_INFO_PAUSE</span> <span class="o">|</span> <span class="n">SNDRV_PCM_INFO_MMAP_VALID</span> <span class="cm">/*|*/</span>
				 <span class="cm">/*SNDRV_PCM_INFO_RESUME*/</span><span class="p">),</span>
	<span class="p">.</span><span class="n">formats</span> <span class="o">=</span>		<span class="p">(</span><span class="cm">/*SNDRV_PCM_FMTBIT_U8 |*/</span>
				 <span class="n">SNDRV_PCM_FMTBIT_S16_LE</span> <span class="o">|</span> <span class="n">SNDRV_PCM_FMTBIT_S24_3LE</span><span class="p">),</span>
	<span class="p">.</span><span class="n">rates</span> <span class="o">=</span>		<span class="n">SNDRV_PCM_RATE_CONTINUOUS</span> <span class="o">|</span> <span class="n">SNDRV_PCM_RATE_8000_48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_min</span> <span class="o">=</span>		<span class="mi">5000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rate_max</span> <span class="o">=</span>		<span class="mi">48000</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span>		<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buffer_bytes_max</span> <span class="o">=</span>	<span class="p">(</span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">),</span>
	<span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span>	<span class="mi">126</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span>	<span class="p">(</span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">),</span>
	<span class="p">.</span><span class="n">periods_min</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_max</span> <span class="o">=</span>		<span class="n">VX_MAX_PERIODS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fifo_size</span> <span class="o">=</span>		<span class="mi">126</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * vx_pcm_capture_open - open callback for capture</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_capture_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe_out_monitoring</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">audio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">audio</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">audio</span> <span class="o">&gt;=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_ins</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_alloc_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="n">subs</span><span class="p">;</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">start_tq</span><span class="p">,</span> <span class="n">vx_pcm_delayed_start</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">subs</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_pipes</span><span class="p">[</span><span class="n">audio</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="cm">/* check if monitoring is needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_monitor_active</span><span class="p">[</span><span class="n">audio</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">pipe_out_monitoring</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">[</span><span class="n">audio</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">pipe_out_monitoring</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* allocate a pipe */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">vx_alloc_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pipe_out_monitoring</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">[</span><span class="n">audio</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe_out_monitoring</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pipe_out_monitoring</span><span class="o">-&gt;</span><span class="n">references</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* </span>
<span class="cm">		   if an output pipe is available, it&#39;s audios still may need to be </span>
<span class="cm">		   unmuted. hence we&#39;ll have to call a mixer entry point.</span>
<span class="cm">		*/</span>
		<span class="n">vx_set_monitor_level</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_monitor</span><span class="p">[</span><span class="n">audio</span><span class="p">],</span>
				     <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_monitor_active</span><span class="p">[</span><span class="n">audio</span><span class="p">]);</span>
		<span class="cm">/* assuming stereo */</span>
		<span class="n">vx_set_monitor_level</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">audio</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_monitor</span><span class="p">[</span><span class="n">audio</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
				     <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_monitor_active</span><span class="p">[</span><span class="n">audio</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span> 
	<span class="p">}</span>

	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">monitoring_pipe</span> <span class="o">=</span> <span class="n">pipe_out_monitoring</span><span class="p">;</span> <span class="cm">/* default value NULL */</span>

	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">vx_pcm_capture_hw</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>

	<span class="cm">/* align to 4 bytes (otherwise will be problematic when 24bit is used) */</span> 
	<span class="n">snd_pcm_hw_constraint_step</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_BUFFER_BYTES</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">snd_pcm_hw_constraint_step</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_BYTES</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_capture_close - close callback for capture</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_pcm_capture_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe_out_monitoring</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pipe</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_pipes</span><span class="p">[</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pipe_out_monitoring</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">monitoring_pipe</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	  if an output pipe is attached to this input, </span>
<span class="cm">	  check if it needs to be released.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe_out_monitoring</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">pipe_out_monitoring</span><span class="o">-&gt;</span><span class="n">references</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vx_free_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe_out_monitoring</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">[</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">monitoring_pipe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="n">vx_free_pipe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cp">#define DMA_READ_ALIGN	6	</span><span class="cm">/* hardware alignment for read */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_capture_update - update the capture buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_pcm_capture_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">prepared</span> <span class="o">||</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">-</span> <span class="n">snd_pcm_capture_avail</span><span class="p">(</span><span class="n">runtime</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">frames_to_bytes</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">vx_query_hbuffer_size</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">_error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">space</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">space</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* align to 3 bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">DMA_READ_ALIGN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">_error</span><span class="p">;</span>

	<span class="cm">/* keep the last 6 bytes, they will be read after disconnection */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">DMA_READ_ALIGN</span><span class="p">;</span>
	<span class="cm">/* read bytes until the current pointer reaches to the aligned position</span>
<span class="cm">	 * for word-transfer</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span> <span class="o">%</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vx_wait_for_rx_full</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">_error</span><span class="p">;</span>
		<span class="n">vx_pcm_read_per_bytes</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ok, let&#39;s accelerate! */</span>
		<span class="kt">int</span> <span class="n">align</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">align</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">space</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">/</span> <span class="n">align</span><span class="p">)</span> <span class="o">*</span> <span class="n">align</span><span class="p">;</span>
		<span class="n">vx_pseudo_dma_read</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">space</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">space</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* read the rest of bytes */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vx_wait_for_rx_full</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">_error</span><span class="p">;</span>
		<span class="n">vx_pcm_read_per_bytes</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* disconnect the host, SIZE_HBUF command always switches to the stream mode */</span>
	<span class="n">vx_send_rih_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_CONNECT_STREAM_NEXT</span><span class="p">);</span>
	<span class="cm">/* read the last pending 6 bytes */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">DMA_READ_ALIGN</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vx_pcm_read_per_bytes</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* update the position */</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">transferred</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">transferred</span> <span class="o">&gt;=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">period_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">transferred</span> <span class="o">%=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">period_bytes</span><span class="p">;</span>
		<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">_error:</span>
	<span class="cm">/* disconnect the host, SIZE_HBUF command always switches to the stream mode */</span>
	<span class="n">vx_send_rih_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_CONNECT_STREAM_NEXT</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_pcm_capture_pointer - pointer callback for capture</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">snd_pcm_uframes_t</span> <span class="nf">vx_pcm_capture_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bytes_to_frames</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">hw_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * operators for PCM capture</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">vx_pcm_capture_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">vx_pcm_capture_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">vx_pcm_capture_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">vx_pcm_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_free</span> <span class="o">=</span>	<span class="n">vx_pcm_hw_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">vx_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">vx_pcm_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">vx_pcm_capture_pointer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_get_vmalloc_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_mmap_vmalloc</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * interrupt handler for pcm streams</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">vx_pcm_update_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>

<span class="cp">#define EVENT_MASK	(END_OF_BUFFER_EVENTS_PENDING|ASYNC_EVENTS_PENDING)</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EVENT_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">,</span> <span class="n">CMD_ASYNC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">ASYNC_EVENTS_PENDING</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x00000001</span><span class="p">;</span>	<span class="cm">/* SEL_ASYNC_EVENTS */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">END_OF_BUFFER_EVENTS_PENDING</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">.</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x00000002</span><span class="p">;</span>	<span class="cm">/* SEL_END_OF_BUF_EVENTS */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;msg send error!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">.</span><span class="n">LgStat</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">capture</span><span class="p">,</span> <span class="n">eob</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_FIRST_FIELD</span><span class="p">;</span>
			<span class="n">capture</span> <span class="o">=</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x400000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">eob</span> <span class="o">=</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x800000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">ASYNC_EVENTS_PENDING</span><span class="p">)</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* force to transfer */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">END_OF_BUFFER_EVENTS_PENDING</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">eob</span><span class="p">)</span>
					<span class="n">buf</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">capture</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_outs</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">pipe</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span> <span class="o">&amp;&amp;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vx_pcm_playback_update</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
				<span class="n">vx_pcm_playback_transfer</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* update the capture pcm pointers as frequently as possible */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_ins</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pipe</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_pipes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span> <span class="o">&amp;&amp;</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">)</span>
			<span class="n">vx_pcm_capture_update</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">,</span> <span class="n">pipe</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_init_audio_io - check the available audio i/o and allocate pipe arrays</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_init_audio_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_rmh</span> <span class="n">rmh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">preferred</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmh</span><span class="p">,</span> <span class="n">CMD_SUPPORTED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vx_send_msg</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rmh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vx: cannot get the supported audio data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_outs</span> <span class="o">=</span> <span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MASK_FIRST_FIELD</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_ins</span> <span class="o">=</span> <span class="p">(</span><span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">FIELD_SIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">MASK_FIRST_FIELD</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_info</span> <span class="o">=</span> <span class="n">rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* allocate pipes */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_outs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_pipes</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_ins</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_pipe</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_pipes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">preferred</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vx_set_ibl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">);</span> <span class="cm">/* query the info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">preferred</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">((</span><span class="n">preferred</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">granularity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
				  <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">granularity</span><span class="p">)</span> <span class="o">*</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">granularity</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">max_size</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">max_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">min_size</span><span class="p">;</span> <span class="cm">/* set to the minimum */</span>
	<span class="n">vx_set_ibl</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * free callback for pcm</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snd_vx_pcm_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">[</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">playback_pipes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_pipes</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">capture_pipes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * snd_vx_pcm_new - create and initialize a pcm</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_vx_pcm_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_init_audio_io</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">num_codecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">;</span>
		<span class="n">outs</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_outs</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ins</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_ins</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">outs</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">ins</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;VX PCM&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				  <span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">outs</span><span class="p">)</span>
			<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vx_pcm_playback_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ins</span><span class="p">)</span>
			<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vx_pcm_capture_ops</span><span class="p">);</span>

		<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
		<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">private_free</span> <span class="o">=</span> <span class="n">snd_vx_pcm_free</span><span class="p">;</span>
		<span class="n">pcm</span><span class="o">-&gt;</span><span class="n">info_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">pcm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
