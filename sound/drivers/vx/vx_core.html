<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › drivers › vx › vx_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>vx_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Driver for Digigram VX soundcards</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware core part</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002 by Takashi Iwai &lt;tiwai@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/asoundef.h&gt;</span>
<span class="cp">#include &lt;sound/info.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;sound/vx_core.h&gt;</span>
<span class="cp">#include &quot;vx_cmd.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Takashi Iwai &lt;tiwai@suse.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Common routines for Digigram VX drivers&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * vx_check_reg_bit - wait for the specified bit is set/reset on a register</span>
<span class="cm"> * @reg: register to check</span>
<span class="cm"> * @mask: bit mask</span>
<span class="cm"> * @bit: resultant bit to be checked</span>
<span class="cm"> * @time: time-out of loop in msec</span>
<span class="cm"> *</span>
<span class="cm"> * returns zero if a bit matches, or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_vx_check_reg_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">+</span> <span class="mi">999</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SND_DEBUG</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reg_names</span><span class="p">[</span><span class="n">VX_REG_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;ICR&quot;</span><span class="p">,</span> <span class="s">&quot;CVR&quot;</span><span class="p">,</span> <span class="s">&quot;ISR&quot;</span><span class="p">,</span> <span class="s">&quot;IVR&quot;</span><span class="p">,</span> <span class="s">&quot;RXH&quot;</span><span class="p">,</span> <span class="s">&quot;RXM&quot;</span><span class="p">,</span> <span class="s">&quot;RXL&quot;</span><span class="p">,</span>
		<span class="s">&quot;DMA&quot;</span><span class="p">,</span> <span class="s">&quot;CDSP&quot;</span><span class="p">,</span> <span class="s">&quot;RFREQ&quot;</span><span class="p">,</span> <span class="s">&quot;RUER/V2&quot;</span><span class="p">,</span> <span class="s">&quot;DATA&quot;</span><span class="p">,</span> <span class="s">&quot;MEMIRQ&quot;</span><span class="p">,</span>
		<span class="s">&quot;ACQ&quot;</span><span class="p">,</span> <span class="s">&quot;BIT0&quot;</span><span class="p">,</span> <span class="s">&quot;BIT1&quot;</span><span class="p">,</span> <span class="s">&quot;MIC0&quot;</span><span class="p">,</span> <span class="s">&quot;MIC1&quot;</span><span class="p">,</span> <span class="s">&quot;MIC2&quot;</span><span class="p">,</span>
		<span class="s">&quot;MIC3&quot;</span><span class="p">,</span> <span class="s">&quot;INTCSR&quot;</span><span class="p">,</span> <span class="s">&quot;CNTRL&quot;</span><span class="p">,</span> <span class="s">&quot;GPIOC&quot;</span><span class="p">,</span>
		<span class="s">&quot;LOFREQ&quot;</span><span class="p">,</span> <span class="s">&quot;HIFREQ&quot;</span><span class="p">,</span> <span class="s">&quot;CSUER&quot;</span><span class="p">,</span> <span class="s">&quot;RUER&quot;</span>
	<span class="p">};</span>
<span class="cp">#endif</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">snd_vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">bit</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>msleep(10);</p></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">));</span>
	<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_check_reg_bit: timeout, reg=%s, mask=0x%x, val=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_names</span><span class="p">[</span><span class="n">reg</span><span class="p">],</span> <span class="n">mask</span><span class="p">,</span> <span class="n">snd_vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">reg</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">snd_vx_check_reg_bit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * vx_send_irq_dsp - set command irq bit</span>
<span class="cm"> * @num: the requested IRQ type, IRQ_XXX</span>
<span class="cm"> *</span>
<span class="cm"> * this triggers the specified IRQ request</span>
<span class="cm"> * returns 0 if successful, or a negative error code.</span>
<span class="cm"> * </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_send_irq_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nirq</span><span class="p">;</span>

	<span class="cm">/* wait for Hc = 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_vx_check_reg_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">VX_CVR</span><span class="p">,</span> <span class="n">CVR_HC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">nirq</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vx_has_new_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="n">nirq</span> <span class="o">+=</span> <span class="n">VXP_IRQ_OFFSET</span><span class="p">;</span>
	<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">CVR</span><span class="p">,</span> <span class="p">(</span><span class="n">nirq</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CVR_HC</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_reset_chk - reset CHK bit on ISR</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if successful, or a negative error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_reset_chk</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reset irq CHK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vx_send_irq_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_RESET_CHK</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="cm">/* Wait until CHK = 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vx_check_isr</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_CHK</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_transfer_end - terminate message transfer</span>
<span class="cm"> * @cmd: IRQ message to send (IRQ_MESS_XXX_END)</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if successful, or a negative error code.</span>
<span class="cm"> * the error code can be VX-specific, retrieved via vx_get_error().</span>
<span class="cm"> * NB: call with spinlock held!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_transfer_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_reset_chk</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* irq MESS_READ/WRITE_END */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_irq_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Wait CHK = 1 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_CHK</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* If error, Read RX */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">ISR_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_for_rx_full</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;transfer_end: error in rx_full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXM</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXL</span><span class="p">);</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;transfer_end: error = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">VX_ERR_MASK</span> <span class="o">|</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vx_read_status - return the status rmh</span>
<span class="cm"> * @rmh: rmh record to store the status</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if successful, or a negative error code.</span>
<span class="cm"> * the error code can be VX-specific, retrieved via vx_get_error().</span>
<span class="cm"> * NB: call with spinlock held!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_read_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_rmh</span> <span class="o">*</span><span class="n">rmh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* no read necessary? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">DspStat</span> <span class="o">==</span> <span class="n">RMH_SSIZE_FIXED</span> <span class="o">&amp;&amp;</span> <span class="n">rmh</span><span class="o">-&gt;</span><span class="n">LgStat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for RX full (with timeout protection)</span>
<span class="cm">	 * The first word of status is in RX</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_for_rx_full</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Read RX */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXM</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXL</span><span class="p">);</span>

	<span class="cm">/* If status given by DSP, let&#39;s decode its size */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">DspStat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RMH_SSIZE_ARG</span>:
		<span class="n">size</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffff00</span><span class="p">;</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">LgStat</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RMH_SSIZE_MASK</span>:
		<span class="cm">/* Let&#39;s count the arg numbers from a mask */</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
				<span class="n">size</span><span class="o">++</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">LgStat</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* else retrieve the status length given by the driver */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">rmh</span><span class="o">-&gt;</span><span class="n">LgStat</span><span class="p">;</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>  <span class="cm">/* Val is the status 1st word */</span>
		<span class="n">size</span><span class="o">--</span><span class="p">;</span>              <span class="cm">/* hence adjust remaining length */</span>
		<span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">SIZE_MAX_STATUS</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* trigger an irq MESS_WRITE_NEXT */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_irq_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_MESS_WRITE_NEXT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="cm">/* Wait for RX full (with timeout protection) */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_for_rx_full</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Stat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Stat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXM</span><span class="p">)</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">;</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Stat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">vx_transfer_end</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_MESS_WRITE_END</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#define MASK_MORE_THAN_1_WORD_COMMAND   0x00008000</span>
<span class="cp">#define MASK_1_WORD_COMMAND             0x00ff7fff</span>

<span class="cm">/*</span>
<span class="cm"> * vx_send_msg_nolock - send a DSP message and read back the status</span>
<span class="cm"> * @rmh: the rmh record to send and receive</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if successful, or a negative error code.</span>
<span class="cm"> * the error code can be VX-specific, retrieved via vx_get_error().</span>
<span class="cm"> * </span>
<span class="cm"> * this function doesn&#39;t call spinlock at all.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vx_send_msg_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_rmh</span> <span class="o">*</span><span class="n">rmh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_reset_chk</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_send_msg: vx_reset_chk error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printk(KERN_DEBUG &quot;rmh: cmd = 0x%06x, length = %d, stype = %d\n&quot;,</span>
<span class="c">	       rmh-&gt;Cmd[0], rmh-&gt;LgCmd, rmh-&gt;DspStat);</span>
<span class="c">	if (rmh-&gt;LgCmd &gt; 1) {</span>
<span class="c">		printk(KERN_DEBUG &quot;  &quot;);</span>
<span class="c">		for (i = 1; i &lt; rmh-&gt;LgCmd; i++)</span>
<span class="c">			printk(&quot;0x%06x &quot;, rmh-&gt;Cmd[i]);</span>
<span class="c">		printk(&quot;\n&quot;);</span>
<span class="c">	}</span>
<span class="cp">#endif</span>
	<span class="cm">/* Check bit M is set according to length of the command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">LgCmd</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">MASK_MORE_THAN_1_WORD_COMMAND</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">MASK_1_WORD_COMMAND</span><span class="p">;</span>

	<span class="cm">/* Wait for TX empty */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_TX_EMPTY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_send_msg: wait tx empty error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write Cmd[0] */</span>
	<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXH</span><span class="p">,</span> <span class="p">(</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXM</span><span class="p">,</span> <span class="p">(</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXL</span><span class="p">,</span> <span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="cm">/* Trigger irq MESSAGE */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_irq_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_MESSAGE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_send_msg: send IRQ_MESSAGE error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for CHK = 1 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_CHK</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* If error, get error value from RX */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ISR_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_for_rx_full</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_send_msg: rx_full read error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXM</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXL</span><span class="p">);</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;msg got error = 0x%x at cmd[0]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">VX_ERR_MASK</span> <span class="o">|</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Send the other words */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">LgCmd</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rmh</span><span class="o">-&gt;</span><span class="n">LgCmd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Wait for TX ready */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_TX_READY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_send_msg: tx_ready error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Write Cmd[i] */</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXH</span><span class="p">,</span> <span class="p">(</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXM</span><span class="p">,</span> <span class="p">(</span><span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXL</span><span class="p">,</span> <span class="n">rmh</span><span class="o">-&gt;</span><span class="n">Cmd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

			<span class="cm">/* Trigger irq MESS_READ_NEXT */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_irq_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_MESS_READ_NEXT</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_send_msg: IRQ_READ_NEXT error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Wait for TX empty */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_TX_READY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;vx_send_msg: TX_READY error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* End of transfer */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vx_transfer_end</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">IRQ_MESS_READ_END</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">vx_read_status</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">rmh</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_send_msg - send a DSP message with spinlock</span>
<span class="cm"> * @rmh: the rmh record to send and receive</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if successful, or a negative error code.</span>
<span class="cm"> * see vx_send_msg_nolock().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vx_send_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vx_rmh</span> <span class="o">*</span><span class="n">rmh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">rmh</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_send_rih_nolock - send an RIH to xilinx</span>
<span class="cm"> * @cmd: the command to send</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if successful, or a negative error code.</span>
<span class="cm"> * the error code can be VX-specific, retrieved via vx_get_error().</span>
<span class="cm"> *</span>
<span class="cm"> * this function doesn&#39;t call spinlock at all.</span>
<span class="cm"> *</span>
<span class="cm"> * unlike RMH, no command is sent to DSP.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vx_send_rih_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printk(KERN_DEBUG &quot;send_rih: cmd = 0x%x\n&quot;, cmd);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_reset_chk</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* send the IRQ */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_irq_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* Wait CHK = 1 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_CHK</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* If error, read RX */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ISR_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_for_rx_full</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXM</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">vx_inb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">RXL</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">VX_ERR_MASK</span> <span class="o">|</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_send_rih - send an RIH with spinlock</span>
<span class="cm"> * @cmd: the command to send</span>
<span class="cm"> *</span>
<span class="cm"> * see vx_send_rih_nolock().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vx_send_rih</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_rih_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define END_OF_RESET_WAIT_TIME		500	</span><span class="cm">/* us */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * snd_vx_boot_xilinx - boot up the xilinx interface</span>
<span class="cm"> * @boot: the boot record to load</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_vx_load_boot_image</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">boot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_fillup</span> <span class="o">=</span> <span class="n">vx_has_new_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* check the length of boot image */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boot</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	{</span>
<span class="c">		/* more strict check */</span>
<span class="c">		unsigned int c = ((u32)boot-&gt;data[0] &lt;&lt; 16) | ((u32)boot-&gt;data[1] &lt;&lt; 8) | boot-&gt;data[2];</span>
<span class="c">		if (boot-&gt;size != (c + 2) * 3)</span>
<span class="c">			return -EINVAL;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="cm">/* reset dsp */</span>
	<span class="n">vx_reset_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	
	<span class="n">udelay</span><span class="p">(</span><span class="n">END_OF_RESET_WAIT_TIME</span><span class="p">);</span> <span class="cm">/* another wait? */</span>

	<span class="cm">/* download boot strap */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x600</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">boot</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">no_fillup</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_TX_EMPTY</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dsp boot failed at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="n">boot</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_TX_EMPTY</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dsp boot failed at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXH</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXM</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXL</span><span class="p">,</span> <span class="n">image</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">snd_vx_load_boot_image</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * vx_test_irq_src - query the source of interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * called from irq handler only</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vx_test_irq_src</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vx_init_rmh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">,</span> <span class="n">CMD_TEST_IT</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">vx_send_msg_nolock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_rmh</span><span class="p">.</span><span class="n">Stat</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * vx_interrupt - soft irq handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_interrupt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="p">)</span> <span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vx_test_irq_src</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
    
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	if (events &amp; 0x000800)</span>
<span class="c">		printk(KERN_ERR &quot;DSP Stream underrun ! IRQ events = 0x%x\n&quot;, events);</span>
<span class="cp">#endif</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>printk(KERN_DEBUG "IRQ events = 0x%x\n", events);</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* We must prevent any application using this DSP</span>
<span class="cm">	 * and block any further request until the application</span>
<span class="cm">	 * either unregisters or reloads the DSP</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">FATAL_DSP_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vx_core: fatal DSP error!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The start on time code conditions are filled (ie the time code</span>
<span class="cm">	 * received by the board is equal to one of those given to it).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">TIME_CODE_EVENT_PENDING</span><span class="p">)</span>
		<span class="p">;</span> <span class="cm">/* so far, nothing to do yet */</span>

	<span class="cm">/* The frequency has changed on the board (UER mode). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">FREQUENCY_CHANGE_EVENT_PENDING</span><span class="p">)</span>
		<span class="n">vx_change_frequency</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* update the pcm streams */</span>
	<span class="n">vx_pcm_update_intr</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * snd_vx_irq_handler - interrupt handler</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">snd_vx_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_CHIP_INIT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_IS_STALE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">vx_test_and_ack</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">tq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">snd_vx_irq_handler</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_reset_board</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cold_reset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">reset_board</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* current source, later sync&#39;ed with target */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_source</span> <span class="o">=</span> <span class="n">VX_AUDIO_SRC_LINE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cold_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_source_target</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_source</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">clock_source</span> <span class="o">=</span> <span class="n">INTERNAL_QUARTZ</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">clock_mode</span> <span class="o">=</span> <span class="n">VX_CLOCK_MODE_AUTO</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">=</span> <span class="mi">48000</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">uer_detected</span> <span class="o">=</span> <span class="n">VX_UER_MODE_NOT_PRESENT</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">uer_bits</span> <span class="o">=</span> <span class="n">SNDRV_PCM_DEFAULT_CON_SPDIF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">reset_board</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">cold_reset</span><span class="p">);</span>

	<span class="n">vx_reset_codec</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">cold_reset</span><span class="p">);</span>

	<span class="n">vx_set_internal_clock</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">);</span>

	<span class="cm">/* Reset the DSP */</span>
	<span class="n">vx_reset_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vx_is_pcmcia</span><span class="p">(</span><span class="n">chip</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Acknowledge any pending IRQ and reset the MEMIRQ flag. */</span>
		<span class="n">vx_test_and_ack</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">vx_validate_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* init CBits */</span>
	<span class="n">vx_set_iec958_status</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">uer_bits</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * proc interface</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_proc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_info_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_info_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">audio_src_vxp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Line&quot;</span><span class="p">,</span> <span class="s">&quot;Mic&quot;</span><span class="p">,</span> <span class="s">&quot;Digital&quot;</span> <span class="p">};</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">audio_src_vx2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Analog&quot;</span><span class="p">,</span> <span class="s">&quot;Analog&quot;</span><span class="p">,</span> <span class="s">&quot;Digital&quot;</span> <span class="p">};</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">clock_mode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Auto&quot;</span><span class="p">,</span> <span class="s">&quot;Internal&quot;</span><span class="p">,</span> <span class="s">&quot;External&quot;</span> <span class="p">};</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">clock_src</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Internal&quot;</span><span class="p">,</span> <span class="s">&quot;External&quot;</span> <span class="p">};</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uer_type</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Consumer&quot;</span><span class="p">,</span> <span class="s">&quot;Professional&quot;</span><span class="p">,</span> <span class="s">&quot;Not Present&quot;</span> <span class="p">};</span>
	
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">longname</span><span class="p">);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Xilinx Firmware: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_XILINX_LOADED</span> <span class="o">?</span> <span class="s">&quot;Loaded&quot;</span> <span class="o">:</span> <span class="s">&quot;No&quot;</span><span class="p">);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Device Initialized: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_DEVICE_INIT</span> <span class="o">?</span> <span class="s">&quot;Yes&quot;</span> <span class="o">:</span> <span class="s">&quot;No&quot;</span><span class="p">);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;DSP audio info:&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_info</span> <span class="o">&amp;</span> <span class="n">VX_AUDIO_INFO_REAL_TIME</span><span class="p">)</span>
		<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot; realtime&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_info</span> <span class="o">&amp;</span> <span class="n">VX_AUDIO_INFO_OFFLINE</span><span class="p">)</span>
		<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot; offline&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_info</span> <span class="o">&amp;</span> <span class="n">VX_AUDIO_INFO_MPEG1</span><span class="p">)</span>
		<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot; mpeg1&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_info</span> <span class="o">&amp;</span> <span class="n">VX_AUDIO_INFO_MPEG2</span><span class="p">)</span>
		<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot; mpeg2&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_info</span> <span class="o">&amp;</span> <span class="n">VX_AUDIO_INFO_LINEAR_8</span><span class="p">)</span>
		<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot; linear8&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_info</span> <span class="o">&amp;</span> <span class="n">VX_AUDIO_INFO_LINEAR_16</span><span class="p">)</span>
		<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot; linear16&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_info</span> <span class="o">&amp;</span> <span class="n">VX_AUDIO_INFO_LINEAR_24</span><span class="p">)</span>
		<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot; linear24&quot;</span><span class="p">);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Input Source: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vx_is_pcmcia</span><span class="p">(</span><span class="n">chip</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">audio_src_vxp</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_source</span><span class="p">]</span> <span class="o">:</span>
		    <span class="n">audio_src_vx2</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">audio_source</span><span class="p">]);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Clock Mode: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clock_mode</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">clock_mode</span><span class="p">]);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Clock Source: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clock_src</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">clock_source</span><span class="p">]);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Frequency: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Detected Frequency: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">freq_detected</span><span class="p">);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Detected UER type: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uer_type</span><span class="p">[</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">uer_detected</span><span class="p">]);</span>
	<span class="n">snd_iprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Min/Max/Cur IBL: %d/%d/%d (granularity=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">min_size</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">max_size</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
		    <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ibl</span><span class="p">.</span><span class="n">granularity</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vx_proc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_info_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">snd_card_proc_new</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="s">&quot;vx-status&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">))</span>
		<span class="n">snd_info_set_text_ops</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">vx_proc_read</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * snd_vx_dsp_boot - load the DSP boot</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_vx_dsp_boot</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">boot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cold_reset</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;</span> <span class="n">VX_STAT_DEVICE_INIT</span><span class="p">);</span>

	<span class="n">vx_reset_board</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">cold_reset</span><span class="p">);</span>
	<span class="n">vx_validate_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_vx_load_boot_image</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">boot</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">snd_vx_dsp_boot</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * snd_vx_dsp_load - load the DSP image</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_vx_dsp_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">dsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dsp</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vx_toggle_dac_mute</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Transfert data buffer from PC to DSP */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dsp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">image</span> <span class="o">=</span> <span class="n">dsp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/* Wait DSP ready for a new read */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_TX_EMPTY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;dsp loading error at position %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cptr</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
		<span class="n">csum</span> <span class="o">^=</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="p">(</span><span class="n">csum</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">csum</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXH</span><span class="p">,</span> <span class="o">*</span><span class="n">cptr</span><span class="o">++</span><span class="p">);</span>
		<span class="n">csum</span> <span class="o">^=</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="p">(</span><span class="n">csum</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">csum</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXM</span><span class="p">,</span> <span class="o">*</span><span class="n">cptr</span><span class="o">++</span><span class="p">);</span>
		<span class="n">csum</span> <span class="o">^=</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="p">(</span><span class="n">csum</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">csum</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">vx_outb</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">TXL</span><span class="p">,</span> <span class="o">*</span><span class="n">cptr</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;checksum = 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">vx_wait_isr_bit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">ISR_CHK</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vx_toggle_dac_mute</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">vx_test_and_ack</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">vx_validate_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">snd_vx_dsp_load</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/*</span>
<span class="cm"> * suspend</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_vx_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">snd_power_change_state</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_CTL_POWER_D3hot</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">|=</span> <span class="n">VX_STAT_IN_SUSPEND</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">num_codecs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">snd_pcm_suspend_all</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">pcm</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">snd_vx_suspend</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * resume</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_vx_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VX_STAT_CHIP_INIT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">firmware</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">load_dsp</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">firmware</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vx: firmware resume error at DSP %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">|=</span> <span class="n">VX_STAT_CHIP_INIT</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VX_STAT_IN_SUSPEND</span><span class="p">;</span>

	<span class="n">snd_power_change_state</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span><span class="p">,</span> <span class="n">SNDRV_CTL_POWER_D0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">snd_vx_resume</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * snd_vx_create - constructor for struct vx_core</span>
<span class="cm"> * @hw: hardware specific record</span>
<span class="cm"> *</span>
<span class="cm"> * this function allocates the instance and prepare for the hardware</span>
<span class="cm"> * initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * return the instance pointer if successful, NULL in error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="nf">snd_vx_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_vx_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">snd_vx_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">extra_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vx_core</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">card</span> <span class="o">||</span> <span class="o">!</span><span class="n">hw</span> <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">chip</span><span class="p">)</span> <span class="o">+</span> <span class="n">extra_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vx_core: no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">hw</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">tq</span><span class="p">,</span> <span class="n">vx_interrupt</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">chip</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mixer_mutex</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">card</span> <span class="o">=</span> <span class="n">card</span><span class="p">;</span>
	<span class="n">card</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">shortname</span><span class="p">,</span> <span class="s">&quot;Digigram %s&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">vx_proc_init</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chip</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">snd_vx_create</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * module entries</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">alsa_vx_core_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">alsa_vx_core_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">alsa_vx_core_init</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">alsa_vx_core_exit</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
