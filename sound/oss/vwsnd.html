<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › oss › vwsnd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vwsnd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Sound driver for Silicon Graphics 320 and 540 Visual Workstations&#39;</span>
<span class="cm"> * onboard audio.  See notes in Documentation/sound/oss/vwsnd .</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1999 Silicon Graphics, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#undef VWSND_DEBUG			</span><span class="cm">/* define for debugging */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * XXX to do -</span>
<span class="cm"> *</span>
<span class="cm"> *	External sync.</span>
<span class="cm"> *	Rename swbuf, hwbuf, u&amp;i, hwptr&amp;swptr to something rational.</span>
<span class="cm"> *	Bug - if select() called before read(), pcm_setup() not called.</span>
<span class="cm"> *	Bug - output doesn&#39;t stop soon enough if process killed.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Things to test -</span>
<span class="cm"> *</span>
<span class="cm"> *	Will readv/writev work?  Write a test.</span>
<span class="cm"> *</span>
<span class="cm"> *	insmod/rmmod 100 million times.</span>
<span class="cm"> *</span>
<span class="cm"> *	Run I/O until int ptrs wrap around (roughly 6.2 hours @ DAT</span>
<span class="cm"> *	rate).</span>
<span class="cm"> *</span>
<span class="cm"> *	Concurrent threads banging on mixer simultaneously, both UP</span>
<span class="cm"> *	and SMP kernels.  Especially, watch for thread A changing</span>
<span class="cm"> *	OUTSRC while thread B changes gain -- both write to the same</span>
<span class="cm"> *	ad1843 register.</span>
<span class="cm"> *</span>
<span class="cm"> *	What happens if a client opens /dev/audio then forks?</span>
<span class="cm"> *	Do two procs have /dev/audio open?  Test.</span>
<span class="cm"> *</span>
<span class="cm"> *	Pump audio through the CD, MIC and line inputs and verify that</span>
<span class="cm"> *	they mix/mute into the output.</span>
<span class="cm"> *</span>
<span class="cm"> *	Apps:</span>
<span class="cm"> *		amp</span>
<span class="cm"> *		mpg123</span>
<span class="cm"> *		x11amp</span>
<span class="cm"> *		mxv</span>
<span class="cm"> *		kmedia</span>
<span class="cm"> *		esound</span>
<span class="cm"> *		need more input apps</span>
<span class="cm"> *</span>
<span class="cm"> *	Run tests while bombarding with signals.  setitimer(2) will do it...  */</span>

<span class="cm">/*</span>
<span class="cm"> * This driver is organized in nine sections.</span>
<span class="cm"> * The nine sections are:</span>
<span class="cm"> *</span>
<span class="cm"> *	debug stuff</span>
<span class="cm"> * 	low level lithium access</span>
<span class="cm"> *	high level lithium access</span>
<span class="cm"> *	AD1843 access</span>
<span class="cm"> *	PCM I/O</span>
<span class="cm"> *	audio driver</span>
<span class="cm"> *	mixer driver</span>
<span class="cm"> *	probe/attach/unload</span>
<span class="cm"> *	initialization and loadable kernel module interface</span>
<span class="cm"> *</span>
<span class="cm"> * That is roughly the order of increasing abstraction, so forward</span>
<span class="cm"> * dependencies are minimal.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Locking Notes</span>
<span class="cm"> *</span>
<span class="cm"> *	INC_USE_COUNT and DEC_USE_COUNT keep track of the number of</span>
<span class="cm"> *	open descriptors to this driver. They store it in vwsnd_use_count.</span>
<span class="cm"> * 	The global device list, vwsnd_dev_list,	is immutable when the IN_USE</span>
<span class="cm"> *	is true.</span>
<span class="cm"> *</span>
<span class="cm"> *	devc-&gt;open_lock is a semaphore that is used to enforce the</span>
<span class="cm"> *	single reader/single writer rule for /dev/audio.  The rule is</span>
<span class="cm"> *	that each device may have at most one reader and one writer.</span>
<span class="cm"> *	Open will block until the previous client has closed the</span>
<span class="cm"> *	device, unless O_NONBLOCK is specified.</span>
<span class="cm"> *</span>
<span class="cm"> *	The semaphore devc-&gt;io_mutex serializes PCM I/O syscalls.  This</span>
<span class="cm"> *	is unnecessary in Linux 2.2, because the kernel lock</span>
<span class="cm"> *	serializes read, write, and ioctl globally, but it&#39;s there,</span>
<span class="cm"> *	ready for the brave, new post-kernel-lock world.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking between interrupt and baselevel is handled by the</span>
<span class="cm"> *	&quot;lock&quot; spinlock in vwsnd_port (one lock each for read and</span>
<span class="cm"> *	write).  Each half holds the lock just long enough to see what</span>
<span class="cm"> *	area it owns and update its pointers.  See pcm_output() and</span>
<span class="cm"> *	pcm_input() for most of the gory stuff.</span>
<span class="cm"> *</span>
<span class="cm"> *	devc-&gt;mix_mutex serializes all mixer ioctls.  This is also</span>
<span class="cm"> *	redundant because of the kernel lock.</span>
<span class="cm"> *</span>
<span class="cm"> *	The lowest level lock is lith-&gt;lithium_lock.  It is a</span>
<span class="cm"> *	spinlock which is held during the two-register tango of</span>
<span class="cm"> *	reading/writing an AD1843 register.  See</span>
<span class="cm"> *	li_{read,write}_ad1843_reg().</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Sample Format Notes</span>
<span class="cm"> *</span>
<span class="cm"> *	Lithium&#39;s DMA engine has two formats: 16-bit 2&#39;s complement</span>
<span class="cm"> *	and 8-bit unsigned .  16-bit transfers the data unmodified, 2</span>
<span class="cm"> *	bytes per sample.  8-bit unsigned transfers 1 byte per sample</span>
<span class="cm"> *	and XORs each byte with 0x80.  Lithium can input or output</span>
<span class="cm"> *	either mono or stereo in either format.</span>
<span class="cm"> *</span>
<span class="cm"> *	The AD1843 has four formats: 16-bit 2&#39;s complement, 8-bit</span>
<span class="cm"> *	unsigned, 8-bit mu-Law and 8-bit A-Law.</span>
<span class="cm"> *</span>
<span class="cm"> *	This driver supports five formats: AFMT_S8, AFMT_U8,</span>
<span class="cm"> *	AFMT_MU_LAW, AFMT_A_LAW, and AFMT_S16_LE.</span>
<span class="cm"> *</span>
<span class="cm"> *	For AFMT_U8 output, we keep the AD1843 in 16-bit mode, and</span>
<span class="cm"> *	rely on Lithium&#39;s XOR to translate between U8 and S8.</span>
<span class="cm"> *</span>
<span class="cm"> *	For AFMT_S8, AFMT_MU_LAW and AFMT_A_LAW output, we have to XOR</span>
<span class="cm"> *	the 0x80 bit in software to compensate for Lithium&#39;s XOR.</span>
<span class="cm"> *	This happens in pcm_copy_{in,out}().</span>
<span class="cm"> *</span>
<span class="cm"> * Changes:</span>
<span class="cm"> * 11-10-2000	Bartlomiej Zolnierkiewicz &lt;bkz@linux-ide.org&gt;</span>
<span class="cm"> *		Added some __init/__exit</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/visws/cobalt.h&gt;</span>

<span class="cp">#include &quot;sound_config.h&quot;</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* debug stuff */</span>

<span class="cp">#ifdef VWSND_DEBUG</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">shut_up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * dbgassert - called when an assertion fails.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dbgassert</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fcn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">expr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;ASSERTION FAILED IN INTERRUPT, %s:%s:%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__FILE__</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">expr</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ASSERTION FAILED, %s:%s:%d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__FILE__</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">expr</span><span class="p">);</span>
		<span class="n">x</span> <span class="o">=</span> <span class="o">*</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* force proc to exit */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Bunch of useful debug macros:</span>
<span class="cm"> *</span>
<span class="cm"> *	ASSERT	- print unless e nonzero (panic if in interrupt)</span>
<span class="cm"> *	DBGDO	- include arbitrary code if debugging</span>
<span class="cm"> *	DBGX	- debug print raw (w/o function name)</span>
<span class="cm"> *	DBGP	- debug print w/ function name</span>
<span class="cm"> *	DBGE	- debug print function entry</span>
<span class="cm"> *	DBGC	- debug print function call</span>
<span class="cm"> *	DBGR	- debug print function return</span>
<span class="cm"> *	DBGXV	- debug print raw when verbose</span>
<span class="cm"> *	DBGPV	- debug print when verbose</span>
<span class="cm"> *	DBGEV	- debug print function entry when verbose</span>
<span class="cm"> *	DBGRV	- debug print function return when verbose</span>
<span class="cm"> */</span>

<span class="cp">#define ASSERT(e)      ((e) ? (void) 0 : dbgassert(__func__, __LINE__, #e))</span>
<span class="cp">#define DBGDO(x)            x</span>
<span class="cp">#define DBGX(fmt, args...)  (in_interrupt() ? 0 : printk(KERN_ERR fmt, ##args))</span>
<span class="cp">#define DBGP(fmt, args...)  (DBGX(&quot;%s: &quot; fmt, __func__ , ##args))</span>
<span class="cp">#define DBGE(fmt, args...)  (DBGX(&quot;%s&quot; fmt, __func__ , ##args))</span>
<span class="cp">#define DBGC(rtn)           (DBGP(&quot;calling %s\n&quot;, rtn))</span>
<span class="cp">#define DBGR()              (DBGP(&quot;returning\n&quot;))</span>
<span class="cp">#define DBGXV(fmt, args...) (shut_up ? 0 : DBGX(fmt, ##args))</span>
<span class="cp">#define DBGPV(fmt, args...) (shut_up ? 0 : DBGP(fmt, ##args))</span>
<span class="cp">#define DBGEV(fmt, args...) (shut_up ? 0 : DBGE(fmt, ##args))</span>
<span class="cp">#define DBGCV(rtn)          (shut_up ? 0 : DBGC(rtn))</span>
<span class="cp">#define DBGRV()             (shut_up ? 0 : DBGR())</span>

<span class="cp">#else </span><span class="cm">/* !VWSND_DEBUG */</span><span class="cp"></span>

<span class="cp">#define ASSERT(e)           ((void) 0)</span>
<span class="cp">#define DBGDO(x)            </span><span class="cm">/* don&#39;t */</span><span class="cp"></span>
<span class="cp">#define DBGX(fmt, args...)  ((void) 0)</span>
<span class="cp">#define DBGP(fmt, args...)  ((void) 0)</span>
<span class="cp">#define DBGE(fmt, args...)  ((void) 0)</span>
<span class="cp">#define DBGC(rtn)           ((void) 0)</span>
<span class="cp">#define DBGR()              ((void) 0)</span>
<span class="cp">#define DBGPV(fmt, args...) ((void) 0)</span>
<span class="cp">#define DBGXV(fmt, args...) ((void) 0)</span>
<span class="cp">#define DBGEV(fmt, args...) ((void) 0)</span>
<span class="cp">#define DBGCV(rtn)          ((void) 0)</span>
<span class="cp">#define DBGRV()             ((void) 0)</span>

<span class="cp">#endif </span><span class="cm">/* !VWSND_DEBUG */</span><span class="cp"></span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* low level lithium access */</span>

<span class="cm">/*</span>
<span class="cm"> * We need to talk to Lithium registers on three pages.  Here are</span>
<span class="cm"> * the pages&#39; offsets from the base address (0xFF001000).</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">LI_PAGE0_OFFSET</span> <span class="o">=</span> <span class="mh">0x01000</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="cm">/* FF001000 */</span>
	<span class="n">LI_PAGE1_OFFSET</span> <span class="o">=</span> <span class="mh">0x0F000</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="cm">/* FF00F000 */</span>
	<span class="n">LI_PAGE2_OFFSET</span> <span class="o">=</span> <span class="mh">0x10000</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="cm">/* FF010000 */</span>
<span class="p">};</span>

<span class="cm">/* low-level lithium data */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">lithium</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span>		<span class="n">page0</span><span class="p">;</span>		<span class="cm">/* virtual addresses */</span>
	<span class="kt">void</span> <span class="o">*</span>		<span class="n">page1</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span>		<span class="n">page2</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* protects codec and UST/MSC access */</span>
<span class="p">}</span> <span class="n">lithium_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * li_destroy destroys the lithium_t structure and vm mappings.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">li_destroy</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span><span class="p">);</span>
		<span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page1</span><span class="p">);</span>
		<span class="n">lith</span><span class="o">-&gt;</span><span class="n">page1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page2</span><span class="p">);</span>
		<span class="n">lith</span><span class="o">-&gt;</span><span class="n">page2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * li_create initializes the lithium_t structure and sets up vm mappings</span>
<span class="cm"> * to access the registers.</span>
<span class="cm"> * Returns 0 on success, -errno on failure.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">li_create</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">baseaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">LI_PAGE0_OFFSET</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">lith</span><span class="o">-&gt;</span><span class="n">page1</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">LI_PAGE1_OFFSET</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">lith</span><span class="o">-&gt;</span><span class="n">page2</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">baseaddr</span> <span class="o">+</span> <span class="n">LI_PAGE2_OFFSET</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span> <span class="o">||</span> <span class="o">!</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page1</span> <span class="o">||</span> <span class="o">!</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">li_destroy</span><span class="p">(</span><span class="n">lith</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * basic register accessors - read/write long/byte</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">li_readl</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span> <span class="o">+</span> <span class="n">off</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">li_readb</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span> <span class="o">+</span> <span class="n">off</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">li_writel</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">li_writeb</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">page0</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* High Level Lithium Access */</span>

<span class="cm">/*</span>
<span class="cm"> * Lithium DMA Notes</span>
<span class="cm"> *</span>
<span class="cm"> * Lithium has two dedicated DMA channels for audio.  They are known</span>
<span class="cm"> * as comm1 and comm2 (communication areas 1 and 2).  Comm1 is for</span>
<span class="cm"> * input, and comm2 is for output.  Each is controlled by three</span>
<span class="cm"> * registers: BASE (base address), CFG (config) and CCTL</span>
<span class="cm"> * (config/control).</span>
<span class="cm"> *</span>
<span class="cm"> * Each DMA channel points to a physically contiguous ring buffer in</span>
<span class="cm"> * main memory of up to 8 Kbytes.  (This driver always uses 8 Kb.)</span>
<span class="cm"> * There are three pointers into the ring buffer: read, write, and</span>
<span class="cm"> * trigger.  The pointers are 8 bits each.  Each pointer points to</span>
<span class="cm"> * 32-byte &quot;chunks&quot; of data.  The DMA engine moves 32 bytes at a time,</span>
<span class="cm"> * so there is no finer-granularity control.</span>
<span class="cm"> *</span>
<span class="cm"> * In comm1, the hardware updates the write ptr, and software updates</span>
<span class="cm"> * the read ptr.  In comm2, it&#39;s the opposite: hardware updates the</span>
<span class="cm"> * read ptr, and software updates the write ptr.  I designate the</span>
<span class="cm"> * hardware-updated ptr as the hwptr, and the software-updated ptr as</span>
<span class="cm"> * the swptr.</span>
<span class="cm"> *</span>
<span class="cm"> * The trigger ptr and trigger mask are used to trigger interrupts.</span>
<span class="cm"> * From the Lithium spec, section 5.6.8, revision of 12/15/1998:</span>
<span class="cm"> *</span>
<span class="cm"> *	Trigger Mask Value</span>
<span class="cm"> *</span>
<span class="cm"> *	A three bit wide field that represents a power of two mask</span>
<span class="cm"> *	that is used whenever the trigger pointer is compared to its</span>
<span class="cm"> *	respective read or write pointer.  A value of zero here</span>
<span class="cm"> *	implies a mask of 0xFF and a value of seven implies a mask</span>
<span class="cm"> *	0x01.  This value can be used to sub-divide the ring buffer</span>
<span class="cm"> *	into pie sections so that interrupts monitor the progress of</span>
<span class="cm"> *	hardware from section to section.</span>
<span class="cm"> *</span>
<span class="cm"> * My interpretation of that is, whenever the hw ptr is updated, it is</span>
<span class="cm"> * compared with the trigger ptr, and the result is masked by the</span>
<span class="cm"> * trigger mask.  (Actually, by the complement of the trigger mask.)</span>
<span class="cm"> * If the result is zero, an interrupt is triggered.  I.e., interrupt</span>
<span class="cm"> * if ((hwptr &amp; ~mask) == (trptr &amp; ~mask)).  The mask is formed from</span>
<span class="cm"> * the trigger register value as mask = (1 &lt;&lt; (8 - tmreg)) - 1.</span>
<span class="cm"> *</span>
<span class="cm"> * In yet different words, setting tmreg to 0 causes an interrupt after</span>
<span class="cm"> * every 256 DMA chunks (8192 bytes) or once per traversal of the</span>
<span class="cm"> * ring buffer.  Setting it to 7 caues an interrupt every 2 DMA chunks</span>
<span class="cm"> * (64 bytes) or 128 times per traversal of the ring buffer.</span>
<span class="cm"> */</span>

<span class="cm">/* Lithium register offsets and bit definitions */</span>

<span class="cp">#define LI_HOST_CONTROLLER	0x000</span>
<span class="cp"># define LI_HC_RESET		 0x00008000</span>
<span class="cp"># define LI_HC_LINK_ENABLE	 0x00004000</span>
<span class="cp"># define LI_HC_LINK_FAILURE	 0x00000004</span>
<span class="cp"># define LI_HC_LINK_CODEC	 0x00000002</span>
<span class="cp"># define LI_HC_LINK_READY	 0x00000001</span>

<span class="cp">#define LI_INTR_STATUS		0x010</span>
<span class="cp">#define LI_INTR_MASK		0x014</span>
<span class="cp"># define LI_INTR_LINK_ERR	 0x00008000</span>
<span class="cp"># define LI_INTR_COMM2_TRIG	 0x00000008</span>
<span class="cp"># define LI_INTR_COMM2_UNDERFLOW 0x00000004</span>
<span class="cp"># define LI_INTR_COMM1_TRIG	 0x00000002</span>
<span class="cp"># define LI_INTR_COMM1_OVERFLOW  0x00000001</span>

<span class="cp">#define LI_CODEC_COMMAND	0x018</span>
<span class="cp"># define LI_CC_BUSY		 0x00008000</span>
<span class="cp"># define LI_CC_DIR		 0x00000080</span>
<span class="cp">#  define LI_CC_DIR_RD		  LI_CC_DIR</span>
<span class="cp">#  define LI_CC_DIR_WR		(!LI_CC_DIR)</span>
<span class="cp"># define LI_CC_ADDR_MASK	 0x0000007F</span>

<span class="cp">#define LI_CODEC_DATA		0x01C</span>

<span class="cp">#define LI_COMM1_BASE		0x100</span>
<span class="cp">#define LI_COMM1_CTL		0x104</span>
<span class="cp"># define LI_CCTL_RESET		 0x80000000</span>
<span class="cp"># define LI_CCTL_SIZE		 0x70000000</span>
<span class="cp"># define LI_CCTL_DMA_ENABLE	 0x08000000</span>
<span class="cp"># define LI_CCTL_TMASK		 0x07000000 </span><span class="cm">/* trigger mask */</span><span class="cp"></span>
<span class="cp"># define LI_CCTL_TPTR		 0x00FF0000 </span><span class="cm">/* trigger pointer */</span><span class="cp"></span>
<span class="cp"># define LI_CCTL_RPTR		 0x0000FF00</span>
<span class="cp"># define LI_CCTL_WPTR		 0x000000FF</span>
<span class="cp">#define LI_COMM1_CFG		0x108</span>
<span class="cp"># define LI_CCFG_LOCK		 0x00008000</span>
<span class="cp"># define LI_CCFG_SLOT		 0x00000070</span>
<span class="cp"># define LI_CCFG_DIRECTION	 0x00000008</span>
<span class="cp">#  define LI_CCFG_DIR_IN	(!LI_CCFG_DIRECTION)</span>
<span class="cp">#  define LI_CCFG_DIR_OUT	  LI_CCFG_DIRECTION</span>
<span class="cp"># define LI_CCFG_MODE		 0x00000004</span>
<span class="cp">#  define LI_CCFG_MODE_MONO	(!LI_CCFG_MODE)</span>
<span class="cp">#  define LI_CCFG_MODE_STEREO	  LI_CCFG_MODE</span>
<span class="cp"># define LI_CCFG_FORMAT		 0x00000003</span>
<span class="cp">#  define LI_CCFG_FMT_8BIT	  0x00000000</span>
<span class="cp">#  define LI_CCFG_FMT_16BIT	  0x00000001</span>
<span class="cp">#define LI_COMM2_BASE		0x10C</span>
<span class="cp">#define LI_COMM2_CTL		0x110</span>
 <span class="cm">/* bit definitions are the same as LI_COMM1_CTL */</span>
<span class="cp">#define LI_COMM2_CFG		0x114</span>
 <span class="cm">/* bit definitions are the same as LI_COMM1_CFG */</span>

<span class="cp">#define LI_UST_LOW		0x200	</span><span class="cm">/* 64-bit Unadjusted System Time is */</span><span class="cp"></span>
<span class="cp">#define LI_UST_HIGH		0x204	</span><span class="cm">/* microseconds since boot */</span><span class="cp"></span>

<span class="cp">#define LI_AUDIO1_UST		0x300	</span><span class="cm">/* UST-MSC pairs */</span><span class="cp"></span>
<span class="cp">#define LI_AUDIO1_MSC		0x304	</span><span class="cm">/* MSC (Media Stream Counter) */</span><span class="cp"></span>
<span class="cp">#define LI_AUDIO2_UST		0x308	</span><span class="cm">/* counts samples actually */</span><span class="cp"></span>
<span class="cp">#define LI_AUDIO2_MSC		0x30C	</span><span class="cm">/* processed as of time UST */</span><span class="cp"></span>

<span class="cm">/* </span>
<span class="cm"> * Lithium&#39;s DMA engine operates on chunks of 32 bytes.  We call that</span>
<span class="cm"> * a DMACHUNK.</span>
<span class="cm"> */</span>

<span class="cp">#define DMACHUNK_SHIFT 5</span>
<span class="cp">#define DMACHUNK_SIZE (1 &lt;&lt; DMACHUNK_SHIFT)</span>
<span class="cp">#define BYTES_TO_CHUNKS(bytes) ((bytes) &gt;&gt; DMACHUNK_SHIFT)</span>
<span class="cp">#define CHUNKS_TO_BYTES(chunks) ((chunks) &lt;&lt; DMACHUNK_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * Two convenient macros to shift bitfields into/out of position.</span>
<span class="cm"> *</span>
<span class="cm"> * Observe that (mask &amp; -mask) is (1 &lt;&lt; low_set_bit_of(mask)).</span>
<span class="cm"> * As long as mask is constant, we trust the compiler will change the</span>
<span class="cm"> * multipy and divide into shifts.</span>
<span class="cm"> */</span>

<span class="cp">#define SHIFT_FIELD(val, mask) (((val) * ((mask) &amp; -(mask))) &amp; (mask))</span>
<span class="cp">#define UNSHIFT_FIELD(val, mask) (((val) &amp; (mask)) / ((mask) &amp; -(mask)))</span>

<span class="cm">/*</span>
<span class="cm"> * dma_chan_desc is invariant information about a Lithium</span>
<span class="cm"> * DMA channel.  There are two instances, li_comm1 and li_comm2.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the CCTL register fields are write ptr and read ptr, but what</span>
<span class="cm"> * we care about are which pointer is updated by software and which by</span>
<span class="cm"> * hardware.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dma_chan_desc</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">basereg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfgreg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctlreg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hwptrreg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">swptrreg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ustreg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mscreg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">swptrmask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ad1843_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">direction</span><span class="p">;</span>			<span class="cm">/* LI_CCTL_DIR_IN/OUT */</span>
<span class="p">}</span> <span class="n">dma_chan_desc_t</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">dma_chan_desc_t</span> <span class="n">li_comm1</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">LI_COMM1_BASE</span><span class="p">,</span>			<span class="cm">/* base register offset */</span>
	<span class="n">LI_COMM1_CFG</span><span class="p">,</span>			<span class="cm">/* config register offset */</span>
	<span class="n">LI_COMM1_CTL</span><span class="p">,</span>			<span class="cm">/* control register offset */</span>
	<span class="n">LI_COMM1_CTL</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* hw ptr reg offset (write ptr) */</span>
	<span class="n">LI_COMM1_CTL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* sw ptr reg offset (read ptr) */</span>
	<span class="n">LI_AUDIO1_UST</span><span class="p">,</span>			<span class="cm">/* ust reg offset */</span>
	<span class="n">LI_AUDIO1_MSC</span><span class="p">,</span>			<span class="cm">/* msc reg offset */</span>
	<span class="n">LI_CCTL_RPTR</span><span class="p">,</span>			<span class="cm">/* sw ptr bitmask in ctlval */</span>
	<span class="mi">2</span><span class="p">,</span>				<span class="cm">/* ad1843 serial slot */</span>
	<span class="n">LI_CCFG_DIR_IN</span>			<span class="cm">/* direction */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">dma_chan_desc_t</span> <span class="n">li_comm2</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">LI_COMM2_BASE</span><span class="p">,</span>			<span class="cm">/* base register offset */</span>
	<span class="n">LI_COMM2_CFG</span><span class="p">,</span>			<span class="cm">/* config register offset */</span>
	<span class="n">LI_COMM2_CTL</span><span class="p">,</span>			<span class="cm">/* control register offset */</span>
	<span class="n">LI_COMM2_CTL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* hw ptr reg offset (read ptr) */</span>
	<span class="n">LI_COMM2_CTL</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* sw ptr reg offset (writr ptr) */</span>
	<span class="n">LI_AUDIO2_UST</span><span class="p">,</span>			<span class="cm">/* ust reg offset */</span>
	<span class="n">LI_AUDIO2_MSC</span><span class="p">,</span>			<span class="cm">/* msc reg offset */</span>
	<span class="n">LI_CCTL_WPTR</span><span class="p">,</span>			<span class="cm">/* sw ptr bitmask in ctlval */</span>
	<span class="mi">2</span><span class="p">,</span>				<span class="cm">/* ad1843 serial slot */</span>
	<span class="n">LI_CCFG_DIR_OUT</span>			<span class="cm">/* direction */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * dma_chan is variable information about a Lithium DMA channel.</span>
<span class="cm"> *</span>
<span class="cm"> * The desc field points to invariant information.</span>
<span class="cm"> * The lith field points to a lithium_t which is passed</span>
<span class="cm"> * to li_read* and li_write* to access the registers.</span>
<span class="cm"> * The *val fields shadow the lithium registers&#39; contents.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dma_chan</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">dma_chan_desc_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="n">lithium_t</span>      <span class="o">*</span><span class="n">lith</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">baseval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">cfgval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ctlval</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dma_chan_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * ustmsc is a UST/MSC pair (Unadjusted System Time/Media Stream Counter).</span>
<span class="cm"> * UST is time in microseconds since the system booted, and MSC is a</span>
<span class="cm"> * counter that increments with every audio sample.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ustmsc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ust</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ustmsc_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * li_ad1843_wait waits until lithium says the AD1843 register</span>
<span class="cm"> * exchange is not busy.  Returns 0 on success, -EBUSY on timeout.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: must be called with lithium_lock held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">li_ad1843_wait</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">later</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_CODEC_COMMAND</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LI_CC_BUSY</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">later</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * li_read_ad1843_reg returns the current contents of a 16 bit AD1843 register.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns unsigned register value on success, -errno on failure.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">li_read_ad1843_reg</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">());</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">li_ad1843_wait</span><span class="p">(</span><span class="n">lith</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_CODEC_COMMAND</span><span class="p">,</span> <span class="n">LI_CC_DIR_RD</span> <span class="o">|</span> <span class="n">reg</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">li_ad1843_wait</span><span class="p">(</span><span class="n">lith</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_CODEC_DATA</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">DBGXV</span><span class="p">(</span><span class="s">&quot;li_read_ad1843_reg(lith=0x%p, reg=%d) returns 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">lith</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * li_write_ad1843_reg writes the specified value to a 16 bit AD1843 register.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">li_write_ad1843_reg</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">li_ad1843_wait</span><span class="p">(</span><span class="n">lith</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_CODEC_DATA</span><span class="p">,</span> <span class="n">newval</span><span class="p">);</span>
			<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_CODEC_COMMAND</span><span class="p">,</span> <span class="n">LI_CC_DIR_WR</span> <span class="o">|</span> <span class="n">reg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * li_setup_dma calculates all the register settings for DMA in a particular</span>
<span class="cm"> * mode.  It takes too many arguments.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">li_setup_dma</span><span class="p">(</span><span class="n">dma_chan_t</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
			 <span class="k">const</span> <span class="n">dma_chan_desc_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			 <span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer_paddr</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">bufshift</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">fragshift</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">channels</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">sampsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mode</span><span class="p">,</span> <span class="n">format</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">tmask</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(chan=0x%p, desc=0x%p, lith=0x%p, buffer_paddr=0x%lx, &quot;</span>
	     <span class="s">&quot;bufshift=%d, fragshift=%d, channels=%d, sampsize=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">chan</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">lith</span><span class="p">,</span> <span class="n">buffer_paddr</span><span class="p">,</span>
	     <span class="n">bufshift</span><span class="p">,</span> <span class="n">fragshift</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">sampsize</span><span class="p">);</span>

	<span class="cm">/* Reset the channel first. */</span>

	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">ctlreg</span><span class="p">,</span> <span class="n">LI_CCTL_RESET</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">channels</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">LI_CCFG_MODE_STEREO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">LI_CCFG_MODE_MONO</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">sampsize</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">sampsize</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sampsize</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">format</span> <span class="o">=</span> <span class="n">LI_CCFG_FMT_16BIT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">format</span> <span class="o">=</span> <span class="n">LI_CCFG_FMT_8BIT</span><span class="p">;</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">lith</span> <span class="o">=</span> <span class="n">lith</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lithium DMA address register takes a 40-bit physical</span>
<span class="cm">	 * address, right-shifted by 8 so it fits in 32 bits.  Bit 37</span>
<span class="cm">	 * must be set -- it enables cache coherence.</span>
<span class="cm">	 */</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">buffer_paddr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">baseval</span> <span class="o">=</span> <span class="p">(</span><span class="n">buffer_paddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">37</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">cfgval</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">cfgval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LI_CCFG_LOCK</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">SHIFT_FIELD</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">ad1843_slot</span><span class="p">,</span> <span class="n">LI_CCFG_SLOT</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">|</span>
			<span class="n">mode</span> <span class="o">|</span>
			<span class="n">format</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">bufshift</span> <span class="o">-</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">tmask</span> <span class="o">=</span> <span class="mi">13</span> <span class="o">-</span> <span class="n">fragshift</span><span class="p">;</span>		<span class="cm">/* See Lithium DMA Notes above. */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">tmask</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tmask</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LI_CCTL_RESET</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">SHIFT_FIELD</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">LI_CCTL_SIZE</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LI_CCTL_DMA_ENABLE</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">SHIFT_FIELD</span><span class="p">(</span><span class="n">tmask</span><span class="p">,</span> <span class="n">LI_CCTL_TMASK</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">SHIFT_FIELD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">LI_CCTL_TPTR</span><span class="p">));</span>

	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;basereg 0x%x = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">basereg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">baseval</span><span class="p">);</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;cfgreg 0x%x = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">cfgreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">cfgval</span><span class="p">);</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;ctlreg 0x%x = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">ctlreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>

	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">basereg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">baseval</span><span class="p">);</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">cfgreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">cfgval</span><span class="p">);</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">ctlreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>

	<span class="n">DBGRV</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">li_shutdown_dma</span><span class="p">(</span><span class="n">dma_chan_t</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span> <span class="n">lith1</span> <span class="o">=</span> <span class="n">lith</span><span class="o">-&gt;</span><span class="n">page1</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(chan=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="p">);</span>
	
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LI_CCTL_DMA_ENABLE</span><span class="p">;</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;ctlreg 0x%x = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">ctlreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">ctlreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Offset 0x500 on Lithium page 1 is an undocumented,</span>
<span class="cm">	 * unsupported register that holds the zero sample value.</span>
<span class="cm">	 * Lithium is supposed to output zero samples when DMA is</span>
<span class="cm">	 * inactive, and repeat the last sample when DMA underflows.</span>
<span class="cm">	 * But it has a bug, where, after underflow occurs, the zero</span>
<span class="cm">	 * sample is not reset.</span>
<span class="cm">	 *</span>
<span class="cm">	 * I expect this to break in a future rev of Lithium.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lith1</span> <span class="o">&amp;&amp;</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">LI_CCFG_DIR_OUT</span><span class="p">)</span>
		<span class="o">*</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lith1</span> <span class="o">+</span> <span class="mh">0x500</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * li_activate_dma always starts dma at the beginning of the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * N.B., these may be called from interrupt.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">li_activate_dma</span><span class="p">(</span><span class="n">dma_chan_t</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span> <span class="o">|=</span> <span class="n">LI_CCTL_DMA_ENABLE</span><span class="p">;</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;ctlval = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">ctlreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">li_deactivate_dma</span><span class="p">(</span><span class="n">dma_chan_t</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span> <span class="n">lith2</span> <span class="o">=</span> <span class="n">lith</span><span class="o">-&gt;</span><span class="n">page2</span><span class="p">;</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LI_CCTL_DMA_ENABLE</span> <span class="o">|</span> <span class="n">LI_CCTL_RPTR</span> <span class="o">|</span> <span class="n">LI_CCTL_WPTR</span><span class="p">);</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;ctlval = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;ctlreg 0x%x = 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">ctlreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">ctlreg</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Offsets 0x98 and 0x9C on Lithium page 2 are undocumented,</span>
<span class="cm">	 * unsupported registers that are internal copies of the DMA</span>
<span class="cm">	 * read and write pointers.  Because of a Lithium bug, these</span>
<span class="cm">	 * registers aren&#39;t zeroed correctly when DMA is shut off.  So</span>
<span class="cm">	 * we whack them directly.</span>
<span class="cm">	 *</span>
<span class="cm">	 * I expect this to break in a future rev of Lithium.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lith2</span> <span class="o">&amp;&amp;</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">LI_CCFG_DIR_OUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lith2</span> <span class="o">+</span> <span class="mh">0x98</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lith2</span> <span class="o">+</span> <span class="mh">0x9C</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read/write the ring buffer pointers.  These routines&#39; arguments and results</span>
<span class="cm"> * are byte offsets from the beginning of the ring buffer.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">li_read_swptr</span><span class="p">(</span><span class="n">dma_chan_t</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">swptrmask</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">CHUNKS_TO_BYTES</span><span class="p">(</span><span class="n">UNSHIFT_FIELD</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span><span class="p">,</span> <span class="n">mask</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">li_read_hwptr</span><span class="p">(</span><span class="n">dma_chan_t</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">CHUNKS_TO_BYTES</span><span class="p">(</span><span class="n">li_readb</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">hwptrreg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">li_write_swptr</span><span class="p">(</span><span class="n">dma_chan_t</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">swptrmask</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CHUNKS_TO_BYTES</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">)));</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">BYTES_TO_CHUNKS</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span> <span class="o">=</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">ctlval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">SHIFT_FIELD</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">li_writeb</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">swptrreg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* li_read_USTMSC() returns a UST/MSC pair for the given channel. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">li_read_USTMSC</span><span class="p">(</span><span class="n">dma_chan_t</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">ustmsc_t</span> <span class="o">*</span><span class="n">ustmsc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">dma_chan_desc_t</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now_low</span><span class="p">,</span> <span class="n">now_high0</span><span class="p">,</span> <span class="n">now_high1</span><span class="p">,</span> <span class="n">chan_ust</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * retry until we do all five reads without the</span>
<span class="cm">		 * high word changing.  (High word increments</span>
<span class="cm">		 * every 2^32 microseconds, i.e., not often)</span>
<span class="cm">		 */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">now_high0</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_UST_HIGH</span><span class="p">);</span>
			<span class="n">now_low</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_UST_LOW</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Lithium guarantees these two reads will be</span>
<span class="cm">			 * atomic -- ust will not increment after msc</span>
<span class="cm">			 * is read.</span>
<span class="cm">			 */</span>

			<span class="n">ustmsc</span><span class="o">-&gt;</span><span class="n">msc</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">mscreg</span><span class="p">);</span>
			<span class="n">chan_ust</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">ustreg</span><span class="p">);</span>

			<span class="n">now_high1</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_UST_HIGH</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">now_high0</span> <span class="o">!=</span> <span class="n">now_high1</span><span class="p">);</span>
	<span class="p">}</span>	
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ustmsc</span><span class="o">-&gt;</span><span class="n">ust</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">now_high0</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span> <span class="o">|</span> <span class="n">chan_ust</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">li_enable_interrupts</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(lith=0x%p, mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lith</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* clear any already-pending interrupts. */</span>

	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_STATUS</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* enable the interrupts. */</span>

	<span class="n">mask</span> <span class="o">|=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_MASK</span><span class="p">);</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_MASK</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">li_disable_interrupts</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">keepmask</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(lith=0x%p, mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lith</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* disable the interrupts */</span>

	<span class="n">keepmask</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_MASK</span><span class="p">,</span> <span class="n">keepmask</span><span class="p">);</span>

	<span class="cm">/* clear any pending interrupts. */</span>

	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_STATUS</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Get the interrupt status and clear all pending interrupts. */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">li_get_clear_intr_status</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_STATUS</span><span class="p">);</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_STATUS</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">li_readl</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_INTR_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">li_init</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* 1. System power supplies stabilize. */</span>

	<span class="cm">/* 2. Assert the ~RESET signal. */</span>

	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_HOST_CONTROLLER</span><span class="p">,</span> <span class="n">LI_HC_RESET</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* 3. Deassert the ~RESET signal and enter a wait period to allow</span>
<span class="cm">	   the AD1843 internal clocks and the external crystal oscillator</span>
<span class="cm">	   to stabilize. */</span>

	<span class="n">li_writel</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_HOST_CONTROLLER</span><span class="p">,</span> <span class="n">LI_HC_LINK_ENABLE</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* AD1843 access */</span>

<span class="cm">/*</span>
<span class="cm"> * AD1843 bitfield definitions.  All are named as in the AD1843 data</span>
<span class="cm"> * sheet, with ad1843_ prepended and individual bit numbers removed.</span>
<span class="cm"> *</span>
<span class="cm"> * E.g., bits LSS0 through LSS2 become ad1843_LSS.</span>
<span class="cm"> *</span>
<span class="cm"> * Only the bitfields we need are defined.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ad1843_bitfield</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">lo_bit</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">nbits</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ad1843_bitfield_t</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">ad1843_bitfield_t</span>
	<span class="n">ad1843_PDNO</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Converter Power-Down Flag */</span>
	<span class="n">ad1843_INIT</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Clock Initialization Flag */</span>
	<span class="n">ad1843_RIG</span>    <span class="o">=</span> <span class="p">{</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">4</span> <span class="p">},</span>	<span class="cm">/* Right ADC Input Gain */</span>
	<span class="n">ad1843_RMGE</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Right ADC Mic Gain Enable */</span>
	<span class="n">ad1843_RSS</span>    <span class="o">=</span> <span class="p">{</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">3</span> <span class="p">},</span>	<span class="cm">/* Right ADC Source Select */</span>
	<span class="n">ad1843_LIG</span>    <span class="o">=</span> <span class="p">{</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">4</span> <span class="p">},</span>	<span class="cm">/* Left ADC Input Gain */</span>
	<span class="n">ad1843_LMGE</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Left ADC Mic Gain Enable */</span>
	<span class="n">ad1843_LSS</span>    <span class="o">=</span> <span class="p">{</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span>  <span class="mi">3</span> <span class="p">},</span>	<span class="cm">/* Left ADC Source Select */</span>
	<span class="n">ad1843_RX1M</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">5</span> <span class="p">},</span>	<span class="cm">/* Right Aux 1 Mix Gain/Atten */</span>
	<span class="n">ad1843_RX1MM</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Right Aux 1 Mix Mute */</span>
	<span class="n">ad1843_LX1M</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">5</span> <span class="p">},</span>	<span class="cm">/* Left Aux 1 Mix Gain/Atten */</span>
	<span class="n">ad1843_LX1MM</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Left Aux 1 Mix Mute */</span>
	<span class="n">ad1843_RX2M</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">5</span> <span class="p">},</span>	<span class="cm">/* Right Aux 2 Mix Gain/Atten */</span>
	<span class="n">ad1843_RX2MM</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Right Aux 2 Mix Mute */</span>
	<span class="n">ad1843_LX2M</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">5</span> <span class="p">},</span>	<span class="cm">/* Left Aux 2 Mix Gain/Atten */</span>
	<span class="n">ad1843_LX2MM</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Left Aux 2 Mix Mute */</span>
	<span class="n">ad1843_RMCM</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">5</span> <span class="p">},</span>	<span class="cm">/* Right Mic Mix Gain/Atten */</span>
	<span class="n">ad1843_RMCMM</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Right Mic Mix Mute */</span>
	<span class="n">ad1843_LMCM</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">5</span> <span class="p">},</span>	<span class="cm">/* Left Mic Mix Gain/Atten */</span>
	<span class="n">ad1843_LMCMM</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Left Mic Mix Mute */</span>
	<span class="n">ad1843_HPOS</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Headphone Output Voltage Swing */</span>
	<span class="n">ad1843_HPOM</span>   <span class="o">=</span> <span class="p">{</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Headphone Output Mute */</span>
	<span class="n">ad1843_RDA1G</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">6</span> <span class="p">},</span>	<span class="cm">/* Right DAC1 Analog/Digital Gain */</span>
	<span class="n">ad1843_RDA1GM</span> <span class="o">=</span> <span class="p">{</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Right DAC1 Analog Mute */</span>
	<span class="n">ad1843_LDA1G</span>  <span class="o">=</span> <span class="p">{</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">6</span> <span class="p">},</span>	<span class="cm">/* Left DAC1 Analog/Digital Gain */</span>
	<span class="n">ad1843_LDA1GM</span> <span class="o">=</span> <span class="p">{</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Left DAC1 Analog Mute */</span>
	<span class="n">ad1843_RDA1AM</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Right DAC1 Digital Mute */</span>
	<span class="n">ad1843_LDA1AM</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Left DAC1 Digital Mute */</span>
	<span class="n">ad1843_ADLC</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">},</span>	<span class="cm">/* ADC Left Sample Rate Source */</span>
	<span class="n">ad1843_ADRC</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">},</span>	<span class="cm">/* ADC Right Sample Rate Source */</span>
	<span class="n">ad1843_DA1C</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">},</span>	<span class="cm">/* DAC1 Sample Rate Source */</span>
	<span class="n">ad1843_C1C</span>    <span class="o">=</span> <span class="p">{</span> <span class="mi">17</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span> <span class="p">},</span>	<span class="cm">/* Clock 1 Sample Rate Select */</span>
	<span class="n">ad1843_C2C</span>    <span class="o">=</span> <span class="p">{</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span> <span class="p">},</span>	<span class="cm">/* Clock 1 Sample Rate Select */</span>
	<span class="n">ad1843_DAADL</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">25</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">},</span>	<span class="cm">/* Digital ADC Left Source Select */</span>
	<span class="n">ad1843_DAADR</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">25</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">},</span>	<span class="cm">/* Digital ADC Right Source Select */</span>
	<span class="n">ad1843_DRSFLT</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Digital Reampler Filter Mode */</span>
	<span class="n">ad1843_ADLF</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">26</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">},</span> <span class="cm">/* ADC Left Channel Data Format */</span>
	<span class="n">ad1843_ADRF</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">26</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">},</span> <span class="cm">/* ADC Right Channel Data Format */</span>
	<span class="n">ad1843_ADTLK</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">26</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* ADC Transmit Lock Mode Select */</span>
	<span class="n">ad1843_SCF</span>    <span class="o">=</span> <span class="p">{</span> <span class="mi">26</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* SCLK Frequency Select */</span>
	<span class="n">ad1843_DA1F</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">26</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">2</span> <span class="p">},</span>	<span class="cm">/* DAC1 Data Format Select */</span>
	<span class="n">ad1843_DA1SM</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* DAC1 Stereo/Mono Mode Select */</span>
	<span class="n">ad1843_ADLEN</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* ADC Left Channel Enable */</span>
	<span class="n">ad1843_ADREN</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* ADC Right Channel Enable */</span>
	<span class="n">ad1843_AAMEN</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Analog to Analog Mix Enable */</span>
	<span class="n">ad1843_ANAEN</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Analog Channel Enable */</span>
	<span class="n">ad1843_DA1EN</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* DAC1 Enable */</span>
	<span class="n">ad1843_DA2EN</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">27</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* DAC2 Enable */</span>
	<span class="n">ad1843_C1EN</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Clock Generator 1 Enable */</span>
	<span class="n">ad1843_C2EN</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">},</span>	<span class="cm">/* Clock Generator 2 Enable */</span>
	<span class="n">ad1843_PDNI</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span> <span class="p">};</span>	<span class="cm">/* Converter Power Down */</span>

<span class="cm">/*</span>
<span class="cm"> * The various registers of the AD1843 use three different formats for</span>
<span class="cm"> * specifying gain.  The ad1843_gain structure parameterizes the</span>
<span class="cm"> * formats.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ad1843_gain</span> <span class="p">{</span>

	<span class="kt">int</span>	<span class="n">negative</span><span class="p">;</span>		<span class="cm">/* nonzero if gain is negative. */</span>
	<span class="k">const</span> <span class="n">ad1843_bitfield_t</span> <span class="o">*</span><span class="n">lfield</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">ad1843_bitfield_t</span> <span class="o">*</span><span class="n">rfield</span><span class="p">;</span>

<span class="p">}</span> <span class="n">ad1843_gain_t</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">ad1843_gain_t</span> <span class="n">ad1843_gain_RECLEV</span>
				<span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LIG</span><span class="p">,</span>   <span class="o">&amp;</span><span class="n">ad1843_RIG</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">ad1843_gain_t</span> <span class="n">ad1843_gain_LINE</span>
				<span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LX1M</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">ad1843_RX1M</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">ad1843_gain_t</span> <span class="n">ad1843_gain_CD</span>
				<span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LX2M</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">ad1843_RX2M</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">ad1843_gain_t</span> <span class="n">ad1843_gain_MIC</span>
				<span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LMCM</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">ad1843_RMCM</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">ad1843_gain_t</span> <span class="n">ad1843_gain_PCM</span>
				<span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LDA1G</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_RDA1G</span> <span class="p">};</span>

<span class="cm">/* read the current value of an AD1843 bitfield. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad1843_read_bits</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="k">const</span> <span class="n">ad1843_bitfield_t</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">li_read_ad1843_reg</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;&gt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">lo_bit</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">nbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">DBGXV</span><span class="p">(</span><span class="s">&quot;ad1843_read_bits(lith=0x%p, field-&gt;{%d %d %d}) returns 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">lith</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">lo_bit</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">nbits</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * write a new value to an AD1843 bitfield and return the old value.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad1843_write_bits</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span>
			     <span class="k">const</span> <span class="n">ad1843_bitfield_t</span> <span class="o">*</span><span class="n">field</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">li_read_ad1843_reg</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">nbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">lo_bit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oldval</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">lo_bit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">newbits</span> <span class="o">=</span> <span class="p">(</span><span class="n">newval</span> <span class="o">&lt;&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">lo_bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">newbits</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">li_write_ad1843_reg</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="n">DBGXV</span><span class="p">(</span><span class="s">&quot;ad1843_write_bits(lith=0x%p, field-&gt;{%d %d %d}, val=0x%x) &quot;</span>
	      <span class="s">&quot;returns 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">lith</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">lo_bit</span><span class="p">,</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">nbits</span><span class="p">,</span> <span class="n">newval</span><span class="p">,</span>
	      <span class="n">oldval</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">oldval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ad1843_read_multi reads multiple bitfields from the same AD1843</span>
<span class="cm"> * register.  It uses a single read cycle to do it.  (Reading the</span>
<span class="cm"> * ad1843 requires 256 bit times at 12.288 MHz, or nearly 20</span>
<span class="cm"> * microseconds.)</span>
<span class="cm"> *</span>
<span class="cm"> * Called ike this.</span>
<span class="cm"> *</span>
<span class="cm"> *  ad1843_read_multi(lith, nfields,</span>
<span class="cm"> *		      &amp;ad1843_FIELD1, &amp;val1,</span>
<span class="cm"> *		      &amp;ad1843_FIELD2, &amp;val2, ...);</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ad1843_read_multi</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argcount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">ad1843_bitfield_t</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">reg</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">argcount</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">argcount</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="n">ad1843_bitfield_t</span> <span class="o">*</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">li_read_ad1843_reg</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">nbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">lo_bit</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ad1843_write_multi stores multiple bitfields into the same AD1843</span>
<span class="cm"> * register.  It uses one read and one write cycle to do it.</span>
<span class="cm"> *</span>
<span class="cm"> * Called like this.</span>
<span class="cm"> *</span>
<span class="cm"> *  ad1843_write_multi(lith, nfields,</span>
<span class="cm"> *		       &amp;ad1843_FIELD1, val1,</span>
<span class="cm"> *		       &amp;ad1843_FIELF2, val2, ...);</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ad1843_write_multi</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argcount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">ad1843_bitfield_t</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">argcount</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">argcount</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="n">ad1843_bitfield_t</span> <span class="o">*</span><span class="p">);</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">reg</span> <span class="o">==</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">nbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">lo_bit</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">m</span><span class="p">;</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">lo_bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">li_read_ad1843_reg</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">bits</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">li_write_ad1843_reg</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ad1843_get_gain reads the specified register and extracts the gain value</span>
<span class="cm"> * using the supplied gain type.  It returns the gain in OSS format.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad1843_get_gain</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="k">const</span> <span class="n">ad1843_gain_t</span> <span class="o">*</span><span class="n">gp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lg</span><span class="p">,</span> <span class="n">rg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gp</span><span class="o">-&gt;</span><span class="n">lfield</span><span class="o">-&gt;</span><span class="n">nbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ad1843_read_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">gp</span><span class="o">-&gt;</span><span class="n">lfield</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lg</span><span class="p">,</span> <span class="n">gp</span><span class="o">-&gt;</span><span class="n">rfield</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gp</span><span class="o">-&gt;</span><span class="n">negative</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lg</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">-</span> <span class="n">lg</span><span class="p">;</span>
		<span class="n">rg</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">-</span> <span class="n">rg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lg</span> <span class="o">=</span> <span class="p">(</span><span class="n">lg</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">rg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rg</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lg</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="o">|</span> <span class="n">rg</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set an audio channel&#39;s gain. Converts from OSS format to AD1843&#39;s</span>
<span class="cm"> * format.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the new gain, which may be lower than the old gain.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad1843_set_gain</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span>
			   <span class="k">const</span> <span class="n">ad1843_gain_t</span> <span class="o">*</span><span class="n">gp</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">newval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gp</span><span class="o">-&gt;</span><span class="n">lfield</span><span class="o">-&gt;</span><span class="n">nbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">lg</span> <span class="o">=</span> <span class="n">newval</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rg</span> <span class="o">=</span> <span class="n">newval</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lg</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">||</span> <span class="n">rg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rg</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">lg</span> <span class="o">=</span> <span class="p">(</span><span class="n">lg</span> <span class="o">*</span> <span class="n">mask</span> <span class="o">+</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">rg</span> <span class="o">=</span> <span class="p">(</span><span class="n">rg</span> <span class="o">*</span> <span class="n">mask</span> <span class="o">+</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gp</span><span class="o">-&gt;</span><span class="n">negative</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lg</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">-</span> <span class="n">lg</span><span class="p">;</span>
		<span class="n">rg</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">-</span> <span class="n">rg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">gp</span><span class="o">-&gt;</span><span class="n">lfield</span><span class="p">,</span> <span class="n">lg</span><span class="p">,</span> <span class="n">gp</span><span class="o">-&gt;</span><span class="n">rfield</span><span class="p">,</span> <span class="n">rg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ad1843_get_gain</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">gp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns the current recording source, in OSS format. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad1843_get_recsrc</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">ad1843_read_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LSS</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="n">SOUND_MASK_MIC</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">return</span> <span class="n">SOUND_MASK_LINE</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="k">return</span> <span class="n">SOUND_MASK_CD</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="k">return</span> <span class="n">SOUND_MASK_PCM</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable/disable digital resample mode in the AD1843.</span>
<span class="cm"> *</span>
<span class="cm"> * The AD1843 requires that ADL, ADR, DA1 and DA2 be powered down</span>
<span class="cm"> * while switching modes.  So we save DA1&#39;s state (DA2&#39;s state is not</span>
<span class="cm"> * interesting), power them down, switch into/out of resample mode,</span>
<span class="cm"> * power them up, and restore state.</span>
<span class="cm"> *</span>
<span class="cm"> * This will cause audible glitches if D/A or A/D is going on, so the</span>
<span class="cm"> * driver disallows that (in mixer_write_ioctl()).</span>
<span class="cm"> *</span>
<span class="cm"> * The open question is, is this worth doing?  I&#39;m leaving it in,</span>
<span class="cm"> * because it&#39;s written, but...</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ad1843_set_resample_mode</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Save DA1 mute and gain (addr 9 is DA1 analog gain/attenuation) */</span>
	<span class="kt">int</span> <span class="n">save_da1</span> <span class="o">=</span> <span class="n">li_read_ad1843_reg</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>

	<span class="cm">/* Power down A/D and D/A. */</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_DA1EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_DA2EN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADLEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADREN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Switch mode */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">onoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">onoff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ad1843_write_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_DRSFLT</span><span class="p">,</span> <span class="n">onoff</span><span class="p">);</span>

 	<span class="cm">/* Power up A/D and D/A. */</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_DA1EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADLEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADREN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Restore DA1 mute and gain. */</span>
	<span class="n">li_write_ad1843_reg</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">save_da1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set recording source.  Arg newsrc specifies an OSS channel mask.</span>
<span class="cm"> *</span>
<span class="cm"> * The complication is that when we switch into/out of loopback mode</span>
<span class="cm"> * (i.e., src = SOUND_MASK_PCM), we change the AD1843 into/out of</span>
<span class="cm"> * digital resampling mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns newsrc on success, -errno on failure.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad1843_set_recsrc</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newsrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oldbits</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">newsrc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOUND_MASK_PCM</span>:
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MASK_MIC</span>:
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MASK_LINE</span>:
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MASK_CD</span>:
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">oldbits</span> <span class="o">=</span> <span class="n">ad1843_read_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LSS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsrc</span> <span class="o">==</span> <span class="n">SOUND_MASK_PCM</span> <span class="o">&amp;&amp;</span> <span class="n">oldbits</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;enabling digital resample mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ad1843_set_resample_mode</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ad1843_DAADL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ad1843_DAADR</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">newsrc</span> <span class="o">!=</span> <span class="n">SOUND_MASK_PCM</span> <span class="o">&amp;&amp;</span> <span class="n">oldbits</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;disabling digital resample mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ad1843_set_resample_mode</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ad1843_DAADL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ad1843_DAADR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LSS</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_RSS</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">newsrc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return current output sources, in OSS format.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad1843_get_outsrc</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pcm</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">mic</span><span class="p">,</span> <span class="n">cd</span><span class="p">;</span>

	<span class="n">pcm</span>  <span class="o">=</span> <span class="n">ad1843_read_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LDA1GM</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">SOUND_MASK_PCM</span><span class="p">;</span>
	<span class="n">line</span> <span class="o">=</span> <span class="n">ad1843_read_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LX1MM</span><span class="p">)</span>  <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">SOUND_MASK_LINE</span><span class="p">;</span>
	<span class="n">cd</span>   <span class="o">=</span> <span class="n">ad1843_read_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LX2MM</span><span class="p">)</span>  <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">SOUND_MASK_CD</span><span class="p">;</span>
	<span class="n">mic</span>  <span class="o">=</span> <span class="n">ad1843_read_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LMCMM</span><span class="p">)</span>  <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">SOUND_MASK_MIC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pcm</span> <span class="o">|</span> <span class="n">line</span> <span class="o">|</span> <span class="n">cd</span> <span class="o">|</span> <span class="n">mic</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set output sources.  Arg is a mask of active sources in OSS format.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns source mask on success, -errno on failure.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad1843_set_outsrc</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pcm</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">mic</span><span class="p">,</span> <span class="n">cd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SOUND_MASK_PCM</span> <span class="o">|</span> <span class="n">SOUND_MASK_LINE</span> <span class="o">|</span>
		     <span class="n">SOUND_MASK_CD</span> <span class="o">|</span> <span class="n">SOUND_MASK_MIC</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pcm</span>  <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">SOUND_MASK_PCM</span><span class="p">)</span>  <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">SOUND_MASK_LINE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mic</span>  <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">SOUND_MASK_MIC</span><span class="p">)</span>  <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cd</span>   <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">SOUND_MASK_CD</span><span class="p">)</span>   <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LDA1GM</span><span class="p">,</span> <span class="n">pcm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_RDA1GM</span><span class="p">,</span> <span class="n">pcm</span><span class="p">);</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LX1MM</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_RX1MM</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LX2MM</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span>   <span class="o">&amp;</span><span class="n">ad1843_RX2MM</span><span class="p">,</span> <span class="n">cd</span><span class="p">);</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LMCMM</span><span class="p">,</span> <span class="n">mic</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">ad1843_RMCMM</span><span class="p">,</span> <span class="n">mic</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Setup ad1843 for D/A conversion. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ad1843_setup_dac</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">framerate</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">fmt</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">channels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ad_fmt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ad_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(lith=0x%p, framerate=%d, fmt=%d, channels=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">lith</span><span class="p">,</span> <span class="n">framerate</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">channels</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AFMT_S8</span>:		<span class="n">ad_fmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFMT_U8</span>:		<span class="n">ad_fmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFMT_S16_LE</span>:	<span class="n">ad_fmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFMT_MU_LAW</span>:	<span class="n">ad_fmt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFMT_A_LAW</span>:	<span class="n">ad_fmt</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">channels</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>:			<span class="n">ad_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:			<span class="n">ad_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
		
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;ad_mode = %d, ad_fmt = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ad_mode</span><span class="p">,</span> <span class="n">ad_fmt</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">framerate</span> <span class="o">&gt;=</span> <span class="mi">4000</span> <span class="o">&amp;&amp;</span> <span class="n">framerate</span> <span class="o">&lt;=</span> <span class="mi">49000</span><span class="p">);</span>
	<span class="n">ad1843_write_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_C1C</span><span class="p">,</span> <span class="n">framerate</span><span class="p">);</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_DA1SM</span><span class="p">,</span> <span class="n">ad_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_DA1F</span><span class="p">,</span> <span class="n">ad_fmt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ad1843_shutdown_dac</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ad1843_write_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_DA1F</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ad1843_setup_adc</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">,</span> <span class="kt">int</span> <span class="n">framerate</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fmt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">da_fmt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(lith=0x%p, framerate=%d, fmt=%d, channels=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">lith</span><span class="p">,</span> <span class="n">framerate</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">channels</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AFMT_S8</span>:		<span class="n">da_fmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFMT_U8</span>:		<span class="n">da_fmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFMT_S16_LE</span>:	<span class="n">da_fmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFMT_MU_LAW</span>:	<span class="n">da_fmt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AFMT_A_LAW</span>:	<span class="n">da_fmt</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;da_fmt = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">da_fmt</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">framerate</span> <span class="o">&gt;=</span> <span class="mi">4000</span> <span class="o">&amp;&amp;</span> <span class="n">framerate</span> <span class="o">&lt;=</span> <span class="mi">49000</span><span class="p">);</span>
	<span class="n">ad1843_write_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_C2C</span><span class="p">,</span> <span class="n">framerate</span><span class="p">);</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADLF</span><span class="p">,</span> <span class="n">da_fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_ADRF</span><span class="p">,</span> <span class="n">da_fmt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ad1843_shutdown_adc</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* nothing to do */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fully initialize the ad1843.  As described in the AD1843 data</span>
<span class="cm"> * sheet, section &quot;START-UP SEQUENCE&quot;.  The numbered comments are</span>
<span class="cm"> * subsection headings from the data sheet.  See the data sheet, pages</span>
<span class="cm"> * 52-54, for more info.</span>
<span class="cm"> *</span>
<span class="cm"> * return 0 on success, -errno on failure.  */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ad1843_init</span><span class="p">(</span><span class="n">lithium_t</span> <span class="o">*</span><span class="n">lith</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">later</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">li_init</span><span class="p">(</span><span class="n">lith</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ad1843_read_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_INIT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vwsnd sound: AD1843 won&#39;t initialize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ad1843_write_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_SCF</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* 4. Put the conversion resources into standby. */</span>

	<span class="n">ad1843_write_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_PDNI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">later</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* roughly half a second */</span>
	<span class="n">DBGDO</span><span class="p">(</span><span class="n">shut_up</span><span class="o">++</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ad1843_read_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_PDNO</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">later</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;vwsnd audio: AD1843 won&#39;t power up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">DBGDO</span><span class="p">(</span><span class="n">shut_up</span><span class="o">--</span><span class="p">);</span>

	<span class="cm">/* 5. Power up the clock generators and enable clock output pins. */</span>

	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_C1EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_C2EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* 6. Configure conversion resources while they are in standby. */</span>

 	<span class="cm">/* DAC1 uses clock 1 as source, ADC uses clock 2.  Always. */</span>

	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_DA1C</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADLC</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADRC</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* 7. Enable conversion resources. */</span>

	<span class="n">ad1843_write_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_ADTLK</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ANAEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_AAMEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_DA1EN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADLEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ad1843_ADREN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* 8. Configure conversion resources while they are enabled. */</span>

	<span class="n">ad1843_write_bits</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_DA1C</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Unmute all channels. */</span>

	<span class="n">ad1843_set_outsrc</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">SOUND_MASK_PCM</span> <span class="o">|</span> <span class="n">SOUND_MASK_LINE</span> <span class="o">|</span>
			   <span class="n">SOUND_MASK_MIC</span> <span class="o">|</span> <span class="n">SOUND_MASK_CD</span><span class="p">));</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LDA1AM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_RDA1AM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set default recording source to Line In and set</span>
<span class="cm">	 * mic gain to +20 dB.</span>
<span class="cm">	 */</span>

	<span class="n">ad1843_set_recsrc</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="n">SOUND_MASK_LINE</span><span class="p">);</span>
	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_LMGE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_RMGE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Set Speaker Out level to +/- 4V and unmute it. */</span>

	<span class="n">ad1843_write_multi</span><span class="p">(</span><span class="n">lith</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_HPOS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_HPOM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* PCM I/O */</span>

<span class="cp">#define READ_INTR_MASK  (LI_INTR_COMM1_TRIG | LI_INTR_COMM1_OVERFLOW)</span>
<span class="cp">#define WRITE_INTR_MASK (LI_INTR_COMM2_TRIG | LI_INTR_COMM2_UNDERFLOW)</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">vwsnd_port_swstate</span> <span class="p">{</span>	<span class="cm">/* software state */</span>
	<span class="n">SW_OFF</span><span class="p">,</span>
	<span class="n">SW_INITIAL</span><span class="p">,</span>
	<span class="n">SW_RUN</span><span class="p">,</span>
	<span class="n">SW_DRAIN</span><span class="p">,</span>
<span class="p">}</span> <span class="n">vwsnd_port_swstate_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">vwsnd_port_hwstate</span> <span class="p">{</span>	<span class="cm">/* hardware state */</span>
	<span class="n">HW_STOPPED</span><span class="p">,</span>
	<span class="n">HW_RUNNING</span><span class="p">,</span>
<span class="p">}</span> <span class="n">vwsnd_port_hwstate_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * These flags are read by ISR, but only written at baseline.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">vwsnd_port_flags</span> <span class="p">{</span>
	<span class="n">DISABLED</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ERFLOWN</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* overflown or underflown */</span>
	<span class="n">HW_BUSY</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span> <span class="n">vwsnd_port_flags_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * vwsnd_port is the per-port data structure.  Each device has two</span>
<span class="cm"> * ports, one for input and one for output.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:</span>
<span class="cm"> *</span>
<span class="cm"> *	port-&gt;lock protects: hwstate, flags, swb_[iu]_avail.</span>
<span class="cm"> *</span>
<span class="cm"> *	devc-&gt;io_mutex protects: swstate, sw_*, swb_[iu]_idx.</span>
<span class="cm"> *</span>
<span class="cm"> *	everything else is only written by open/release or</span>
<span class="cm"> *	pcm_{setup,shutdown}(), which are serialized by a</span>
<span class="cm"> *	combination of devc-&gt;open_mutex and devc-&gt;io_mutex.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">vwsnd_port</span> <span class="p">{</span>

	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">queue</span><span class="p">;</span>
	<span class="n">vwsnd_port_swstate_t</span> <span class="n">swstate</span><span class="p">;</span>
	<span class="n">vwsnd_port_hwstate_t</span> <span class="n">hwstate</span><span class="p">;</span>
	<span class="n">vwsnd_port_flags_t</span> <span class="n">flags</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="n">sw_channels</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">sw_samplefmt</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">sw_framerate</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">sample_size</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">frame_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">zero_word</span><span class="p">;</span>	<span class="cm">/* zero for the sample format */</span>

	<span class="kt">int</span>		<span class="n">sw_fragshift</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">sw_fragcount</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">sw_subdivshift</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">hw_fragshift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">hw_fragsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">hw_fragcount</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="n">hwbuf_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">hwbuf_paddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">hwbuf_vaddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span>		<span class="n">hwbuf</span><span class="p">;</span>		<span class="cm">/* hwbuf == hwbuf_vaddr */</span>
	<span class="kt">int</span>		<span class="n">hwbuf_max</span><span class="p">;</span>	<span class="cm">/* max bytes to preload */</span>

	<span class="kt">void</span> <span class="o">*</span>		<span class="n">swbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">swbuf_size</span><span class="p">;</span>	<span class="cm">/* size in bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">swb_u_idx</span><span class="p">;</span>	<span class="cm">/* index of next user byte */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">swb_i_idx</span><span class="p">;</span>	<span class="cm">/* index of next intr byte */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">swb_u_avail</span><span class="p">;</span>	<span class="cm">/* # bytes avail to user */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">swb_i_avail</span><span class="p">;</span>	<span class="cm">/* # bytes avail to intr */</span>

	<span class="n">dma_chan_t</span>	<span class="n">chan</span><span class="p">;</span>

	<span class="cm">/* Accounting */</span>

	<span class="kt">int</span>		<span class="n">byte_count</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">frag_count</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">MSC_offset</span><span class="p">;</span>

<span class="p">}</span> <span class="n">vwsnd_port_t</span><span class="p">;</span>

<span class="cm">/* vwsnd_dev is the per-device data structure. */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">vwsnd_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vwsnd_dev</span> <span class="o">*</span><span class="n">next_dev</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">audio_minor</span><span class="p">;</span>	<span class="cm">/* minor number of audio device */</span>
	<span class="kt">int</span>		<span class="n">mixer_minor</span><span class="p">;</span>	<span class="cm">/* minor number of mixer device */</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">open_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">io_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mix_mutex</span><span class="p">;</span>
	<span class="n">fmode_t</span>		<span class="n">open_mode</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">open_wait</span><span class="p">;</span>

	<span class="n">lithium_t</span>	<span class="n">lith</span><span class="p">;</span>

	<span class="n">vwsnd_port_t</span>	<span class="n">rport</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span>	<span class="n">wport</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vwsnd_dev_t</span><span class="p">;</span>

<span class="k">static</span> <span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">vwsnd_dev_list</span><span class="p">;</span>	<span class="cm">/* linked list of all devices */</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">vwsnd_use_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cp"># define INC_USE_COUNT (atomic_inc(&amp;vwsnd_use_count))</span>
<span class="cp"># define DEC_USE_COUNT (atomic_dec(&amp;vwsnd_use_count))</span>
<span class="cp"># define IN_USE        (atomic_read(&amp;vwsnd_use_count) != 0)</span>

<span class="cm">/*</span>
<span class="cm"> * Lithium can only DMA multiples of 32 bytes.  Its DMA buffer may</span>
<span class="cm"> * be up to 8 Kb.  This driver always uses 8 Kb.</span>
<span class="cm"> *</span>
<span class="cm"> * Memory bug workaround -- I&#39;m not sure what&#39;s going on here, but</span>
<span class="cm"> * somehow pcm_copy_out() was triggering segv&#39;s going on to the next</span>
<span class="cm"> * page of the hw buffer.  So, I make the hw buffer one size bigger</span>
<span class="cm"> * than we actually use.  That way, the following page is allocated</span>
<span class="cm"> * and mapped, and no error.  I suspect that something is broken</span>
<span class="cm"> * in Cobalt, but haven&#39;t really investigated.  HBO is the actual</span>
<span class="cm"> * size of the buffer, and HWBUF_ORDER is what we allocate.</span>
<span class="cm"> */</span>

<span class="cp">#define HWBUF_SHIFT 13</span>
<span class="cp">#define HWBUF_SIZE (1 &lt;&lt; HWBUF_SHIFT)</span>
<span class="cp"># define HBO         (HWBUF_SHIFT &gt; PAGE_SHIFT ? HWBUF_SHIFT - PAGE_SHIFT : 0)</span>
<span class="cp"># define HWBUF_ORDER (HBO + 1)		</span><span class="cm">/* next size bigger */</span><span class="cp"></span>
<span class="cp">#define MIN_SPEED 4000</span>
<span class="cp">#define MAX_SPEED 49000</span>

<span class="cp">#define MIN_FRAGSHIFT			(DMACHUNK_SHIFT + 1)</span>
<span class="cp">#define MAX_FRAGSHIFT			(PAGE_SHIFT)</span>
<span class="cp">#define MIN_FRAGSIZE			(1 &lt;&lt; MIN_FRAGSHIFT)</span>
<span class="cp">#define MAX_FRAGSIZE			(1 &lt;&lt; MAX_FRAGSHIFT)</span>
<span class="cp">#define MIN_FRAGCOUNT(fragsize)		3</span>
<span class="cp">#define MAX_FRAGCOUNT(fragsize)		(32 * PAGE_SIZE / (fragsize))</span>
<span class="cp">#define DEFAULT_FRAGSHIFT		12</span>
<span class="cp">#define DEFAULT_FRAGCOUNT		16</span>
<span class="cp">#define DEFAULT_SUBDIVSHIFT		0</span>

<span class="cm">/*</span>
<span class="cm"> * The software buffer (swbuf) is a ring buffer shared between user</span>
<span class="cm"> * level and interrupt level.  Each level owns some of the bytes in</span>
<span class="cm"> * the buffer, and may give bytes away by calling swb_inc_{u,i}().</span>
<span class="cm"> * User level calls _u for user, and interrupt level calls _i for</span>
<span class="cm"> * interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * port-&gt;swb_{u,i}_avail is the number of bytes available to that level.</span>
<span class="cm"> *</span>
<span class="cm"> * port-&gt;swb_{u,i}_idx is the index of the first available byte in the</span>
<span class="cm"> * buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Each level calls swb_inc_{u,i}() to atomically increment its index,</span>
<span class="cm"> * recalculate the number of bytes available for both sides, and</span>
<span class="cm"> * return the number of bytes available.  Since each side can only</span>
<span class="cm"> * give away bytes, the other side can only increase the number of</span>
<span class="cm"> * bytes available to this side.  Each side updates its own index</span>
<span class="cm"> * variable, swb_{u,i}_idx, so no lock is needed to read it.</span>
<span class="cm"> *</span>
<span class="cm"> * To query the number of bytes available, call swb_inc_{u,i} with an</span>
<span class="cm"> * increment of zero.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__swb_inc_u</span><span class="p">(</span><span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_u_idx</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_u_idx</span> <span class="o">%=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_u_avail</span> <span class="o">-=</span> <span class="n">inc</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_i_avail</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_u_avail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">swb_inc_u</span><span class="p">(</span><span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__swb_inc_u</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">inc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__swb_inc_i</span><span class="p">(</span><span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_i_idx</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_i_idx</span> <span class="o">%=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_i_avail</span> <span class="o">-=</span> <span class="n">inc</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_u_avail</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">swb_i_avail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">swb_inc_i</span><span class="p">(</span><span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__swb_inc_i</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">inc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pcm_setup - this routine initializes all port state after</span>
<span class="cm"> * mode-setting ioctls have been done, but before the first I/O is</span>
<span class="cm"> * done.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: called with devc-&gt;io_mutex held.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -errno on failure.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcm_setup</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span>
		     <span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">rport</span><span class="p">,</span>
		     <span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">aport</span> <span class="o">=</span> <span class="n">rport</span> <span class="o">?</span> <span class="n">rport</span> <span class="o">:</span> <span class="n">wport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sample_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zero_word</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(devc=0x%p, rport=0x%p, wport=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">aport</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_samplefmt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AFMT_MU_LAW</span>:
		<span class="n">sample_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">zero_word</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span> <span class="o">^</span> <span class="mh">0x80808080</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AFMT_A_LAW</span>:
		<span class="n">sample_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">zero_word</span> <span class="o">=</span> <span class="mh">0xD5D5D5D5</span> <span class="o">^</span> <span class="mh">0x80808080</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AFMT_U8</span>:
		<span class="n">sample_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">zero_word</span> <span class="o">=</span> <span class="mh">0x80808080</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AFMT_S8</span>:
		<span class="n">sample_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">zero_word</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AFMT_S16_LE</span>:
		<span class="n">sample_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">zero_word</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">sample_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* prevent compiler warning */</span>
		<span class="n">zero_word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">sample_size</span>  <span class="o">=</span> <span class="n">sample_size</span><span class="p">;</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">zero_word</span>    <span class="o">=</span> <span class="n">zero_word</span><span class="p">;</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">frame_size</span>   <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_channels</span> <span class="o">*</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sample_size</span><span class="p">;</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span> <span class="o">-</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_subdivshift</span><span class="p">;</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span><span class="p">;</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragcount</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_fragcount</span> <span class="o">&lt;&lt;</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_subdivshift</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span> <span class="o">&gt;=</span> <span class="n">MIN_FRAGSIZE</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span> <span class="o">&lt;=</span> <span class="n">MAX_FRAGSIZE</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragcount</span> <span class="o">&gt;=</span> <span class="n">MIN_FRAGCOUNT</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragcount</span> <span class="o">&lt;=</span> <span class="n">MAX_FRAGCOUNT</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">hwfrags</span><span class="p">,</span> <span class="n">swfrags</span><span class="p">;</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hwbuf_size</span> <span class="o">-</span> <span class="n">DMACHUNK_SIZE</span><span class="p">;</span>
		<span class="n">hwfrags</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span> <span class="o">&gt;&gt;</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span><span class="p">;</span>
		<span class="n">swfrags</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragcount</span> <span class="o">-</span> <span class="n">hwfrags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swfrags</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">swfrags</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span> <span class="o">=</span> <span class="n">swfrags</span> <span class="o">*</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span><span class="p">;</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;hwfrags = %d, swfrags = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hwfrags</span><span class="p">,</span> <span class="n">swfrags</span><span class="p">);</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;read hwbuf_max = %d, swbuf_size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">hwfrags</span><span class="p">,</span> <span class="n">swfrags</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragcount</span> <span class="o">*</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hwbuf_size</span> <span class="o">-</span> <span class="n">DMACHUNK_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span> <span class="o">&gt;</span> <span class="n">total_bytes</span><span class="p">)</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span> <span class="o">=</span> <span class="n">total_bytes</span><span class="p">;</span>
		<span class="n">hwfrags</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span> <span class="o">&gt;&gt;</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span><span class="p">;</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;hwfrags = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hwfrags</span><span class="p">);</span>
		<span class="n">swfrags</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragcount</span> <span class="o">-</span> <span class="n">hwfrags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swfrags</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">swfrags</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span> <span class="o">=</span> <span class="n">swfrags</span> <span class="o">*</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span><span class="p">;</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;hwfrags = %d, swfrags = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hwfrags</span><span class="p">,</span> <span class="n">swfrags</span><span class="p">);</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;write hwbuf_max = %d, swbuf_size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span><span class="p">,</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">swb_u_idx</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">swb_i_idx</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">byte_count</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is this a Cobalt bug?  We need to make this buffer extend</span>
<span class="cm">	 * one page further than we actually use -- somehow memcpy</span>
<span class="cm">	 * causes an exceptoin otherwise.  I suspect there&#39;s a bug in</span>
<span class="cm">	 * Cobalt (or somewhere) where it&#39;s generating a fault on a</span>
<span class="cm">	 * speculative load or something.  Obviously, I haven&#39;t taken</span>
<span class="cm">	 * the time to track it down.</span>
<span class="cm">	 */</span>

	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf</span>        <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span> <span class="o">&amp;&amp;</span> <span class="n">wport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">aport</span> <span class="o">==</span> <span class="n">rport</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* One extra page - see comment above. */</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf</span><span class="p">);</span>
			<span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">sample_size</span>  <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sample_size</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">zero_word</span>    <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">zero_word</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">frame_size</span>   <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">frame_size</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span>  <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hw_fragcount</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hw_fragcount</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span>   <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span>    <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_u_idx</span>    <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swb_u_idx</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_i_idx</span>    <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swb_i_idx</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">byte_count</span>   <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">byte_count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">swb_u_avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">swb_i_avail</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">;</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_RUN</span><span class="p">;</span>
		<span class="n">li_setup_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">li_comm1</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span>
			     <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf_paddr</span><span class="p">,</span>
			     <span class="n">HWBUF_SHIFT</span><span class="p">,</span>
			     <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span><span class="p">,</span>
			     <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_channels</span><span class="p">,</span>
			     <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sample_size</span><span class="p">);</span>
		<span class="n">ad1843_setup_adc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span>
				 <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_framerate</span><span class="p">,</span>
				 <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_samplefmt</span><span class="p">,</span>
				 <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_channels</span><span class="p">);</span>
		<span class="n">li_enable_interrupts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">READ_INTR_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISABLED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ustmsc_t</span> <span class="n">ustmsc</span><span class="p">;</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwstate</span> <span class="o">=</span> <span class="n">HW_RUNNING</span><span class="p">;</span>
			<span class="n">li_activate_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
			<span class="n">li_read_USTMSC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ustmsc</span><span class="p">);</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">MSC_offset</span> <span class="o">=</span> <span class="n">ustmsc</span><span class="p">.</span><span class="n">msc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span> <span class="o">&gt;</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">)</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ERFLOWN</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_u_avail</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_i_avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_RUN</span><span class="p">;</span>
		<span class="n">li_setup_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">li_comm2</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span>
			     <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_paddr</span><span class="p">,</span>
			     <span class="n">HWBUF_SHIFT</span><span class="p">,</span>
			     <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span><span class="p">,</span>
			     <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_channels</span><span class="p">,</span>
			     <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sample_size</span><span class="p">);</span>
		<span class="n">ad1843_setup_dac</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span>
				 <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_framerate</span><span class="p">,</span>
				 <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_samplefmt</span><span class="p">,</span>
				 <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_channels</span><span class="p">);</span>
		<span class="n">li_enable_interrupts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">WRITE_INTR_MASK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DBGRV</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pcm_shutdown_port - shut down one port (direction) for PCM I/O.</span>
<span class="cm"> * Only called from pcm_shutdown.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcm_shutdown_port</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span>
			      <span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">aport</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">vwsnd_port_hwstate_t</span> <span class="n">hwstate</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_INITIAL</span><span class="p">;</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">{</span>
			<span class="n">hwstate</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">hwstate</span><span class="p">;</span>
		<span class="p">}</span>		
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwstate</span> <span class="o">==</span> <span class="n">HW_STOPPED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">li_disable_interrupts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aport</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">)</span>
		<span class="n">ad1843_shutdown_adc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">);</span>
	<span class="k">else</span> <span class="cm">/* aport == &amp;devc-&gt;wport) */</span>
		<span class="n">ad1843_shutdown_dac</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">);</span>
	<span class="n">li_shutdown_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf</span><span class="p">);</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">aport</span><span class="o">-&gt;</span><span class="n">byte_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pcm_shutdown undoes what pcm_setup did.</span>
<span class="cm"> * Also sets the ports&#39; swstate to newstate.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcm_shutdown</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span>
			 <span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">rport</span><span class="p">,</span>
			 <span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(devc=0x%p, rport=0x%p, wport=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span> <span class="o">&amp;&amp;</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;shutting down rport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pcm_shutdown_port</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">READ_INTR_MASK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wport</span> <span class="o">&amp;&amp;</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;shutting down wport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pcm_shutdown_port</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">wport</span><span class="p">,</span> <span class="n">WRITE_INTR_MASK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DBGRV</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcm_copy_in</span><span class="p">(</span><span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">rport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">swidx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hwidx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf</span> <span class="o">+</span> <span class="n">hwidx</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">+</span> <span class="n">swidx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_samplefmt</span><span class="p">;</span>

	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;swidx = %d, hwidx = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">swidx</span><span class="p">,</span> <span class="n">hwidx</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nb</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">swidx</span> <span class="o">%</span> <span class="mi">32</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hwidx</span> <span class="o">%</span> <span class="mi">32</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">swidx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">swidx</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">&lt;=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">hwidx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hwidx</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">&lt;=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">==</span> <span class="n">AFMT_MU_LAW</span> <span class="o">||</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">AFMT_A_LAW</span> <span class="o">||</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">AFMT_S8</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* See Sample Format Notes above. */</span>

		<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="n">nb</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">src</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span> <span class="o">^</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcm_copy_out</span><span class="p">(</span><span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">swidx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hwidx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">+</span> <span class="n">swidx</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf</span> <span class="o">+</span> <span class="n">hwidx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_samplefmt</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nb</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">swidx</span> <span class="o">%</span> <span class="mi">32</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hwidx</span> <span class="o">%</span> <span class="mi">32</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">swidx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">swidx</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">&lt;=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">hwidx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hwidx</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">&lt;=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">==</span> <span class="n">AFMT_MU_LAW</span> <span class="o">||</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">AFMT_A_LAW</span> <span class="o">||</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">AFMT_S8</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* See Sample Format Notes above. */</span>

		<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="n">nb</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">src</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span> <span class="o">^</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pcm_output() is called both from baselevel and from interrupt level.</span>
<span class="cm"> * This is where audio frames are copied into the hardware-accessible</span>
<span class="cm"> * ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking note: The part of this routine that figures out what to do</span>
<span class="cm"> * holds wport-&gt;lock.  The longer part releases wport-&gt;lock, but sets</span>
<span class="cm"> * wport-&gt;flags &amp; HW_BUSY.  Afterward, it reacquires wport-&gt;lock, and</span>
<span class="cm"> * checks for more work to do.</span>
<span class="cm"> *</span>
<span class="cm"> * If another thread calls pcm_output() while HW_BUSY is set, it</span>
<span class="cm"> * returns immediately, knowing that the thread that set HW_BUSY will</span>
<span class="cm"> * look for more work to do before returning.</span>
<span class="cm"> *</span>
<span class="cm"> * This has the advantage that port-&gt;lock is held for several short</span>
<span class="cm"> * periods instead of one long period.  Also, when pcm_output is</span>
<span class="cm"> * called from base level, it reenables interrupts.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcm_output</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">erflown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">hwmax</span>  <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">hwsize</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">swsize</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">fragsize</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(devc=0x%p, erflown=%d, nb=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">,</span> <span class="n">erflown</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">erflown</span><span class="p">)</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ERFLOWN</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__swb_inc_u</span><span class="p">(</span><span class="n">wport</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HW_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;returning: HW BUSY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;returning: DISABLED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">HW_BUSY</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">swptr</span><span class="p">,</span> <span class="n">hwptr</span><span class="p">,</span> <span class="n">hw_avail</span><span class="p">,</span> <span class="n">sw_avail</span><span class="p">,</span> <span class="n">swidx</span><span class="p">;</span>
		<span class="n">vwsnd_port_hwstate_t</span> <span class="n">hwstate</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwstate</span><span class="p">;</span>
		<span class="n">vwsnd_port_swstate_t</span> <span class="n">swstate</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">hw_unavail</span><span class="p">;</span>
		<span class="n">ustmsc_t</span> <span class="n">ustmsc</span><span class="p">;</span>

		<span class="n">hwptr</span> <span class="o">=</span> <span class="n">li_read_hwptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
		<span class="n">swptr</span> <span class="o">=</span> <span class="n">li_read_swptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
		<span class="n">hw_unavail</span> <span class="o">=</span> <span class="p">(</span><span class="n">swptr</span> <span class="o">-</span> <span class="n">hwptr</span> <span class="o">+</span> <span class="n">hwsize</span><span class="p">)</span> <span class="o">%</span> <span class="n">hwsize</span><span class="p">;</span>
		<span class="n">hw_avail</span> <span class="o">=</span> <span class="p">(</span><span class="n">hwmax</span> <span class="o">-</span> <span class="n">hw_unavail</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">fragsize</span><span class="p">;</span>
		<span class="n">sw_avail</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_i_avail</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">fragsize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sw_avail</span> <span class="o">&amp;&amp;</span> <span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_RUN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ERFLOWN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ERFLOWN</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_INITIAL</span> <span class="o">||</span>
			 <span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_OFF</span> <span class="o">||</span>
			 <span class="p">(</span><span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_DRAIN</span> <span class="o">&amp;&amp;</span>
			  <span class="o">!</span><span class="n">sw_avail</span> <span class="o">&amp;&amp;</span>
			  <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ERFLOWN</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;stopping.  hwstate = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hwstate</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hwstate</span> <span class="o">!=</span> <span class="n">HW_STOPPED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">li_deactivate_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
				<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwstate</span> <span class="o">=</span> <span class="n">HW_STOPPED</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sw_avail</span> <span class="o">||</span> <span class="o">!</span><span class="n">hw_avail</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We gave up the port lock, but we have the HW_BUSY flag.</span>
<span class="cm">		 * Proceed without accessing any nonlocal state.</span>
<span class="cm">		 * Do not exit the loop -- must check for more work.</span>
<span class="cm">		 */</span>

		<span class="n">swidx</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_i_idx</span><span class="p">;</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">hw_avail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">sw_avail</span><span class="p">)</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">sw_avail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">hwsize</span> <span class="o">-</span> <span class="n">swptr</span><span class="p">)</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">hwsize</span> <span class="o">-</span> <span class="n">swptr</span><span class="p">;</span> <span class="cm">/* don&#39;t overflow hwbuf */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">swsize</span> <span class="o">-</span> <span class="n">swidx</span><span class="p">)</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">swsize</span> <span class="o">-</span> <span class="n">swidx</span><span class="p">;</span> <span class="cm">/* don&#39;t overflow swbuf */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">%</span> <span class="n">fragsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;nb = %d, fragsize = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">fragsize</span><span class="p">);</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;hw_avail = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw_avail</span><span class="p">);</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;sw_avail = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sw_avail</span><span class="p">);</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;hwsize = %d, swptr = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hwsize</span><span class="p">,</span> <span class="n">swptr</span><span class="p">);</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;swsize = %d, swidx = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">swsize</span><span class="p">,</span> <span class="n">swidx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nb</span> <span class="o">%</span> <span class="n">fragsize</span><span class="p">));</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;copying swb[%d..%d] to hwb[%d..%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">swidx</span><span class="p">,</span> <span class="n">swidx</span> <span class="o">+</span> <span class="n">nb</span><span class="p">,</span> <span class="n">swptr</span><span class="p">,</span> <span class="n">swptr</span> <span class="o">+</span> <span class="n">nb</span><span class="p">);</span>
		<span class="n">pcm_copy_out</span><span class="p">(</span><span class="n">wport</span><span class="p">,</span> <span class="n">swidx</span><span class="p">,</span> <span class="n">swptr</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="n">li_write_swptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="p">(</span><span class="n">swptr</span> <span class="o">+</span> <span class="n">nb</span><span class="p">)</span> <span class="o">%</span> <span class="n">hwsize</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwstate</span> <span class="o">==</span> <span class="n">HW_STOPPED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;starting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">li_activate_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwstate</span> <span class="o">=</span> <span class="n">HW_RUNNING</span><span class="p">;</span>
			<span class="n">li_read_USTMSC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ustmsc</span><span class="p">);</span>
			<span class="n">ASSERT</span><span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">byte_count</span> <span class="o">%</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">frame_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">MSC_offset</span> <span class="o">=</span> <span class="n">ustmsc</span><span class="p">.</span><span class="n">msc</span> <span class="o">-</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">byte_count</span> <span class="o">/</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">frame_size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__swb_inc_i</span><span class="p">(</span><span class="n">wport</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">byte_count</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">;</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">frag_count</span> <span class="o">+=</span> <span class="n">nb</span> <span class="o">/</span> <span class="n">fragsize</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nb</span> <span class="o">%</span> <span class="n">fragsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HW_BUSY</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">DBGRV</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pcm_input() is called both from baselevel and from interrupt level.</span>
<span class="cm"> * This is where audio frames are copied out of the hardware-accessible</span>
<span class="cm"> * ring buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking note: The part of this routine that figures out what to do</span>
<span class="cm"> * holds rport-&gt;lock.  The longer part releases rport-&gt;lock, but sets</span>
<span class="cm"> * rport-&gt;flags &amp; HW_BUSY.  Afterward, it reacquires rport-&gt;lock, and</span>
<span class="cm"> * checks for more work to do.</span>
<span class="cm"> *</span>
<span class="cm"> * If another thread calls pcm_input() while HW_BUSY is set, it</span>
<span class="cm"> * returns immediately, knowing that the thread that set HW_BUSY will</span>
<span class="cm"> * look for more work to do before returning.</span>
<span class="cm"> *</span>
<span class="cm"> * This has the advantage that port-&gt;lock is held for several short</span>
<span class="cm"> * periods instead of one long period.  Also, when pcm_input is</span>
<span class="cm"> * called from base level, it reenables interrupts.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcm_input</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">erflown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">hwmax</span>  <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf_max</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">hwsize</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwbuf_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">swsize</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf_size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">fragsize</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(devc=0x%p, erflown=%d, nb=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">,</span> <span class="n">erflown</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">erflown</span><span class="p">)</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ERFLOWN</span><span class="p">;</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__swb_inc_u</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HW_BUSY</span> <span class="o">||</span> <span class="o">!</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;returning: HW BUSY or !swbuf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;returning: DISABLED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">HW_BUSY</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">swptr</span><span class="p">,</span> <span class="n">hwptr</span><span class="p">,</span> <span class="n">hw_avail</span><span class="p">,</span> <span class="n">sw_avail</span><span class="p">,</span> <span class="n">swidx</span><span class="p">;</span>
		<span class="n">vwsnd_port_hwstate_t</span> <span class="n">hwstate</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwstate</span><span class="p">;</span>
		<span class="n">vwsnd_port_swstate_t</span> <span class="n">swstate</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swstate</span><span class="p">;</span>

		<span class="n">hwptr</span> <span class="o">=</span> <span class="n">li_read_hwptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
		<span class="n">swptr</span> <span class="o">=</span> <span class="n">li_read_swptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
		<span class="n">hw_avail</span> <span class="o">=</span> <span class="p">(</span><span class="n">hwptr</span> <span class="o">-</span> <span class="n">swptr</span> <span class="o">+</span> <span class="n">hwsize</span><span class="p">)</span> <span class="o">%</span> <span class="n">hwsize</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">fragsize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw_avail</span> <span class="o">&gt;</span> <span class="n">hwmax</span><span class="p">)</span>
			<span class="n">hw_avail</span> <span class="o">=</span> <span class="n">hwmax</span><span class="p">;</span>
		<span class="n">sw_avail</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swb_i_avail</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">fragsize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swstate</span> <span class="o">!=</span> <span class="n">SW_RUN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;stopping.  hwstate = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hwstate</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hwstate</span> <span class="o">!=</span> <span class="n">HW_STOPPED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">li_deactivate_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwstate</span> <span class="o">=</span> <span class="n">HW_STOPPED</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sw_avail</span> <span class="o">||</span> <span class="o">!</span><span class="n">hw_avail</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We gave up the port lock, but we have the HW_BUSY flag.</span>
<span class="cm">		 * Proceed without accessing any nonlocal state.</span>
<span class="cm">		 * Do not exit the loop -- must check for more work.</span>
<span class="cm">		 */</span>

		<span class="n">swidx</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swb_i_idx</span><span class="p">;</span>
		<span class="n">nb</span> <span class="o">=</span> <span class="n">hw_avail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">sw_avail</span><span class="p">)</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">sw_avail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">hwsize</span> <span class="o">-</span> <span class="n">swptr</span><span class="p">)</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">hwsize</span> <span class="o">-</span> <span class="n">swptr</span><span class="p">;</span> <span class="cm">/* don&#39;t overflow hwbuf */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">swsize</span> <span class="o">-</span> <span class="n">swidx</span><span class="p">)</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">swsize</span> <span class="o">-</span> <span class="n">swidx</span><span class="p">;</span> <span class="cm">/* don&#39;t overflow swbuf */</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">%</span> <span class="n">fragsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;nb = %d, fragsize = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="n">fragsize</span><span class="p">);</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;hw_avail = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw_avail</span><span class="p">);</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;sw_avail = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sw_avail</span><span class="p">);</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;hwsize = %d, swptr = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hwsize</span><span class="p">,</span> <span class="n">swptr</span><span class="p">);</span>
			<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;swsize = %d, swidx = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">swsize</span><span class="p">,</span> <span class="n">swidx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nb</span> <span class="o">%</span> <span class="n">fragsize</span><span class="p">));</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;copying hwb[%d..%d] to swb[%d..%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">swptr</span><span class="p">,</span> <span class="n">swptr</span> <span class="o">+</span> <span class="n">nb</span><span class="p">,</span> <span class="n">swidx</span><span class="p">,</span> <span class="n">swidx</span> <span class="o">+</span> <span class="n">nb</span><span class="p">);</span>
		<span class="n">pcm_copy_in</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">swidx</span><span class="p">,</span> <span class="n">swptr</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="n">li_write_swptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="p">(</span><span class="n">swptr</span> <span class="o">+</span> <span class="n">nb</span><span class="p">)</span> <span class="o">%</span> <span class="n">hwsize</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">__swb_inc_i</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">byte_count</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">;</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">frag_count</span> <span class="o">+=</span> <span class="n">nb</span> <span class="o">/</span> <span class="n">fragsize</span><span class="p">;</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="n">nb</span> <span class="o">%</span> <span class="n">fragsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HW_BUSY</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">DBGRV</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pcm_flush_frag() writes zero samples to fill the current fragment,</span>
<span class="cm"> * then flushes it to the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * It is only meaningful to flush output, not input.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcm_flush_frag</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">;</span>

	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;swstate = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_RUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_u_idx</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hw_fragsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span>
			<span class="o">&lt;&lt;</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hw_fragshift</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">idx</span><span class="p">;</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;clearing %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">zero_word</span><span class="p">,</span>
			       <span class="n">nb</span><span class="p">);</span>
		<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_DRAIN</span><span class="p">;</span>
		<span class="n">pcm_output</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DBGRV</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for output to drain.  This sleeps uninterruptibly because</span>
<span class="cm"> * there is nothing intelligent we can do if interrupted.  This</span>
<span class="cm"> * means the process will be delayed in responding to the signal.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcm_write_sync</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">vwsnd_port_hwstate_t</span> <span class="n">hwstate</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(devc=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">);</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">{</span>
			<span class="n">hwstate</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwstate</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hwstate</span> <span class="o">==</span> <span class="n">HW_STOPPED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;swstate = %d, hwstate = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span><span class="p">,</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwstate</span><span class="p">);</span>
	<span class="n">DBGRV</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* audio driver */</span>

<span class="cm">/*</span>
<span class="cm"> * seek on an audio device always fails.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vwsnd_audio_read_intr</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">overflown</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">LI_INTR_COMM1_OVERFLOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">READ_INTR_MASK</span><span class="p">)</span>
		<span class="n">pcm_input</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">overflown</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">vwsnd_audio_write_intr</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">underflown</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">LI_INTR_COMM2_UNDERFLOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">WRITE_INTR_MASK</span><span class="p">)</span>
		<span class="n">pcm_output</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">underflown</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">vwsnd_audio_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(irq=%d, dev_id=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">li_get_clear_intr_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">);</span>
	<span class="n">vwsnd_audio_read_intr</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">vwsnd_audio_write_intr</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vwsnd_audio_do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				   <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="o">?</span>
			       <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nb</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(file=0x%p, buffer=0x%p, count=%d, ppos=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">file</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rport</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">?</span>
			<span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pcm_setup</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">nb</span> <span class="o">=</span> <span class="n">swb_inc_u</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;blocking</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISABLED</span> <span class="o">||</span>
			    <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
				<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
				<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">pcm_input</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* nb bytes are available in userbuf. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;nb = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">+</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">swb_u_idx</span><span class="p">,</span> <span class="n">nb</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">swb_inc_u</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="n">buffer</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;returning %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vwsnd_audio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vwsnd_audio_do_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vwsnd_audio_do_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				    <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span> <span class="o">=</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">?</span>
			       <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nb</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(file=0x%p, buffer=0x%p, count=%d, ppos=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">file</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wport</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="o">?</span>
			<span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pcm_setup</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">nb</span> <span class="o">=</span> <span class="n">swb_inc_u</span><span class="p">(</span><span class="n">wport</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISABLED</span> <span class="o">||</span>
			    <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
				<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
				<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="cm">/* nb bytes are available in userbuf. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">nb</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;nb = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">+</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_u_idx</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">nb</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">pcm_output</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
		<span class="n">buffer</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">nb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;returning %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vwsnd_audio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				 <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vwsnd_audio_do_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No kernel lock - fine */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">vwsnd_audio_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="o">?</span>
		<span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">?</span>
		<span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(file=0x%p, wait=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">rport</span> <span class="o">||</span> <span class="n">wport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swb_inc_u</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">swb_inc_u</span><span class="p">(</span><span class="n">wport</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;returning 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vwsnd_audio_do_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="o">?</span>
		<span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">?</span>
		<span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">aport</span> <span class="o">=</span> <span class="n">rport</span> <span class="o">?</span> <span class="n">rport</span> <span class="o">:</span> <span class="n">wport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audio_buf_info</span> <span class="n">buf_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">count_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ival</span><span class="p">;</span>

	
	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(file=0x%p, cmd=0x%x, arg=0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OSS_GETVERSION</span>:		<span class="cm">/* _SIOR (&#39;M&#39;, 118, int) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;OSS_GETVERSION</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">SOUND_VERSION</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETCAPS</span>:	<span class="cm">/* _SIOR (&#39;P&#39;,15, int) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETCAPS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">DSP_CAP_DUPLEX</span> <span class="o">|</span> <span class="n">DSP_CAP_REALTIME</span> <span class="o">|</span> <span class="n">DSP_CAP_TRIGGER</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETFMTS</span>:	<span class="cm">/* _SIOR (&#39;P&#39;,11, int) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETFMTS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="p">(</span><span class="n">AFMT_S16_LE</span> <span class="o">|</span> <span class="n">AFMT_MU_LAW</span> <span class="o">|</span> <span class="n">AFMT_A_LAW</span> <span class="o">|</span>
			<span class="n">AFMT_U8</span> <span class="o">|</span> <span class="n">AFMT_S8</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_PCM_READ_RATE</span>:	<span class="cm">/* _SIOR (&#39;P&#39;, 2, int) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SOUND_PCM_READ_RATE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_framerate</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SOUND_PCM_READ_CHANNELS</span>:	<span class="cm">/* _SIOR (&#39;P&#39;, 6, int) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SOUND_PCM_READ_CHANNELS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_channels</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_SPEED</span>:		<span class="cm">/* _SIOWR(&#39;P&#39;, 2, int) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_SPEED %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ival</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">!=</span> <span class="n">SW_INITIAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_SPEED failed: swstate = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&lt;</span> <span class="n">MIN_SPEED</span><span class="p">)</span>
				<span class="n">ival</span> <span class="o">=</span> <span class="n">MIN_SPEED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&gt;</span> <span class="n">MAX_SPEED</span><span class="p">)</span>
				<span class="n">ival</span> <span class="o">=</span> <span class="n">MAX_SPEED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span>
				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_framerate</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span>
				<span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_framerate</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ival</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_framerate</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_STEREO</span>:		<span class="cm">/* _SIOWR(&#39;P&#39;, 3, int) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_STEREO %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ival</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ival</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">!=</span> <span class="n">SW_INITIAL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_channels</span> <span class="o">=</span> <span class="n">ival</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_channels</span> <span class="o">=</span> <span class="n">ival</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_CHANNELS</span>:	<span class="cm">/* _SIOWR(&#39;P&#39;, 6, int) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_CHANNELS %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ival</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ival</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">!=</span> <span class="n">SW_INITIAL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_channels</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_channels</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETBLKSIZE</span>:	<span class="cm">/* _SIOWR(&#39;P&#39;, 4, int) */</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">pcm_setup</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETBLKSIZE failed, errno %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ival</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ival</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETBLKSIZE returning %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ival</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_SETFRAGMENT</span>:	<span class="cm">/* _SIOWR(&#39;P&#39;,10, int) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_SETFRAGMENT %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ival</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">ival</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">!=</span> <span class="n">SW_INITIAL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">sw_fragshift</span> <span class="o">=</span> <span class="n">ival</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">sw_subdivshift</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_subdivshift</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">hw_fragshift</span> <span class="o">=</span> <span class="n">sw_fragshift</span> <span class="o">-</span> <span class="n">sw_subdivshift</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">sw_fragcount</span> <span class="o">=</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">hw_fragsize</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw_fragshift</span> <span class="o">&lt;</span> <span class="n">MIN_FRAGSHIFT</span><span class="p">)</span>
				<span class="n">hw_fragshift</span> <span class="o">=</span> <span class="n">MIN_FRAGSHIFT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw_fragshift</span> <span class="o">&gt;</span> <span class="n">MAX_FRAGSHIFT</span><span class="p">)</span>
				<span class="n">hw_fragshift</span> <span class="o">=</span> <span class="n">MAX_FRAGSHIFT</span><span class="p">;</span>
			<span class="n">sw_fragshift</span> <span class="o">=</span> <span class="n">hw_fragshift</span> <span class="o">+</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_subdivshift</span><span class="p">;</span>
			<span class="n">hw_fragsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hw_fragshift</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sw_fragcount</span> <span class="o">&lt;</span> <span class="n">MIN_FRAGCOUNT</span><span class="p">(</span><span class="n">hw_fragsize</span><span class="p">))</span>
				<span class="n">sw_fragcount</span> <span class="o">=</span> <span class="n">MIN_FRAGCOUNT</span><span class="p">(</span><span class="n">hw_fragsize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sw_fragcount</span> <span class="o">&gt;</span> <span class="n">MAX_FRAGCOUNT</span><span class="p">(</span><span class="n">hw_fragsize</span><span class="p">))</span>
				<span class="n">sw_fragcount</span> <span class="o">=</span> <span class="n">MAX_FRAGCOUNT</span><span class="p">(</span><span class="n">hw_fragsize</span><span class="p">);</span>
			<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;sw_fragshift = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sw_fragshift</span><span class="p">);</span>
			<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;rport = 0x%p, wport = 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span> <span class="o">=</span> <span class="n">sw_fragshift</span><span class="p">;</span>
				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_fragcount</span> <span class="o">=</span> <span class="n">sw_fragcount</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span> <span class="o">=</span> <span class="n">sw_fragshift</span><span class="p">;</span>
				<span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_fragcount</span> <span class="o">=</span> <span class="n">sw_fragcount</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ival</span> <span class="o">=</span> <span class="n">sw_fragcount</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> <span class="n">sw_fragshift</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_SETFRAGMENT returns %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">ival</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">ival</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_SUBDIVIDE</span>:	<span class="cm">/* _SIOWR(&#39;P&#39;, 9, int) */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_SUBDIVIDE %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ival</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">!=</span> <span class="n">SW_INITIAL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">subdivshift</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">hw_fragshift</span><span class="p">,</span> <span class="n">hw_fragsize</span><span class="p">,</span> <span class="n">hw_fragcount</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">ival</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">1</span>: <span class="n">subdivshift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>: <span class="n">subdivshift</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">4</span>: <span class="n">subdivshift</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">hw_fragshift</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span> <span class="o">-</span> <span class="n">subdivshift</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw_fragshift</span> <span class="o">&lt;</span> <span class="n">MIN_FRAGSHIFT</span> <span class="o">||</span>
			    <span class="n">hw_fragshift</span> <span class="o">&gt;</span> <span class="n">MAX_FRAGSHIFT</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">hw_fragsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hw_fragshift</span><span class="p">;</span>
			<span class="n">hw_fragcount</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_fragcount</span> <span class="o">&gt;&gt;</span> <span class="n">subdivshift</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw_fragcount</span> <span class="o">&lt;</span> <span class="n">MIN_FRAGCOUNT</span><span class="p">(</span><span class="n">hw_fragsize</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">hw_fragcount</span> <span class="o">&gt;</span> <span class="n">MAX_FRAGCOUNT</span><span class="p">(</span><span class="n">hw_fragsize</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span>
				<span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_subdivshift</span> <span class="o">=</span> <span class="n">subdivshift</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span>
				<span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_subdivshift</span> <span class="o">=</span> <span class="n">subdivshift</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_SETFMT</span>:		<span class="cm">/* _SIOWR(&#39;P&#39;,5, int) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_SETFMT %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ival</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">!=</span> <span class="n">AFMT_QUERY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">!=</span> <span class="n">SW_INITIAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;SETFMT failed, swstate = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">ival</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">AFMT_MU_LAW</span>:
			<span class="k">case</span> <span class="n">AFMT_A_LAW</span>:
			<span class="k">case</span> <span class="n">AFMT_U8</span>:
			<span class="k">case</span> <span class="n">AFMT_S8</span>:
			<span class="k">case</span> <span class="n">AFMT_S16_LE</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span>
					<span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_samplefmt</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span>
					<span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_samplefmt</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">aport</span><span class="o">-&gt;</span><span class="n">sw_samplefmt</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETOSPACE</span>:	<span class="cm">/* _SIOR (&#39;P&#39;,12, audio_buf_info) */</span>
		<span class="n">DBGXV</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETOSPACE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wport</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">pcm_setup</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ival</span><span class="p">;</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">swb_inc_u</span><span class="p">(</span><span class="n">wport</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">buf_info</span><span class="p">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">ival</span> <span class="o">&gt;&gt;</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span><span class="p">;</span>
		<span class="n">buf_info</span><span class="p">.</span><span class="n">fragstotal</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_fragcount</span><span class="p">;</span>
		<span class="n">buf_info</span><span class="p">.</span><span class="n">fragsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span><span class="p">;</span>
		<span class="n">buf_info</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>
		<span class="n">DBGXV</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETOSPACE returns { %d %d %d %d }</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">buf_info</span><span class="p">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">buf_info</span><span class="p">.</span><span class="n">fragstotal</span><span class="p">,</span>
		     <span class="n">buf_info</span><span class="p">.</span><span class="n">fragsize</span><span class="p">,</span> <span class="n">buf_info</span><span class="p">.</span><span class="n">bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_info</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf_info</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETISPACE</span>:	<span class="cm">/* _SIOR (&#39;P&#39;,13, audio_buf_info) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETISPACE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rport</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">pcm_setup</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ival</span><span class="p">;</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="n">swb_inc_u</span><span class="p">(</span><span class="n">rport</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">buf_info</span><span class="p">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">ival</span> <span class="o">&gt;&gt;</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span><span class="p">;</span>
		<span class="n">buf_info</span><span class="p">.</span><span class="n">fragstotal</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_fragcount</span><span class="p">;</span>
		<span class="n">buf_info</span><span class="p">.</span><span class="n">fragsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">sw_fragshift</span><span class="p">;</span>
		<span class="n">buf_info</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETISPACE returns { %d %d %d %d }</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">buf_info</span><span class="p">.</span><span class="n">fragments</span><span class="p">,</span> <span class="n">buf_info</span><span class="p">.</span><span class="n">fragstotal</span><span class="p">,</span>
		     <span class="n">buf_info</span><span class="p">.</span><span class="n">fragsize</span><span class="p">,</span> <span class="n">buf_info</span><span class="p">.</span><span class="n">bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_info</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf_info</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_NONBLOCK</span>:	<span class="cm">/* _SIO  (&#39;P&#39;,14) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_NONBLOCK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_RESET</span>:		<span class="cm">/* _SIO  (&#39;P&#39;, 0) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_RESET</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Nothing special needs to be done for input.  Input</span>
<span class="cm">		 * samples sit in swbuf, but it will be reinitialized</span>
<span class="cm">		 * to empty when pcm_setup() is called.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span> <span class="o">&amp;&amp;</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swbuf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_INITIAL</span><span class="p">;</span>
			<span class="n">pcm_output</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">pcm_write_sync</span><span class="p">(</span><span class="n">devc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pcm_shutdown</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_SYNC</span>:		<span class="cm">/* _SIO  (&#39;P&#39;, 1) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_SYNC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pcm_flush_frag</span><span class="p">(</span><span class="n">devc</span><span class="p">);</span>
			<span class="n">pcm_write_sync</span><span class="p">(</span><span class="n">devc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pcm_shutdown</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_POST</span>:		<span class="cm">/* _SIO  (&#39;P&#39;, 8) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_POST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wport</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">pcm_flush_frag</span><span class="p">(</span><span class="n">devc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETIPTR</span>:	<span class="cm">/* _SIOR (&#39;P&#39;, 17, count_info) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETIPTR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rport</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">{</span>
			<span class="n">ustmsc_t</span> <span class="n">ustmsc</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwstate</span> <span class="o">==</span> <span class="n">HW_RUNNING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_RUN</span><span class="p">);</span>
				<span class="n">li_read_USTMSC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ustmsc</span><span class="p">);</span>
				<span class="n">info</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">ustmsc</span><span class="p">.</span><span class="n">msc</span> <span class="o">-</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">MSC_offset</span><span class="p">;</span>
				<span class="n">info</span><span class="p">.</span><span class="n">bytes</span> <span class="o">*=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">frame_size</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">info</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">byte_count</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">info</span><span class="p">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">frag_count</span><span class="p">;</span>
			<span class="n">info</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* not implemented */</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">frag_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">info</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETOPTR</span>:	<span class="cm">/* _SIOR (&#39;P&#39;,18, count_info) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETOPTR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wport</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">{</span>
			<span class="n">ustmsc_t</span> <span class="n">ustmsc</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwstate</span> <span class="o">==</span> <span class="n">HW_RUNNING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERT</span><span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_RUN</span><span class="p">);</span>
				<span class="n">li_read_USTMSC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ustmsc</span><span class="p">);</span>
				<span class="n">info</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">ustmsc</span><span class="p">.</span><span class="n">msc</span> <span class="o">-</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">MSC_offset</span><span class="p">;</span>
				<span class="n">info</span><span class="p">.</span><span class="n">bytes</span> <span class="o">*=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">frame_size</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">info</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">byte_count</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">info</span><span class="p">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">frag_count</span><span class="p">;</span>
			<span class="n">info</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* not implemented */</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">frag_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">info</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETODELAY</span>:	<span class="cm">/* _SIOR (&#39;P&#39;, 23, int) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETODELAY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wport</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">fsize</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">frame_size</span><span class="p">;</span>
			<span class="n">ival</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">swb_i_avail</span> <span class="o">/</span> <span class="n">fsize</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwstate</span> <span class="o">==</span> <span class="n">HW_RUNNING</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">swptr</span><span class="p">,</span> <span class="n">hwptr</span><span class="p">,</span> <span class="n">hwframes</span><span class="p">,</span> <span class="n">hwbytes</span><span class="p">,</span> <span class="n">hwsize</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">totalhwbytes</span><span class="p">;</span>
				<span class="n">ustmsc_t</span> <span class="n">ustmsc</span><span class="p">;</span>

				<span class="n">hwsize</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">hwbuf_size</span><span class="p">;</span>
				<span class="n">swptr</span> <span class="o">=</span> <span class="n">li_read_swptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
				<span class="n">li_read_USTMSC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ustmsc</span><span class="p">);</span>
				<span class="n">hwframes</span> <span class="o">=</span> <span class="n">ustmsc</span><span class="p">.</span><span class="n">msc</span> <span class="o">-</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">MSC_offset</span><span class="p">;</span>
				<span class="n">totalhwbytes</span> <span class="o">=</span> <span class="n">hwframes</span> <span class="o">*</span> <span class="n">fsize</span><span class="p">;</span>
				<span class="n">hwptr</span> <span class="o">=</span> <span class="n">totalhwbytes</span> <span class="o">%</span> <span class="n">hwsize</span><span class="p">;</span>
				<span class="n">hwbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">swptr</span> <span class="o">-</span> <span class="n">hwptr</span> <span class="o">+</span> <span class="n">hwsize</span><span class="p">)</span> <span class="o">%</span> <span class="n">hwsize</span><span class="p">;</span>
				<span class="n">ival</span> <span class="o">+=</span> <span class="n">hwbytes</span> <span class="o">/</span> <span class="n">fsize</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_PROFILE</span>:	<span class="cm">/* _SIOW (&#39;P&#39;, 23, int) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_PROFILE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Thomas Sailer explains SNDCTL_DSP_PROFILE</span>
<span class="cm">		 * (private email, March 24, 1999):</span>
<span class="cm">		 *</span>
<span class="cm">		 *     This gives the sound driver a hint on what it</span>
<span class="cm">		 *     should do with partial fragments</span>
<span class="cm">		 *     (i.e. fragments partially filled with write).</span>
<span class="cm">		 *     This can direct the driver to zero them or</span>
<span class="cm">		 *     leave them alone.  But don&#39;t ask me what this</span>
<span class="cm">		 *     is good for, my driver just zeroes the last</span>
<span class="cm">		 *     fragment before the receiver stops, no idea</span>
<span class="cm">		 *     what good for any other behaviour could</span>
<span class="cm">		 *     be. Implementing it as NOP seems safe.</span>
<span class="cm">		 */</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_GETTRIGGER</span>:	<span class="cm">/* _SIOR (&#39;P&#39;,16, int) */</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_GETTRIGGER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ival</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISABLED</span><span class="p">))</span>
					<span class="n">ival</span> <span class="o">|=</span> <span class="n">PCM_ENABLE_INPUT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DISABLED</span><span class="p">))</span>
					<span class="n">ival</span> <span class="o">|=</span> <span class="n">PCM_ENABLE_OUTPUT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SNDCTL_DSP_SETTRIGGER</span>:	<span class="cm">/* _SIOW (&#39;P&#39;,16, int) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ival</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;SNDCTL_DSP_SETTRIGGER %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ival</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If user is disabling I/O and port is not in initial</span>
<span class="cm">		 * state, fail with EINVAL.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">rport</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ival</span> <span class="o">&amp;</span> <span class="n">PCM_ENABLE_INPUT</span><span class="p">))</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">wport</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ival</span> <span class="o">&amp;</span> <span class="n">PCM_ENABLE_OUTPUT</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">aport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">!=</span> <span class="n">SW_INITIAL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vwsnd_port_hwstate_t</span> <span class="n">hwstate</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">{</span>
				<span class="n">hwstate</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">hwstate</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&amp;</span> <span class="n">PCM_ENABLE_INPUT</span><span class="p">)</span>
					<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DISABLED</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">rport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DISABLED</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hwstate</span> <span class="o">!=</span> <span class="n">HW_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">ival</span> <span class="o">&amp;</span> <span class="n">PCM_ENABLE_INPUT</span><span class="p">)</span> <span class="p">{</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_INITIAL</span><span class="p">)</span>
					<span class="n">pcm_setup</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">li_activate_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vwsnd_port_flags_t</span> <span class="n">pflags</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">{</span>
				<span class="n">pflags</span> <span class="o">=</span> <span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ival</span> <span class="o">&amp;</span> <span class="n">PCM_ENABLE_OUTPUT</span><span class="p">)</span>
					<span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DISABLED</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">wport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DISABLED</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">DISABLED</span> <span class="o">&amp;&amp;</span> <span class="n">ival</span> <span class="o">&amp;</span> <span class="n">PCM_ENABLE_OUTPUT</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">==</span> <span class="n">SW_RUN</span><span class="p">)</span>
					<span class="n">pcm_output</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;unknown ioctl 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;unimplemented ioctl 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">vwsnd_audio_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">vwsnd_audio_do_ioctl</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No mmap. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vwsnd_audio_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBGE</span><span class="p">(</span><span class="s">&quot;(file=0x%p, vma=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Open the audio device for read and/or write.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -errno on failure.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vwsnd_audio_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sw_samplefmt</span><span class="p">;</span>

	<span class="n">DBGE</span><span class="p">(</span><span class="s">&quot;(inode=0x%p, file=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="n">INC_USE_COUNT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">devc</span> <span class="o">=</span> <span class="n">vwsnd_dev_list</span><span class="p">;</span> <span class="n">devc</span><span class="p">;</span> <span class="n">devc</span> <span class="o">=</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">next_dev</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0F</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">minor</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0F</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DEC_USE_COUNT</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mode</span> <span class="o">&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEC_USE_COUNT</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">interruptible_sleep_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DEC_USE_COUNT</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mode</span> <span class="o">|=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>

	<span class="cm">/* get default sample format from minor number. */</span>

	<span class="n">sw_samplefmt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">minor</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">==</span> <span class="n">SND_DEV_DSP</span><span class="p">)</span>
		<span class="n">sw_samplefmt</span> <span class="o">=</span> <span class="n">AFMT_U8</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">minor</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">==</span> <span class="n">SND_DEV_AUDIO</span><span class="p">)</span>
		<span class="n">sw_samplefmt</span> <span class="o">=</span> <span class="n">AFMT_MU_LAW</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">minor</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">==</span> <span class="n">SND_DEV_DSP16</span><span class="p">)</span>
		<span class="n">sw_samplefmt</span> <span class="o">=</span> <span class="n">AFMT_S16_LE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Initialize vwsnd_ports. */</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">swstate</span>        <span class="o">=</span> <span class="n">SW_INITIAL</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">flags</span>          <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">sw_channels</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">sw_samplefmt</span>   <span class="o">=</span> <span class="n">sw_samplefmt</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">sw_framerate</span>   <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">sw_fragshift</span>   <span class="o">=</span> <span class="n">DEFAULT_FRAGSHIFT</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">sw_fragcount</span>   <span class="o">=</span> <span class="n">DEFAULT_FRAGCOUNT</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">sw_subdivshift</span> <span class="o">=</span> <span class="n">DEFAULT_SUBDIVSHIFT</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">byte_count</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">frag_count</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">swstate</span>        <span class="o">=</span> <span class="n">SW_INITIAL</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">flags</span>          <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">sw_channels</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">sw_samplefmt</span>   <span class="o">=</span> <span class="n">sw_samplefmt</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">sw_framerate</span>   <span class="o">=</span> <span class="mi">8000</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">sw_fragshift</span>   <span class="o">=</span> <span class="n">DEFAULT_FRAGSHIFT</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">sw_fragcount</span>   <span class="o">=</span> <span class="n">DEFAULT_FRAGCOUNT</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">sw_subdivshift</span> <span class="o">=</span> <span class="n">DEFAULT_SUBDIVSHIFT</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">byte_count</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">frag_count</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">devc</span><span class="p">;</span>
	<span class="n">DBGRV</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release (close) the audio device.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vwsnd_audio_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">vwsnd_port_t</span> <span class="o">*</span><span class="n">wport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(inode=0x%p, file=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
			<span class="n">rport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">;</span>
			<span class="n">pcm_flush_frag</span><span class="p">(</span><span class="n">devc</span><span class="p">);</span>
			<span class="n">pcm_write_sync</span><span class="p">(</span><span class="n">devc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pcm_shutdown</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">rport</span><span class="p">,</span> <span class="n">wport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span>
			<span class="n">rport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_OFF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wport</span><span class="p">)</span>
			<span class="n">wport</span><span class="o">-&gt;</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_OFF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
	<span class="n">DEC_USE_COUNT</span><span class="p">;</span>
	<span class="n">DBGR</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">vwsnd_audio_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span>		<span class="n">vwsnd_audio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span>	<span class="n">vwsnd_audio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">vwsnd_audio_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">vwsnd_audio_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">vwsnd_audio_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">vwsnd_audio_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">vwsnd_audio_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* mixer driver */</span>

<span class="cm">/* open the mixer device. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vwsnd_mixer_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(inode=0x%p, file=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

	<span class="n">INC_USE_COUNT</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">devc</span> <span class="o">=</span> <span class="n">vwsnd_dev_list</span><span class="p">;</span> <span class="n">devc</span><span class="p">;</span> <span class="n">devc</span> <span class="o">=</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">next_dev</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">mixer_minor</span> <span class="o">==</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DEC_USE_COUNT</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">devc</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* release (close) the mixer device. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vwsnd_mixer_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(inode=0x%p, file=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="n">DEC_USE_COUNT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mixer_read_ioctl handles all read ioctls on the mixer device. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mixer_read_ioctl</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(devc=0x%p, nr=0x%x, arg=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOUND_MIXER_CAPS</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">SOUND_CAP_EXCL_INPUT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_DEVMASK</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">SOUND_MASK_PCM</span> <span class="o">|</span> <span class="n">SOUND_MASK_LINE</span> <span class="o">|</span>
		       <span class="n">SOUND_MASK_MIC</span> <span class="o">|</span> <span class="n">SOUND_MASK_CD</span> <span class="o">|</span> <span class="n">SOUND_MASK_RECLEV</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_STEREODEVS</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">SOUND_MASK_PCM</span> <span class="o">|</span> <span class="n">SOUND_MASK_LINE</span> <span class="o">|</span>
		       <span class="n">SOUND_MASK_MIC</span> <span class="o">|</span> <span class="n">SOUND_MASK_CD</span> <span class="o">|</span> <span class="n">SOUND_MASK_RECLEV</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_OUTMASK</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">SOUND_MASK_PCM</span> <span class="o">|</span> <span class="n">SOUND_MASK_LINE</span> <span class="o">|</span>
		       <span class="n">SOUND_MASK_MIC</span> <span class="o">|</span> <span class="n">SOUND_MASK_CD</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_RECMASK</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">SOUND_MASK_PCM</span> <span class="o">|</span> <span class="n">SOUND_MASK_LINE</span> <span class="o">|</span>
		       <span class="n">SOUND_MASK_MIC</span> <span class="o">|</span> <span class="n">SOUND_MASK_CD</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_PCM</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_get_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_PCM</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_LINE</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_get_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_LINE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_MIC</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_get_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_MIC</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_CD</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_get_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_CD</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_RECLEV</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_get_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_RECLEV</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_RECSRC</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_get_recsrc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_OUTSRC</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_get_outsrc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* mixer_write_ioctl handles all write ioctls on the mixer device. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mixer_write_ioctl</span><span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(devc=0x%p, nr=0x%x, arg=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOUND_MIXER_PCM</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_set_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_PCM</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_LINE</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_set_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_LINE</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_MIC</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_set_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_MIC</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_CD</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_set_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_CD</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_RECLEV</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_set_gain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ad1843_gain_RECLEV</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_RECSRC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">swbuf</span> <span class="o">||</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">swbuf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>	<span class="cm">/* can&#39;t change recsrc while running */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_set_recsrc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SOUND_MIXER_OUTSRC</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ad1843_set_outsrc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is the ioctl entry to the mixer driver. */</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">vwsnd_mixer_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="p">(</span><span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nrmask</span> <span class="o">=</span> <span class="n">_IOC_NRMASK</span> <span class="o">&lt;&lt;</span> <span class="n">_IOC_NRSHIFT</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">nrmask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">_IOC_NRSHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(devc=0x%p, cmd=0x%x, arg=0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">mix_mutex</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">nrmask</span><span class="p">)</span> <span class="o">==</span> <span class="n">MIXER_READ</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">mixer_read_ioctl</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">nrmask</span><span class="p">)</span> <span class="o">==</span> <span class="n">MIXER_WRITE</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">mixer_write_ioctl</span><span class="p">(</span><span class="n">devc</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">mix_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">vwsnd_mixer_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">vwsnd_mixer_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">vwsnd_mixer_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">vwsnd_mixer_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* probe/attach/unload */</span>

<span class="cm">/* driver probe routine.  Return nonzero if hardware is found. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">probe_vwsnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_info</span> <span class="o">*</span><span class="n">hw_config</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lithium_t</span> <span class="n">lith</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">later</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(hw_config=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw_config</span><span class="p">);</span>

	<span class="cm">/* XXX verify lithium present (to prevent crash on non-vw) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">li_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="p">,</span> <span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;probe_vwsnd: can&#39;t map lithium</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">later</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">li_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_HOST_CONTROLLER</span><span class="p">,</span> <span class="n">LI_HC_LINK_ENABLE</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">li_readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_HOST_CONTROLLER</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="n">LI_HC_LINK_ENABLE</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">later</span><span class="p">));</span>
	
	<span class="n">li_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lith</span><span class="p">);</span>

	<span class="n">DBGPV</span><span class="p">(</span><span class="s">&quot;HC = 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">w</span> <span class="o">==</span> <span class="n">LI_HC_LINK_ENABLE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">w</span> <span class="o">&amp;</span> <span class="n">LI_HC_LINK_CODEC</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* This may indicate a beta machine with no audio,</span>
<span class="cm">		 * or a future machine with different audio.</span>
<span class="cm">		 * On beta-release 320 w/ no audio, HC == 0x4000 */</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;probe_vwsnd: audio codec not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&amp;</span> <span class="n">LI_HC_LINK_FAILURE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;probe_vwsnd: can&#39;t init audio codec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;vwsnd: lithium audio at mmio %#x irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">,</span> <span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * driver attach routine.  Initialize driver data structures and</span>
<span class="cm"> * initialize hardware.  A new vwsnd_dev_t is allocated and put</span>
<span class="cm"> * onto the global list, vwsnd_dev_list.</span>
<span class="cm"> *</span>
<span class="cm"> * Return +minor_dev on success, -errno on failure.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">attach_vwsnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_info</span> <span class="o">*</span><span class="n">hw_config</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">DBGEV</span><span class="p">(</span><span class="s">&quot;(hw_config=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw_config</span><span class="p">);</span>

	<span class="n">devc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">vwsnd_dev_t</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">li_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>

	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf_size</span> <span class="o">=</span> <span class="n">HWBUF_SIZE</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">HWBUF_ORDER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail2</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf_paddr</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Quote from the NT driver:</span>
<span class="cm">	 *</span>
<span class="cm">	 * // WARNING!!! HACK to setup output dma!!!</span>
<span class="cm">	 * // This is required because even on output there is some data</span>
<span class="cm">	 * // trickling into the input DMA channel.  This is a bug in the</span>
<span class="cm">	 * // Lithium microcode.</span>
<span class="cm">	 * // --sde</span>
<span class="cm">	 *</span>
<span class="cm">	 * We set the input side&#39;s DMA base address here.  It will remain</span>
<span class="cm">	 * valid until the driver is unloaded.</span>
<span class="cm">	 */</span>

	<span class="n">li_writel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">,</span> <span class="n">LI_COMM1_BASE</span><span class="p">,</span>
		  <span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf_paddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">37</span> <span class="o">-</span> <span class="mi">8</span><span class="p">));</span>

	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf_size</span> <span class="o">=</span> <span class="n">HWBUF_SIZE</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span> <span class="o">=</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">HWBUF_ORDER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail3</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf_paddr</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf</span><span class="p">);</span>
	<span class="n">DBGP</span><span class="p">(</span><span class="s">&quot;wport hwbuf = 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf</span><span class="p">);</span>

	<span class="n">DBGDO</span><span class="p">(</span><span class="n">shut_up</span><span class="o">++</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ad1843_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">);</span>
	<span class="n">DBGDO</span><span class="p">(</span><span class="n">shut_up</span><span class="o">--</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail4</span><span class="p">;</span>

	<span class="cm">/* install interrupt handler */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">vwsnd_audio_intr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;vwsnd&quot;</span><span class="p">,</span> <span class="n">devc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail5</span><span class="p">;</span>

	<span class="cm">/* register this device&#39;s drivers. */</span>

	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span> <span class="o">=</span> <span class="n">register_sound_dsp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_audio_fops</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBGDO</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			     <span class="s">&quot;attach_vwsnd: register_sound_dsp error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">err</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">fail6</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">mixer_minor</span> <span class="o">=</span> <span class="n">register_sound_mixer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vwsnd_mixer_fops</span><span class="p">,</span>
						 <span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">mixer_minor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBGDO</span><span class="p">(</span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			     <span class="s">&quot;attach_vwsnd: register_sound_mixer error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">err</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">fail7</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Squirrel away device indices for unload routine. */</span>

	<span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span><span class="p">;</span>

	<span class="cm">/* Initialize as much of *devc as possible */</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">mix_mutex</span><span class="p">);</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">open_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_OFF</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwstate</span> <span class="o">=</span> <span class="n">HW_STOPPED</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">swbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">swstate</span> <span class="o">=</span> <span class="n">SW_OFF</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwstate</span> <span class="o">=</span> <span class="n">HW_STOPPED</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">swbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Success.  Link us onto the local device list. */</span>

	<span class="n">devc</span><span class="o">-&gt;</span><span class="n">next_dev</span> <span class="o">=</span> <span class="n">vwsnd_dev_list</span><span class="p">;</span>
	<span class="n">vwsnd_dev_list</span> <span class="o">=</span> <span class="n">devc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span><span class="p">;</span>

	<span class="cm">/* So many ways to fail.  Undo what we did. */</span>

 <span class="nl">fail7:</span>
	<span class="n">unregister_sound_dsp</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span><span class="p">);</span>
 <span class="nl">fail6:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">devc</span><span class="p">);</span>
 <span class="nl">fail5:</span>
 <span class="nl">fail4:</span>
	<span class="n">free_pages</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span><span class="p">,</span> <span class="n">HWBUF_ORDER</span><span class="p">);</span>
 <span class="nl">fail3:</span>
	<span class="n">free_pages</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span><span class="p">,</span> <span class="n">HWBUF_ORDER</span><span class="p">);</span>
 <span class="nl">fail2:</span>
	<span class="n">li_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">);</span>
 <span class="nl">fail1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">devc</span><span class="p">);</span>
 <span class="nl">fail0:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">unload_vwsnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_info</span> <span class="o">*</span><span class="n">hw_config</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vwsnd_dev_t</span> <span class="o">*</span><span class="n">devc</span><span class="p">,</span> <span class="o">**</span><span class="n">devcp</span><span class="p">;</span>

	<span class="n">DBGE</span><span class="p">(</span><span class="s">&quot;()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">devcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vwsnd_dev_list</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">devc</span> <span class="o">=</span> <span class="o">*</span><span class="n">devcp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span> <span class="o">==</span> <span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">devcp</span> <span class="o">=</span> <span class="n">devc</span><span class="o">-&gt;</span><span class="n">next_dev</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">devcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">next_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">unregister_sound_mixer</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">mixer_minor</span><span class="p">);</span>
	<span class="n">unregister_sound_dsp</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">audio_minor</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">hw_config</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">devc</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">wport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span><span class="p">,</span> <span class="n">HWBUF_ORDER</span><span class="p">);</span>
	<span class="n">free_pages</span><span class="p">(</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">.</span><span class="n">hwbuf_vaddr</span><span class="p">,</span> <span class="n">HWBUF_ORDER</span><span class="p">);</span>
	<span class="n">li_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devc</span><span class="o">-&gt;</span><span class="n">lith</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">devc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************************************************************************/</span>
<span class="cm">/* initialization and loadable kernel module interface */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">address_info</span> <span class="n">the_hw_config</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0xFF001000</span><span class="p">,</span>			<span class="cm">/* lithium phys addr  */</span>
	<span class="n">CO_IRQ</span><span class="p">(</span><span class="n">CO_APIC_LI_AUDIO</span><span class="p">)</span>	<span class="cm">/* irq */</span>
<span class="p">};</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SGI Visual Workstation sound module&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Bob Miller &lt;kbob@sgi.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_vwsnd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">DBGXV</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">DBGXV</span><span class="p">(</span><span class="s">&quot;sound::vwsnd::init_module()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">probe_vwsnd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_hw_config</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">attach_vwsnd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_hw_config</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_vwsnd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DBGX</span><span class="p">(</span><span class="s">&quot;sound::vwsnd::cleanup_module()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">unload_vwsnd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_hw_config</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_vwsnd</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_vwsnd</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
