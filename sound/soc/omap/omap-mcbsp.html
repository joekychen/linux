<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › soc › omap › omap-mcbsp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>omap-mcbsp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * omap-mcbsp.c  --  OMAP ALSA SoC DAI driver using McBSP port</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Contact: Jarkko Nikula &lt;jarkko.nikula@bitmer.com&gt;</span>
<span class="cm"> *          Peter Ujfalusi &lt;peter.ujfalusi@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/pcm_params.h&gt;</span>
<span class="cp">#include &lt;sound/initval.h&gt;</span>
<span class="cp">#include &lt;sound/soc.h&gt;</span>

<span class="cp">#include &lt;plat/dma.h&gt;</span>
<span class="cp">#include &lt;plat/mcbsp.h&gt;</span>
<span class="cp">#include &quot;mcbsp.h&quot;</span>
<span class="cp">#include &quot;omap-mcbsp.h&quot;</span>
<span class="cp">#include &quot;omap-pcm.h&quot;</span>

<span class="cp">#define OMAP_MCBSP_RATES	(SNDRV_PCM_RATE_8000_96000)</span>

<span class="cp">#define OMAP_MCBSP_SOC_SINGLE_S16_EXT(xname, xmin, xmax, \</span>
<span class="cp">	xhandler_get, xhandler_put) \</span>
<span class="cp">{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span>
<span class="cp">	.info = omap_mcbsp_st_info_volsw, \</span>
<span class="cp">	.get = xhandler_get, .put = xhandler_put, \</span>
<span class="cp">	.private_value = (unsigned long) &amp;(struct soc_mixer_control) \</span>
<span class="cp">	{.min = xmin, .max = xmax} }</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">OMAP_MCBSP_WORD_8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">OMAP_MCBSP_WORD_12</span><span class="p">,</span>
	<span class="n">OMAP_MCBSP_WORD_16</span><span class="p">,</span>
	<span class="n">OMAP_MCBSP_WORD_20</span><span class="p">,</span>
	<span class="n">OMAP_MCBSP_WORD_24</span><span class="p">,</span>
	<span class="n">OMAP_MCBSP_WORD_32</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Stream DMA parameters. DMA request line and port address are set runtime</span>
<span class="cm"> * since they are different between OMAP1 and later OMAPs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_mcbsp_set_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span> <span class="o">=</span> <span class="n">rtd</span><span class="o">-&gt;</span><span class="n">cpu_dai</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_pcm_dma_data</span> <span class="o">*</span><span class="n">dma_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">words</span><span class="p">;</span>

	<span class="n">dma_data</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_dma_data</span><span class="p">(</span><span class="n">rtd</span><span class="o">-&gt;</span><span class="n">cpu_dai</span><span class="p">,</span> <span class="n">substream</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configure McBSP threshold based on either:</span>
<span class="cm">	 * packet_size, when the sDMA is in packet mode, or based on the</span>
<span class="cm">	 * period size in THRESHOLD mode, otherwise use McBSP threshold = 1</span>
<span class="cm">	 * for mono streams.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_data</span><span class="o">-&gt;</span><span class="n">packet_size</span><span class="p">)</span>
		<span class="n">words</span> <span class="o">=</span> <span class="n">dma_data</span><span class="o">-&gt;</span><span class="n">packet_size</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">dma_op_mode</span> <span class="o">==</span> <span class="n">MCBSP_DMA_MODE_THRESHOLD</span><span class="p">)</span>
		<span class="n">words</span> <span class="o">=</span> <span class="n">snd_pcm_lib_period_bytes</span><span class="p">(</span><span class="n">substream</span><span class="p">)</span> <span class="o">/</span>
						<span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">wlen</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">words</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Configure McBSP internal buffer usage */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span>
		<span class="n">omap_mcbsp_set_tx_threshold</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="n">words</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">omap_mcbsp_set_rx_threshold</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="n">words</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_hwrule_min_buffersize</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">snd_pcm_hw_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="o">*</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">hw_param_interval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span>
					<span class="n">SNDRV_PCM_HW_PARAM_BUFFER_SIZE</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="o">*</span><span class="n">channels</span> <span class="o">=</span> <span class="n">hw_param_interval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span>
					<span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="n">frames</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">snd_interval_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frames</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span>

	<span class="n">frames</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">channels</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>
	<span class="n">frames</span><span class="p">.</span><span class="n">integer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snd_interval_refine</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frames</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_dai_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_dai</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">omap_mcbsp_request</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * OMAP3 McBSP FIFO is word structured.</span>
<span class="cm">	 * McBSP2 has 1024 + 256 = 1280 word long buffer,</span>
<span class="cm">	 * McBSP1,3,4,5 has 128 word long buffer</span>
<span class="cm">	 * This means that the size of the FIFO depends on the sample format.</span>
<span class="cm">	 * For example on McBSP3:</span>
<span class="cm">	 * 16bit samples: size is 128 * 2 = 256 bytes</span>
<span class="cm">	 * 32bit samples: size is 128 * 4 = 512 bytes</span>
<span class="cm">	 * It is simpler to place constraint for buffer and period based on</span>
<span class="cm">	 * channels.</span>
<span class="cm">	 * McBSP3 as example again (16 or 32 bit samples):</span>
<span class="cm">	 * 1 channel (mono): size is 128 frames (128 words)</span>
<span class="cm">	 * 2 channels (stereo): size is 128 / 2 = 64 frames (2 * 64 words)</span>
<span class="cm">	 * 4 channels: size is 128 / 4 = 32 frames (4 * 32 words)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		* Rule for the buffer size. We should not allow</span>
<span class="cm">		* smaller buffer than the FIFO size to avoid underruns.</span>
<span class="cm">		* This applies only for the playback stream.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span>
			<span class="n">snd_pcm_hw_rule_add</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">SNDRV_PCM_HW_PARAM_BUFFER_SIZE</span><span class="p">,</span>
					    <span class="n">omap_mcbsp_hwrule_min_buffersize</span><span class="p">,</span>
					    <span class="n">mcbsp</span><span class="p">,</span>
					    <span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Make sure, that the period size is always even */</span>
		<span class="n">snd_pcm_hw_constraint_step</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">omap_mcbsp_dai_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_dai</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">omap_mcbsp_free</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">);</span>
		<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">configured</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_dai_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">play</span> <span class="o">=</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_RESUME</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_RELEASE</span>:
		<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">active</span><span class="o">++</span><span class="p">;</span>
		<span class="n">omap_mcbsp_start</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="n">play</span><span class="p">,</span> <span class="o">!</span><span class="n">play</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_SUSPEND</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_PUSH</span>:
		<span class="n">omap_mcbsp_stop</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="n">play</span><span class="p">,</span> <span class="o">!</span><span class="n">play</span><span class="p">);</span>
		<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">active</span><span class="o">--</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">snd_pcm_sframes_t</span> <span class="nf">omap_mcbsp_dai_delay</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span> <span class="o">=</span> <span class="n">rtd</span><span class="o">-&gt;</span><span class="n">cpu_dai</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">fifo_use</span><span class="p">;</span>
	<span class="n">snd_pcm_sframes_t</span> <span class="n">delay</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span>
		<span class="n">fifo_use</span> <span class="o">=</span> <span class="n">omap_mcbsp_get_tx_delay</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fifo_use</span> <span class="o">=</span> <span class="n">omap_mcbsp_get_rx_delay</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Divide the used locations with the channel count to get the</span>
<span class="cm">	 * FIFO usage in samples (don&#39;t care about partial samples in the</span>
<span class="cm">	 * buffer).</span>
<span class="cm">	 */</span>
	<span class="n">delay</span> <span class="o">=</span> <span class="n">fifo_use</span> <span class="o">/</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">delay</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_dai_hw_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp_reg_cfg</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">cfg_regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_pcm_dma_data</span> <span class="o">*</span><span class="n">dma_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wlen</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">wpf</span><span class="p">,</span> <span class="n">sync_mode</span> <span class="o">=</span> <span class="n">OMAP_DMA_SYNC_ELEMENT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pkt_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">framesize</span><span class="p">,</span> <span class="n">master</span><span class="p">;</span>

	<span class="n">dma_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">dma_data</span><span class="p">[</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">];</span>
	<span class="n">channels</span> <span class="o">=</span> <span class="n">params_channels</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">params_format</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_FORMAT_S16_LE</span>:
		<span class="n">dma_data</span><span class="o">-&gt;</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">OMAP_DMA_DATA_TYPE_S16</span><span class="p">;</span>
		<span class="n">wlen</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_FORMAT_S32_LE</span>:
		<span class="n">dma_data</span><span class="o">-&gt;</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">OMAP_DMA_DATA_TYPE_S32</span><span class="p">;</span>
		<span class="n">wlen</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_data</span><span class="o">-&gt;</span><span class="n">set_threshold</span> <span class="o">=</span> <span class="n">omap_mcbsp_set_threshold</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">dma_op_mode</span> <span class="o">==</span> <span class="n">MCBSP_DMA_MODE_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">period_words</span><span class="p">,</span> <span class="n">max_thrsh</span><span class="p">;</span>

			<span class="n">period_words</span> <span class="o">=</span> <span class="n">params_period_bytes</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">wlen</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span>
				<span class="n">max_thrsh</span> <span class="o">=</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">max_tx_thres</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">max_thrsh</span> <span class="o">=</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">max_rx_thres</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the period contains less or equal number of words,</span>
<span class="cm">			 * we are using the original threshold mode setup:</span>
<span class="cm">			 * McBSP threshold = sDMA frame size = period_size</span>
<span class="cm">			 * Otherwise we switch to sDMA packet mode:</span>
<span class="cm">			 * McBSP threshold = sDMA packet size</span>
<span class="cm">			 * sDMA frame size = period size</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">period_words</span> <span class="o">&gt;</span> <span class="n">max_thrsh</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">divider</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Look for the biggest threshold value, which</span>
<span class="cm">				 * divides the period size evenly.</span>
<span class="cm">				 */</span>
				<span class="n">divider</span> <span class="o">=</span> <span class="n">period_words</span> <span class="o">/</span> <span class="n">max_thrsh</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">period_words</span> <span class="o">%</span> <span class="n">max_thrsh</span><span class="p">)</span>
					<span class="n">divider</span><span class="o">++</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">period_words</span> <span class="o">%</span> <span class="n">divider</span> <span class="o">&amp;&amp;</span>
					<span class="n">divider</span> <span class="o">&lt;</span> <span class="n">period_words</span><span class="p">)</span>
					<span class="n">divider</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">divider</span> <span class="o">==</span> <span class="n">period_words</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

				<span class="n">pkt_size</span> <span class="o">=</span> <span class="n">period_words</span> <span class="o">/</span> <span class="n">divider</span><span class="p">;</span>
				<span class="n">sync_mode</span> <span class="o">=</span> <span class="n">OMAP_DMA_SYNC_PACKET</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sync_mode</span> <span class="o">=</span> <span class="n">OMAP_DMA_SYNC_FRAME</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">channels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Use packet mode for non mono streams */</span>
			<span class="n">pkt_size</span> <span class="o">=</span> <span class="n">channels</span><span class="p">;</span>
			<span class="n">sync_mode</span> <span class="o">=</span> <span class="n">OMAP_DMA_SYNC_PACKET</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dma_data</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">sync_mode</span><span class="p">;</span>
	<span class="n">dma_data</span><span class="o">-&gt;</span><span class="n">packet_size</span> <span class="o">=</span> <span class="n">pkt_size</span><span class="p">;</span>

	<span class="n">snd_soc_dai_set_dma_data</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">,</span> <span class="n">substream</span><span class="p">,</span> <span class="n">dma_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">configured</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* McBSP already configured by another stream */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RPHASE</span> <span class="o">|</span> <span class="n">RFRLEN2</span><span class="p">(</span><span class="mh">0x7f</span><span class="p">)</span> <span class="o">|</span> <span class="n">RWDLEN2</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RPHASE</span> <span class="o">|</span> <span class="n">XFRLEN2</span><span class="p">(</span><span class="mh">0x7f</span><span class="p">)</span> <span class="o">|</span> <span class="n">XWDLEN2</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr1</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RFRLEN1</span><span class="p">(</span><span class="mh">0x7f</span><span class="p">)</span> <span class="o">|</span> <span class="n">RWDLEN1</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr1</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">XFRLEN1</span><span class="p">(</span><span class="mh">0x7f</span><span class="p">)</span> <span class="o">|</span> <span class="n">XWDLEN1</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
	<span class="n">format</span> <span class="o">=</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">SND_SOC_DAIFMT_FORMAT_MASK</span><span class="p">;</span>
	<span class="n">wpf</span> <span class="o">=</span> <span class="n">channels</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">format</span> <span class="o">==</span> <span class="n">SND_SOC_DAIFMT_I2S</span> <span class="o">||</span>
			      <span class="n">format</span> <span class="o">==</span> <span class="n">SND_SOC_DAIFMT_LEFT_J</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Use dual-phase frames */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>	<span class="o">|=</span> <span class="n">RPHASE</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>	<span class="o">|=</span> <span class="n">XPHASE</span><span class="p">;</span>
		<span class="cm">/* Set 1 word per (McBSP) frame for phase1 and phase2 */</span>
		<span class="n">wpf</span><span class="o">--</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>	<span class="o">|=</span> <span class="n">RFRLEN2</span><span class="p">(</span><span class="n">wpf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>	<span class="o">|=</span> <span class="n">XFRLEN2</span><span class="p">(</span><span class="n">wpf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr1</span>	<span class="o">|=</span> <span class="n">RFRLEN1</span><span class="p">(</span><span class="n">wpf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr1</span>	<span class="o">|=</span> <span class="n">XFRLEN1</span><span class="p">(</span><span class="n">wpf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">params_format</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_FORMAT_S16_LE</span>:
		<span class="cm">/* Set word lengths */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>	<span class="o">|=</span> <span class="n">RWDLEN2</span><span class="p">(</span><span class="n">OMAP_MCBSP_WORD_16</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr1</span>	<span class="o">|=</span> <span class="n">RWDLEN1</span><span class="p">(</span><span class="n">OMAP_MCBSP_WORD_16</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>	<span class="o">|=</span> <span class="n">XWDLEN2</span><span class="p">(</span><span class="n">OMAP_MCBSP_WORD_16</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr1</span>	<span class="o">|=</span> <span class="n">XWDLEN1</span><span class="p">(</span><span class="n">OMAP_MCBSP_WORD_16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_FORMAT_S32_LE</span>:
		<span class="cm">/* Set word lengths */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>	<span class="o">|=</span> <span class="n">RWDLEN2</span><span class="p">(</span><span class="n">OMAP_MCBSP_WORD_32</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr1</span>	<span class="o">|=</span> <span class="n">RWDLEN1</span><span class="p">(</span><span class="n">OMAP_MCBSP_WORD_32</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>	<span class="o">|=</span> <span class="n">XWDLEN2</span><span class="p">(</span><span class="n">OMAP_MCBSP_WORD_32</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr1</span>	<span class="o">|=</span> <span class="n">XWDLEN1</span><span class="p">(</span><span class="n">OMAP_MCBSP_WORD_32</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Unsupported PCM format */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* In McBSP master modes, FRAME (i.e. sample rate) is generated</span>
<span class="cm">	 * by _counting_ BCLKs. Calculate frame size in BCLKs */</span>
	<span class="n">master</span> <span class="o">=</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">SND_SOC_DAIFMT_MASTER_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="o">==</span>	<span class="n">SND_SOC_DAIFMT_CBS_CFS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">div</span> <span class="o">=</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">clk_div</span> <span class="o">?</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">clk_div</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">framesize</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">in_freq</span> <span class="o">/</span> <span class="n">div</span><span class="p">)</span> <span class="o">/</span> <span class="n">params_rate</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">framesize</span> <span class="o">&lt;</span> <span class="n">wlen</span> <span class="o">*</span> <span class="n">channels</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: not enough bandwidth for desired rate and &quot;</span>
					<span class="s">&quot;channels</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">framesize</span> <span class="o">=</span> <span class="n">wlen</span> <span class="o">*</span> <span class="n">channels</span><span class="p">;</span>

	<span class="cm">/* Set FS period and length in terms of bit clock periods */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr2</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="n">FPER</span><span class="p">(</span><span class="mh">0xfff</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr1</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="n">FWID</span><span class="p">(</span><span class="mh">0xff</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_I2S</span>:
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_LEFT_J</span>:
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr2</span>	<span class="o">|=</span> <span class="n">FPER</span><span class="p">(</span><span class="n">framesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr1</span>	<span class="o">|=</span> <span class="n">FWID</span><span class="p">((</span><span class="n">framesize</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_DSP_A</span>:
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_DSP_B</span>:
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr2</span>	<span class="o">|=</span> <span class="n">FPER</span><span class="p">(</span><span class="n">framesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr1</span>	<span class="o">|=</span> <span class="n">FWID</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">omap_mcbsp_config</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">cfg_regs</span><span class="p">);</span>
	<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">wlen</span> <span class="o">=</span> <span class="n">wlen</span><span class="p">;</span>
	<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">configured</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This must be called before _set_clkdiv and _set_sysclk since McBSP register</span>
<span class="cm"> * cache is initialized here</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_dai_set_dai_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp_reg_cfg</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">cfg_regs</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">inv_fs</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">configured</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">regs</span><span class="p">));</span>
	<span class="cm">/* Generic McBSP register settings */</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">spcr2</span>	<span class="o">|=</span> <span class="n">XINTM</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="n">FREE</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">spcr1</span>	<span class="o">|=</span> <span class="n">RINTM</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="cm">/* RFIG and XFIG are not defined in 34xx */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_is_omap34xx</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_is_omap44xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>	<span class="o">|=</span> <span class="n">RFIG</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>	<span class="o">|=</span> <span class="n">XFIG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_omap2430</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap34xx</span><span class="p">()</span> <span class="o">||</span> <span class="n">cpu_is_omap44xx</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xccr</span> <span class="o">=</span> <span class="n">DXENDLY</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">XDMAEN</span> <span class="o">|</span> <span class="n">XDISABLE</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rccr</span> <span class="o">=</span> <span class="n">RFULL_CYCLE</span> <span class="o">|</span> <span class="n">RDMAEN</span> <span class="o">|</span> <span class="n">RDISABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">SND_SOC_DAIFMT_FORMAT_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_I2S</span>:
		<span class="cm">/* 1-bit data delay */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>	<span class="o">|=</span> <span class="n">RDATDLY</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>	<span class="o">|=</span> <span class="n">XDATDLY</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_LEFT_J</span>:
		<span class="cm">/* 0-bit data delay */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>	<span class="o">|=</span> <span class="n">RDATDLY</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>	<span class="o">|=</span> <span class="n">XDATDLY</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">spcr1</span>	<span class="o">|=</span> <span class="n">RJUST</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="cm">/* Invert FS polarity configuration */</span>
		<span class="n">inv_fs</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_DSP_A</span>:
		<span class="cm">/* 1-bit data delay */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>      <span class="o">|=</span> <span class="n">RDATDLY</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>      <span class="o">|=</span> <span class="n">XDATDLY</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* Invert FS polarity configuration */</span>
		<span class="n">inv_fs</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_DSP_B</span>:
		<span class="cm">/* 0-bit data delay */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">rcr2</span>      <span class="o">|=</span> <span class="n">RDATDLY</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">xcr2</span>      <span class="o">|=</span> <span class="n">XDATDLY</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Invert FS polarity configuration */</span>
		<span class="n">inv_fs</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Unsupported data format */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">SND_SOC_DAIFMT_MASTER_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_CBS_CFS</span>:
		<span class="cm">/* McBSP master. Set FS and bit clocks as outputs */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pcr0</span>	<span class="o">|=</span> <span class="n">FSXM</span> <span class="o">|</span> <span class="n">FSRM</span> <span class="o">|</span>
				   <span class="n">CLKXM</span> <span class="o">|</span> <span class="n">CLKRM</span><span class="p">;</span>
		<span class="cm">/* Sample rate generator drives the FS */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr2</span>	<span class="o">|=</span> <span class="n">FSGM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_CBM_CFM</span>:
		<span class="cm">/* McBSP slave */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Unsupported master/slave configuration */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set bit clock (CLKX/CLKR) and FS polarities */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">SND_SOC_DAIFMT_INV_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_NB_NF</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Normal BCLK + FS.</span>
<span class="cm">		 * FS active low. TX data driven on falling edge of bit clock</span>
<span class="cm">		 * and RX data sampled on rising edge of bit clock.</span>
<span class="cm">		 */</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pcr0</span>	<span class="o">|=</span> <span class="n">FSXP</span> <span class="o">|</span> <span class="n">FSRP</span> <span class="o">|</span>
				   <span class="n">CLKXP</span> <span class="o">|</span> <span class="n">CLKRP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_NB_IF</span>:
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pcr0</span>	<span class="o">|=</span> <span class="n">CLKXP</span> <span class="o">|</span> <span class="n">CLKRP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_IB_NF</span>:
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pcr0</span>	<span class="o">|=</span> <span class="n">FSXP</span> <span class="o">|</span> <span class="n">FSRP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_IB_IF</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inv_fs</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pcr0</span> <span class="o">^=</span> <span class="n">FSXP</span> <span class="o">|</span> <span class="n">FSRP</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_dai_set_clkdiv</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">div_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">div</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp_reg_cfg</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">cfg_regs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">div_id</span> <span class="o">!=</span> <span class="n">OMAP_MCBSP_CLKGDV</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">clk_div</span> <span class="o">=</span> <span class="n">div</span><span class="p">;</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr1</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLKGDV</span><span class="p">(</span><span class="mh">0xff</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr1</span>	<span class="o">|=</span> <span class="n">CLKGDV</span><span class="p">(</span><span class="n">div</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_dai_set_dai_sysclk</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">clk_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp_reg_cfg</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">cfg_regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">==</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">in_freq</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk_id</span> <span class="o">==</span> <span class="n">OMAP_MCBSP_SYSCLK_CLK</span> <span class="o">||</span>
	    <span class="n">clk_id</span> <span class="o">==</span> <span class="n">OMAP_MCBSP_SYSCLK_CLKS_FCLK</span> <span class="o">||</span>
	    <span class="n">clk_id</span> <span class="o">==</span> <span class="n">OMAP_MCBSP_SYSCLK_CLKS_EXT</span> <span class="o">||</span>
	    <span class="n">clk_id</span> <span class="o">==</span> <span class="n">OMAP_MCBSP_SYSCLK_CLKX_EXT</span> <span class="o">||</span>
	    <span class="n">clk_id</span> <span class="o">==</span> <span class="n">OMAP_MCBSP_SYSCLK_CLKR_EXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">in_freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr2</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="n">CLKSM</span><span class="p">;</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pcr0</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="n">SCLKME</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cpu_class_is_omap1</span><span class="p">())</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * McBSP CLKR/FSR signal muxing functions are only available on</span>
<span class="cm">		 * OMAP2 or newer versions</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">clk_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OMAP_MCBSP_SYSCLK_CLK</span>:
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr2</span>	<span class="o">|=</span> <span class="n">CLKSM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OMAP_MCBSP_SYSCLK_CLKS_FCLK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_class_is_omap1</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">omap2_mcbsp_set_clks_src</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span>
					       <span class="n">MCBSP_CLKS_PRCM_SRC</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OMAP_MCBSP_SYSCLK_CLKS_EXT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_class_is_omap1</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">omap2_mcbsp_set_clks_src</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span>
					       <span class="n">MCBSP_CLKS_PAD_SRC</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">OMAP_MCBSP_SYSCLK_CLKX_EXT</span>:
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">srgr2</span>	<span class="o">|=</span> <span class="n">CLKSM</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OMAP_MCBSP_SYSCLK_CLKR_EXT</span>:
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">pcr0</span>	<span class="o">|=</span> <span class="n">SCLKME</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>


	<span class="k">case</span> <span class="n">OMAP_MCBSP_CLKR_SRC_CLKR</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">omap_mcbsp_6pin_src_mux</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="n">CLKR_SRC_CLKR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OMAP_MCBSP_CLKR_SRC_CLKX</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">omap_mcbsp_6pin_src_mux</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="n">CLKR_SRC_CLKX</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OMAP_MCBSP_FSR_SRC_FSR</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">omap_mcbsp_6pin_src_mux</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="n">FSR_SRC_FSR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OMAP_MCBSP_FSR_SRC_FSX</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">omap_mcbsp_6pin_src_mux</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">,</span> <span class="n">FSR_SRC_FSX</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dai_ops</span> <span class="n">mcbsp_dai_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">startup</span>	<span class="o">=</span> <span class="n">omap_mcbsp_dai_startup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">omap_mcbsp_dai_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span>	<span class="o">=</span> <span class="n">omap_mcbsp_dai_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">delay</span>		<span class="o">=</span> <span class="n">omap_mcbsp_dai_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span>	<span class="o">=</span> <span class="n">omap_mcbsp_dai_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_fmt</span>	<span class="o">=</span> <span class="n">omap_mcbsp_dai_set_dai_fmt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_clkdiv</span>	<span class="o">=</span> <span class="n">omap_mcbsp_dai_set_clkdiv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_sysclk</span>	<span class="o">=</span> <span class="n">omap_mcbsp_dai_set_dai_sysclk</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">dai</span><span class="p">);</span>

	<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">dai</span><span class="p">);</span>

	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_soc_dai_driver</span> <span class="n">omap_mcbsp_dai</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">omap_mcbsp_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">omap_mcbsp_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">playback</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rates</span> <span class="o">=</span> <span class="n">OMAP_MCBSP_RATES</span><span class="p">,</span>
		<span class="p">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">SNDRV_PCM_FMTBIT_S16_LE</span> <span class="o">|</span> <span class="n">SNDRV_PCM_FMTBIT_S32_LE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">capture</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rates</span> <span class="o">=</span> <span class="n">OMAP_MCBSP_RATES</span><span class="p">,</span>
		<span class="p">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">SNDRV_PCM_FMTBIT_S16_LE</span> <span class="o">|</span> <span class="n">SNDRV_PCM_FMTBIT_S32_LE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcbsp_dai_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">omap_mcbsp_st_info_volsw</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">soc_mixer_control</span> <span class="o">*</span><span class="n">mc</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">soc_mixer_control</span> <span class="o">*</span><span class="p">)</span><span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>

	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define OMAP_MCBSP_ST_SET_CHANNEL_VOLUME(channel)			\</span>
<span class="cp">static int								\</span>
<span class="cp">omap_mcbsp_set_st_ch##channel##_volume(struct snd_kcontrol *kc,	\</span>
<span class="cp">					struct snd_ctl_elem_value *uc)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kc);		\</span>
<span class="cp">	struct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);	\</span>
<span class="cp">	struct soc_mixer_control *mc =					\</span>
<span class="cp">		(struct soc_mixer_control *)kc-&gt;private_value;		\</span>
<span class="cp">	int max = mc-&gt;max;						\</span>
<span class="cp">	int min = mc-&gt;min;						\</span>
<span class="cp">	int val = uc-&gt;value.integer.value[0];				\</span>
<span class="cp">									\</span>
<span class="cp">	if (val &lt; min || val &gt; max)					\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">									\</span>
<span class="cp">	</span><span class="cm">/* OMAP McBSP implementation uses index values 0..4 */</span><span class="cp">		\</span>
<span class="cp">	return omap_st_set_chgain(mcbsp, channel, val);			\</span>
<span class="cp">}</span>

<span class="cp">#define OMAP_MCBSP_ST_GET_CHANNEL_VOLUME(channel)			\</span>
<span class="cp">static int								\</span>
<span class="cp">omap_mcbsp_get_st_ch##channel##_volume(struct snd_kcontrol *kc,	\</span>
<span class="cp">					struct snd_ctl_elem_value *uc)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kc);		\</span>
<span class="cp">	struct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);	\</span>
<span class="cp">	s16 chgain;							\</span>
<span class="cp">									\</span>
<span class="cp">	if (omap_st_get_chgain(mcbsp, channel, &amp;chgain))		\</span>
<span class="cp">		return -EAGAIN;						\</span>
<span class="cp">									\</span>
<span class="cp">	uc-&gt;value.integer.value[0] = chgain;				\</span>
<span class="cp">	return 0;							\</span>
<span class="cp">}</span>

<span class="n">OMAP_MCBSP_ST_SET_CHANNEL_VOLUME</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">OMAP_MCBSP_ST_SET_CHANNEL_VOLUME</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">OMAP_MCBSP_ST_GET_CHANNEL_VOLUME</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">OMAP_MCBSP_ST_GET_CHANNEL_VOLUME</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">omap_mcbsp_st_put_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">omap_st_is_enabled</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span>
		<span class="n">omap_st_enable</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">omap_st_disable</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">omap_mcbsp_st_get_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>

	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">omap_st_is_enabled</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">omap_mcbsp2_st_controls</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SOC_SINGLE_EXT</span><span class="p">(</span><span class="s">&quot;McBSP2 Sidetone Switch&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">omap_mcbsp_st_get_mode</span><span class="p">,</span> <span class="n">omap_mcbsp_st_put_mode</span><span class="p">),</span>
	<span class="n">OMAP_MCBSP_SOC_SINGLE_S16_EXT</span><span class="p">(</span><span class="s">&quot;McBSP2 Sidetone Channel 0 Volume&quot;</span><span class="p">,</span>
				      <span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">32767</span><span class="p">,</span>
				      <span class="n">omap_mcbsp_get_st_ch0_volume</span><span class="p">,</span>
				      <span class="n">omap_mcbsp_set_st_ch0_volume</span><span class="p">),</span>
	<span class="n">OMAP_MCBSP_SOC_SINGLE_S16_EXT</span><span class="p">(</span><span class="s">&quot;McBSP2 Sidetone Channel 1 Volume&quot;</span><span class="p">,</span>
				      <span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">32767</span><span class="p">,</span>
				      <span class="n">omap_mcbsp_get_st_ch1_volume</span><span class="p">,</span>
				      <span class="n">omap_mcbsp_set_st_ch1_volume</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">omap_mcbsp3_st_controls</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SOC_SINGLE_EXT</span><span class="p">(</span><span class="s">&quot;McBSP3 Sidetone Switch&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">omap_mcbsp_st_get_mode</span><span class="p">,</span> <span class="n">omap_mcbsp_st_put_mode</span><span class="p">),</span>
	<span class="n">OMAP_MCBSP_SOC_SINGLE_S16_EXT</span><span class="p">(</span><span class="s">&quot;McBSP3 Sidetone Channel 0 Volume&quot;</span><span class="p">,</span>
				      <span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">32767</span><span class="p">,</span>
				      <span class="n">omap_mcbsp_get_st_ch0_volume</span><span class="p">,</span>
				      <span class="n">omap_mcbsp_set_st_ch0_volume</span><span class="p">),</span>
	<span class="n">OMAP_MCBSP_SOC_SINGLE_S16_EXT</span><span class="p">(</span><span class="s">&quot;McBSP3 Sidetone Channel 1 Volume&quot;</span><span class="p">,</span>
				      <span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">32767</span><span class="p">,</span>
				      <span class="n">omap_mcbsp_get_st_ch1_volume</span><span class="p">,</span>
				      <span class="n">omap_mcbsp_set_st_ch1_volume</span><span class="p">),</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">omap_mcbsp_st_add_controls</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_pcm_runtime</span> <span class="o">*</span><span class="n">rtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">cpu_dai</span> <span class="o">=</span> <span class="n">rtd</span><span class="o">-&gt;</span><span class="n">cpu_dai</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">snd_soc_dai_get_drvdata</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">st_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cpu_dai</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* McBSP 2 */</span>
		<span class="k">return</span> <span class="n">snd_soc_add_dai_controls</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">,</span>
					<span class="n">omap_mcbsp2_st_controls</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">omap_mcbsp2_st_controls</span><span class="p">));</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* McBSP 3 */</span>
		<span class="k">return</span> <span class="n">snd_soc_add_dai_controls</span><span class="p">(</span><span class="n">cpu_dai</span><span class="p">,</span>
					<span class="n">omap_mcbsp3_st_controls</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">omap_mcbsp3_st_controls</span><span class="p">));</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">omap_mcbsp_st_add_controls</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">asoc_mcbsp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">dev_get_platdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;missing platform data.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mcbsp</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">omap_mcbsp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcbsp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">pdata</span><span class="p">;</span>
	<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mcbsp</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">omap_mcbsp_init</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snd_soc_register_dai</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">omap_mcbsp_dai</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">asoc_mcbsp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">omap_mcbsp</span> <span class="o">*</span><span class="n">mcbsp</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">snd_soc_unregister_dai</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span>
		<span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="n">omap_mcbsp_sysfs_remove</span><span class="p">(</span><span class="n">mcbsp</span><span class="p">);</span>

	<span class="n">clk_put</span><span class="p">(</span><span class="n">mcbsp</span><span class="o">-&gt;</span><span class="n">fclk</span><span class="p">);</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">asoc_mcbsp_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;omap-mcbsp&quot;</span><span class="p">,</span>
			<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">asoc_mcbsp_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">asoc_mcbsp_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">asoc_mcbsp_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jarkko Nikula &lt;jarkko.nikula@bitmer.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;OMAP I2S SoC Interface&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
