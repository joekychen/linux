<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › soc › codecs › tlv320dac33.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tlv320dac33.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ALSA SoC Texas Instruments TLV320DAC33 codec driver</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Peter Ujfalusi &lt;peter.ujfalusi@ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright:   (C) 2009 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/regulator/consumer.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/pcm_params.h&gt;</span>
<span class="cp">#include &lt;sound/soc.h&gt;</span>
<span class="cp">#include &lt;sound/initval.h&gt;</span>
<span class="cp">#include &lt;sound/tlv.h&gt;</span>

<span class="cp">#include &lt;sound/tlv320dac33-plat.h&gt;</span>
<span class="cp">#include &quot;tlv320dac33.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * The internal FIFO is 24576 bytes long</span>
<span class="cm"> * It can be configured to hold 16bit or 24bit samples</span>
<span class="cm"> * In 16bit configuration the FIFO can hold 6144 stereo samples</span>
<span class="cm"> * In 24bit configuration the FIFO can hold 4096 stereo samples</span>
<span class="cm"> */</span>
<span class="cp">#define DAC33_FIFO_SIZE_16BIT	6144</span>
<span class="cp">#define DAC33_FIFO_SIZE_24BIT	4096</span>
<span class="cp">#define DAC33_MODE7_MARGIN	10	</span><span class="cm">/* Safety margin for FIFO in Mode7 */</span><span class="cp"></span>

<span class="cp">#define BURST_BASEFREQ_HZ	49152000</span>

<span class="cp">#define SAMPLES_TO_US(rate, samples) \</span>
<span class="cp">	(1000000000 / (((rate) * 1000) / (samples)))</span>

<span class="cp">#define US_TO_SAMPLES(rate, us) \</span>
<span class="cp">	((rate) / (1000000 / ((us) &lt; 1000000 ? (us) : 1000000)))</span>

<span class="cp">#define UTHR_FROM_PERIOD_SIZE(samples, playrate, burstrate) \</span>
<span class="cp">	(((samples)*5000) / (((burstrate)*5000) / ((burstrate) - (playrate))))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dac33_calculate_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dac33_prepare_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">dac33_state</span> <span class="p">{</span>
	<span class="n">DAC33_IDLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DAC33_PREFILL</span><span class="p">,</span>
	<span class="n">DAC33_PLAYBACK</span><span class="p">,</span>
	<span class="n">DAC33_FLUSH</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">dac33_fifo_modes</span> <span class="p">{</span>
	<span class="n">DAC33_FIFO_BYPASS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DAC33_FIFO_MODE1</span><span class="p">,</span>
	<span class="n">DAC33_FIFO_MODE7</span><span class="p">,</span>
	<span class="n">DAC33_FIFO_LAST_MODE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define DAC33_NUM_SUPPLIES 3</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dac33_supply_names</span><span class="p">[</span><span class="n">DAC33_NUM_SUPPLIES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;AVDD&quot;</span><span class="p">,</span>
	<span class="s">&quot;DVDD&quot;</span><span class="p">,</span>
	<span class="s">&quot;IOVDD&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">dac33_wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulator_bulk_data</span> <span class="n">supplies</span><span class="p">[</span><span class="n">DAC33_NUM_SUPPLIES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">power_gpio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip_power</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">refclk</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alarm_threshold</span><span class="p">;</span>	<span class="cm">/* set to be half of LATENCY_TIME_MS */</span>
	<span class="k">enum</span> <span class="n">dac33_fifo_modes</span> <span class="n">fifo_mode</span><span class="p">;</span><span class="cm">/* FIFO mode selection */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fifo_size</span><span class="p">;</span>		<span class="cm">/* Size of the FIFO in samples */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nsample</span><span class="p">;</span>		<span class="cm">/* burst read amount from host */</span>
	<span class="kt">int</span> <span class="n">mode1_latency</span><span class="p">;</span>		<span class="cm">/* latency caused by the i2c writes in</span>
<span class="cm">					 * us */</span>
	<span class="n">u8</span> <span class="n">burst_bclkdiv</span><span class="p">;</span>		<span class="cm">/* BCLK divider value in burst mode */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">burst_rate</span><span class="p">;</span>	<span class="cm">/* Interface speed in Burst modes */</span>

	<span class="kt">int</span> <span class="n">keep_bclk</span><span class="p">;</span>			<span class="cm">/* Keep the BCLK continuously running</span>
<span class="cm">					 * in FIFO modes */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">t_stamp1</span><span class="p">;</span>	<span class="cm">/* Time stamp for FIFO modes to */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">t_stamp2</span><span class="p">;</span>	<span class="cm">/* calculate the FIFO caused delay */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode1_us_burst</span><span class="p">;</span>	<span class="cm">/* Time to burst read n number of</span>
<span class="cm">					 * samples */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode7_us_to_lthr</span><span class="p">;</span>	<span class="cm">/* Time to reach lthr from uthr */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uthr</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">dac33_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">snd_soc_control_type</span> <span class="n">control_type</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">control_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">dac33_reg</span><span class="p">[</span><span class="n">DAC33_CACHEREGNUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x00 - 0x03 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x04 - 0x07 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x08 - 0x0b */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x0c - 0x0f */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x10 - 0x13 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x14 - 0x17 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x18 - 0x1b */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x1c - 0x1f */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x20 - 0x23 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x24 - 0x27 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x28 - 0x2b */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="cm">/* 0x2c - 0x2f */</span>
<span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x30 - 0x33 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x34 - 0x37 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>             <span class="cm">/* 0x38 - 0x39 */</span>
<span class="cm">/* Registers 0x3a - 0x3f are reserved  */</span>
            <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x3a - 0x3b */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x3c - 0x3f */</span>

<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x40 - 0x43 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span>             <span class="cm">/* 0x44 - 0x45 */</span>
<span class="cm">/* Registers 0x46 - 0x47 are reserved  */</span>
            <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="cm">/* 0x46 - 0x47 */</span>

<span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>       <span class="cm">/* 0x48 - 0x4a */</span>
<span class="cm">/* Registers 0x4b - 0x7c are reserved  */</span>
                  <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x4b        */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x4c - 0x4f */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x50 - 0x53 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x54 - 0x57 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x58 - 0x5b */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x5c - 0x5f */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x60 - 0x63 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x64 - 0x67 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x68 - 0x6b */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x6c - 0x6f */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x70 - 0x73 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x74 - 0x77 */</span>
<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="cm">/* 0x78 - 0x7b */</span>
<span class="mh">0x00</span><span class="p">,</span>                   <span class="cm">/* 0x7c        */</span>

      <span class="mh">0xda</span><span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="cm">/* 0x7d - 0x7f */</span>
<span class="p">};</span>

<span class="cm">/* Register read and write */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">dac33_read_reg_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">reg_cache</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;=</span> <span class="n">DAC33_CACHEREGNUM</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">reg</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dac33_write_reg_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
					 <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">reg_cache</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;=</span> <span class="n">DAC33_CACHEREGNUM</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cache</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		      <span class="n">u8</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="cm">/* If powered off, return the cached value */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">i2c_smbus_read_byte_data</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_data</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Read failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="n">dac33_write_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * data is</span>
<span class="cm">	 *   D15..D8 dac33 register offset</span>
<span class="cm">	 *   D7...D0 register data</span>
<span class="cm">	 */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">dac33_write_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">hw_write</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Write failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_write_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DAC33_I2C_ADDR_AUTOINC	0x80</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_write16</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * data is</span>
<span class="cm">	 *   D23..D16 dac33 register offset</span>
<span class="cm">	 *   D15..D8  register data MSB</span>
<span class="cm">	 *   D7...D0  register data LSB</span>
<span class="cm">	 */</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">dac33_write_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">dac33_write_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We need to set autoincrement mode for 16 bit writes */</span>
		<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">DAC33_I2C_ADDR_AUTOINC</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">hw_write</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Write failed (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dac33_init_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* A : DAC sample rate Fsref/1.5 */</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_DAC_CTRL_A</span><span class="p">,</span> <span class="n">DAC33_DACRATE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="cm">/* B : DAC src=normal, not muted */</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_DAC_CTRL_B</span><span class="p">,</span> <span class="n">DAC33_DACSRCR_RIGHT</span> <span class="o">|</span>
					     <span class="n">DAC33_DACSRCL_LEFT</span><span class="p">);</span>
	<span class="cm">/* C : (defaults) */</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_DAC_CTRL_C</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="cm">/* 73 : volume soft stepping control,</span>
<span class="cm">	 clock source = internal osc (?) */</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_ANA_VOL_SOFT_STEP_CTRL</span><span class="p">,</span> <span class="n">DAC33_VOLCLKEN</span><span class="p">);</span>

	<span class="cm">/* Restore only selected registers (gains mostly) */</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LDAC_DIG_VOL_CTRL</span><span class="p">,</span>
		    <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LDAC_DIG_VOL_CTRL</span><span class="p">));</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_RDAC_DIG_VOL_CTRL</span><span class="p">,</span>
		    <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_RDAC_DIG_VOL_CTRL</span><span class="p">));</span>

	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LINEL_TO_LLO_VOL</span><span class="p">,</span>
		    <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LINEL_TO_LLO_VOL</span><span class="p">));</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LINER_TO_RLO_VOL</span><span class="p">,</span>
		    <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LINER_TO_RLO_VOL</span><span class="p">));</span>

	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_OUT_AMP_CTRL</span><span class="p">,</span>
		    <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_OUT_AMP_CTRL</span><span class="p">));</span>

	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LDAC_PWR_CTRL</span><span class="p">,</span>
		    <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LDAC_PWR_CTRL</span><span class="p">));</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_RDAC_PWR_CTRL</span><span class="p">,</span>
		    <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_RDAC_PWR_CTRL</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dac33_read_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dac33_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_DEVICE_ID_MSB</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dac33_soft_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">power</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_PWR_CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power</span><span class="p">)</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">DAC33_PDNALLB</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DAC33_PDNALLB</span> <span class="o">|</span> <span class="n">DAC33_OSCPDNB</span> <span class="o">|</span>
			 <span class="n">DAC33_DACRPDNB</span> <span class="o">|</span> <span class="n">DAC33_DACLPDNB</span><span class="p">);</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_PWR_CTRL</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dac33_disable_digital</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Stop the DAI clock */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_B</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_BCLKON</span><span class="p">;</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_B</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Power down the Oscillator, and DACs */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_PWR_CTRL</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DAC33_OSCPDNB</span> <span class="o">|</span> <span class="n">DAC33_DACRPDNB</span> <span class="o">|</span> <span class="n">DAC33_DACLPDNB</span><span class="p">);</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_PWR_CTRL</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_hard_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">power</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="cm">/* Safety check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">power</span> <span class="o">==</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Trying to set the same power state: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">power</span> <span class="o">?</span> <span class="s">&quot;ON&quot;</span> <span class="o">:</span> <span class="s">&quot;OFF&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">power</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_bulk_enable</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">),</span>
					  <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Failed to enable supplies: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dac33_soft_power</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">gpio_set_value</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_bulk_disable</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">),</span>
					     <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Failed to disable supplies: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">exit:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_playback_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dapm_widget</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAPM_PRE_PMU</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dac33_calculate_times</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
			<span class="n">dac33_prepare_chip</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAPM_POST_PMD</span>:
		<span class="n">dac33_disable_digital</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_get_fifo_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_set_fifo_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Do not allow changes while stream is running*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">DAC33_FIFO_LAST_MODE</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Codec operation modes */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dac33_fifo_mode_texts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Bypass&quot;</span><span class="p">,</span> <span class="s">&quot;Mode 1&quot;</span><span class="p">,</span> <span class="s">&quot;Mode 7&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">soc_enum</span> <span class="n">dac33_fifo_mode_enum</span> <span class="o">=</span>
	<span class="n">SOC_ENUM_SINGLE_EXT</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33_fifo_mode_texts</span><span class="p">),</span>
			    <span class="n">dac33_fifo_mode_texts</span><span class="p">);</span>

<span class="cm">/* L/R Line Output Gain */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lr_lineout_gain_texts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Line -12dB DAC 0dB&quot;</span><span class="p">,</span> <span class="s">&quot;Line -6dB DAC 6dB&quot;</span><span class="p">,</span>
	<span class="s">&quot;Line 0dB DAC 12dB&quot;</span><span class="p">,</span> <span class="s">&quot;Line 6dB DAC 18dB&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">soc_enum</span> <span class="n">l_lineout_gain_enum</span> <span class="o">=</span>
	<span class="n">SOC_ENUM_SINGLE</span><span class="p">(</span><span class="n">DAC33_LDAC_PWR_CTRL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">lr_lineout_gain_texts</span><span class="p">),</span>
			<span class="n">lr_lineout_gain_texts</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">soc_enum</span> <span class="n">r_lineout_gain_enum</span> <span class="o">=</span>
	<span class="n">SOC_ENUM_SINGLE</span><span class="p">(</span><span class="n">DAC33_RDAC_PWR_CTRL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">lr_lineout_gain_texts</span><span class="p">),</span>
			<span class="n">lr_lineout_gain_texts</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * DACL/R digital volume control:</span>
<span class="cm"> * from 0 dB to -63.5 in 0.5 dB steps</span>
<span class="cm"> * Need to be inverted later on:</span>
<span class="cm"> * 0x00 == 0 dB</span>
<span class="cm"> * 0x7f == -63.5 dB</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DECLARE_TLV_DB_SCALE</span><span class="p">(</span><span class="n">dac_digivol_tlv</span><span class="p">,</span> <span class="o">-</span><span class="mi">6350</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">dac33_snd_controls</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SOC_DOUBLE_R_TLV</span><span class="p">(</span><span class="s">&quot;DAC Digital Playback Volume&quot;</span><span class="p">,</span>
		<span class="n">DAC33_LDAC_DIG_VOL_CTRL</span><span class="p">,</span> <span class="n">DAC33_RDAC_DIG_VOL_CTRL</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dac_digivol_tlv</span><span class="p">),</span>
	<span class="n">SOC_DOUBLE_R</span><span class="p">(</span><span class="s">&quot;DAC Digital Playback Switch&quot;</span><span class="p">,</span>
		 <span class="n">DAC33_LDAC_DIG_VOL_CTRL</span><span class="p">,</span> <span class="n">DAC33_RDAC_DIG_VOL_CTRL</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">SOC_DOUBLE_R</span><span class="p">(</span><span class="s">&quot;Line to Line Out Volume&quot;</span><span class="p">,</span>
		 <span class="n">DAC33_LINEL_TO_LLO_VOL</span><span class="p">,</span> <span class="n">DAC33_LINER_TO_RLO_VOL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">SOC_ENUM</span><span class="p">(</span><span class="s">&quot;Left Line Output Gain&quot;</span><span class="p">,</span> <span class="n">l_lineout_gain_enum</span><span class="p">),</span>
	<span class="n">SOC_ENUM</span><span class="p">(</span><span class="s">&quot;Right Line Output Gain&quot;</span><span class="p">,</span> <span class="n">r_lineout_gain_enum</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">dac33_mode_snd_controls</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SOC_ENUM_EXT</span><span class="p">(</span><span class="s">&quot;FIFO Mode&quot;</span><span class="p">,</span> <span class="n">dac33_fifo_mode_enum</span><span class="p">,</span>
		 <span class="n">dac33_get_fifo_mode</span><span class="p">,</span> <span class="n">dac33_set_fifo_mode</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* Analog bypass */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">dac33_dapm_abypassl_control</span> <span class="o">=</span>
	<span class="n">SOC_DAPM_SINGLE</span><span class="p">(</span><span class="s">&quot;Switch&quot;</span><span class="p">,</span> <span class="n">DAC33_LINEL_TO_LLO_VOL</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">dac33_dapm_abypassr_control</span> <span class="o">=</span>
	<span class="n">SOC_DAPM_SINGLE</span><span class="p">(</span><span class="s">&quot;Switch&quot;</span><span class="p">,</span> <span class="n">DAC33_LINER_TO_RLO_VOL</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cm">/* LOP L/R invert selection */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dac33_lr_lom_texts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;DAC&quot;</span><span class="p">,</span> <span class="s">&quot;LOP&quot;</span><span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">soc_enum</span> <span class="n">dac33_left_lom_enum</span> <span class="o">=</span>
	<span class="n">SOC_ENUM_SINGLE</span><span class="p">(</span><span class="n">DAC33_OUT_AMP_CTRL</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
			<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33_lr_lom_texts</span><span class="p">),</span>
			<span class="n">dac33_lr_lom_texts</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">dac33_dapm_left_lom_control</span> <span class="o">=</span>
<span class="n">SOC_DAPM_ENUM</span><span class="p">(</span><span class="s">&quot;Route&quot;</span><span class="p">,</span> <span class="n">dac33_left_lom_enum</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">soc_enum</span> <span class="n">dac33_right_lom_enum</span> <span class="o">=</span>
	<span class="n">SOC_ENUM_SINGLE</span><span class="p">(</span><span class="n">DAC33_OUT_AMP_CTRL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33_lr_lom_texts</span><span class="p">),</span>
			<span class="n">dac33_lr_lom_texts</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">dac33_dapm_right_lom_control</span> <span class="o">=</span>
<span class="n">SOC_DAPM_ENUM</span><span class="p">(</span><span class="s">&quot;Route&quot;</span><span class="p">,</span> <span class="n">dac33_right_lom_enum</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dapm_widget</span> <span class="n">dac33_dapm_widgets</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SND_SOC_DAPM_OUTPUT</span><span class="p">(</span><span class="s">&quot;LEFT_LO&quot;</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_OUTPUT</span><span class="p">(</span><span class="s">&quot;RIGHT_LO&quot;</span><span class="p">),</span>

	<span class="n">SND_SOC_DAPM_INPUT</span><span class="p">(</span><span class="s">&quot;LINEL&quot;</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_INPUT</span><span class="p">(</span><span class="s">&quot;LINER&quot;</span><span class="p">),</span>

	<span class="n">SND_SOC_DAPM_DAC</span><span class="p">(</span><span class="s">&quot;DACL&quot;</span><span class="p">,</span> <span class="s">&quot;Left Playback&quot;</span><span class="p">,</span> <span class="n">SND_SOC_NOPM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_DAC</span><span class="p">(</span><span class="s">&quot;DACR&quot;</span><span class="p">,</span> <span class="s">&quot;Right Playback&quot;</span><span class="p">,</span> <span class="n">SND_SOC_NOPM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

	<span class="cm">/* Analog bypass */</span>
	<span class="n">SND_SOC_DAPM_SWITCH</span><span class="p">(</span><span class="s">&quot;Analog Left Bypass&quot;</span><span class="p">,</span> <span class="n">SND_SOC_NOPM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dac33_dapm_abypassl_control</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_SWITCH</span><span class="p">(</span><span class="s">&quot;Analog Right Bypass&quot;</span><span class="p">,</span> <span class="n">SND_SOC_NOPM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">dac33_dapm_abypassr_control</span><span class="p">),</span>

	<span class="n">SND_SOC_DAPM_MUX</span><span class="p">(</span><span class="s">&quot;Left LOM Inverted From&quot;</span><span class="p">,</span> <span class="n">SND_SOC_NOPM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">dac33_dapm_left_lom_control</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_MUX</span><span class="p">(</span><span class="s">&quot;Right LOM Inverted From&quot;</span><span class="p">,</span> <span class="n">SND_SOC_NOPM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">dac33_dapm_right_lom_control</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 * For DAPM path, when only the anlog bypass path is enabled, and the</span>
<span class="cm">	 * LOP inverted from the corresponding DAC side.</span>
<span class="cm">	 * This is needed, so we can attach the DAC power supply in this case.</span>
<span class="cm">	 */</span>
	<span class="n">SND_SOC_DAPM_PGA</span><span class="p">(</span><span class="s">&quot;Left Bypass PGA&quot;</span><span class="p">,</span> <span class="n">SND_SOC_NOPM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_PGA</span><span class="p">(</span><span class="s">&quot;Right Bypass PGA&quot;</span><span class="p">,</span> <span class="n">SND_SOC_NOPM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

	<span class="n">SND_SOC_DAPM_REG</span><span class="p">(</span><span class="n">snd_soc_dapm_mixer</span><span class="p">,</span> <span class="s">&quot;Output Left Amplifier&quot;</span><span class="p">,</span>
			 <span class="n">DAC33_OUT_AMP_PWR_CTRL</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_REG</span><span class="p">(</span><span class="n">snd_soc_dapm_mixer</span><span class="p">,</span> <span class="s">&quot;Output Right Amplifier&quot;</span><span class="p">,</span>
			 <span class="n">DAC33_OUT_AMP_PWR_CTRL</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

	<span class="n">SND_SOC_DAPM_SUPPLY</span><span class="p">(</span><span class="s">&quot;Left DAC Power&quot;</span><span class="p">,</span>
			    <span class="n">DAC33_LDAC_PWR_CTRL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_SUPPLY</span><span class="p">(</span><span class="s">&quot;Right DAC Power&quot;</span><span class="p">,</span>
			    <span class="n">DAC33_RDAC_PWR_CTRL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

	<span class="n">SND_SOC_DAPM_SUPPLY</span><span class="p">(</span><span class="s">&quot;Codec Power&quot;</span><span class="p">,</span>
			    <span class="n">DAC33_PWR_CTRL</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>

	<span class="n">SND_SOC_DAPM_PRE</span><span class="p">(</span><span class="s">&quot;Pre Playback&quot;</span><span class="p">,</span> <span class="n">dac33_playback_event</span><span class="p">),</span>
	<span class="n">SND_SOC_DAPM_POST</span><span class="p">(</span><span class="s">&quot;Post Playback&quot;</span><span class="p">,</span> <span class="n">dac33_playback_event</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dapm_route</span> <span class="n">audio_map</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Analog bypass */</span>
	<span class="p">{</span><span class="s">&quot;Analog Left Bypass&quot;</span><span class="p">,</span> <span class="s">&quot;Switch&quot;</span><span class="p">,</span> <span class="s">&quot;LINEL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;Analog Right Bypass&quot;</span><span class="p">,</span> <span class="s">&quot;Switch&quot;</span><span class="p">,</span> <span class="s">&quot;LINER&quot;</span><span class="p">},</span>

	<span class="p">{</span><span class="s">&quot;Output Left Amplifier&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;DACL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;Output Right Amplifier&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;DACR&quot;</span><span class="p">},</span>

	<span class="p">{</span><span class="s">&quot;Left Bypass PGA&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Analog Left Bypass&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;Right Bypass PGA&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Analog Right Bypass&quot;</span><span class="p">},</span>

	<span class="p">{</span><span class="s">&quot;Left LOM Inverted From&quot;</span><span class="p">,</span> <span class="s">&quot;DAC&quot;</span><span class="p">,</span> <span class="s">&quot;Left Bypass PGA&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;Right LOM Inverted From&quot;</span><span class="p">,</span> <span class="s">&quot;DAC&quot;</span><span class="p">,</span> <span class="s">&quot;Right Bypass PGA&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;Left LOM Inverted From&quot;</span><span class="p">,</span> <span class="s">&quot;LOP&quot;</span><span class="p">,</span> <span class="s">&quot;Analog Left Bypass&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;Right LOM Inverted From&quot;</span><span class="p">,</span> <span class="s">&quot;LOP&quot;</span><span class="p">,</span> <span class="s">&quot;Analog Right Bypass&quot;</span><span class="p">},</span>

	<span class="p">{</span><span class="s">&quot;Output Left Amplifier&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Left LOM Inverted From&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;Output Right Amplifier&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Right LOM Inverted From&quot;</span><span class="p">},</span>

	<span class="p">{</span><span class="s">&quot;DACL&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Left DAC Power&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;DACR&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Right DAC Power&quot;</span><span class="p">},</span>

	<span class="p">{</span><span class="s">&quot;Left Bypass PGA&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Left DAC Power&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;Right Bypass PGA&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Right DAC Power&quot;</span><span class="p">},</span>

	<span class="cm">/* output */</span>
	<span class="p">{</span><span class="s">&quot;LEFT_LO&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Output Left Amplifier&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;RIGHT_LO&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Output Right Amplifier&quot;</span><span class="p">},</span>

	<span class="p">{</span><span class="s">&quot;LEFT_LO&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Codec Power&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;RIGHT_LO&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;Codec Power&quot;</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_set_bias_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">snd_soc_bias_level</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SND_SOC_BIAS_ON</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_BIAS_PREPARE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_BIAS_STANDBY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dapm</span><span class="p">.</span><span class="n">bias_level</span> <span class="o">==</span> <span class="n">SND_SOC_BIAS_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Coming from OFF, switch on the codec */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dac33_hard_power</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">dac33_init_chip</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_BIAS_OFF</span>:
		<span class="cm">/* Do not power off, when the codec is already off */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dapm</span><span class="p">.</span><span class="n">bias_level</span> <span class="o">==</span> <span class="n">SND_SOC_BIAS_OFF</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dac33_hard_power</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">dapm</span><span class="p">.</span><span class="n">bias_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dac33_prefill_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE1</span>:
		<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_NSAMPLE_MSB</span><span class="p">,</span>
			<span class="n">DAC33_THRREG</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">nsample</span><span class="p">));</span>

		<span class="cm">/* Take the timestamps */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp2</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp1</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp2</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_PREFILL_MSB</span><span class="p">,</span>
				<span class="n">DAC33_THRREG</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span><span class="p">));</span>
		<span class="cm">/* Enable Alarm Threshold IRQ with a delay */</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="n">SAMPLES_TO_US</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_rate</span><span class="p">,</span>
				     <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">delay</span> <span class="o">+</span> <span class="mi">500</span><span class="p">);</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_IRQ_MASK</span><span class="p">,</span> <span class="n">DAC33_MAT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE7</span>:
		<span class="cm">/* Take the timestamp */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp1</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>
		<span class="cm">/* Move back the timestamp with drain time */</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp1</span> <span class="o">-=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode7_us_to_lthr</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_PREFILL_MSB</span><span class="p">,</span>
				<span class="n">DAC33_THRREG</span><span class="p">(</span><span class="n">DAC33_MODE7_MARGIN</span><span class="p">));</span>

		<span class="cm">/* Enable Upper Threshold IRQ */</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_IRQ_MASK</span><span class="p">,</span> <span class="n">DAC33_MUT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unhandled FIFO mode: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dac33_playback_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE1</span>:
		<span class="cm">/* Take the timestamp */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp2</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_NSAMPLE_MSB</span><span class="p">,</span>
				<span class="n">DAC33_THRREG</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">nsample</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE7</span>:
		<span class="cm">/* At the moment we are not using interrupts in mode7 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unhandled FIFO mode: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dac33_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">dac33</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tlv320dac33_priv</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">codec</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DAC33_PREFILL</span>:
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DAC33_PLAYBACK</span><span class="p">;</span>
		<span class="n">dac33_prefill_handler</span><span class="p">(</span><span class="n">dac33</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_PLAYBACK</span>:
		<span class="n">dac33_playback_handler</span><span class="p">(</span><span class="n">dac33</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_IDLE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FLUSH</span>:
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DAC33_IDLE</span><span class="p">;</span>
		<span class="cm">/* Mask all interrupts from dac33 */</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_IRQ_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* flush fifo */</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_CTRL_A</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">DAC33_FIFOFLUSH</span><span class="p">;</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_CTRL_A</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dac33_interrupt_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp1</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Do not schedule the workqueue in Mode7 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span> <span class="o">!=</span> <span class="n">DAC33_FIFO_MODE7</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">dac33_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dac33_oscwait</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
		<span class="n">dac33_read</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INT_OSC_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DAC33_OSCSTATUS_NORMAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="o">--</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DAC33_OSCSTATUS_NORMAL</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;internal oscillator calibration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">dai</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="cm">/* Stream started, save the substream pointer */</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="n">substream</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dac33_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">dai</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">substream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CALC_BURST_RATE(bclkdiv, bclk_per_sample) \</span>
<span class="cp">	(BURST_BASEFREQ_HZ / bclkdiv / bclk_per_sample)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_hw_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">dai</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="cm">/* Check parameters for validity */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">params_rate</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">44100</span>:
	<span class="k">case</span> <span class="mi">48000</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported rate %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">params_rate</span><span class="p">(</span><span class="n">params</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">params_format</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_FORMAT_S16_LE</span>:
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">=</span> <span class="n">DAC33_FIFO_SIZE_16BIT</span><span class="p">;</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_rate</span> <span class="o">=</span> <span class="n">CALC_BURST_RATE</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_bclkdiv</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_FORMAT_S32_LE</span>:
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">=</span> <span class="n">DAC33_FIFO_SIZE_24BIT</span><span class="p">;</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_rate</span> <span class="o">=</span> <span class="n">CALC_BURST_RATE</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_bclkdiv</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported format %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">params_format</span><span class="p">(</span><span class="n">params</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CALC_OSCSET(rate, refclk) ( \</span>
<span class="cp">	((((rate * 10000) / refclk) * 4096) + 7000) / 10000)</span>
<span class="cp">#define CALC_RATIOSET(rate, refclk) ( \</span>
<span class="cp">	((((refclk  * 100000) / rate) * 16384) + 50000) / 100000)</span>

<span class="cm">/*</span>
<span class="cm"> * tlv320dac33 is strict on the sequence of the register writes, if the register</span>
<span class="cm"> * writes happens in different order, than dac33 might end up in unknown state.</span>
<span class="cm"> * Use the known, working sequence of register writes to initialize the dac33.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_prepare_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oscset</span><span class="p">,</span> <span class="n">ratioset</span><span class="p">,</span> <span class="n">pwr_ctrl</span><span class="p">,</span> <span class="n">reg_tmp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">aictrl_a</span><span class="p">,</span> <span class="n">aictrl_b</span><span class="p">,</span> <span class="n">fifoctrl_a</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">44100</span>:
	<span class="k">case</span> <span class="mi">48000</span>:
		<span class="n">oscset</span> <span class="o">=</span> <span class="n">CALC_OSCSET</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">refclk</span><span class="p">);</span>
		<span class="n">ratioset</span> <span class="o">=</span> <span class="n">CALC_RATIOSET</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
					 <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">refclk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported rate %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">aictrl_a</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_A</span><span class="p">);</span>
	<span class="n">aictrl_a</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DAC33_NCYCL_MASK</span> <span class="o">|</span> <span class="n">DAC33_WLEN_MASK</span><span class="p">);</span>
	<span class="cm">/* Read FIFO control A, and clear FIFO flush bit */</span>
	<span class="n">fifoctrl_a</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_CTRL_A</span><span class="p">);</span>
	<span class="n">fifoctrl_a</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_FIFOFLUSH</span><span class="p">;</span>

	<span class="n">fifoctrl_a</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_WIDTH</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_FORMAT_S16_LE</span>:
		<span class="n">aictrl_a</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DAC33_NCYCL_16</span> <span class="o">|</span> <span class="n">DAC33_WLEN_16</span><span class="p">);</span>
		<span class="n">fifoctrl_a</span> <span class="o">|=</span> <span class="n">DAC33_WIDTH</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_FORMAT_S32_LE</span>:
		<span class="n">aictrl_a</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DAC33_NCYCL_32</span> <span class="o">|</span> <span class="n">DAC33_WLEN_24</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported format %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Chip is not powered yet.</span>
<span class="cm">		 * Do the init in the dac33_set_bias_level later.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dac33_soft_power</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dac33_soft_power</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">reg_tmp</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INT_OSC_CTRL</span><span class="p">);</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INT_OSC_CTRL</span><span class="p">,</span> <span class="n">reg_tmp</span><span class="p">);</span>

	<span class="cm">/* Write registers 0x08 and 0x09 (MSB, LSB) */</span>
	<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INT_OSC_FREQ_RAT_A</span><span class="p">,</span> <span class="n">oscset</span><span class="p">);</span>

	<span class="cm">/* OSC calibration time */</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_CALIB_TIME</span><span class="p">,</span> <span class="mi">96</span><span class="p">);</span>

	<span class="cm">/* adjustment treshold &amp; step */</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INT_OSC_CTRL_B</span><span class="p">,</span> <span class="n">DAC33_ADJTHRSHLD</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
						 <span class="n">DAC33_ADJSTEP</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* div=4 / gain=1 / div */</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INT_OSC_CTRL_C</span><span class="p">,</span> <span class="n">DAC33_REFDIV</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

	<span class="n">pwr_ctrl</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_PWR_CTRL</span><span class="p">);</span>
	<span class="n">pwr_ctrl</span> <span class="o">|=</span> <span class="n">DAC33_OSCPDNB</span> <span class="o">|</span> <span class="n">DAC33_DACRPDNB</span> <span class="o">|</span> <span class="n">DAC33_DACLPDNB</span><span class="p">;</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_PWR_CTRL</span><span class="p">,</span> <span class="n">pwr_ctrl</span><span class="p">);</span>

	<span class="n">dac33_oscwait</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Generic for all FIFO modes */</span>
		<span class="cm">/* 50-51 : ASRC Control registers */</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_ASRC_CTRL_A</span><span class="p">,</span> <span class="n">DAC33_SRCLKDIV</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_ASRC_CTRL_B</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* ??? */</span>

		<span class="cm">/* Write registers 0x34 and 0x35 (MSB, LSB) */</span>
		<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SRC_REF_CLK_RATIO_A</span><span class="p">,</span> <span class="n">ratioset</span><span class="p">);</span>

		<span class="cm">/* Set interrupts to high active */</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INTP_CTRL_A</span><span class="p">,</span> <span class="n">DAC33_INTPM_AHIGH</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* FIFO bypass mode */</span>
		<span class="cm">/* 50-51 : ASRC Control registers */</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_ASRC_CTRL_A</span><span class="p">,</span> <span class="n">DAC33_SRCBYP</span><span class="p">);</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_ASRC_CTRL_B</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* ??? */</span>
	<span class="p">}</span>

	<span class="cm">/* Interrupt behaviour configuration */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE1</span>:
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_IRQ_MODE_B</span><span class="p">,</span>
			    <span class="n">DAC33_ATM</span><span class="p">(</span><span class="n">DAC33_FIFO_IRQ_MODE_LEVEL</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE7</span>:
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_IRQ_MODE_A</span><span class="p">,</span>
			<span class="n">DAC33_UTM</span><span class="p">(</span><span class="n">DAC33_FIFO_IRQ_MODE_LEVEL</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* in FIFO bypass mode, the interrupts are not used */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">aictrl_b</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_B</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE1</span>:
		<span class="cm">/*</span>
<span class="cm">		 * For mode1:</span>
<span class="cm">		 * Disable the FIFO bypass (Enable the use of FIFO)</span>
<span class="cm">		 * Select nSample mode</span>
<span class="cm">		 * BCLK is only running when data is needed by DAC33</span>
<span class="cm">		 */</span>
		<span class="n">fifoctrl_a</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_FBYPAS</span><span class="p">;</span>
		<span class="n">fifoctrl_a</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_FAUTO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">keep_bclk</span><span class="p">)</span>
			<span class="n">aictrl_b</span> <span class="o">|=</span> <span class="n">DAC33_BCLKON</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">aictrl_b</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_BCLKON</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE7</span>:
		<span class="cm">/*</span>
<span class="cm">		 * For mode1:</span>
<span class="cm">		 * Disable the FIFO bypass (Enable the use of FIFO)</span>
<span class="cm">		 * Select Threshold mode</span>
<span class="cm">		 * BCLK is only running when data is needed by DAC33</span>
<span class="cm">		 */</span>
		<span class="n">fifoctrl_a</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_FBYPAS</span><span class="p">;</span>
		<span class="n">fifoctrl_a</span> <span class="o">|=</span> <span class="n">DAC33_FAUTO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">keep_bclk</span><span class="p">)</span>
			<span class="n">aictrl_b</span> <span class="o">|=</span> <span class="n">DAC33_BCLKON</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">aictrl_b</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_BCLKON</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * For FIFO bypass mode:</span>
<span class="cm">		 * Enable the FIFO bypass (Disable the FIFO use)</span>
<span class="cm">		 * Set the BCLK as continuous</span>
<span class="cm">		 */</span>
		<span class="n">fifoctrl_a</span> <span class="o">|=</span> <span class="n">DAC33_FBYPAS</span><span class="p">;</span>
		<span class="n">aictrl_b</span> <span class="o">|=</span> <span class="n">DAC33_BCLKON</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_FIFO_CTRL_A</span><span class="p">,</span> <span class="n">fifoctrl_a</span><span class="p">);</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_A</span><span class="p">,</span> <span class="n">aictrl_a</span><span class="p">);</span>
	<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_B</span><span class="p">,</span> <span class="n">aictrl_b</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * BCLK divide ratio</span>
<span class="cm">	 * 0: 1.5</span>
<span class="cm">	 * 1: 1</span>
<span class="cm">	 * 2: 2</span>
<span class="cm">	 * ...</span>
<span class="cm">	 * 254: 254</span>
<span class="cm">	 * 255: 255</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span>
		<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_C</span><span class="p">,</span>
							<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_bclkdiv</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">format</span> <span class="o">==</span> <span class="n">SNDRV_PCM_FORMAT_S16_LE</span><span class="p">)</span>
			<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_C</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dac33_write</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_C</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE1</span>:
		<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_ATHR_MSB</span><span class="p">,</span>
			      <span class="n">DAC33_THRREG</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE7</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Configure the threshold levels, and leave 10 sample space</span>
<span class="cm">		 * at the bottom, and also at the top of the FIFO</span>
<span class="cm">		 */</span>
		<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_UTHR_MSB</span><span class="p">,</span> <span class="n">DAC33_THRREG</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">uthr</span><span class="p">));</span>
		<span class="n">dac33_write16</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_LTHR_MSB</span><span class="p">,</span>
			      <span class="n">DAC33_THRREG</span><span class="p">(</span><span class="n">DAC33_MODE7_MARGIN</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dac33_calculate_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">period_size</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nsample_limit</span><span class="p">;</span>

	<span class="cm">/* In bypass mode we don&#39;t need to calculate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE1</span>:
		<span class="cm">/* Number of samples under i2c latency */</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span> <span class="o">=</span> <span class="n">US_TO_SAMPLES</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span>
						<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode1_latency</span><span class="p">);</span>
		<span class="n">nsample_limit</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">-</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">period_size</span> <span class="o">&lt;=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * Configure nSamaple to number of periods,</span>
<span class="cm">			 * which covers the latency requironment.</span>
<span class="cm">			 */</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">nsample</span> <span class="o">=</span> <span class="n">period_size</span> <span class="o">*</span>
				<span class="p">((</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span> <span class="o">/</span> <span class="n">period_size</span><span class="p">)</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span> <span class="o">%</span> <span class="n">period_size</span> <span class="o">?</span>
				<span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">period_size</span> <span class="o">&gt;</span> <span class="n">nsample_limit</span><span class="p">)</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">nsample</span> <span class="o">=</span> <span class="n">nsample_limit</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">nsample</span> <span class="o">=</span> <span class="n">period_size</span><span class="p">;</span>

		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode1_us_burst</span> <span class="o">=</span> <span class="n">SAMPLES_TO_US</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_rate</span><span class="p">,</span>
						      <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">nsample</span><span class="p">);</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE7</span>:
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">uthr</span> <span class="o">=</span> <span class="n">UTHR_FROM_PERIOD_SIZE</span><span class="p">(</span><span class="n">period_size</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span>
						    <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_rate</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">uthr</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">-</span> <span class="n">DAC33_MODE7_MARGIN</span><span class="p">))</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">uthr</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">-</span> <span class="n">DAC33_MODE7_MARGIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">uthr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">DAC33_MODE7_MARGIN</span> <span class="o">+</span> <span class="mi">10</span><span class="p">))</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">uthr</span> <span class="o">=</span> <span class="p">(</span><span class="n">DAC33_MODE7_MARGIN</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>

		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode7_us_to_lthr</span> <span class="o">=</span>
				<span class="n">SAMPLES_TO_US</span><span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
					<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">uthr</span> <span class="o">-</span> <span class="n">DAC33_MODE7_MARGIN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_pcm_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">dai</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_RESUME</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_RELEASE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DAC33_PREFILL</span><span class="p">;</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">dac33_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_SUSPEND</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_PUSH</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DAC33_FLUSH</span><span class="p">;</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">dac33_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">snd_pcm_sframes_t</span> <span class="nf">dac33_dai_delay</span><span class="p">(</span>
			<span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">dai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">dai</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t_now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_delta</span><span class="p">,</span> <span class="n">uthr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">samples_out</span><span class="p">,</span> <span class="n">samples_in</span><span class="p">,</span> <span class="n">samples</span><span class="p">;</span>
	<span class="n">snd_pcm_sframes_t</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_BYPASS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE1</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">t0</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp1</span><span class="p">;</span>
		<span class="n">t1</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp2</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">t_now</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>

		<span class="cm">/* We have not started to fill the FIFO yet, delay is 0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t0</span> <span class="o">&gt;</span> <span class="n">t1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Phase 1:</span>
<span class="cm">			 * After Alarm threshold, and before nSample write</span>
<span class="cm">			 */</span>
			<span class="n">time_delta</span> <span class="o">=</span> <span class="n">t_now</span> <span class="o">-</span> <span class="n">t0</span><span class="p">;</span>
			<span class="n">samples_out</span> <span class="o">=</span> <span class="n">time_delta</span> <span class="o">?</span> <span class="n">US_TO_SAMPLES</span><span class="p">(</span>
						<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
						<span class="n">time_delta</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span> <span class="o">&gt;</span> <span class="n">samples_out</span><span class="p">))</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span> <span class="o">-</span> <span class="n">samples_out</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">t_now</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode1_us_burst</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Phase 2:</span>
<span class="cm">			 * After nSample write (during burst operation)</span>
<span class="cm">			 */</span>
			<span class="n">time_delta</span> <span class="o">=</span> <span class="n">t_now</span> <span class="o">-</span> <span class="n">t0</span><span class="p">;</span>
			<span class="n">samples_out</span> <span class="o">=</span> <span class="n">time_delta</span> <span class="o">?</span> <span class="n">US_TO_SAMPLES</span><span class="p">(</span>
						<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
						<span class="n">time_delta</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">time_delta</span> <span class="o">=</span> <span class="n">t_now</span> <span class="o">-</span> <span class="n">t1</span><span class="p">;</span>
			<span class="n">samples_in</span> <span class="o">=</span> <span class="n">time_delta</span> <span class="o">?</span> <span class="n">US_TO_SAMPLES</span><span class="p">(</span>
						<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_rate</span><span class="p">,</span>
						<span class="n">time_delta</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">samples</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span><span class="p">;</span>
			<span class="n">samples</span> <span class="o">+=</span> <span class="p">(</span><span class="n">samples_in</span> <span class="o">-</span> <span class="n">samples_out</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="n">samples</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Phase 3:</span>
<span class="cm">			 * After burst operation, before next alarm threshold</span>
<span class="cm">			 */</span>
			<span class="n">time_delta</span> <span class="o">=</span> <span class="n">t_now</span> <span class="o">-</span> <span class="n">t0</span><span class="p">;</span>
			<span class="n">samples_out</span> <span class="o">=</span> <span class="n">time_delta</span> <span class="o">?</span> <span class="n">US_TO_SAMPLES</span><span class="p">(</span>
						<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
						<span class="n">time_delta</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">samples_in</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">nsample</span><span class="p">;</span>
			<span class="n">samples</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">alarm_threshold</span><span class="p">;</span>
			<span class="n">samples</span> <span class="o">+=</span> <span class="p">(</span><span class="n">samples_in</span> <span class="o">-</span> <span class="n">samples_out</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">&gt;</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">?</span>
					<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_size</span> <span class="o">:</span> <span class="n">samples</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DAC33_FIFO_MODE7</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">t0</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">t_stamp1</span><span class="p">;</span>
		<span class="n">uthr</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">uthr</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">t_now</span> <span class="o">=</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">());</span>

		<span class="cm">/* We have not started to fill the FIFO yet, delay is 0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">t_now</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Either the timestamps are messed or equal. Report</span>
<span class="cm">			 * maximum delay</span>
<span class="cm">			 */</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">uthr</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">time_delta</span> <span class="o">=</span> <span class="n">t_now</span> <span class="o">-</span> <span class="n">t0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_delta</span> <span class="o">&lt;=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode7_us_to_lthr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			* Phase 1:</span>
<span class="cm">			* After burst (draining phase)</span>
<span class="cm">			*/</span>
			<span class="n">samples_out</span> <span class="o">=</span> <span class="n">US_TO_SAMPLES</span><span class="p">(</span>
					<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
					<span class="n">time_delta</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">uthr</span> <span class="o">&gt;</span> <span class="n">samples_out</span><span class="p">))</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="n">uthr</span> <span class="o">-</span> <span class="n">samples_out</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			* Phase 2:</span>
<span class="cm">			* During burst operation</span>
<span class="cm">			*/</span>
			<span class="n">time_delta</span> <span class="o">=</span> <span class="n">time_delta</span> <span class="o">-</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode7_us_to_lthr</span><span class="p">;</span>

			<span class="n">samples_out</span> <span class="o">=</span> <span class="n">US_TO_SAMPLES</span><span class="p">(</span>
					<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span>
					<span class="n">time_delta</span><span class="p">);</span>
			<span class="n">samples_in</span> <span class="o">=</span> <span class="n">US_TO_SAMPLES</span><span class="p">(</span>
					<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_rate</span><span class="p">,</span>
					<span class="n">time_delta</span><span class="p">);</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="n">DAC33_MODE7_MARGIN</span> <span class="o">+</span> <span class="n">samples_in</span> <span class="o">-</span> <span class="n">samples_out</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delay</span> <span class="o">&gt;</span> <span class="n">uthr</span><span class="p">))</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="n">uthr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unhandled FIFO mode: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">delay</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_set_dai_sysclk</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">codec_dai</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">clk_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">codec_dai</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">ioc_reg</span><span class="p">,</span> <span class="n">asrcb_reg</span><span class="p">;</span>

	<span class="n">ioc_reg</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INT_OSC_CTRL</span><span class="p">);</span>
	<span class="n">asrcb_reg</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_ASRC_CTRL_B</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">clk_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TLV320DAC33_MCLK</span>:
		<span class="n">ioc_reg</span> <span class="o">|=</span> <span class="n">DAC33_REFSEL</span><span class="p">;</span>
		<span class="n">asrcb_reg</span> <span class="o">|=</span> <span class="n">DAC33_SRCREFSEL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TLV320DAC33_SLEEPCLK</span>:
		<span class="n">ioc_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_REFSEL</span><span class="p">;</span>
		<span class="n">asrcb_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_SRCREFSEL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid clock ID (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clk_id</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">refclk</span> <span class="o">=</span> <span class="n">freq</span><span class="p">;</span>

	<span class="n">dac33_write_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_INT_OSC_CTRL</span><span class="p">,</span> <span class="n">ioc_reg</span><span class="p">);</span>
	<span class="n">dac33_write_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_ASRC_CTRL_B</span><span class="p">,</span> <span class="n">asrcb_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_set_dai_fmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_dai</span> <span class="o">*</span><span class="n">codec_dai</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="n">codec_dai</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">aictrl_a</span><span class="p">,</span> <span class="n">aictrl_b</span><span class="p">;</span>

	<span class="n">aictrl_a</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_A</span><span class="p">);</span>
	<span class="n">aictrl_b</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_B</span><span class="p">);</span>
	<span class="cm">/* set master/slave audio interface */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">SND_SOC_DAIFMT_MASTER_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_CBM_CFM</span>:
		<span class="cm">/* Codec Master */</span>
		<span class="n">aictrl_a</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DAC33_MSBCLK</span> <span class="o">|</span> <span class="n">DAC33_MSWCLK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_CBS_CFS</span>:
		<span class="cm">/* Codec Slave */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;FIFO mode requires master mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">aictrl_a</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DAC33_MSBCLK</span> <span class="o">|</span> <span class="n">DAC33_MSWCLK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">aictrl_a</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_AFMT_MASK</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">SND_SOC_DAIFMT_FORMAT_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_I2S</span>:
		<span class="n">aictrl_a</span> <span class="o">|=</span> <span class="n">DAC33_AFMT_I2S</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_DSP_A</span>:
		<span class="n">aictrl_a</span> <span class="o">|=</span> <span class="n">DAC33_AFMT_DSP</span><span class="p">;</span>
		<span class="n">aictrl_b</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DAC33_DATA_DELAY_MASK</span><span class="p">;</span>
		<span class="n">aictrl_b</span> <span class="o">|=</span> <span class="n">DAC33_DATA_DELAY</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_RIGHT_J</span>:
		<span class="n">aictrl_a</span> <span class="o">|=</span> <span class="n">DAC33_AFMT_RIGHT_J</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SND_SOC_DAIFMT_LEFT_J</span>:
		<span class="n">aictrl_a</span> <span class="o">|=</span> <span class="n">DAC33_AFMT_LEFT_J</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unsupported format (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">SND_SOC_DAIFMT_FORMAT_MASK</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dac33_write_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_A</span><span class="p">,</span> <span class="n">aictrl_a</span><span class="p">);</span>
	<span class="n">dac33_write_reg_cache</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">DAC33_SER_AUDIOIF_CTRL_B</span><span class="p">,</span> <span class="n">aictrl_b</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_soc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">control_data</span> <span class="o">=</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">control_data</span><span class="p">;</span>
	<span class="n">codec</span><span class="o">-&gt;</span><span class="n">hw_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw_write_t</span><span class="p">)</span> <span class="n">i2c_master_send</span><span class="p">;</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">codec</span> <span class="o">=</span> <span class="n">codec</span><span class="p">;</span>

	<span class="cm">/* Read the tlv320dac33 ID registers */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dac33_hard_power</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to power up codec: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_power</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dac33_read_id</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">dac33_hard_power</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to read chip ID: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_power</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if the IRQ number is valid and request it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dac33_interrupt_handler</span><span class="p">,</span>
				  <span class="n">IRQF_TRIGGER_RISING</span><span class="p">,</span>
				  <span class="n">codec</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">codec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not request IRQ%d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Setup work queue */</span>
			<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">dac33_wq</span> <span class="o">=</span>
				<span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;tlv320dac33&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">dac33_wq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_irq</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">codec</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">dac33_work</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Only add the FIFO controls, if we have valid IRQ number */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">snd_soc_add_codec_controls</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">dac33_mode_snd_controls</span><span class="p">,</span>
				     <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33_mode_snd_controls</span><span class="p">));</span>

<span class="nl">err_power:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_soc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">snd_soc_codec_get_drvdata</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="n">dac33_set_bias_level</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">SND_SOC_BIAS_OFF</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">dac33_wq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_soc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dac33_set_bias_level</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">SND_SOC_BIAS_OFF</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dac33_soc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_soc_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dac33_set_bias_level</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="n">SND_SOC_BIAS_STANDBY</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_soc_codec_driver</span> <span class="n">soc_codec_dev_tlv320dac33</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">dac33_read_reg_cache</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">dac33_write_locked</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_bias_level</span> <span class="o">=</span> <span class="n">dac33_set_bias_level</span><span class="p">,</span>
	<span class="p">.</span><span class="n">idle_bias_off</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reg_cache_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33_reg</span><span class="p">),</span>
	<span class="p">.</span><span class="n">reg_word_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">),</span>
	<span class="p">.</span><span class="n">reg_cache_default</span> <span class="o">=</span> <span class="n">dac33_reg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">dac33_soc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">dac33_soc_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">dac33_soc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">dac33_soc_resume</span><span class="p">,</span>

	<span class="p">.</span><span class="n">controls</span> <span class="o">=</span> <span class="n">dac33_snd_controls</span><span class="p">,</span>
	<span class="p">.</span><span class="n">num_controls</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33_snd_controls</span><span class="p">),</span>
	<span class="p">.</span><span class="n">dapm_widgets</span> <span class="o">=</span> <span class="n">dac33_dapm_widgets</span><span class="p">,</span>
	<span class="p">.</span><span class="n">num_dapm_widgets</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33_dapm_widgets</span><span class="p">),</span>
	<span class="p">.</span><span class="n">dapm_routes</span> <span class="o">=</span> <span class="n">audio_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">num_dapm_routes</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">audio_map</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define DAC33_RATES	(SNDRV_PCM_RATE_44100 | \</span>
<span class="cp">			 SNDRV_PCM_RATE_48000)</span>
<span class="cp">#define DAC33_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">snd_soc_dai_ops</span> <span class="n">dac33_dai_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">startup</span>	<span class="o">=</span> <span class="n">dac33_startup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">dac33_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span>	<span class="o">=</span> <span class="n">dac33_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span>	<span class="o">=</span> <span class="n">dac33_pcm_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">delay</span>		<span class="o">=</span> <span class="n">dac33_dai_delay</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_sysclk</span>	<span class="o">=</span> <span class="n">dac33_set_dai_sysclk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_fmt</span>	<span class="o">=</span> <span class="n">dac33_set_dai_fmt</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_soc_dai_driver</span> <span class="n">dac33_dai</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;tlv320dac33-hifi&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">playback</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">stream_name</span> <span class="o">=</span> <span class="s">&quot;Playback&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rates</span> <span class="o">=</span> <span class="n">DAC33_RATES</span><span class="p">,</span>
		<span class="p">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">DAC33_FORMATS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sig_bits</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dac33_dai_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">dac33_i2c_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Platform data not set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pdata</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="n">dac33</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlv320dac33_priv</span><span class="p">),</span>
			     <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">control_data</span> <span class="o">=</span> <span class="n">client</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">i2c_set_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">dac33</span><span class="p">);</span>

	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">;</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">burst_bclkdiv</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">burst_bclkdiv</span><span class="p">;</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">keep_bclk</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">keep_bclk</span><span class="p">;</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode1_latency</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mode1_latency</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode1_latency</span><span class="p">)</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">mode1_latency</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="cm">/* 10ms */</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="cm">/* Disable FIFO use by default */</span>
	<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">fifo_mode</span> <span class="o">=</span> <span class="n">DAC33_FIFO_BYPASS</span><span class="p">;</span>

	<span class="cm">/* Check if the reset GPIO number is valid and request it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">,</span> <span class="s">&quot;tlv320dac33 reset&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Failed to request reset GPIO (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_gpio</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">supply</span> <span class="o">=</span> <span class="n">dac33_supply_names</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">regulator_bulk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">),</span>
				 <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to request supplies: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_get</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">snd_soc_register_codec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">soc_codec_dev_tlv320dac33</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dac33_dai</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">err_register:</span>
	<span class="n">regulator_bulk_free</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">),</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">);</span>
<span class="nl">err_get:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">);</span>
<span class="nl">err_gpio:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">dac33_i2c_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlv320dac33_priv</span> <span class="o">*</span><span class="n">dac33</span> <span class="o">=</span> <span class="n">i2c_get_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">chip_power</span><span class="p">))</span>
		<span class="n">dac33_hard_power</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">power_gpio</span><span class="p">);</span>

	<span class="n">regulator_bulk_free</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">),</span> <span class="n">dac33</span><span class="o">-&gt;</span><span class="n">supplies</span><span class="p">);</span>

	<span class="n">snd_soc_unregister_codec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="n">tlv320dac33_i2c_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;tlv320dac33&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">i2c</span><span class="p">,</span> <span class="n">tlv320dac33_i2c_id</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="n">tlv320dac33_i2c_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;tlv320dac33-codec&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">dac33_i2c_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">dac33_i2c_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">tlv320dac33_i2c_id</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dac33_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">i2c_add_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlv320dac33_i2c_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DAC33: driver registration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">dac33_module_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">dac33_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2c_del_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlv320dac33_i2c_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dac33_module_exit</span><span class="p">);</span>


<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;ASoC TLV320DAC33 codec driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Peter Ujfalusi &lt;peter.ujfalusi@ti.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
