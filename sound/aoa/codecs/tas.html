<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › aoa › codecs › tas.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tas.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Apple Onboard Audio driver for tas codec</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2006 Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * GPL v2, can be found in COPYING.</span>
<span class="cm"> *</span>
<span class="cm"> * Open questions:</span>
<span class="cm"> *  - How to distinguish between 3004 and versions?</span>
<span class="cm"> *</span>
<span class="cm"> * FIXMEs:</span>
<span class="cm"> *  - This codec driver doesn&#39;t honour the &#39;connected&#39;</span>
<span class="cm"> *    property of the aoa_codec struct, hence if</span>
<span class="cm"> *    it is used in machines where not everything is</span>
<span class="cm"> *    connected it will display wrong mixer elements.</span>
<span class="cm"> *  - Driver assumes that the microphone is always</span>
<span class="cm"> *    monaureal and connected to the right channel of</span>
<span class="cm"> *    the input. This should also be a codec-dependent</span>
<span class="cm"> *    flag, maybe the codec should have 3 different</span>
<span class="cm"> *    bits for the three different possibilities how</span>
<span class="cm"> *    it can be hooked up...</span>
<span class="cm"> *    But as long as I don&#39;t see any hardware hooked</span>
<span class="cm"> *    up that way...</span>
<span class="cm"> *  - As Apple notes in their code, the tas3004 seems</span>
<span class="cm"> *    to delay the right channel by one sample. You can</span>
<span class="cm"> *    see this when for example recording stereo in</span>
<span class="cm"> *    audacity, or recording the tas output via cable</span>
<span class="cm"> *    on another machine (use a sinus generator or so).</span>
<span class="cm"> *    I tried programming the BiQuads but couldn&#39;t</span>
<span class="cm"> *    make the delay work, maybe someone can read the</span>
<span class="cm"> *    datasheet and fix it. The relevant Apple comment</span>
<span class="cm"> *    is in AppleTAS3004Audio.cpp lines 1637 ff. Note</span>
<span class="cm"> *    that their comment describing how they program</span>
<span class="cm"> *    the filters sucks...</span>
<span class="cm"> *</span>
<span class="cm"> * Other things:</span>
<span class="cm"> *  - this should actually register *two* aoa_codec</span>
<span class="cm"> *    structs since it has two inputs. Then it must</span>
<span class="cm"> *    use the prepare callback to forbid running the</span>
<span class="cm"> *    secondary output on a different clock.</span>
<span class="cm"> *    Also, whatever bus knows how to do this must</span>
<span class="cm"> *    provide two soundbus_dev devices and the fabric</span>
<span class="cm"> *    must be able to link them correctly.</span>
<span class="cm"> *</span>
<span class="cm"> *    I don&#39;t even know if Apple ever uses the second</span>
<span class="cm"> *    port on the tas3004 though, I don&#39;t think their</span>
<span class="cm"> *    i2s controllers can even do it. OTOH, they all</span>
<span class="cm"> *    derive the clocks from common clocks, so it</span>
<span class="cm"> *    might just be possible. The framework allows the</span>
<span class="cm"> *    codec to refine the transfer_info items in the</span>
<span class="cm"> *    usable callback, so we can simply remove the</span>
<span class="cm"> *    rates the second instance is not using when it</span>
<span class="cm"> *    actually is in use.</span>
<span class="cm"> *    Maybe we&#39;ll need to make the sound busses have</span>
<span class="cm"> *    a &#39;clock group id&#39; value so the codec can</span>
<span class="cm"> *    determine if the two outputs can be driven at</span>
<span class="cm"> *    the same time. But that is likely overkill, up</span>
<span class="cm"> *    to the fabric to not link them up incorrectly,</span>
<span class="cm"> *    and up to the hardware designer to not wire</span>
<span class="cm"> *    them up in some weird unusable way.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;stddef.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;asm/pmac_low_i2c.h&gt;</span>
<span class="cp">#include &lt;asm/prom.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Johannes Berg &lt;johannes@sipsolutions.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;tas codec driver for snd-aoa&quot;</span><span class="p">);</span>

<span class="cp">#include &quot;tas.h&quot;</span>
<span class="cp">#include &quot;tas-gain-table.h&quot;</span>
<span class="cp">#include &quot;tas-basstreble.h&quot;</span>
<span class="cp">#include &quot;../aoa.h&quot;</span>
<span class="cp">#include &quot;../soundbus/soundbus.h&quot;</span>

<span class="cp">#define PFX &quot;snd-aoa-codec-tas: &quot;</span>


<span class="k">struct</span> <span class="n">tas</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">aoa_codec</span>	<span class="n">codec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">i2c</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">mute_l</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">mute_r</span><span class="o">:</span><span class="mi">1</span> <span class="p">,</span>
				<span class="nl">controls_created:</span><span class="mi">1</span> <span class="p">,</span>
				<span class="nl">drc_enabled:</span><span class="mi">1</span><span class="p">,</span>
				<span class="nl">hw_enabled:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">cached_volume_l</span><span class="p">,</span> <span class="n">cached_volume_r</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">mixer_l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">mixer_r</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span>			<span class="n">bass</span><span class="p">,</span> <span class="n">treble</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">acr</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">drc_range</span><span class="p">;</span>
	<span class="cm">/* protects hardware access against concurrency from</span>
<span class="cm">	 * userspace when hitting controls and during</span>
<span class="cm">	 * codec init/suspend/resume */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">mtx</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">tas_reset_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="nf">codec_to_tas</span><span class="p">(</span><span class="k">struct</span> <span class="n">aoa_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">codec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tas</span><span class="p">,</span> <span class="n">codec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tas_write_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">len</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">i2c</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">i2c_smbus_write_i2c_block_data</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">i2c</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tas3004_set_drc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_enabled</span><span class="p">)</span>
		<span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x50</span><span class="p">;</span> <span class="cm">/* 3:1 above threshold */</span>
	<span class="k">else</span>
		<span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x51</span><span class="p">;</span> <span class="cm">/* disabled */</span>
	<span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span> <span class="cm">/* 1:1 below threshold */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_range</span> <span class="o">&gt;</span> <span class="mh">0xef</span><span class="p">)</span>
		<span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xef</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_range</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_range</span><span class="p">;</span>
	<span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xb0</span><span class="p">;</span>
	<span class="n">val</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x60</span><span class="p">;</span>
	<span class="n">val</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xa0</span><span class="p">;</span>

	<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_DRC</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tas_set_treble</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tas3004_treble</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">treble</span><span class="p">);</span>
	<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_TREBLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tas_set_bass</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tas3004_bass</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">bass</span><span class="p">);</span>
	<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_BASS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tas_set_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">block</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">;</span>

	<span class="n">left</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">cached_volume_l</span><span class="p">;</span>
	<span class="n">right</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">cached_volume_r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="mi">177</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">177</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="mi">177</span><span class="p">)</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">177</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mute_l</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mute_r</span><span class="p">)</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* analysing the volume and mixer tables shows</span>
<span class="cm">	 * that they are similar enough when we shift</span>
<span class="cm">	 * the mixer table down by 4 bits. The error</span>
<span class="cm">	 * is miniscule, in just one item the error</span>
<span class="cm">	 * is 1, at a value of 0x07f17b (mixer table</span>
<span class="cm">	 * value is 0x07f17a) */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tas_gaintable</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
	<span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">;</span>
	<span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">12</span><span class="p">;</span>
	<span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tas_gaintable</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
	<span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">;</span>
	<span class="n">block</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">12</span><span class="p">;</span>
	<span class="n">block</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_VOL</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tas_set_mixer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">block</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">mixer_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">177</span><span class="p">)</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">177</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tas_gaintable</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>
		<span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">;</span>
		<span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_LMIX</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">mixer_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">177</span><span class="p">)</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">177</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tas_gaintable</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>
		<span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">;</span>
		<span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">;</span>
		<span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_RMIX</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* alsa stuff */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_dev_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_device_ops</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">dev_register</span> <span class="o">=</span> <span class="n">tas_dev_register</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_vol_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">177</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_vol_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">cached_volume_l</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">cached_volume_r</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_vol_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">177</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">177</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">cached_volume_l</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	 <span class="o">&amp;&amp;</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">cached_volume_r</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">cached_volume_l</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">cached_volume_r</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span><span class="p">)</span>
		<span class="n">tas_set_volume</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">volume_control</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Master Playback Volume&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">tas_snd_vol_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">tas_snd_vol_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">tas_snd_vol_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define tas_snd_mute_info	snd_ctl_boolean_stereo_info</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_mute_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mute_l</span><span class="p">;</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mute_r</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_mute_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mute_l</span> <span class="o">==</span> <span class="o">!</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	 <span class="o">&amp;&amp;</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">mute_r</span> <span class="o">==</span> <span class="o">!</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">mute_l</span> <span class="o">=</span> <span class="o">!</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">mute_r</span> <span class="o">=</span> <span class="o">!</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span><span class="p">)</span>
		<span class="n">tas_set_volume</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">mute_control</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Master Playback Switch&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">tas_snd_mute_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">tas_snd_mute_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">tas_snd_mute_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_mixer_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">177</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_mixer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">mixer_l</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">mixer_r</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_mixer_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">kcontrol</span><span class="o">-&gt;</span><span class="n">private_value</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mixer_l</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	 <span class="o">&amp;&amp;</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">mixer_r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">mixer_l</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">mixer_r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span><span class="p">)</span>
		<span class="n">tas_set_mixer</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MIXER_CONTROL(n,descr,idx)			\</span>
<span class="cp">static struct snd_kcontrol_new n##_control = {		\</span>
<span class="cp">	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,		\</span>
<span class="cp">	.name = descr &quot; Playback Volume&quot;,		\</span>
<span class="cp">	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,	\</span>
<span class="cp">	.info = tas_snd_mixer_info,			\</span>
<span class="cp">	.get = tas_snd_mixer_get,			\</span>
<span class="cp">	.put = tas_snd_mixer_put,			\</span>
<span class="cp">	.private_value = idx,				\</span>
<span class="cp">}</span>

<span class="n">MIXER_CONTROL</span><span class="p">(</span><span class="n">pcm1</span><span class="p">,</span> <span class="s">&quot;PCM&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MIXER_CONTROL</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span> <span class="s">&quot;Monitor&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_drc_range_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">TAS3004_DRC_MAX</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_drc_range_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_range</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_drc_range_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">TAS3004_DRC_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_range</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_range</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span><span class="p">)</span>
		<span class="n">tas3004_set_drc</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">drc_range_control</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DRC Range&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">tas_snd_drc_range_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">tas_snd_drc_range_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">tas_snd_drc_range_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define tas_snd_drc_switch_info		snd_ctl_boolean_mono_info</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_drc_switch_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_enabled</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_drc_switch_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_enabled</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_enabled</span> <span class="o">=</span> <span class="o">!!</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span><span class="p">)</span>
		<span class="n">tas3004_set_drc</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">drc_switch_control</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DRC Range Switch&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">tas_snd_drc_switch_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">tas_snd_drc_switch_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">tas_snd_drc_switch_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_capture_source_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">texts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;Line-In&quot;</span><span class="p">,</span> <span class="s">&quot;Microphone&quot;</span> <span class="p">};</span>

	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_ENUMERATED</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">texts</span><span class="p">[</span><span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_capture_source_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span> <span class="o">&amp;</span> <span class="n">TAS_ACR_INPUT_B</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_capture_source_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">oldacr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">oldacr</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Despite what the data sheet says in one place, the</span>
<span class="cm">	 * TAS_ACR_B_MONAUREAL bit forces mono output even when</span>
<span class="cm">	 * input A (line in) is selected.</span>
<span class="cm">	 */</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TAS_ACR_INPUT_B</span> <span class="o">|</span> <span class="n">TAS_ACR_B_MONAUREAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">enumerated</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span> <span class="o">|=</span> <span class="n">TAS_ACR_INPUT_B</span> <span class="o">|</span> <span class="n">TAS_ACR_B_MONAUREAL</span> <span class="o">|</span>
		      <span class="n">TAS_ACR_B_MON_SEL_RIGHT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldacr</span> <span class="o">==</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span><span class="p">)</span>
		<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_ACR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">capture_source_control</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="cm">/* If we name this &#39;Input Source&#39;, it properly shows up in</span>
<span class="cm">	 * alsamixer as a selection, * but it&#39;s shown under the</span>
<span class="cm">	 * &#39;Playback&#39; category.</span>
<span class="cm">	 * If I name it &#39;Capture Source&#39;, it shows up in strange</span>
<span class="cm">	 * ways (two bools of which one can be selected at a</span>
<span class="cm">	 * time) but at least it&#39;s shown in the &#39;Capture&#39;</span>
<span class="cm">	 * category.</span>
<span class="cm">	 * I was told that this was due to backward compatibility,</span>
<span class="cm">	 * but I don&#39;t understand then why the mangling is *not*</span>
<span class="cm">	 * done when I name it &quot;Input Source&quot;.....</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Capture Source&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">tas_snd_capture_source_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">tas_snd_capture_source_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">tas_snd_capture_source_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_treble_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">TAS3004_TREBLE_MIN</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">TAS3004_TREBLE_MAX</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_treble_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">treble</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_treble_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">TAS3004_TREBLE_MIN</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">TAS3004_TREBLE_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">treble</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">treble</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span><span class="p">)</span>
		<span class="n">tas_set_treble</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">treble_control</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Treble&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">tas_snd_treble_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">tas_snd_treble_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">tas_snd_treble_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_bass_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_info</span> <span class="o">*</span><span class="n">uinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_TYPE_INTEGER</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">TAS3004_BASS_MIN</span><span class="p">;</span>
	<span class="n">uinfo</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">TAS3004_BASS_MAX</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_bass_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tas</span><span class="o">-&gt;</span><span class="n">bass</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_snd_bass_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_kcontrol</span> <span class="o">*</span><span class="n">kcontrol</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">snd_ctl_elem_value</span> <span class="o">*</span><span class="n">ucontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">snd_kcontrol_chip</span><span class="p">(</span><span class="n">kcontrol</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">TAS3004_BASS_MIN</span> <span class="o">||</span>
	    <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">TAS3004_BASS_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">bass</span> <span class="o">==</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">bass</span> <span class="o">=</span> <span class="n">ucontrol</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">.</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span><span class="p">)</span>
		<span class="n">tas_set_bass</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_kcontrol_new</span> <span class="n">bass_control</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">iface</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_IFACE_MIXER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Bass&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">access</span> <span class="o">=</span> <span class="n">SNDRV_CTL_ELEM_ACCESS_READWRITE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">tas_snd_bass_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">tas_snd_bass_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span> <span class="o">=</span> <span class="n">tas_snd_bass_put</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">transfer_info</span> <span class="n">tas_transfers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="cm">/* input */</span>
		<span class="p">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">SNDRV_PCM_FMTBIT_S16_BE</span> <span class="o">|</span> <span class="n">SNDRV_PCM_FMTBIT_S24_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rates</span> <span class="o">=</span> <span class="n">SNDRV_PCM_RATE_32000</span> <span class="o">|</span> <span class="n">SNDRV_PCM_RATE_44100</span> <span class="o">|</span> <span class="n">SNDRV_PCM_RATE_48000</span><span class="p">,</span>
		<span class="p">.</span><span class="n">transfer_in</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="cm">/* output */</span>
		<span class="p">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">SNDRV_PCM_FMTBIT_S16_BE</span> <span class="o">|</span> <span class="n">SNDRV_PCM_FMTBIT_S24_BE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rates</span> <span class="o">=</span> <span class="n">SNDRV_PCM_RATE_32000</span> <span class="o">|</span> <span class="n">SNDRV_PCM_RATE_44100</span> <span class="o">|</span> <span class="n">SNDRV_PCM_RATE_48000</span><span class="p">,</span>
		<span class="p">.</span><span class="n">transfer_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_usable</span><span class="p">(</span><span class="k">struct</span> <span class="n">codec_info_item</span> <span class="o">*</span><span class="n">cii</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">transfer_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">transfer_info</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_reset_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="o">-&gt;</span><span class="n">methods</span><span class="o">-&gt;</span><span class="n">all_amps_off</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="o">-&gt;</span><span class="n">methods</span><span class="o">-&gt;</span><span class="n">set_hw_reset</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="o">-&gt;</span><span class="n">methods</span><span class="o">-&gt;</span><span class="n">set_hw_reset</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="o">-&gt;</span><span class="n">methods</span><span class="o">-&gt;</span><span class="n">set_hw_reset</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="o">-&gt;</span><span class="n">methods</span><span class="o">-&gt;</span><span class="n">all_amps_restore</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">TAS_MCS_SCLK64</span> <span class="o">|</span> <span class="n">TAS_MCS_SPORT_MODE_I2S</span> <span class="o">|</span> <span class="n">TAS_MCS_SPORT_WL_24BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_MCS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">outerr</span><span class="p">;</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span> <span class="o">|=</span> <span class="n">TAS_ACR_ANALOG_PDOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_ACR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">outerr</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_MCS2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">outerr</span><span class="p">;</span>

	<span class="n">tas3004_set_drc</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>

	<span class="cm">/* Set treble &amp; bass to 0dB */</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">treble</span> <span class="o">=</span> <span class="n">TAS3004_TREBLE_ZERO</span><span class="p">;</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">bass</span> <span class="o">=</span> <span class="n">TAS3004_BASS_ZERO</span><span class="p">;</span>
	<span class="n">tas_set_treble</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">tas_set_bass</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>

	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TAS_ACR_ANALOG_PDOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_ACR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">outerr</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">outerr:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_switch_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">codec_info_item</span> <span class="o">*</span><span class="n">cii</span><span class="p">,</span> <span class="k">enum</span> <span class="n">clock_switch</span> <span class="n">clock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">cii</span><span class="o">-&gt;</span><span class="n">codec_data</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CLOCK_SWITCH_PREPARE_SLAVE</span>:
		<span class="cm">/* Clocks are going away, mute mute mute */</span>
		<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="o">-&gt;</span><span class="n">methods</span><span class="o">-&gt;</span><span class="n">all_amps_off</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="p">);</span>
		<span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CLOCK_SWITCH_SLAVE</span>:
		<span class="cm">/* Clocks are back, re-init the codec */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="n">tas_reset_init</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
		<span class="n">tas_set_volume</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
		<span class="n">tas_set_mixer</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
		<span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="o">-&gt;</span><span class="n">methods</span><span class="o">-&gt;</span><span class="n">all_amps_restore</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* doesn&#39;t happen as of now */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/* we are controlled via i2c and assume that is always up</span>
<span class="cm"> * If that wasn&#39;t the case, we&#39;d have to suspend once</span>
<span class="cm"> * our i2c device is suspended, and then take note of that! */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span> <span class="o">|=</span> <span class="n">TAS_ACR_ANALOG_PDOWN</span><span class="p">;</span>
	<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_ACR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">acr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* reset codec */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">tas_reset_init</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">tas_set_volume</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">tas_set_mixer</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_tas_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">codec_info_item</span> <span class="o">*</span><span class="n">cii</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tas_suspend</span><span class="p">(</span><span class="n">cii</span><span class="o">-&gt;</span><span class="n">codec_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_tas_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">codec_info_item</span> <span class="o">*</span><span class="n">cii</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tas_resume</span><span class="p">(</span><span class="n">cii</span><span class="o">-&gt;</span><span class="n">codec_data</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>
<span class="cp">#define _tas_suspend	NULL</span>
<span class="cp">#define _tas_resume	NULL</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">codec_info</span> <span class="n">tas_codec_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">transfers</span> <span class="o">=</span> <span class="n">tas_transfers</span><span class="p">,</span>
	<span class="cm">/* in theory, we can drive it at 512 too...</span>
<span class="cm">	 * but so far the framework doesn&#39;t allow</span>
<span class="cm">	 * for that and I don&#39;t see much point in it. */</span>
	<span class="p">.</span><span class="n">sysclock_factor</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
	<span class="cm">/* same here, could be 32 for just one 16 bit format */</span>
	<span class="p">.</span><span class="n">bus_factor</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">usable</span> <span class="o">=</span> <span class="n">tas_usable</span><span class="p">,</span>
	<span class="p">.</span><span class="n">switch_clock</span> <span class="o">=</span> <span class="n">tas_switch_clock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">_tas_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">_tas_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_init_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">aoa_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">codec_to_tas</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span> <span class="o">||</span> <span class="o">!</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">gpio</span><span class="o">-&gt;</span><span class="n">methods</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;gpios not assigned!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tas_reset_init</span><span class="p">(</span><span class="n">tas</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;tas failed to initialise</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">hw_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">soundbus_dev</span><span class="o">-&gt;</span><span class="n">attach_codec</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">soundbus_dev</span><span class="p">,</span>
						   <span class="n">aoa_get_card</span><span class="p">(),</span>
						   <span class="o">&amp;</span><span class="n">tas_codec_info</span><span class="p">,</span> <span class="n">tas</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;error attaching tas to soundbus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aoa_snd_device_new</span><span class="p">(</span><span class="n">SNDRV_DEV_LOWLEVEL</span><span class="p">,</span> <span class="n">tas</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PFX</span> <span class="s">&quot;failed to create tas snd device!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">volume_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mute_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcm1_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monitor_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">capture_source_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drc_range_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drc_switch_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">treble_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">aoa_snd_ctl_add</span><span class="p">(</span><span class="n">snd_ctl_new1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bass_control</span><span class="p">,</span> <span class="n">tas</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">error:</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">soundbus_dev</span><span class="o">-&gt;</span><span class="n">detach_codec</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">soundbus_dev</span><span class="p">,</span> <span class="n">tas</span><span class="p">);</span>
	<span class="n">snd_device_free</span><span class="p">(</span><span class="n">aoa_get_card</span><span class="p">(),</span> <span class="n">tas</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tas_exit_codec</span><span class="p">(</span><span class="k">struct</span> <span class="n">aoa_codec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">codec_to_tas</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">soundbus_dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">soundbus_dev</span><span class="o">-&gt;</span><span class="n">detach_codec</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">soundbus_dev</span><span class="p">,</span> <span class="n">tas</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_board_info</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;aoa_codec_tas&quot;</span><span class="p">,</span> <span class="n">I2C_NAME_SIZE</span><span class="p">);</span>
	<span class="n">info</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">client</span> <span class="o">=</span> <span class="n">i2c_new_device</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We know the driver is already loaded, so the device should be</span>
<span class="cm">	 * already bound. If not it means binding failed, and then there</span>
<span class="cm">	 * is no point in keeping the device instantiated.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2c_unregister_device</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let i2c-core delete that device on driver removal.</span>
<span class="cm">	 * This is safe because i2c-core holds the core_lock mutex for us.</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">detected</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_i2c_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span><span class="p">;</span>

	<span class="n">tas</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tas</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tas</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">i2c</span> <span class="o">=</span> <span class="n">client</span><span class="p">;</span>
	<span class="n">i2c_set_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">tas</span><span class="p">);</span>

	<span class="cm">/* seems that half is a saner default */</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">drc_range</span> <span class="o">=</span> <span class="n">TAS3004_DRC_MAX</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;tas&quot;</span><span class="p">,</span> <span class="n">MAX_CODEC_NAME_LEN</span><span class="p">);</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">tas_init_codec</span><span class="p">;</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">tas_exit_codec</span><span class="p">;</span>
	<span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aoa_codec_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
	       <span class="s">&quot;snd-aoa-codec-tas: tas found, addr 0x%02x on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">fail:</span>
	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_i2c_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">busnode</span><span class="p">,</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pmac_i2c_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

	<span class="n">bus</span> <span class="o">=</span> <span class="n">pmac_i2c_adapter_to_bus</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">busnode</span> <span class="o">=</span> <span class="n">pmac_i2c_get_bus_node</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">dev</span> <span class="o">=</span> <span class="n">of_get_next_child</span><span class="p">(</span><span class="n">busnode</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;tas3004&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PFX</span> <span class="s">&quot;found tas3004</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">tas_create</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="p">((</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* older machines have no &#39;codec&#39; node with a &#39;compatible&#39;</span>
<span class="cm">		 * property that says &#39;tas3004&#39;, they just have a &#39;deq&#39;</span>
<span class="cm">		 * node without any such property... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;deq&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">_addr</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">addr</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PFX</span> <span class="s">&quot;found &#39;deq&#39; node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">_addr</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;i2c-address&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_addr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">_addr</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
			<span class="cm">/* now, if the address doesn&#39;t match any of the two</span>
<span class="cm">			 * that a tas3004 can have, we cannot handle this.</span>
<span class="cm">			 * I doubt it ever happens but hey. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="mh">0x34</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">!=</span> <span class="mh">0x35</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">tas_create</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tas_i2c_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tas</span> <span class="o">*</span><span class="n">tas</span> <span class="o">=</span> <span class="n">i2c_get_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">TAS_ACR_ANALOG_PDOWN</span><span class="p">;</span>

	<span class="n">aoa_codec_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">.</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/* power down codec chip */</span>
	<span class="n">tas_write_reg</span><span class="p">(</span><span class="n">tas</span><span class="p">,</span> <span class="n">TAS_REG_ACR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tas</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tas</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="n">tas_i2c_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;aoa_codec_tas&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="n">tas_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;aoa_codec_tas&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">attach_adapter</span> <span class="o">=</span> <span class="n">tas_i2c_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">tas_i2c_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">tas_i2c_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">tas_i2c_id</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_i2c_driver</span><span class="p">(</span><span class="n">tas_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
