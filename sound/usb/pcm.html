<!DOCTYPE html>
<html><head><title>joekychen/linux » sound › usb › pcm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pcm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *   the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *   GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU General Public License</span>
<span class="cm"> *   along with this program; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/usb/audio.h&gt;</span>
<span class="cp">#include &lt;linux/usb/audio-v2.h&gt;</span>

<span class="cp">#include &lt;sound/core.h&gt;</span>
<span class="cp">#include &lt;sound/pcm.h&gt;</span>
<span class="cp">#include &lt;sound/pcm_params.h&gt;</span>

<span class="cp">#include &quot;usbaudio.h&quot;</span>
<span class="cp">#include &quot;card.h&quot;</span>
<span class="cp">#include &quot;quirks.h&quot;</span>
<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;endpoint.h&quot;</span>
<span class="cp">#include &quot;helper.h&quot;</span>
<span class="cp">#include &quot;pcm.h&quot;</span>
<span class="cp">#include &quot;clock.h&quot;</span>
<span class="cp">#include &quot;power.h&quot;</span>

<span class="cp">#define SUBSTREAM_FLAG_DATA_EP_STARTED	0</span>
<span class="cp">#define SUBSTREAM_FLAG_SYNC_EP_STARTED	1</span>

<span class="cm">/* return the estimated delay based on USB frame counters */</span>
<span class="n">snd_pcm_uframes_t</span> <span class="nf">snd_usb_pcm_delay</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">current_frame_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_diff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">est_delay</span><span class="p">;</span>

	<span class="n">current_frame_number</span> <span class="o">=</span> <span class="n">usb_get_current_frame_number</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * HCD implementations use different widths, use lower 8 bits.</span>
<span class="cm">	 * The delay will be managed up to 256ms, which is more than</span>
<span class="cm">	 * enough</span>
<span class="cm">	 */</span>
	<span class="n">frame_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_frame_number</span> <span class="o">-</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">last_frame_number</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="cm">/* Approximation based on number of samples per USB frame (ms),</span>
<span class="cm">	   some truncation for 44.1 but the estimate is good enough */</span>
	<span class="n">est_delay</span> <span class="o">=</span>  <span class="n">subs</span><span class="o">-&gt;</span><span class="n">last_delay</span> <span class="o">-</span> <span class="p">(</span><span class="n">frame_diff</span> <span class="o">*</span> <span class="n">rate</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">est_delay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">est_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">est_delay</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return the current pcm pointer.  just based on the hwptr_done value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">snd_pcm_uframes_t</span> <span class="nf">snd_usb_pcm_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hwptr_done</span><span class="p">;</span>

	<span class="n">subs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="p">)</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">hwptr_done</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span><span class="p">;</span>
	<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="n">snd_usb_pcm_delay</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span>
						<span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hwptr_done</span> <span class="o">/</span> <span class="p">(</span><span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">frame_bits</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find a matching audio format</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="nf">find_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">format</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channels</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cur_attr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">attr</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audioformat</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">formats</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1uLL</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">!=</span> <span class="n">channels</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rate</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span> <span class="o">||</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rates</span> <span class="o">&amp;</span> <span class="n">SNDRV_PCM_RATE_CONTINUOUS</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">nr_rates</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">rate</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">nr_rates</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">attr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">ep_attr</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_SYNCTYPE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
			<span class="n">cur_attr</span> <span class="o">=</span> <span class="n">attr</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* avoid async out and adaptive in if the other method</span>
<span class="cm">		 * supports the same format.</span>
<span class="cm">		 * this is a workaround for the case like</span>
<span class="cm">		 * M-audio audiophile USB.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">!=</span> <span class="n">cur_attr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">attr</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_SYNC_ASYNC</span> <span class="o">&amp;&amp;</span>
			     <span class="n">subs</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_SYNC_ADAPTIVE</span> <span class="o">&amp;&amp;</span>
			     <span class="n">subs</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cur_attr</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_SYNC_ASYNC</span> <span class="o">&amp;&amp;</span>
			     <span class="n">subs</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">cur_attr</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_SYNC_ADAPTIVE</span> <span class="o">&amp;&amp;</span>
			     <span class="n">subs</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
				<span class="n">cur_attr</span> <span class="o">=</span> <span class="n">attr</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* find the format with the largest max. packet size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">maxpacksize</span> <span class="o">&gt;</span> <span class="n">found</span><span class="o">-&gt;</span><span class="n">maxpacksize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
			<span class="n">cur_attr</span> <span class="o">=</span> <span class="n">attr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_pitch_v1</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_audio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iface</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alts</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">;</span>

	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_usb_ctl_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">UAC_SET_CUR</span><span class="p">,</span>
				   <span class="n">USB_TYPE_CLASS</span><span class="o">|</span><span class="n">USB_RECIP_ENDPOINT</span><span class="o">|</span><span class="n">USB_DIR_OUT</span><span class="p">,</span>
				   <span class="n">UAC_EP_CS_ATTR_PITCH_CONTROL</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
				   <span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%d:%d:%d: cannot set enable PITCH</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">iface</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_pitch_v2</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_audio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iface</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alts</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ep</span> <span class="o">=</span> <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">;</span>

	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_usb_ctl_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">UAC2_CS_CUR</span><span class="p">,</span>
				   <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_ENDPOINT</span> <span class="o">|</span> <span class="n">USB_DIR_OUT</span><span class="p">,</span>
				   <span class="n">UAC2_EP_CS_PITCH</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%d:%d:%d: cannot set enable PITCH (v2)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">iface</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialize the pitch control and sample rate</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">snd_usb_init_pitch</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_audio</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iface</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alts</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface_descriptor</span> <span class="o">*</span><span class="n">altsd</span> <span class="o">=</span> <span class="n">get_iface_desc</span><span class="p">(</span><span class="n">alts</span><span class="p">);</span>

	<span class="cm">/* if endpoint doesn&#39;t have pitch control, bail out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">attributes</span> <span class="o">&amp;</span> <span class="n">UAC_EP_CS_ATTR_PITCH_CONTROL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">altsd</span><span class="o">-&gt;</span><span class="n">bInterfaceProtocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UAC_VERSION_1</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">init_pitch_v1</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">iface</span><span class="p">,</span> <span class="n">alts</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">UAC_VERSION_2</span>:
		<span class="k">return</span> <span class="n">init_pitch_v2</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">iface</span><span class="p">,</span> <span class="n">alts</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">start_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">SUBSTREAM_FLAG_DATA_EP_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">snd_usb_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">;</span>

		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Starting data EP @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>

		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">data_subs</span> <span class="o">=</span> <span class="n">subs</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_usb_endpoint_start</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">SUBSTREAM_FLAG_DATA_EP_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">SUBSTREAM_FLAG_SYNC_EP_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">snd_usb_endpoint</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">;</span>

		<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Starting sync EP @%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>

		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">sync_slave</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_usb_endpoint_start</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">SUBSTREAM_FLAG_SYNC_EP_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">stop_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">force</span><span class="p">,</span> <span class="kt">int</span> <span class="n">can_sleep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">SUBSTREAM_FLAG_SYNC_EP_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">snd_usb_endpoint_stop</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">,</span>
				      <span class="n">force</span><span class="p">,</span> <span class="n">can_sleep</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">SUBSTREAM_FLAG_DATA_EP_STARTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">snd_usb_endpoint_stop</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">,</span>
				      <span class="n">force</span><span class="p">,</span> <span class="n">can_sleep</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">activate_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">snd_usb_endpoint_activate</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">snd_usb_endpoint_activate</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">deactivate_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">reta</span><span class="p">,</span> <span class="n">retb</span><span class="p">;</span>

	<span class="n">reta</span> <span class="o">=</span> <span class="n">snd_usb_endpoint_deactivate</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">);</span>
	<span class="n">retb</span> <span class="o">=</span> <span class="n">snd_usb_endpoint_deactivate</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">reta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retb</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find a matching format and set up the interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface_descriptor</span> <span class="o">*</span><span class="n">altsd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">,</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_playback</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">implicit_fb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iface</span> <span class="o">=</span> <span class="n">usb_ifnum_to_if</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">iface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">iface</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">alts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">altset_idx</span><span class="p">];</span>
	<span class="n">altsd</span> <span class="o">=</span> <span class="n">get_iface_desc</span><span class="p">(</span><span class="n">alts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">altsd</span><span class="o">-&gt;</span><span class="n">bAlternateSetting</span> <span class="o">!=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="o">==</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_audiofmt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span> <span class="o">=</span> <span class="n">snd_usb_add_endpoint</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">,</span>
						   <span class="n">alts</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">,</span>
						   <span class="n">SND_USB_ENDPOINT_TYPE_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* we need a sync pipe in async OUT or adaptive IN mode */</span>
	<span class="cm">/* check the number of EP, since some devices have broken</span>
<span class="cm">	 * descriptors which fool us.  if it has only one EP,</span>
<span class="cm">	 * assume it as adaptive-out or sync-in.</span>
<span class="cm">	 */</span>
	<span class="n">attr</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">ep_attr</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_SYNCTYPE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">usb_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">USB_ID</span><span class="p">(</span><span class="mh">0x0763</span><span class="p">,</span> <span class="mh">0x2080</span><span class="p">)</span>: <span class="cm">/* M-Audio FastTrack Ultra */</span>
	<span class="k">case</span> <span class="n">USB_ID</span><span class="p">(</span><span class="mh">0x0763</span><span class="p">,</span> <span class="mh">0x2081</span><span class="p">)</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">is_playback</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">implicit_fb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ep</span> <span class="o">=</span> <span class="mh">0x81</span><span class="p">;</span>
			<span class="n">iface</span> <span class="o">=</span> <span class="n">usb_ifnum_to_if</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iface</span> <span class="o">||</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">num_altsetting</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="n">alts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="k">goto</span> <span class="n">add_sync_ep</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">is_playback</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_SYNC_ASYNC</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="o">!</span><span class="n">is_playback</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_SYNC_ADAPTIVE</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">altsd</span><span class="o">-&gt;</span><span class="n">bNumEndpoints</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check sync-pipe endpoint */</span>
		<span class="cm">/* ... and check descriptor size before accessing bSynchAddress</span>
<span class="cm">		   because there is a version of the SB Audigy 2 NX firmware lacking</span>
<span class="cm">		   the audio fields in the endpoint descriptors */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_XFERTYPE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x01</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">&gt;=</span> <span class="n">USB_DT_ENDPOINT_AUDIO_SIZE</span> <span class="o">&amp;&amp;</span>
		     <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bSynchAddress</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">implicit_fb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%d:%d:%d : invalid sync pipe. bmAttributes %02x, bLength %d, bSynchAddress %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">iface</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">,</span>
				   <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmAttributes</span><span class="p">,</span>
				   <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">,</span>
				   <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bSynchAddress</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">implicit_fb</span> <span class="o">&amp;&amp;</span>
		    <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bLength</span> <span class="o">&gt;=</span> <span class="n">USB_DT_ENDPOINT_AUDIO_SIZE</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span> <span class="n">is_playback</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bSynchAddress</span> <span class="o">|</span> <span class="n">USB_DIR_IN</span><span class="p">))</span> <span class="o">||</span>
		     <span class="p">(</span><span class="o">!</span><span class="n">is_playback</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bSynchAddress</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">USB_DIR_IN</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%d:%d:%d : invalid sync pipe. is_playback %d, ep %02x, bSynchAddress %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">iface</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">,</span>
				   <span class="n">is_playback</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bSynchAddress</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">implicit_fb</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_endpoint</span><span class="p">(</span><span class="n">alts</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bmAttributes</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_USAGE_MASK</span><span class="p">)</span>
				<span class="o">==</span> <span class="n">USB_ENDPOINT_USAGE_IMPLICIT_FB</span><span class="p">;</span>

<span class="nl">add_sync_ep:</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span> <span class="o">=</span> <span class="n">snd_usb_add_endpoint</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">,</span>
							   <span class="n">alts</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="o">!</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">,</span>
							   <span class="n">implicit_fb</span> <span class="o">?</span>
								<span class="n">SND_USB_ENDPOINT_TYPE_DATA</span> <span class="o">:</span>
								<span class="n">SND_USB_ENDPOINT_TYPE_SYNC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">sync_master</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_usb_init_pitch</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">,</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">,</span> <span class="n">alts</span><span class="p">,</span> <span class="n">fmt</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_audiofmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>

	<span class="n">snd_usb_set_format_quirk</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printk(KERN_DEBUG</span>
<span class="c">	       &quot;setting done: format = %d, rate = %d..%d, channels = %d\n&quot;,</span>
<span class="c">	       fmt-&gt;format, fmt-&gt;rate_min, fmt-&gt;rate_max, fmt-&gt;channels);</span>
<span class="c">	printk(KERN_DEBUG</span>
<span class="c">	       &quot;  datapipe = 0x%0x, syncpipe = 0x%0x\n&quot;,</span>
<span class="c">	       subs-&gt;datapipe, subs-&gt;syncpipe);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hw_params callback</span>
<span class="cm"> *</span>
<span class="cm"> * allocate a buffer and set the given audio format.</span>
<span class="cm"> *</span>
<span class="cm"> * so far we use a physically linear buffer although packetize transfer</span>
<span class="cm"> * doesn&#39;t need a continuous area.</span>
<span class="cm"> * if sg buffer is supported on the later version of alsa, we&#39;ll follow</span>
<span class="cm"> * that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_hw_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">hw_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channels</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">format</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">changed</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">snd_pcm_lib_alloc_vmalloc_buffer</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span>
					       <span class="n">params_buffer_bytes</span><span class="p">(</span><span class="n">hw_params</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">format</span> <span class="o">=</span> <span class="n">params_format</span><span class="p">(</span><span class="n">hw_params</span><span class="p">);</span>
	<span class="n">rate</span> <span class="o">=</span> <span class="n">params_rate</span><span class="p">(</span><span class="n">hw_params</span><span class="p">);</span>
	<span class="n">channels</span> <span class="o">=</span> <span class="n">params_channels</span><span class="p">(</span><span class="n">hw_params</span><span class="p">);</span>
	<span class="n">fmt</span> <span class="o">=</span> <span class="n">find_format</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">channels</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printd</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;cannot set format: format = %#x, rate = %d, channels = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">format</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">channels</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">changed</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_audiofmt</span> <span class="o">!=</span> <span class="n">fmt</span> <span class="o">||</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">!=</span> <span class="n">params_period_bytes</span><span class="p">(</span><span class="n">hw_params</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_rate</span> <span class="o">!=</span> <span class="n">rate</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">set_format</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">fmt</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_rate</span> <span class="o">!=</span> <span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">alts</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>
		<span class="n">iface</span> <span class="o">=</span> <span class="n">usb_ifnum_to_if</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">iface</span><span class="p">);</span>
		<span class="n">alts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">[</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">altset_idx</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">snd_usb_init_sample_rate</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">,</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">interface</span><span class="p">,</span> <span class="n">alts</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">rate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_rate</span> <span class="o">=</span> <span class="n">rate</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">shutdown_mutex</span><span class="p">);</span>
		<span class="cm">/* format changed */</span>
		<span class="n">stop_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">deactivate_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">activate_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">snd_usb_endpoint_set_params</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">,</span> <span class="n">hw_params</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span>
						  <span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">snd_usb_endpoint_set_params</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">sync_endpoint</span><span class="p">,</span>
							  <span class="n">hw_params</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">unlock:</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">shutdown_mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">iface</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">altset_idx</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">altset_idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hw_free callback</span>
<span class="cm"> *</span>
<span class="cm"> * reset the audio format and release the buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_hw_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_audiofmt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">period_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">shutdown_mutex</span><span class="p">);</span>
	<span class="n">stop_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">shutdown_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snd_pcm_lib_free_vmalloc_buffer</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * prepare callback</span>
<span class="cm"> *</span>
<span class="cm"> * only a few subtle things...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_pcm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">cur_audiofmt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;usbaudio: no format is specified!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snd_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* some unit conversions in runtime */</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">maxframesize</span> <span class="o">=</span>
		<span class="n">bytes_to_frames</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">maxpacksize</span><span class="p">);</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">curframesize</span> <span class="o">=</span>
		<span class="n">bytes_to_frames</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">curpacksize</span><span class="p">);</span>

	<span class="cm">/* reset the pointer */</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">last_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">last_frame_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* for playback, submit the URBs now; otherwise, the first hwptr_done</span>
<span class="cm">	 * updates for all URBs would happen at the same time when starting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">start_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_hardware</span> <span class="n">snd_usb_hardware</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">info</span> <span class="o">=</span>			<span class="n">SNDRV_PCM_INFO_MMAP</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_MMAP_VALID</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_BATCH</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_INTERLEAVED</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_BLOCK_TRANSFER</span> <span class="o">|</span>
				<span class="n">SNDRV_PCM_INFO_PAUSE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">buffer_bytes_max</span> <span class="o">=</span>	<span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span>	<span class="mi">64</span><span class="p">,</span>
	<span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span>	<span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_min</span> <span class="o">=</span>		<span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">periods_max</span> <span class="o">=</span>		<span class="mi">1024</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_check_valid_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">hw_param_interval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="o">*</span><span class="n">ct</span> <span class="o">=</span> <span class="n">hw_param_interval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_mask</span> <span class="o">*</span><span class="n">fmts</span> <span class="o">=</span> <span class="n">hw_param_mask</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_FORMAT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">hw_param_interval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_TIME</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_mask</span> <span class="n">check_fmts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptime</span><span class="p">;</span>

	<span class="cm">/* check the format */</span>
	<span class="n">snd_mask_none</span><span class="p">(</span><span class="o">&amp;</span><span class="n">check_fmts</span><span class="p">);</span>
	<span class="n">check_fmts</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">formats</span><span class="p">;</span>
	<span class="n">check_fmts</span><span class="p">.</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">formats</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">snd_mask_intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">check_fmts</span><span class="p">,</span> <span class="n">fmts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_mask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">check_fmts</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;   &gt; check: no supported format %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* check the channels */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">&lt;</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">||</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span> <span class="o">&gt;</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;   &gt; check: no valid channels %d (%d/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">,</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">,</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* check the rate is within the range */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span> <span class="o">&gt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">||</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span> <span class="o">==</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">openmax</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;   &gt; check: rate_min %d &gt; max %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span> <span class="o">&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">||</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span> <span class="o">==</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">openmin</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;   &gt; check: rate_max %d &lt; min %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* check whether the period time is &gt;= the data packet interval */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_usb_get_speed</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ptime</span> <span class="o">=</span> <span class="mi">125</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">datainterval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptime</span> <span class="o">&gt;</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">||</span> <span class="p">(</span><span class="n">ptime</span> <span class="o">==</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&amp;&amp;</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">openmax</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;   &gt; check: ptime %u &gt; max %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptime</span><span class="p">,</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_rule_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">snd_pcm_hw_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">hw_param_interval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">changed</span><span class="p">;</span>

	<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;hw_rule_rate: (%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
	<span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rmin</span> <span class="o">=</span> <span class="n">rmax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audioformat</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw_check_valid_format</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmin</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span><span class="p">)</span>
				<span class="n">rmin</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmax</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span><span class="p">)</span>
				<span class="n">rmax</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rmin</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span><span class="p">;</span>
			<span class="n">rmax</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;  --&gt; get empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">rmin</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">rmin</span><span class="p">;</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">openmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">rmax</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">rmax</span><span class="p">;</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">openmax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_interval_checkempty</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;  --&gt; (%d, %d) (changed = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="n">changed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">changed</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_rule_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">snd_pcm_hw_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">hw_param_interval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">changed</span><span class="p">;</span>

	<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;hw_rule_channels: (%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
	<span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rmin</span> <span class="o">=</span> <span class="n">rmax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audioformat</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw_check_valid_format</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmin</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">)</span>
				<span class="n">rmin</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmax</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">)</span>
				<span class="n">rmax</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rmin</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
			<span class="n">rmax</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;  --&gt; get empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">rmin</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">rmin</span><span class="p">;</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">openmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">rmax</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">rmax</span><span class="p">;</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">openmax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_interval_checkempty</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;  --&gt; (%d, %d) (changed = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="n">changed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">changed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_rule_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">snd_pcm_hw_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_mask</span> <span class="o">*</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">hw_param_mask</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_FORMAT</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">fbits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">oldbits</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">changed</span><span class="p">;</span>

	<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;hw_rule_format: %x:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">fbits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audioformat</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw_check_valid_format</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">fbits</span> <span class="o">|=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">formats</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">oldbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">oldbits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">fbits</span><span class="p">;</span>
	<span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">fbits</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;  --&gt; get empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">oldbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">oldbits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;  --&gt; %x:%x (changed = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">changed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">changed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hw_rule_period_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_hw_params</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">snd_pcm_hw_rule</span> <span class="o">*</span><span class="n">rule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_interval</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">min_datainterval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">changed</span><span class="p">;</span>

	<span class="n">it</span> <span class="o">=</span> <span class="n">hw_param_interval</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_TIME</span><span class="p">);</span>
	<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;hw_rule_period_time: (%u,%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
	<span class="n">min_datainterval</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw_check_valid_format</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">min_datainterval</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min_datainterval</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">datainterval</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min_datainterval</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;  --&gt; get empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pmin</span> <span class="o">=</span> <span class="mi">125</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">min_datainterval</span><span class="p">);</span>
	<span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">pmin</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">pmin</span><span class="p">;</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">openmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_interval_checkempty</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">it</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hwc_debug</span><span class="p">(</span><span class="s">&quot;  --&gt; (%u,%u) (changed = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="n">changed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">changed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  If the device supports unusual bit rates, does the request meet these?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_pcm_check_knot</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">rate_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">needs_knot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">rate_list</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">rate_list</span><span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rates</span> <span class="o">&amp;</span> <span class="n">SNDRV_PCM_RATE_CONTINUOUS</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">nr_rates</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rates</span> <span class="o">&amp;</span> <span class="n">SNDRV_PCM_RATE_KNOT</span><span class="p">)</span>
			<span class="n">needs_knot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">needs_knot</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">rate_list</span><span class="p">.</span><span class="n">list</span> <span class="o">=</span> <span class="n">rate_list</span> <span class="o">=</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">count</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">rate_list</span><span class="p">.</span><span class="n">list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">rate_list</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">rate_list</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">nr_rates</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rate_list</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_hw_constraint_list</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">rate_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * set up the runtime hardware information.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_hw_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span><span class="p">,</span> <span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ptmin</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">param_period_time_if_needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">formats</span><span class="p">;</span>

	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rate_min</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rate_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rates</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ptmin</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="cm">/* check min/max rates and channels */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">audioformat</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audioformat</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rates</span> <span class="o">|=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rates</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rate_min</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span><span class="p">)</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rate_min</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_min</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rate_max</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span><span class="p">)</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">rate_max</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">rate_max</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_min</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">)</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_min</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_max</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">)</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">channels_max</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">fmt_type</span> <span class="o">==</span> <span class="n">UAC_FORMAT_TYPE_II</span> <span class="o">&amp;&amp;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">frame_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIXME: there might be more than one audio formats... */</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_bytes_min</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">period_bytes_max</span> <span class="o">=</span>
				<span class="n">fp</span><span class="o">-&gt;</span><span class="n">frame_size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pt</span> <span class="o">=</span> <span class="mi">125</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">datainterval</span><span class="p">);</span>
		<span class="n">ptmin</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ptmin</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">snd_usb_autoresume</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">param_period_time_if_needed</span> <span class="o">=</span> <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_TIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snd_usb_get_speed</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_SPEED_FULL</span><span class="p">)</span>
		<span class="cm">/* full speed devices have fixed data packet interval */</span>
		<span class="n">ptmin</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptmin</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="cm">/* if period time doesn&#39;t go below 1 ms, no rules needed */</span>
		<span class="n">param_period_time_if_needed</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">snd_pcm_hw_constraint_minmax</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_TIME</span><span class="p">,</span>
				     <span class="n">ptmin</span><span class="p">,</span> <span class="n">UINT_MAX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_hw_rule_add</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">,</span>
				       <span class="n">hw_rule_rate</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span>
				       <span class="n">SNDRV_PCM_HW_PARAM_FORMAT</span><span class="p">,</span>
				       <span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">,</span>
				       <span class="n">param_period_time_if_needed</span><span class="p">,</span>
				       <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rep_err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_hw_rule_add</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">,</span>
				       <span class="n">hw_rule_channels</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span>
				       <span class="n">SNDRV_PCM_HW_PARAM_FORMAT</span><span class="p">,</span>
				       <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">,</span>
				       <span class="n">param_period_time_if_needed</span><span class="p">,</span>
				       <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rep_err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_hw_rule_add</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SNDRV_PCM_HW_PARAM_FORMAT</span><span class="p">,</span>
				       <span class="n">hw_rule_format</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span>
				       <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">,</span>
				       <span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">,</span>
				       <span class="n">param_period_time_if_needed</span><span class="p">,</span>
				       <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rep_err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param_period_time_if_needed</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">snd_pcm_hw_rule_add</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">SNDRV_PCM_HW_PARAM_PERIOD_TIME</span><span class="p">,</span>
					  <span class="n">hw_rule_period_time</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span>
					  <span class="n">SNDRV_PCM_HW_PARAM_FORMAT</span><span class="p">,</span>
					  <span class="n">SNDRV_PCM_HW_PARAM_CHANNELS</span><span class="p">,</span>
					  <span class="n">SNDRV_PCM_HW_PARAM_RATE</span><span class="p">,</span>
					  <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rep_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">snd_usb_pcm_check_knot</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">subs</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">rep_err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">rep_err:</span>
	<span class="n">snd_usb_autosuspend</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_pcm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_stream</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">[</span><span class="n">direction</span><span class="p">];</span>

	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">interface</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">altset_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">hw</span> <span class="o">=</span> <span class="n">snd_usb_hardware</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">subs</span><span class="p">;</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm_substream</span> <span class="o">=</span> <span class="n">substream</span><span class="p">;</span>
	<span class="cm">/* runtime PM is also done there */</span>
	<span class="k">return</span> <span class="n">setup_hw_info</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">subs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_pcm_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_usb_stream</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="n">snd_pcm_substream_chip</span><span class="p">(</span><span class="n">substream</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">substream</span><span class="p">[</span><span class="n">direction</span><span class="p">];</span>

	<span class="n">stop_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">deactivate_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm_substream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">snd_usb_autosuspend</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Since a URB can handle only a single linear buffer, we must use double</span>
<span class="cm"> * buffering when the data to be transferred overflows the buffer boundary.</span>
<span class="cm"> * To avoid inconsistencies when updating hwptr_done, we use double buffering</span>
<span class="cm"> * for all URBs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">retire_capture_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm_substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">oldptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">period_elapsed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">stride</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">frame_bits</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;frame %d active: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>continue;</p></td><td class="code"><div class="highlight"><pre>		<span class="p">}</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">actual_length</span><span class="p">;</span>
		<span class="n">frames</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">/</span> <span class="n">stride</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">txfr_quirk</span><span class="p">)</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">frames</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">%</span> <span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">sample_bits</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SND_DEBUG_VERBOSE</span>
			<span class="kt">int</span> <span class="n">oldbytes</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">frames</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
			<span class="n">snd_printdd</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Corrected urb data len. %d-&gt;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">oldbytes</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* update the current pointer */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">oldptr</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span> <span class="o">&gt;=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">stride</span><span class="p">)</span>
			<span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span> <span class="o">-=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
		<span class="n">frames</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">+</span> <span class="p">(</span><span class="n">oldptr</span> <span class="o">%</span> <span class="n">stride</span><span class="p">))</span> <span class="o">/</span> <span class="n">stride</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">+=</span> <span class="n">frames</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">&gt;=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">-=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">;</span>
			<span class="n">period_elapsed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* copy a data chunk */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldptr</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes1</span> <span class="o">=</span>
					<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">stride</span> <span class="o">-</span> <span class="n">oldptr</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span> <span class="o">+</span> <span class="n">oldptr</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">bytes1</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span><span class="p">,</span> <span class="n">cp</span> <span class="o">+</span> <span class="n">bytes1</span><span class="p">,</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">bytes1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span> <span class="o">+</span> <span class="n">oldptr</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">period_elapsed</span><span class="p">)</span>
		<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm_substream</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prepare_playback_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm_substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_urb_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">counts</span><span class="p">,</span> <span class="n">frames</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">period_elapsed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">stride</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">frame_bits</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">packets</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">counts</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">packet_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* set up descriptor */</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">frames</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
		<span class="n">frames</span> <span class="o">+=</span> <span class="n">counts</span><span class="p">;</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">+=</span> <span class="n">counts</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">&gt;=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">-=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">period_size</span><span class="p">;</span>
			<span class="n">period_elapsed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">fmt_type</span> <span class="o">==</span> <span class="n">UAC_FORMAT_TYPE_II</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* FIXME: fill-max mode is not</span>
<span class="cm">					 * supported yet */</span>
					<span class="n">frames</span> <span class="o">-=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span><span class="p">;</span>
					<span class="n">counts</span> <span class="o">-=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span><span class="p">;</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span>
						<span class="n">counts</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
					<span class="n">subs</span><span class="o">-&gt;</span><span class="n">transfer_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">packets</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* add a transfer delimiter */</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span>
						<span class="n">frames</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">iso_frame_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">urb</span><span class="o">-&gt;</span><span class="n">number_of_packets</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">period_elapsed</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">snd_usb_endpoint_implict_feedback_sink</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="p">))</span> <span class="cm">/* finish at the period boundary */</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">frames</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* err, the transferred area goes over buffer boundary. */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes1</span> <span class="o">=</span>
			<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">stride</span> <span class="o">-</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
		       <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span> <span class="o">+</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span><span class="p">,</span> <span class="n">bytes1</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">+</span> <span class="n">bytes1</span><span class="p">,</span>
		       <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span><span class="p">,</span> <span class="n">bytes</span> <span class="o">-</span> <span class="n">bytes1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
		       <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">dma_area</span> <span class="o">+</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span> <span class="o">&gt;=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">stride</span><span class="p">)</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">hwptr_done</span> <span class="o">-=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="n">stride</span><span class="p">;</span>
	<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">+=</span> <span class="n">frames</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period_elapsed</span><span class="p">)</span>
		<span class="n">snd_pcm_period_elapsed</span><span class="p">(</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm_substream</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * process after playback data complete</span>
<span class="cm"> * - decrease the delay count again</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">retire_playback_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_pcm_runtime</span> <span class="o">*</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">subs</span><span class="o">-&gt;</span><span class="n">pcm_substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">frame_bits</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">/</span> <span class="n">stride</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">processed</span> <span class="o">&gt;</span> <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">)</span>
		<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">runtime</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">-=</span> <span class="n">processed</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_playback_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_usb_pcm_open</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_playback_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_usb_pcm_close</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_capture_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_usb_pcm_open</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_capture_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snd_usb_pcm_close</span><span class="p">(</span><span class="n">substream</span><span class="p">,</span> <span class="n">SNDRV_PCM_STREAM_CAPTURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_substream_playback_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_RELEASE</span>:
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">prepare_data_urb</span> <span class="o">=</span> <span class="n">prepare_playback_urb</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">retire_data_urb</span> <span class="o">=</span> <span class="n">retire_playback_urb</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
		<span class="n">stop_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_PUSH</span>:
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">prepare_data_urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">retire_data_urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">snd_usb_substream_capture_trigger</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm_substream</span> <span class="o">*</span><span class="n">substream</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">snd_usb_substream</span> <span class="o">*</span><span class="n">subs</span> <span class="o">=</span> <span class="n">substream</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_START</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">start_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">retire_data_urb</span> <span class="o">=</span> <span class="n">retire_capture_urb</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_STOP</span>:
		<span class="n">stop_endpoints</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_PUSH</span>:
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">retire_data_urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SNDRV_PCM_TRIGGER_PAUSE_RELEASE</span>:
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">data_endpoint</span><span class="o">-&gt;</span><span class="n">retire_data_urb</span> <span class="o">=</span> <span class="n">retire_capture_urb</span><span class="p">;</span>
		<span class="n">subs</span><span class="o">-&gt;</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">snd_usb_playback_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_usb_playback_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_usb_playback_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">snd_usb_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_free</span> <span class="o">=</span>	<span class="n">snd_usb_hw_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">snd_usb_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_usb_substream_playback_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">snd_usb_pcm_pointer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_get_vmalloc_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_mmap_vmalloc</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">snd_pcm_ops</span> <span class="n">snd_usb_capture_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">snd_usb_capture_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span>	<span class="n">snd_usb_capture_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">snd_pcm_lib_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_params</span> <span class="o">=</span>	<span class="n">snd_usb_hw_params</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hw_free</span> <span class="o">=</span>	<span class="n">snd_usb_hw_free</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span>	<span class="n">snd_usb_pcm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span>	<span class="n">snd_usb_substream_capture_trigger</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pointer</span> <span class="o">=</span>	<span class="n">snd_usb_pcm_pointer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_get_vmalloc_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">snd_pcm_lib_mmap_vmalloc</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">snd_usb_set_pcm_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">snd_pcm</span> <span class="o">*</span><span class="n">pcm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stream</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">snd_pcm_set_ops</span><span class="p">(</span><span class="n">pcm</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span>
			<span class="n">stream</span> <span class="o">==</span> <span class="n">SNDRV_PCM_STREAM_PLAYBACK</span> <span class="o">?</span>
			<span class="o">&amp;</span><span class="n">snd_usb_playback_ops</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">snd_usb_capture_ops</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
