<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › zlib_inflate › inflate.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inflate.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* inflate.c -- zlib decompression</span>
<span class="cm"> * Copyright (C) 1995-2005 Mark Adler</span>
<span class="cm"> * For conditions of distribution and use, see copyright notice in zlib.h</span>
<span class="cm"> *</span>
<span class="cm"> * Based on zlib 1.2.3 but modified for the Linux Kernel by</span>
<span class="cm"> * Richard Purdie &lt;richard@openedhand.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Changes mainly for static instead of dynamic memory allocation</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/zutil.h&gt;</span>
<span class="cp">#include &quot;inftrees.h&quot;</span>
<span class="cp">#include &quot;inflate.h&quot;</span>
<span class="cp">#include &quot;inffast.h&quot;</span>
<span class="cp">#include &quot;infutil.h&quot;</span>

<span class="kt">int</span> <span class="nf">zlib_inflate_workspacesize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inflate_workspace</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zlib_inflateReset</span><span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="p">)</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_in</span> <span class="o">=</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_out</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="cm">/* to support ill-conceived Java test suite */</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">HEAD</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">havedict</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">dmax</span> <span class="o">=</span> <span class="mi">32768U</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">hold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">lencode</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">distcode</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">;</span>

    <span class="cm">/* Initialise Window */</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span> <span class="o">=</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wbits</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">whave</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int zlib_inflatePrime(z_streamp strm, int bits, int value)</span>
<span class="c">{</span>
<span class="c">    struct inflate_state *state;</span>

<span class="c">    if (strm == NULL || strm-&gt;state == NULL) return Z_STREAM_ERROR;</span>
<span class="c">    state = (struct inflate_state *)strm-&gt;state;</span>
<span class="c">    if (bits &gt; 16 || state-&gt;bits + bits &gt; 32) return Z_STREAM_ERROR;</span>
<span class="c">    value &amp;= (1L &lt;&lt; bits) - 1;</span>
<span class="c">    state-&gt;hold += value &lt;&lt; state-&gt;bits;</span>
<span class="c">    state-&gt;bits += bits;</span>
<span class="c">    return Z_OK;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">zlib_inflateInit2</span><span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">windowBits</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                 <span class="cm">/* in case we return an error */</span>

    <span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">WS</span><span class="p">(</span><span class="n">strm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">inflate_state</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">internal_state</span> <span class="o">*</span><span class="p">)</span><span class="n">state</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">windowBits</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">wrap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">windowBits</span> <span class="o">=</span> <span class="o">-</span><span class="n">windowBits</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">wrap</span> <span class="o">=</span> <span class="p">(</span><span class="n">windowBits</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">windowBits</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">windowBits</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">wbits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">windowBits</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">WS</span><span class="p">(</span><span class="n">strm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">working_window</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">zlib_inflateReset</span><span class="p">(</span><span class="n">strm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">   Return state with length and distance decoding tables and index sizes set to</span>
<span class="cm">   fixed code decoding.  This returns fixed tables from inffixed.h.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zlib_fixedtables</span><span class="p">(</span><span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#   include &quot;inffixed.h&quot;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">lencode</span> <span class="o">=</span> <span class="n">lenfix</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">lenbits</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">distcode</span> <span class="o">=</span> <span class="n">distfix</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">distbits</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">   Update the window with the last wsize (normally 32K) bytes written before</span>
<span class="cm">   returning. This is only called when a window is already in use, or when</span>
<span class="cm">   output has been written during this inflate call, but the end of the deflate</span>
<span class="cm">   stream has not been reached yet. It is also called to window dictionary data</span>
<span class="cm">   when a dictionary is loaded.</span>

<span class="cm">   Providing output buffers larger than 32K to inflate() should provide a speed</span>
<span class="cm">   advantage, since only the last 32K of output is copied to the sliding window</span>
<span class="cm">   upon return from inflate(), and since all distances after the first 32K of</span>
<span class="cm">   output will fall in the output data, making match copies simpler and faster.</span>
<span class="cm">   The advantage may be dependent on the size of the processor&#39;s data caches.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">zlib_updatewindow</span><span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">copy</span><span class="p">,</span> <span class="n">dist</span><span class="p">;</span>

    <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="p">)</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

    <span class="cm">/* copy state-&gt;wsize or less output bytes into the circular window */</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">out</span> <span class="o">-</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">,</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">-</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">);</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">whave</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span> <span class="o">-</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">copy</span><span class="p">)</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">copy</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">-</span> <span class="n">copy</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
        <span class="n">copy</span> <span class="o">-=</span> <span class="n">dist</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copy</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">,</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">-</span> <span class="n">copy</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="n">copy</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">whave</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">+=</span> <span class="n">dist</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">)</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">whave</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">)</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">whave</span> <span class="o">+=</span> <span class="n">dist</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * At the end of a Deflate-compressed PPP packet, we expect to have seen</span>
<span class="cm"> * a `stored&#39; block type value but not the (zero) length bytes.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm">   Returns true if inflate is currently at the end of a block generated by</span>
<span class="cm">   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP</span>
<span class="cm">   implementation to provide an additional safety check. PPP uses</span>
<span class="cm">   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored</span>
<span class="cm">   block. When decompressing, PPP checks that at the end of input packet,</span>
<span class="cm">   inflate is waiting for these length bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">zlib_inflateSyncPacket</span><span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="p">)</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">STORED</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TYPE</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Z_DATA_ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Macros for inflate(): */</span>

<span class="cm">/* check function to use adler32() for zlib or crc32() for gzip */</span>
<span class="cp">#define UPDATE(check, buf, len) zlib_adler32(check, buf, len)</span>

<span class="cm">/* Load registers with state in inflate() for speed */</span>
<span class="cp">#define LOAD() \</span>
<span class="cp">    do { \</span>
<span class="cp">        put = strm-&gt;next_out; \</span>
<span class="cp">        left = strm-&gt;avail_out; \</span>
<span class="cp">        next = strm-&gt;next_in; \</span>
<span class="cp">        have = strm-&gt;avail_in; \</span>
<span class="cp">        hold = state-&gt;hold; \</span>
<span class="cp">        bits = state-&gt;bits; \</span>
<span class="cp">    } while (0)</span>

<span class="cm">/* Restore state from registers in inflate() */</span>
<span class="cp">#define RESTORE() \</span>
<span class="cp">    do { \</span>
<span class="cp">        strm-&gt;next_out = put; \</span>
<span class="cp">        strm-&gt;avail_out = left; \</span>
<span class="cp">        strm-&gt;next_in = next; \</span>
<span class="cp">        strm-&gt;avail_in = have; \</span>
<span class="cp">        state-&gt;hold = hold; \</span>
<span class="cp">        state-&gt;bits = bits; \</span>
<span class="cp">    } while (0)</span>

<span class="cm">/* Clear the input bit accumulator */</span>
<span class="cp">#define INITBITS() \</span>
<span class="cp">    do { \</span>
<span class="cp">        hold = 0; \</span>
<span class="cp">        bits = 0; \</span>
<span class="cp">    } while (0)</span>

<span class="cm">/* Get a byte of input into the bit accumulator, or return from inflate()</span>
<span class="cm">   if there is no input available. */</span>
<span class="cp">#define PULLBYTE() \</span>
<span class="cp">    do { \</span>
<span class="cp">        if (have == 0) goto inf_leave; \</span>
<span class="cp">        have--; \</span>
<span class="cp">        hold += (unsigned long)(*next++) &lt;&lt; bits; \</span>
<span class="cp">        bits += 8; \</span>
<span class="cp">    } while (0)</span>

<span class="cm">/* Assure that there are at least n bits in the bit accumulator.  If there is</span>
<span class="cm">   not enough available input to do that, then return from inflate(). */</span>
<span class="cp">#define NEEDBITS(n) \</span>
<span class="cp">    do { \</span>
<span class="cp">        while (bits &lt; (unsigned)(n)) \</span>
<span class="cp">            PULLBYTE(); \</span>
<span class="cp">    } while (0)</span>

<span class="cm">/* Return the low n bits of the bit accumulator (n &lt; 16) */</span>
<span class="cp">#define BITS(n) \</span>
<span class="cp">    ((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))</span>

<span class="cm">/* Remove n bits from the bit accumulator */</span>
<span class="cp">#define DROPBITS(n) \</span>
<span class="cp">    do { \</span>
<span class="cp">        hold &gt;&gt;= (n); \</span>
<span class="cp">        bits -= (unsigned)(n); \</span>
<span class="cp">    } while (0)</span>

<span class="cm">/* Remove zero to seven bits as needed to go to a byte boundary */</span>
<span class="cp">#define BYTEBITS() \</span>
<span class="cp">    do { \</span>
<span class="cp">        hold &gt;&gt;= bits &amp; 7; \</span>
<span class="cp">        bits -= bits &amp; 7; \</span>
<span class="cp">    } while (0)</span>

<span class="cm">/* Reverse the bytes in a 32-bit value */</span>
<span class="cp">#define REVERSE(q) \</span>
<span class="cp">    ((((q) &gt;&gt; 24) &amp; 0xff) + (((q) &gt;&gt; 8) &amp; 0xff00) + \</span>
<span class="cp">     (((q) &amp; 0xff00) &lt;&lt; 8) + (((q) &amp; 0xff) &lt;&lt; 24))</span>

<span class="cm">/*</span>
<span class="cm">   inflate() uses a state machine to process as much input data and generate as</span>
<span class="cm">   much output data as possible before returning.  The state machine is</span>
<span class="cm">   structured roughly as follows:</span>

<span class="cm">    for (;;) switch (state) {</span>
<span class="cm">    ...</span>
<span class="cm">    case STATEn:</span>
<span class="cm">        if (not enough input data or output space to make progress)</span>
<span class="cm">            return;</span>
<span class="cm">        ... make progress ...</span>
<span class="cm">        state = STATEm;</span>
<span class="cm">        break;</span>
<span class="cm">    ...</span>
<span class="cm">    }</span>

<span class="cm">   so when inflate() is called again, the same case is attempted again, and</span>
<span class="cm">   if the appropriate resources are provided, the machine proceeds to the</span>
<span class="cm">   next state.  The NEEDBITS() macro is usually the way the state evaluates</span>
<span class="cm">   whether it can proceed or should return.  NEEDBITS() does the return if</span>
<span class="cm">   the requested bits are not available.  The typical use of the BITS macros</span>
<span class="cm">   is:</span>

<span class="cm">        NEEDBITS(n);</span>
<span class="cm">        ... do something with BITS(n) ...</span>
<span class="cm">        DROPBITS(n);</span>

<span class="cm">   where NEEDBITS(n) either returns from inflate() if there isn&#39;t enough</span>
<span class="cm">   input left to load n bits into the accumulator, or it continues.  BITS(n)</span>
<span class="cm">   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops</span>
<span class="cm">   the low n bits off the accumulator.  INITBITS() clears the accumulator</span>
<span class="cm">   and sets the number of available bits to zero.  BYTEBITS() discards just</span>
<span class="cm">   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()</span>
<span class="cm">   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.</span>

<span class="cm">   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return</span>
<span class="cm">   if there is no input available.  The decoding of variable length codes uses</span>
<span class="cm">   PULLBYTE() directly in order to pull just enough bytes to decode the next</span>
<span class="cm">   code, and no more.</span>

<span class="cm">   Some states loop until they get enough input, making sure that enough</span>
<span class="cm">   state information is maintained to continue the loop where it left off</span>
<span class="cm">   if NEEDBITS() returns in the loop.  For example, want, need, and keep</span>
<span class="cm">   would all have to actually be part of the saved state in case NEEDBITS()</span>
<span class="cm">   returns:</span>

<span class="cm">    case STATEw:</span>
<span class="cm">        while (want &lt; need) {</span>
<span class="cm">            NEEDBITS(n);</span>
<span class="cm">            keep[want++] = BITS(n);</span>
<span class="cm">            DROPBITS(n);</span>
<span class="cm">        }</span>
<span class="cm">        state = STATEx;</span>
<span class="cm">    case STATEx:</span>

<span class="cm">   As shown above, if the next state is also the next case, then the break</span>
<span class="cm">   is omitted.</span>

<span class="cm">   A state may also return if there is not enough output space available to</span>
<span class="cm">   complete that state.  Those states are copying stored data, writing a</span>
<span class="cm">   literal byte, and copying a matching string.</span>

<span class="cm">   When returning, a &quot;goto inf_leave&quot; is used to update the total counters,</span>
<span class="cm">   update the check value, and determine whether any progress has been made</span>
<span class="cm">   during that inflate() call in order to return the proper return code.</span>
<span class="cm">   Progress is defined as a change in either strm-&gt;avail_in or strm-&gt;avail_out.</span>
<span class="cm">   When there is a window, goto inf_leave will update the window with the last</span>
<span class="cm">   output written.  If a goto inf_leave occurs in the middle of decompression</span>
<span class="cm">   and there is no window currently, goto inf_leave will create one and copy</span>
<span class="cm">   output to the window for the next call of inflate().</span>

<span class="cm">   In this implementation, the flush parameter of inflate() only affects the</span>
<span class="cm">   return code (per zlib.h).  inflate() always writes as much as possible to</span>
<span class="cm">   strm-&gt;next_out, given the space available and the provided input--the effect</span>
<span class="cm">   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers</span>
<span class="cm">   the allocation of and copying into a sliding window until necessary, which</span>
<span class="cm">   provides the effect documented in zlib.h for Z_FINISH when the entire input</span>
<span class="cm">   stream available.  So the only thing the flush parameter actually does is:</span>
<span class="cm">   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it</span>
<span class="cm">   will return Z_BUF_ERROR if it has not reached the end of the stream.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">zlib_inflate</span><span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>  <span class="cm">/* next input */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">put</span><span class="p">;</span>         <span class="cm">/* next output */</span>
    <span class="kt">unsigned</span> <span class="n">have</span><span class="p">,</span> <span class="n">left</span><span class="p">;</span>        <span class="cm">/* available input and output */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hold</span><span class="p">;</span>         <span class="cm">/* bit buffer */</span>
    <span class="kt">unsigned</span> <span class="n">bits</span><span class="p">;</span>              <span class="cm">/* bits in bit buffer */</span>
    <span class="kt">unsigned</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">;</span>           <span class="cm">/* save starting available input and output */</span>
    <span class="kt">unsigned</span> <span class="n">copy</span><span class="p">;</span>              <span class="cm">/* number of stored or match bytes to copy */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>        <span class="cm">/* where to copy match bytes from */</span>
    <span class="n">code</span> <span class="n">this</span><span class="p">;</span>                  <span class="cm">/* current decoding table entry */</span>
    <span class="n">code</span> <span class="n">last</span><span class="p">;</span>                  <span class="cm">/* parent table entry */</span>
    <span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>               <span class="cm">/* length to copy for repeats, bits to drop */</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>                    <span class="cm">/* return code */</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">order</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="cm">/* permutation of code lengths */</span>
        <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>

    <span class="cm">/* Do not check for strm-&gt;next_out == NULL here as ppc zImage</span>
<span class="cm">       inflates to strm-&gt;next_out = 0 */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_in</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>

    <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="p">)</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TYPE</span><span class="p">)</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TYPEDO</span><span class="p">;</span>      <span class="cm">/* skip check */</span>
    <span class="n">LOAD</span><span class="p">();</span>
    <span class="n">in</span> <span class="o">=</span> <span class="n">have</span><span class="p">;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">Z_OK</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">HEAD</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wrap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TYPEDO</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">NEEDBITS</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">((</span><span class="n">BITS</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">hold</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">))</span> <span class="o">%</span> <span class="mi">31</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;incorrect header check&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">BITS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Z_DEFLATED</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;unknown compression method&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
            <span class="n">len</span> <span class="o">=</span> <span class="n">BITS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">wbits</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid window size&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">dmax</span> <span class="o">=</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="p">;</span>
            <span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">zlib_adler32</span><span class="p">(</span><span class="mi">0L</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">hold</span> <span class="o">&amp;</span> <span class="mh">0x200</span> <span class="o">?</span> <span class="n">DICTID</span> <span class="o">:</span> <span class="n">TYPE</span><span class="p">;</span>
            <span class="n">INITBITS</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DICTID</span>:
            <span class="n">NEEDBITS</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
            <span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">REVERSE</span><span class="p">(</span><span class="n">hold</span><span class="p">);</span>
            <span class="n">INITBITS</span><span class="p">();</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DICT</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DICT</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">havedict</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">RESTORE</span><span class="p">();</span>
                <span class="k">return</span> <span class="n">Z_NEED_DICT</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">zlib_adler32</span><span class="p">(</span><span class="mi">0L</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TYPE</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">TYPE</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">==</span> <span class="n">Z_BLOCK</span><span class="p">)</span> <span class="k">goto</span> <span class="n">inf_leave</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">TYPEDO</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">BYTEBITS</span><span class="p">();</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">CHECK</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">NEEDBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">BITS</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">BITS</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">0</span>:                             <span class="cm">/* stored block */</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">STORED</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">1</span>:                             <span class="cm">/* fixed block */</span>
                <span class="n">zlib_fixedtables</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">LEN</span><span class="p">;</span>              <span class="cm">/* decode codes */</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">2</span>:                             <span class="cm">/* dynamic block */</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TABLE</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">3</span>:
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid block type&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">STORED</span>:
            <span class="n">BYTEBITS</span><span class="p">();</span>                         <span class="cm">/* go to byte boundary */</span>
            <span class="n">NEEDBITS</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">hold</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">!=</span> <span class="p">((</span><span class="n">hold</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0xffff</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid stored block lengths&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">hold</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
            <span class="n">INITBITS</span><span class="p">();</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">COPY</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">COPY</span>:
            <span class="n">copy</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">copy</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">have</span><span class="p">)</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">have</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">inf_leave</span><span class="p">;</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">put</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
                <span class="n">have</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
                <span class="n">next</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
                <span class="n">left</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
                <span class="n">put</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TYPE</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">TABLE</span>:
            <span class="n">NEEDBITS</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">nlen</span> <span class="o">=</span> <span class="n">BITS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">257</span><span class="p">;</span>
            <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">ndist</span> <span class="o">=</span> <span class="n">BITS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">ncode</span> <span class="o">=</span> <span class="n">BITS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
            <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="cp">#ifndef PKZIP_BUG_WORKAROUND</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">nlen</span> <span class="o">&gt;</span> <span class="mi">286</span> <span class="o">||</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">ndist</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;too many length or distance symbols&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
<span class="cp">#endif</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">LENLENS</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">LENLENS</span>:
            <span class="k">while</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">ncode</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">NEEDBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span><span class="o">++</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">BITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
                <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span> <span class="o">&lt;</span> <span class="mi">19</span><span class="p">)</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span><span class="o">++</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">lencode</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span> <span class="k">const</span> <span class="o">*</span><span class="p">)(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">lenbits</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">zlib_inflate_table</span><span class="p">(</span><span class="n">CODES</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">),</span>
                                <span class="o">&amp;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lenbits</span><span class="p">),</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid code lengths set&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">CODELENS</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">CODELENS</span>:
            <span class="k">while</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">nlen</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">ndist</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
                    <span class="n">this</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">lencode</span><span class="p">[</span><span class="n">BITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lenbits</span><span class="p">)];</span>
                    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bits</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                    <span class="n">PULLBYTE</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">NEEDBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
                    <span class="n">DROPBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
                    <span class="n">state</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">this</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">NEEDBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="n">DROPBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid bit length repeat&quot;</span><span class="p">;</span>
                            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="n">len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                        <span class="n">copy</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">BITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
                        <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="mi">17</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">NEEDBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
                        <span class="n">DROPBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
                        <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="n">copy</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">BITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
                        <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="p">{</span>
                        <span class="n">NEEDBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>
                        <span class="n">DROPBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
                        <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="n">copy</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">+</span> <span class="n">BITS</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
                        <span class="n">DROPBITS</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span> <span class="o">+</span> <span class="n">copy</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">nlen</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">ndist</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid bit length repeat&quot;</span><span class="p">;</span>
                        <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">copy</span><span class="o">--</span><span class="p">)</span>
                        <span class="n">state</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">have</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* handle error breaks in while */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BAD</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

            <span class="cm">/* build code tables */</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">lencode</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span> <span class="k">const</span> <span class="o">*</span><span class="p">)(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">lenbits</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">zlib_inflate_table</span><span class="p">(</span><span class="n">LENS</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">),</span>
                                <span class="o">&amp;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lenbits</span><span class="p">),</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid literal/lengths set&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">distcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span> <span class="k">const</span> <span class="o">*</span><span class="p">)(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">distbits</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">zlib_inflate_table</span><span class="p">(</span><span class="n">DISTS</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">lens</span> <span class="o">+</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">ndist</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">distbits</span><span class="p">),</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid distances set&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">LEN</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">LEN</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">have</span> <span class="o">&gt;=</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">258</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">RESTORE</span><span class="p">();</span>
                <span class="n">inflate_fast</span><span class="p">(</span><span class="n">strm</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
                <span class="n">LOAD</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
                <span class="n">this</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">lencode</span><span class="p">[</span><span class="n">BITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">lenbits</span><span class="p">)];</span>
                <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bits</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="n">PULLBYTE</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">op</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">op</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
                    <span class="n">this</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">lencode</span><span class="p">[</span><span class="n">last</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span>
                            <span class="p">(</span><span class="n">BITS</span><span class="p">(</span><span class="n">last</span><span class="p">.</span><span class="n">bits</span> <span class="o">+</span> <span class="n">last</span><span class="p">.</span><span class="n">op</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">last</span><span class="p">.</span><span class="n">bits</span><span class="p">)];</span>
                    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">last</span><span class="p">.</span><span class="n">bits</span> <span class="o">+</span> <span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bits</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                    <span class="n">PULLBYTE</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="n">DROPBITS</span><span class="p">(</span><span class="n">last</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">DROPBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">this</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">this</span><span class="p">.</span><span class="n">op</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">LIT</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">op</span> <span class="o">&amp;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">TYPE</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">op</span> <span class="o">&amp;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid literal/length code&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">this</span><span class="p">.</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">LENEXT</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">LENEXT</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">NEEDBITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+=</span> <span class="n">BITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
                <span class="n">DROPBITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DIST</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DIST</span>:
            <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
                <span class="n">this</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">distcode</span><span class="p">[</span><span class="n">BITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">distbits</span><span class="p">)];</span>
                <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bits</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="n">PULLBYTE</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">this</span><span class="p">.</span><span class="n">op</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
                    <span class="n">this</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">distcode</span><span class="p">[</span><span class="n">last</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span>
                            <span class="p">(</span><span class="n">BITS</span><span class="p">(</span><span class="n">last</span><span class="p">.</span><span class="n">bits</span> <span class="o">+</span> <span class="n">last</span><span class="p">.</span><span class="n">op</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">last</span><span class="p">.</span><span class="n">bits</span><span class="p">)];</span>
                    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">last</span><span class="p">.</span><span class="n">bits</span> <span class="o">+</span> <span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">bits</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                    <span class="n">PULLBYTE</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="n">DROPBITS</span><span class="p">(</span><span class="n">last</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">DROPBITS</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">op</span> <span class="o">&amp;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid distance code&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">this</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">this</span><span class="p">.</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DISTEXT</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DISTEXT</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">NEEDBITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">BITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
                <span class="n">DROPBITS</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">);</span>
            <span class="p">}</span>
<span class="cp">#ifdef INFLATE_STRICT</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">dmax</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid distance too far back&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
<span class="cp">#endif</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">whave</span> <span class="o">+</span> <span class="n">out</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;invalid distance too far back&quot;</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MATCH</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">MATCH</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">inf_leave</span><span class="p">;</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="n">out</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">copy</span><span class="p">)</span> <span class="p">{</span>         <span class="cm">/* copy from window */</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">-</span> <span class="n">copy</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">copy</span> <span class="o">-=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">;</span>
                    <span class="n">from</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span> <span class="o">-</span> <span class="n">copy</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                    <span class="n">from</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">-</span> <span class="n">copy</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>                              <span class="cm">/* copy from output */</span>
                <span class="n">from</span> <span class="o">=</span> <span class="n">put</span> <span class="o">-</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
            <span class="n">left</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">put</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">copy</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">LEN</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">LIT</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">inf_leave</span><span class="p">;</span>
            <span class="o">*</span><span class="n">put</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
            <span class="n">left</span><span class="o">--</span><span class="p">;</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">LEN</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">CHECK</span>:
            <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wrap</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">NEEDBITS</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
                <span class="n">out</span> <span class="o">-=</span> <span class="n">left</span><span class="p">;</span>
                <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_out</span> <span class="o">+=</span> <span class="n">out</span><span class="p">;</span>
                <span class="n">state</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">+=</span> <span class="n">out</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span>
                    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span>
                        <span class="n">UPDATE</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">,</span> <span class="n">put</span> <span class="o">-</span> <span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">((</span>
                     <span class="n">REVERSE</span><span class="p">(</span><span class="n">hold</span><span class="p">))</span> <span class="o">!=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;incorrect data check&quot;</span><span class="p">;</span>
                    <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">BAD</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">INITBITS</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">DONE</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DONE</span>:
            <span class="n">ret</span> <span class="o">=</span> <span class="n">Z_STREAM_END</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">inf_leave</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">BAD</span>:
            <span class="n">ret</span> <span class="o">=</span> <span class="n">Z_DATA_ERROR</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">inf_leave</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">MEM</span>:
            <span class="k">return</span> <span class="n">Z_MEM_ERROR</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SYNC</span>:
        <span class="nl">default:</span>
            <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">       Return from inflate(), updating the total counts and the check value.</span>
<span class="cm">       If there was no progress during the inflate() call, return a buffer</span>
<span class="cm">       error.  Call zlib_updatewindow() to create and/or update the window state.</span>
<span class="cm">     */</span>
  <span class="nl">inf_leave:</span>
    <span class="n">RESTORE</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wsize</span> <span class="o">||</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&lt;</span> <span class="n">CHECK</span> <span class="o">&amp;&amp;</span> <span class="n">out</span> <span class="o">!=</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span><span class="p">))</span>
        <span class="n">zlib_updatewindow</span><span class="p">(</span><span class="n">strm</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>

    <span class="n">in</span> <span class="o">-=</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">;</span>
    <span class="n">out</span> <span class="o">-=</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_in</span> <span class="o">+=</span> <span class="n">in</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_out</span> <span class="o">+=</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">+=</span> <span class="n">out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wrap</span> <span class="o">&amp;&amp;</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span>
            <span class="n">UPDATE</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">,</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">-</span> <span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>

    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">+</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">?</span> <span class="mi">64</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
                      <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TYPE</span> <span class="o">?</span> <span class="mi">128</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">==</span> <span class="n">Z_PACKET_FLUSH</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">Z_OK</span> <span class="o">&amp;&amp;</span>
            <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">zlib_inflateSyncPacket</span><span class="p">(</span><span class="n">strm</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(((</span><span class="n">in</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">out</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_FINISH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">Z_OK</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">Z_BUF_ERROR</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">zlib_inflateEnd</span><span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int zlib_inflateSetDictionary(z_streamp strm, const Byte *dictionary,</span>
<span class="c">        uInt dictLength)</span>
<span class="c">{</span>
<span class="c">    struct inflate_state *state;</span>
<span class="c">    unsigned long id;</span>

<span class="c">    /* check state */</span>
<span class="c">    if (strm == NULL || strm-&gt;state == NULL) return Z_STREAM_ERROR;</span>
<span class="c">    state = (struct inflate_state *)strm-&gt;state;</span>
<span class="c">    if (state-&gt;wrap != 0 &amp;&amp; state-&gt;mode != DICT)</span>
<span class="c">        return Z_STREAM_ERROR;</span>

<span class="c">    /* check for correct dictionary id */</span>
<span class="c">    if (state-&gt;mode == DICT) {</span>
<span class="c">        id = zlib_adler32(0L, NULL, 0);</span>
<span class="c">        id = zlib_adler32(id, dictionary, dictLength);</span>
<span class="c">        if (id != state-&gt;check)</span>
<span class="c">            return Z_DATA_ERROR;</span>
<span class="c">    }</span>

<span class="c">    /* copy dictionary to window */</span>
<span class="c">    zlib_updatewindow(strm, strm-&gt;avail_out);</span>

<span class="c">    if (dictLength &gt; state-&gt;wsize) {</span>
<span class="c">        memcpy(state-&gt;window, dictionary + dictLength - state-&gt;wsize,</span>
<span class="c">                state-&gt;wsize);</span>
<span class="c">        state-&gt;whave = state-&gt;wsize;</span>
<span class="c">    }</span>
<span class="c">    else {</span>
<span class="c">        memcpy(state-&gt;window + state-&gt;wsize - dictLength, dictionary,</span>
<span class="c">                dictLength);</span>
<span class="c">        state-&gt;whave = dictLength;</span>
<span class="c">    }</span>
<span class="c">    state-&gt;havedict = 1;</span>
<span class="c">    return Z_OK;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c">   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found</span>
<span class="c">   or when out of input.  When called, *have is the number of pattern bytes</span>
<span class="c">   found in order so far, in 0..3.  On return *have is updated to the new</span>
<span class="c">   state.  If on return *have equals four, then the pattern was found and the</span>
<span class="c">   return value is how many bytes were read including the last byte of the</span>
<span class="c">   pattern.  If *have is less than four, then the pattern has not been found</span>
<span class="c">   yet and the return value is len.  In the latter case, zlib_syncsearch() can be</span>
<span class="c">   called again with more data and the *have state.  *have is initialized to</span>
<span class="c">   zero for the first call.</span>
<span class="c"> */</span>
<span class="c">static unsigned zlib_syncsearch(unsigned *have, unsigned char *buf,</span>
<span class="c">        unsigned len)</span>
<span class="c">{</span>
<span class="c">    unsigned got;</span>
<span class="c">    unsigned next;</span>

<span class="c">    got = *have;</span>
<span class="c">    next = 0;</span>
<span class="c">    while (next &lt; len &amp;&amp; got &lt; 4) {</span>
<span class="c">        if ((int)(buf[next]) == (got &lt; 2 ? 0 : 0xff))</span>
<span class="c">            got++;</span>
<span class="c">        else if (buf[next])</span>
<span class="c">            got = 0;</span>
<span class="c">        else</span>
<span class="c">            got = 4 - got;</span>
<span class="c">        next++;</span>
<span class="c">    }</span>
<span class="c">    *have = got;</span>
<span class="c">    return next;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int zlib_inflateSync(z_streamp strm)</span>
<span class="c">{</span>
<span class="c">    unsigned len;               /* number of bytes to look at or looked at */</span>
<span class="c">    unsigned long in, out;      /* temporary to save total_in and total_out */</span>
<span class="c">    unsigned char buf[4];       /* to restore bit buffer to byte string */</span>
<span class="c">    struct inflate_state *state;</span>

<span class="c">    /* check parameters */</span>
<span class="c">    if (strm == NULL || strm-&gt;state == NULL) return Z_STREAM_ERROR;</span>
<span class="c">    state = (struct inflate_state *)strm-&gt;state;</span>
<span class="c">    if (strm-&gt;avail_in == 0 &amp;&amp; state-&gt;bits &lt; 8) return Z_BUF_ERROR;</span>

<span class="c">    /* if first time, start search in bit buffer */</span>
<span class="c">    if (state-&gt;mode != SYNC) {</span>
<span class="c">        state-&gt;mode = SYNC;</span>
<span class="c">        state-&gt;hold &lt;&lt;= state-&gt;bits &amp; 7;</span>
<span class="c">        state-&gt;bits -= state-&gt;bits &amp; 7;</span>
<span class="c">        len = 0;</span>
<span class="c">        while (state-&gt;bits &gt;= 8) {</span>
<span class="c">            buf[len++] = (unsigned char)(state-&gt;hold);</span>
<span class="c">            state-&gt;hold &gt;&gt;= 8;</span>
<span class="c">            state-&gt;bits -= 8;</span>
<span class="c">        }</span>
<span class="c">        state-&gt;have = 0;</span>
<span class="c">        zlib_syncsearch(&amp;(state-&gt;have), buf, len);</span>
<span class="c">    }</span>

<span class="c">    /* search available input */</span>
<span class="c">    len = zlib_syncsearch(&amp;(state-&gt;have), strm-&gt;next_in, strm-&gt;avail_in);</span>
<span class="c">    strm-&gt;avail_in -= len;</span>
<span class="c">    strm-&gt;next_in += len;</span>
<span class="c">    strm-&gt;total_in += len;</span>

<span class="c">    /* return no joy or set up to restart inflate() on a new block */</span>
<span class="c">    if (state-&gt;have != 4) return Z_DATA_ERROR;</span>
<span class="c">    in = strm-&gt;total_in;  out = strm-&gt;total_out;</span>
<span class="c">    zlib_inflateReset(strm);</span>
<span class="c">    strm-&gt;total_in = in;  strm-&gt;total_out = out;</span>
<span class="c">    state-&gt;mode = TYPE;</span>
<span class="c">    return Z_OK;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This subroutine adds the data at next_in/avail_in to the output history</span>
<span class="cm"> * without performing any output.  The output buffer must be &quot;caught up&quot;;</span>
<span class="cm"> * i.e. no pending output but this should always be the case. The state must</span>
<span class="cm"> * be waiting on the start of a block (i.e. mode == TYPE or HEAD).  On exit,</span>
<span class="cm"> * the output will also be caught up, and the checksum will have been updated</span>
<span class="cm"> * if need be.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">zlib_inflateIncomp</span><span class="p">(</span><span class="n">z_stream</span> <span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inflate_state</span> <span class="o">*</span><span class="p">)</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
    <span class="n">Byte</span> <span class="o">*</span><span class="n">saved_no</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">next_out</span><span class="p">;</span>
    <span class="n">uInt</span> <span class="n">saved_ao</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_out</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">TYPE</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">HEAD</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">Z_DATA_ERROR</span><span class="p">;</span>

    <span class="cm">/* Setup some variables to allow misuse of updateWindow */</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">next_in</span> <span class="o">+</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">;</span>

    <span class="n">zlib_updatewindow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">);</span>

    <span class="cm">/* Restore saved variables */</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">=</span> <span class="n">saved_ao</span><span class="p">;</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">=</span> <span class="n">saved_no</span><span class="p">;</span>

    <span class="n">z</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span>
        <span class="n">UPDATE</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">,</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">next_in</span><span class="p">,</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">);</span>

    <span class="n">z</span><span class="o">-&gt;</span><span class="n">total_out</span> <span class="o">+=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">;</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">total_in</span> <span class="o">+=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">;</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">next_in</span> <span class="o">+=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">total</span> <span class="o">+=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">;</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
