<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › scatterlist.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>scatterlist.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007 Jens Axboe &lt;jens.axboe@oracle.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Scatterlist handling helpers.</span>
<span class="cm"> *</span>
<span class="cm"> * This source code is licensed under the GNU General Public License,</span>
<span class="cm"> * Version 2. See the file COPYING for more details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/kmemleak.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * sg_next - return the next scatterlist entry in a list</span>
<span class="cm"> * @sg:		The current sg entry</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Usually the next entry will be @sg@ + 1, but if this sg element is part</span>
<span class="cm"> *   of a chained scatterlist, it could jump to the start of a new</span>
<span class="cm"> *   scatterlist array.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="nf">sg_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_SG</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sg_magic</span> <span class="o">!=</span> <span class="n">SG_MAGIC</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_is_last</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sg</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sg_is_chain</span><span class="p">(</span><span class="n">sg</span><span class="p">)))</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">sg_chain_ptr</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sg</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_next</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_last - return the last scatterlist entry in a list</span>
<span class="cm"> * @sgl:	First entry in the scatterlist</span>
<span class="cm"> * @nents:	Number of entries in the scatterlist</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Should only be used casually, it (currently) scans the entire list</span>
<span class="cm"> *   to get the last entry.</span>
<span class="cm"> *</span>
<span class="cm"> *   Note that the @sgl@ pointer passed in need not be the first one,</span>
<span class="cm"> *   the important bit is that @nents@ denotes the number of entries that</span>
<span class="cm"> *   exist from @sgl@.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="nf">sg_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef ARCH_HAS_SG_CHAIN</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="n">nents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>

<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_DEBUG_SG</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sgl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sg_magic</span> <span class="o">!=</span> <span class="n">SG_MAGIC</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sg_is_last</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_last</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_init_table - Initialize SG table</span>
<span class="cm"> * @sgl:	   The SG table</span>
<span class="cm"> * @nents:	   Number of entries in table</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *   If this is part of a chained sg table, sg_mark_end() should be</span>
<span class="cm"> *   used only on the last table part.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">sg_init_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sgl</span><span class="p">)</span> <span class="o">*</span> <span class="n">nents</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_SG</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nents</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">sgl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sg_magic</span> <span class="o">=</span> <span class="n">SG_MAGIC</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">sg_mark_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="n">nents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_init_table</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_init_one - Initialize a single entry sg list</span>
<span class="cm"> * @sg:		 SG entry</span>
<span class="cm"> * @buf:	 Virtual address for IO</span>
<span class="cm"> * @buflen:	 IO length</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">sg_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sg_set_buf</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_init_one</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The default behaviour of sg_alloc_table() is to use these kmalloc/kfree</span>
<span class="cm"> * helpers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="nf">sg_kmalloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nents</span> <span class="o">==</span> <span class="n">SG_MAX_SINGLE_ALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Kmemleak doesn&#39;t track page allocations as they are not</span>
<span class="cm">		 * commonly used (in a raw form) for kernel data structures.</span>
<span class="cm">		 * As we chain together a list of pages and then a normal</span>
<span class="cm">		 * kmalloc (tracked by kmemleak), in order to for that last</span>
<span class="cm">		 * allocation not to become decoupled (and thus a</span>
<span class="cm">		 * false-positive) we need to inform kmemleak of all the</span>
<span class="cm">		 * intermediate allocations.</span>
<span class="cm">		 */</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
		<span class="n">kmemleak_alloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nents</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span><span class="p">),</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_kfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nents</span> <span class="o">==</span> <span class="n">SG_MAX_SINGLE_ALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmemleak_free</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">sg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __sg_free_table - Free a previously mapped sg table</span>
<span class="cm"> * @table:	The sg table header to use</span>
<span class="cm"> * @max_ents:	The maximum number of entries per single scatterlist</span>
<span class="cm"> * @free_fn:	Free function</span>
<span class="cm"> *</span>
<span class="cm"> *  Description:</span>
<span class="cm"> *    Free an sg table previously allocated and setup with</span>
<span class="cm"> *    __sg_alloc_table().  The @max_ents value must be identical to</span>
<span class="cm"> *    that previously used with __sg_alloc_table().</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">__sg_free_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_ents</span><span class="p">,</span>
		     <span class="n">sg_free_fn</span> <span class="o">*</span><span class="n">free_fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sgl</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">orig_nents</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">orig_nents</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_size</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we have more than max_ents segments left,</span>
<span class="cm">		 * then assign &#39;next&#39; to the sg table after the current one.</span>
<span class="cm">		 * sg_size is then one less than alloc size, since the last</span>
<span class="cm">		 * element is the chain pointer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">&gt;</span> <span class="n">max_ents</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">sg_chain_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="n">max_ents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
			<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">max_ents</span><span class="p">;</span>
			<span class="n">sg_size</span> <span class="o">=</span> <span class="n">alloc_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sg_size</span> <span class="o">=</span> <span class="n">alloc_size</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">table</span><span class="o">-&gt;</span><span class="n">orig_nents</span> <span class="o">-=</span> <span class="n">sg_size</span><span class="p">;</span>
		<span class="n">free_fn</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
		<span class="n">sgl</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">table</span><span class="o">-&gt;</span><span class="n">sgl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__sg_free_table</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_free_table - Free a previously allocated sg table</span>
<span class="cm"> * @table:	The mapped sg table header</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">sg_free_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__sg_free_table</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">SG_MAX_SINGLE_ALLOC</span><span class="p">,</span> <span class="n">sg_kfree</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_free_table</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __sg_alloc_table - Allocate and initialize an sg table with given allocator</span>
<span class="cm"> * @table:	The sg table header to use</span>
<span class="cm"> * @nents:	Number of entries in sg list</span>
<span class="cm"> * @max_ents:	The maximum number of entries the allocator returns per call</span>
<span class="cm"> * @gfp_mask:	GFP allocation mask</span>
<span class="cm"> * @alloc_fn:	Allocator to use</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   This function returns a @table @nents long. The allocator is</span>
<span class="cm"> *   defined to return scatterlist chunks of maximum size @max_ents.</span>
<span class="cm"> *   Thus if @nents is bigger than @max_ents, the scatterlists will be</span>
<span class="cm"> *   chained in units of @max_ents.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *   If this function returns non-0 (eg failure), the caller must call</span>
<span class="cm"> *   __sg_free_table() to cleanup any leftover allocations.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">__sg_alloc_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_ents</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
		     <span class="n">sg_alloc_fn</span> <span class="o">*</span><span class="n">alloc_fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="o">*</span><span class="n">prv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">left</span><span class="p">;</span>

<span class="cp">#ifndef ARCH_HAS_SG_CHAIN</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nents</span> <span class="o">&gt;</span> <span class="n">max_ents</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">table</span><span class="p">));</span>

	<span class="n">left</span> <span class="o">=</span> <span class="n">nents</span><span class="p">;</span>
	<span class="n">prv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_size</span><span class="p">,</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">&gt;</span> <span class="n">max_ents</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">max_ents</span><span class="p">;</span>
			<span class="n">sg_size</span> <span class="o">=</span> <span class="n">alloc_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sg_size</span> <span class="o">=</span> <span class="n">alloc_size</span><span class="p">;</span>

		<span class="n">left</span> <span class="o">-=</span> <span class="n">sg_size</span><span class="p">;</span>

		<span class="n">sg</span> <span class="o">=</span> <span class="n">alloc_fn</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Adjust entry count to reflect that the last</span>
<span class="cm">			 * entry of the previous table won&#39;t be used for</span>
<span class="cm">			 * linkage.  Without this, sg_kfree() may get</span>
<span class="cm">			 * confused.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prv</span><span class="p">)</span>
				<span class="n">table</span><span class="o">-&gt;</span><span class="n">nents</span> <span class="o">=</span> <span class="o">++</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">orig_nents</span><span class="p">;</span>

 			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sg_init_table</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">nents</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">orig_nents</span> <span class="o">+=</span> <span class="n">sg_size</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this is the first mapping, assign the sg table header.</span>
<span class="cm">		 * If this is not the first mapping, chain previous part.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prv</span><span class="p">)</span>
			<span class="n">sg_chain</span><span class="p">(</span><span class="n">prv</span><span class="p">,</span> <span class="n">max_ents</span><span class="p">,</span> <span class="n">sg</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">sgl</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If no more entries after this one, mark the end</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span>
			<span class="n">sg_mark_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="n">sg_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

		<span class="cm">/*</span>
<span class="cm">		 * only really needed for mempool backed sg allocations (like</span>
<span class="cm">		 * SCSI), a possible improvement here would be to pass the</span>
<span class="cm">		 * table pointer into the allocator and let that clear these</span>
<span class="cm">		 * flags</span>
<span class="cm">		 */</span>
		<span class="n">gfp_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__GFP_WAIT</span><span class="p">;</span>
		<span class="n">gfp_mask</span> <span class="o">|=</span> <span class="n">__GFP_HIGH</span><span class="p">;</span>
		<span class="n">prv</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__sg_alloc_table</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_alloc_table - Allocate and initialize an sg table</span>
<span class="cm"> * @table:	The sg table header to use</span>
<span class="cm"> * @nents:	Number of entries in sg list</span>
<span class="cm"> * @gfp_mask:	GFP allocation mask</span>
<span class="cm"> *</span>
<span class="cm"> *  Description:</span>
<span class="cm"> *    Allocate and initialize an sg table. If @nents@ is larger than</span>
<span class="cm"> *    SG_MAX_SINGLE_ALLOC a chained sg table will be setup.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">sg_alloc_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sg_alloc_table</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">SG_MAX_SINGLE_ALLOC</span><span class="p">,</span>
			       <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">sg_kmalloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">__sg_free_table</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">SG_MAX_SINGLE_ALLOC</span><span class="p">,</span> <span class="n">sg_kfree</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_alloc_table</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_miter_start - start mapping iteration over a sg list</span>
<span class="cm"> * @miter: sg mapping iter to be started</span>
<span class="cm"> * @sgl: sg list to iterate over</span>
<span class="cm"> * @nents: number of sg entries</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Starts mapping iterator @miter.</span>
<span class="cm"> *</span>
<span class="cm"> * Context:</span>
<span class="cm"> *   Don&#39;t care.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sg_miter_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_mapping_iter</span> <span class="o">*</span><span class="n">miter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">miter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_mapping_iter</span><span class="p">));</span>

	<span class="n">miter</span><span class="o">-&gt;</span><span class="n">__sg</span> <span class="o">=</span> <span class="n">sgl</span><span class="p">;</span>
	<span class="n">miter</span><span class="o">-&gt;</span><span class="n">__nents</span> <span class="o">=</span> <span class="n">nents</span><span class="p">;</span>
	<span class="n">miter</span><span class="o">-&gt;</span><span class="n">__offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SG_MITER_TO_SG</span> <span class="o">|</span> <span class="n">SG_MITER_FROM_SG</span><span class="p">)));</span>
	<span class="n">miter</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_miter_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_miter_next - proceed mapping iterator to the next mapping</span>
<span class="cm"> * @miter: sg mapping iter to proceed</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Proceeds @miter@ to the next mapping.  @miter@ should have been</span>
<span class="cm"> *   started using sg_miter_start().  On successful return,</span>
<span class="cm"> *   @miter@-&gt;page, @miter@-&gt;addr and @miter@-&gt;length point to the</span>
<span class="cm"> *   current mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * Context:</span>
<span class="cm"> *   IRQ disabled if SG_MITER_ATOMIC.  IRQ must stay disabled till</span>
<span class="cm"> *   @miter@ is stopped.  May sleep if !SG_MITER_ATOMIC.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   true if @miter contains the next mapping.  false if end of sg</span>
<span class="cm"> *   list is reached.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">sg_miter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_mapping_iter</span> <span class="o">*</span><span class="n">miter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* check for end and drop resources from the last iteration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">__nents</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">sg_miter_stop</span><span class="p">(</span><span class="n">miter</span><span class="p">);</span>

	<span class="cm">/* get to the next sg if necessary.  __offset is adjusted by stop */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">__offset</span> <span class="o">==</span> <span class="n">miter</span><span class="o">-&gt;</span><span class="n">__sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">__nents</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">miter</span><span class="o">-&gt;</span><span class="n">__sg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">__sg</span><span class="p">);</span>
			<span class="n">miter</span><span class="o">-&gt;</span><span class="n">__offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* map the next page */</span>
	<span class="n">off</span> <span class="o">=</span> <span class="n">miter</span><span class="o">-&gt;</span><span class="n">__sg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">miter</span><span class="o">-&gt;</span><span class="n">__offset</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">miter</span><span class="o">-&gt;</span><span class="n">__sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">miter</span><span class="o">-&gt;</span><span class="n">__offset</span><span class="p">;</span>

	<span class="n">miter</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">nth_page</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">__sg</span><span class="p">),</span> <span class="n">off</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">off</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">miter</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">off</span><span class="p">);</span>
	<span class="n">miter</span><span class="o">-&gt;</span><span class="n">consumed</span> <span class="o">=</span> <span class="n">miter</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&amp;</span> <span class="n">SG_MITER_ATOMIC</span><span class="p">)</span>
		<span class="n">miter</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">miter</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_miter_next</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_miter_stop - stop mapping iteration</span>
<span class="cm"> * @miter: sg mapping iter to be stopped</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Stops mapping iterator @miter.  @miter should have been started</span>
<span class="cm"> *   started using sg_miter_start().  A stopped iteration can be</span>
<span class="cm"> *   resumed by calling sg_miter_next() on it.  This is useful when</span>
<span class="cm"> *   resources (kmap) need to be released during iteration.</span>
<span class="cm"> *</span>
<span class="cm"> * Context:</span>
<span class="cm"> *   IRQ disabled if the SG_MITER_ATOMIC is set.  Don&#39;t care otherwise.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sg_miter_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_mapping_iter</span> <span class="o">*</span><span class="n">miter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">consumed</span> <span class="o">&gt;</span> <span class="n">miter</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="cm">/* drop resources from the last iteration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">miter</span><span class="o">-&gt;</span><span class="n">__offset</span> <span class="o">+=</span> <span class="n">miter</span><span class="o">-&gt;</span><span class="n">consumed</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&amp;</span> <span class="n">SG_MITER_TO_SG</span><span class="p">)</span>
			<span class="n">flush_kernel_dcache_page</span><span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">__flags</span> <span class="o">&amp;</span> <span class="n">SG_MITER_ATOMIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">miter</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

		<span class="n">miter</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">miter</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">miter</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">miter</span><span class="o">-&gt;</span><span class="n">consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_miter_stop</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_copy_buffer - Copy data between a linear buffer and an SG list</span>
<span class="cm"> * @sgl:		 The SG list</span>
<span class="cm"> * @nents:		 Number of SG entries</span>
<span class="cm"> * @buf:		 Where to copy from</span>
<span class="cm"> * @buflen:		 The number of bytes to copy</span>
<span class="cm"> * @to_buffer: 		 transfer direction (non zero == from an sg list to a</span>
<span class="cm"> * 			 buffer, 0 == from a buffer to an sg list</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of copied bytes.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">sg_copy_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_mapping_iter</span> <span class="n">miter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_flags</span> <span class="o">=</span> <span class="n">SG_MITER_ATOMIC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_buffer</span><span class="p">)</span>
		<span class="n">sg_flags</span> <span class="o">|=</span> <span class="n">SG_MITER_FROM_SG</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sg_flags</span> <span class="o">|=</span> <span class="n">SG_MITER_TO_SG</span><span class="p">;</span>

	<span class="n">sg_miter_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">miter</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">sg_flags</span><span class="p">);</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sg_miter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">miter</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">miter</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to_buffer</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">miter</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">miter</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sg_miter_stop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">miter</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sg_copy_from_buffer - Copy from a linear buffer to an SG list</span>
<span class="cm"> * @sgl:		 The SG list</span>
<span class="cm"> * @nents:		 Number of SG entries</span>
<span class="cm"> * @buf:		 Where to copy from</span>
<span class="cm"> * @buflen:		 The number of bytes to copy</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of copied bytes.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">size_t</span> <span class="nf">sg_copy_from_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sg_copy_buffer</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_copy_from_buffer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sg_copy_to_buffer - Copy from an SG list to a linear buffer</span>
<span class="cm"> * @sgl:		 The SG list</span>
<span class="cm"> * @nents:		 Number of SG entries</span>
<span class="cm"> * @buf:		 Where to copy to</span>
<span class="cm"> * @buflen:		 The number of bytes to copy</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of copied bytes.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">size_t</span> <span class="nf">sg_copy_to_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sg_copy_buffer</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">nents</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sg_copy_to_buffer</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
