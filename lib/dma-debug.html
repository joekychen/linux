<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › dma-debug.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>dma-debug.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2008 Advanced Micro Devices, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Joerg Roedel &lt;joerg.roedel@amd.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/stacktrace.h&gt;</span>
<span class="cp">#include &lt;linux/dma-debug.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/sections.h&gt;</span>

<span class="cp">#define HASH_SIZE       1024ULL</span>
<span class="cp">#define HASH_FN_SHIFT   13</span>
<span class="cp">#define HASH_FN_MASK    (HASH_SIZE - 1)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">dma_debug_single</span><span class="p">,</span>
	<span class="n">dma_debug_page</span><span class="p">,</span>
	<span class="n">dma_debug_sg</span><span class="p">,</span>
	<span class="n">dma_debug_coherent</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define DMA_DEBUG_STACKTRACE_ENTRIES 5</span>

<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>    <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>              <span class="n">type</span><span class="p">;</span>
	<span class="n">phys_addr_t</span>      <span class="n">paddr</span><span class="p">;</span>
	<span class="n">u64</span>              <span class="n">dev_addr</span><span class="p">;</span>
	<span class="n">u64</span>              <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span>              <span class="n">direction</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">sg_call_ents</span><span class="p">;</span>
	<span class="kt">int</span>		 <span class="n">sg_mapped_ents</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_STACKTRACE</span>
	<span class="k">struct</span>		 <span class="n">stack_trace</span> <span class="n">stacktrace</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	 <span class="n">st_entries</span><span class="p">[</span><span class="n">DMA_DEBUG_STACKTRACE_ENTRIES</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">hash_bucket</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="cm">/* Hash list to save the allocated dma addresses */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hash_bucket</span> <span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">HASH_SIZE</span><span class="p">];</span>
<span class="cm">/* List of pre-allocated dma_debug_entry&#39;s */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">free_entries</span><span class="p">);</span>
<span class="cm">/* Lock for the list above */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">free_entries_lock</span><span class="p">);</span>

<span class="cm">/* Global disable flag - will be set in case of an error */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">global_disable</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* Global error count */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">error_count</span><span class="p">;</span>

<span class="cm">/* Global error show enable*/</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">show_all_errors</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="cm">/* Number of errors to show */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">show_num_errors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">num_free_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">min_free_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">nr_total_entries</span><span class="p">;</span>

<span class="cm">/* number of preallocated entries requested by kernel cmdline */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">req_entries</span><span class="p">;</span>

<span class="cm">/* debugfs dentry&#39;s for the stuff above */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dma_debug_dent</span>        <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">global_disable_dent</span>   <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error_count_dent</span>      <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">show_all_errors_dent</span>  <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">show_num_errors_dent</span>  <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">num_free_entries_dent</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">min_free_entries_dent</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">filter_dent</span>           <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* per-driver filter related state */</span>

<span class="cp">#define NAME_MAX_LEN	64</span>

<span class="k">static</span> <span class="kt">char</span>                  <span class="n">current_driver_name</span><span class="p">[</span><span class="n">NAME_MAX_LEN</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">current_driver</span>                    <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">driver_name_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type2name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;single&quot;</span><span class="p">,</span> <span class="s">&quot;page&quot;</span><span class="p">,</span>
				    <span class="s">&quot;scather-gather&quot;</span><span class="p">,</span> <span class="s">&quot;coherent&quot;</span> <span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dir2name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;DMA_BIDIRECTIONAL&quot;</span><span class="p">,</span> <span class="s">&quot;DMA_TO_DEVICE&quot;</span><span class="p">,</span>
				   <span class="s">&quot;DMA_FROM_DEVICE&quot;</span><span class="p">,</span> <span class="s">&quot;DMA_NONE&quot;</span> <span class="p">};</span>

<span class="cm">/* little merge helper - remove it after the merge window */</span>
<span class="cp">#ifndef BUS_NOTIFY_UNBOUND_DRIVER</span>
<span class="cp">#define BUS_NOTIFY_UNBOUND_DRIVER 0x0005</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The access to some variables in this macro is racy. We can&#39;t use atomic_t</span>
<span class="cm"> * here because all these variables are exported to debugfs. Some of them even</span>
<span class="cm"> * writeable. This is also the reason why a lock won&#39;t help much. But anyway,</span>
<span class="cm"> * the races are no big deal. Here is why:</span>
<span class="cm"> *</span>
<span class="cm"> *   error_count: the addition is racy, but the worst thing that can happen is</span>
<span class="cm"> *                that we don&#39;t count some errors</span>
<span class="cm"> *   show_num_errors: the subtraction is racy. Also no big deal because in</span>
<span class="cm"> *                    worst case this will result in one warning more in the</span>
<span class="cm"> *                    system log than the user configured. This variable is</span>
<span class="cm"> *                    writeable via debugfs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dump_entry_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_STACKTRACE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Mapped at:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">print_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">stacktrace</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">driver_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* driver filter off */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">current_driver_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* driver filter on and initialized */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">==</span> <span class="n">current_driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* driver filter on, but we can&#39;t filter on a NULL device... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_driver</span> <span class="o">||</span> <span class="o">!</span><span class="n">current_driver_name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* driver filter on but not yet initialized */</span>
	<span class="n">drv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* lock to protect against change of current_driver_name */</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_name_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&amp;&amp;</span>
	    <span class="n">strncmp</span><span class="p">(</span><span class="n">current_driver_name</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">NAME_MAX_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_driver</span> <span class="o">=</span> <span class="n">drv</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_name_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define err_printk(dev, entry, format, arg...) do {			\</span>
<span class="cp">		error_count += 1;					\</span>
<span class="cp">		if (driver_filter(dev) &amp;&amp;				\</span>
<span class="cp">		    (show_all_errors || show_num_errors &gt; 0)) {		\</span>
<span class="cp">			WARN(1, &quot;%s %s: &quot; format,			\</span>
<span class="cp">			     dev ? dev_driver_string(dev) : &quot;NULL&quot;,	\</span>
<span class="cp">			     dev ? dev_name(dev) : &quot;NULL&quot;, ## arg);	\</span>
<span class="cp">			dump_entry_trace(entry);			\</span>
<span class="cp">		}							\</span>
<span class="cp">		if (!show_all_errors &amp;&amp; show_num_errors &gt; 0)		\</span>
<span class="cp">			show_num_errors -= 1;				\</span>
<span class="cp">	} while (0);</span>

<span class="cm">/*</span>
<span class="cm"> * Hash related functions</span>
<span class="cm"> *</span>
<span class="cm"> * Every DMA-API request is saved into a struct dma_debug_entry. To</span>
<span class="cm"> * have quick access to these structs they are stored into a hash.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hash_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Hash function is based on the dma address.</span>
<span class="cm">	 * We use bits 20-27 here as the index into the hash</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="o">&gt;&gt;</span> <span class="n">HASH_FN_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HASH_FN_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Request exclusive access to a hash bucket for a given dma_debug_entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="nf">get_hash_bucket</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">hash_fn</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">__flags</span><span class="p">);</span>
	<span class="o">*</span><span class="n">flags</span> <span class="o">=</span> <span class="n">__flags</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Give up exclusive access to the hash bucket</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_hash_bucket</span><span class="p">(</span><span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__flags</span> <span class="o">=</span> <span class="o">*</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">__flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">exact_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">containing_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dev_addr</span> <span class="o">+</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search a given entry in the hash bucket list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="nf">__hash_bucket_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span>
						  <span class="n">match_fn</span> <span class="n">match</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">match_lvl</span><span class="p">,</span> <span class="n">last_lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Some drivers map the same physical address multiple</span>
<span class="cm">		 * times. Without a hardware IOMMU this results in the</span>
<span class="cm">		 * same device addresses being put into the dma-debug</span>
<span class="cm">		 * hash multiple times too. This can result in false</span>
<span class="cm">		 * positives being reported. Therefore we implement a</span>
<span class="cm">		 * best-fit algorithm here which returns the entry from</span>
<span class="cm">		 * the hash which fits best to the reference value</span>
<span class="cm">		 * instead of the first-fit.</span>
<span class="cm">		 */</span>
		<span class="n">matches</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">match_lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span>         <span class="o">==</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span>         <span class="o">?</span> <span class="o">++</span><span class="n">match_lvl</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span>         <span class="o">==</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">type</span>         <span class="o">?</span> <span class="o">++</span><span class="n">match_lvl</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span>    <span class="o">==</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span>    <span class="o">?</span> <span class="o">++</span><span class="n">match_lvl</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">sg_call_ents</span> <span class="o">==</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">sg_call_ents</span> <span class="o">?</span> <span class="o">++</span><span class="n">match_lvl</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match_lvl</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* perfect-fit - return the result */</span>
			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">match_lvl</span> <span class="o">&gt;</span> <span class="n">last_lvl</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We found an entry that fits better then the</span>
<span class="cm">			 * previous one</span>
<span class="cm">			 */</span>
			<span class="n">last_lvl</span> <span class="o">=</span> <span class="n">match_lvl</span><span class="p">;</span>
			<span class="n">ret</span>      <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have multiple matches but no perfect-fit, just return</span>
<span class="cm">	 * NULL.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">matches</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="nf">bucket_find_exact</span><span class="p">(</span><span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__hash_bucket_find</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">exact_match</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="nf">bucket_find_contain</span><span class="p">(</span><span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">**</span><span class="n">bucket</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span>
						   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_range</span> <span class="o">=</span> <span class="n">dma_get_max_seg_size</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">range</span> <span class="o">&lt;=</span> <span class="n">max_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">__hash_bucket_find</span><span class="p">(</span><span class="o">*</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">containing_match</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Nothing found, go back a hash bucket</span>
<span class="cm">		 */</span>
		<span class="n">put_hash_bucket</span><span class="p">(</span><span class="o">*</span><span class="n">bucket</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">range</span>          <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">HASH_FN_SHIFT</span><span class="p">);</span>
		<span class="n">index</span><span class="p">.</span><span class="n">dev_addr</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">HASH_FN_SHIFT</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bucket</span> <span class="o">=</span> <span class="n">get_hash_bucket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add an entry to a hash bucket</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hash_bucket_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove entry from a hash bucket list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hash_bucket_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dump mapping entries for debugging purposes</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_dma_dump_mappings</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">HASH_SIZE</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="n">dev</span> <span class="o">==</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					 <span class="s">&quot;%s idx %d P=%Lx D=%Lx L=%Lx %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">type2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">],</span> <span class="n">idx</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">,</span>
					 <span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					 <span class="n">dir2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bucket</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_dump_mappings</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Wrapper function for adding an entry to the hash.</span>
<span class="cm"> * This function takes care of locking itself.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_dma_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="n">get_hash_bucket</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">hash_bucket_add</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="n">put_hash_bucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="nf">__dma_entry_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">free_entries</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">));</span>

	<span class="n">num_free_entries</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_free_entries</span> <span class="o">&lt;</span> <span class="n">min_free_entries</span><span class="p">)</span>
		<span class="n">min_free_entries</span> <span class="o">=</span> <span class="n">num_free_entries</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* struct dma_entry allocator</span>
<span class="cm"> *</span>
<span class="cm"> * The next two functions implement the allocator for</span>
<span class="cm"> * struct dma_debug_entries.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="nf">dma_entry_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DMA-API: debugging out of memory - disabling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">global_disable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">__dma_entry_alloc</span><span class="p">();</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_STACKTRACE</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">stacktrace</span><span class="p">.</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">DMA_DEBUG_STACKTRACE_ENTRIES</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">stacktrace</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">st_entries</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">stacktrace</span><span class="p">.</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">save_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">stacktrace</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_entry_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * add to beginning of the list - this way the entries are</span>
<span class="cm">	 * more likely cache hot when they are reallocated.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_entries</span><span class="p">);</span>
	<span class="n">num_free_entries</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dma_debug_resize_entries</span><span class="p">(</span><span class="n">u32</span> <span class="n">num_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_total_entries</span> <span class="o">&lt;</span> <span class="n">num_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">num_entries</span> <span class="o">-</span> <span class="n">nr_total_entries</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_entries</span><span class="p">);</span>
		<span class="n">nr_total_entries</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">num_free_entries</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">nr_total_entries</span> <span class="o">-</span> <span class="n">num_entries</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">delta</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">__dma_entry_alloc</span><span class="p">();</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">nr_total_entries</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_total_entries</span> <span class="o">!=</span> <span class="n">num_entries</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_entries_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dma_debug_resize_entries</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * DMA-API debugging init code</span>
<span class="cm"> *</span>
<span class="cm"> * The init code does two things:</span>
<span class="cm"> *   1. Initialize core data structures</span>
<span class="cm"> *   2. Preallocate a given number of dma_debug_entry structs</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prealloc_memory</span><span class="p">(</span><span class="n">u32</span> <span class="n">num_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">next_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_entries</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_entries</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">num_free_entries</span> <span class="o">=</span> <span class="n">num_entries</span><span class="p">;</span>
	<span class="n">min_free_entries</span> <span class="o">=</span> <span class="n">num_entries</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DMA-API: preallocated %d debug entries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_entries</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">next_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_entries</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">filter_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buf</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">NAME_MAX_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_driver_name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t copy to userspace directly because current_driver_name can</span>
<span class="cm">	 * only be read under the driver_name_lock with irqs disabled. So</span>
<span class="cm">	 * create a temporary copy first.</span>
<span class="cm">	 */</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_name_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">NAME_MAX_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current_driver_name</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_name_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">user_buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">filter_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">userbuf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">NAME_MAX_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t copy from userspace directly. Access to</span>
<span class="cm">	 * current_driver_name is protected with a write_lock with irqs</span>
<span class="cm">	 * disabled. Since copy_from_user can fault and may sleep we</span>
<span class="cm">	 * need to copy to temporary buffer first</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">NAME_MAX_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">userbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_name_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now handle the string we got from userspace very carefully.</span>
<span class="cm">	 * The rules are:</span>
<span class="cm">	 *         - only use the first token we got</span>
<span class="cm">	 *         - token delimiter is everything looking like a space</span>
<span class="cm">	 *           character (&#39; &#39;, &#39;\n&#39;, &#39;\t&#39; ...)</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isalnum</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the first character userspace gave us is not</span>
<span class="cm">		 * alphanumerical then assume the filter should be</span>
<span class="cm">		 * switched off.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_driver_name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DMA-API: switching off dma-debug driver filter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">current_driver_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">current_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now parse out the first token and use it as the name for the</span>
<span class="cm">	 * driver to filter for.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NAME_MAX_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_driver_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="o">||</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">current_driver_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">current_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DMA-API: enable driver filter for driver [%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current_driver_name</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver_name_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">filter_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>  <span class="o">=</span> <span class="n">filter_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">filter_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_debug_fs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_debug_dent</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;dma-api&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_debug_dent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DMA-API: can not create debugfs directory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">global_disable_dent</span> <span class="o">=</span> <span class="n">debugfs_create_bool</span><span class="p">(</span><span class="s">&quot;disabled&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
			<span class="n">dma_debug_dent</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">global_disable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">global_disable_dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">error_count_dent</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;error_count&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
			<span class="n">dma_debug_dent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error_count_dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">show_all_errors_dent</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;all_errors&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
			<span class="n">dma_debug_dent</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">show_all_errors</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">show_all_errors_dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">show_num_errors_dent</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;num_errors&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
			<span class="n">dma_debug_dent</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">show_num_errors</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">show_num_errors_dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">num_free_entries_dent</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;num_free_entries&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
			<span class="n">dma_debug_dent</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">num_free_entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_free_entries_dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">min_free_entries_dent</span> <span class="o">=</span> <span class="n">debugfs_create_u32</span><span class="p">(</span><span class="s">&quot;min_free_entries&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span>
			<span class="n">dma_debug_dent</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">min_free_entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">min_free_entries_dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">filter_dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;driver_filter&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
					  <span class="n">dma_debug_dent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filter_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filter_dent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">dma_debug_dent</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">device_dma_allocations</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">**</span><span class="n">out_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASH_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="o">*</span><span class="n">out_entry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_debug_device_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_disable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BUS_NOTIFY_UNBOUND_DRIVER</span>:
		<span class="n">count</span> <span class="o">=</span> <span class="n">device_dma_allocations</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver has pending &quot;</span>
				<span class="s">&quot;DMA allocations while released from device &quot;</span>
				<span class="s">&quot;[count=%d]</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;One of leaked entries details: &quot;</span>
				<span class="s">&quot;[device address=0x%016llx] [size=%llu bytes] &quot;</span>
				<span class="s">&quot;[mapped with %s] [mapped as %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">count</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			<span class="n">dir2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">],</span> <span class="n">type2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dma_debug_add_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_disable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">nb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;dma_debug_add_bus: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">dma_debug_device_change</span><span class="p">;</span>

	<span class="n">bus_register_notifier</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Let the architectures decide how many entries should be preallocated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dma_debug_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">num_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_disable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HASH_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_entry_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_debug_fs_init</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DMA-API: error creating debugfs entries - disabling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">global_disable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req_entries</span><span class="p">)</span>
		<span class="n">num_entries</span> <span class="o">=</span> <span class="n">req_entries</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prealloc_memory</span><span class="p">(</span><span class="n">num_entries</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DMA-API: debugging out of memory error - disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">global_disable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nr_total_entries</span> <span class="o">=</span> <span class="n">num_free_entries</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DMA-API: debugging enabled by kernel config</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">dma_debug_cmdline</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DMA-API: debugging disabled on kernel command line</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">global_disable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">dma_debug_entries_cmdline</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req_entries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="n">req_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;dma_debug=&quot;</span><span class="p">,</span> <span class="n">dma_debug_cmdline</span><span class="p">);</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;dma_debug_entries=&quot;</span><span class="p">,</span> <span class="n">dma_debug_entries_cmdline</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver tries &quot;</span>
			   <span class="s">&quot;to free an invalid DMA memory address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="n">get_hash_bucket</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">bucket_find_exact</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver tries &quot;</span>
			   <span class="s">&quot;to free DMA memory it has not allocated &quot;</span>
			   <span class="s">&quot;[device address=0x%016llx] [size=%llu bytes]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver frees &quot;</span>
			   <span class="s">&quot;DMA memory with different size &quot;</span>
			   <span class="s">&quot;[device address=0x%016llx] [map size=%llu bytes] &quot;</span>
			   <span class="s">&quot;[unmap size=%llu bytes]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver frees &quot;</span>
			   <span class="s">&quot;DMA memory with wrong function &quot;</span>
			   <span class="s">&quot;[device address=0x%016llx] [size=%llu bytes] &quot;</span>
			   <span class="s">&quot;[mapped as %s] [unmapped as %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			   <span class="n">type2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">],</span> <span class="n">type2name</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">dma_debug_coherent</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">paddr</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver frees &quot;</span>
			   <span class="s">&quot;DMA memory with different CPU address &quot;</span>
			   <span class="s">&quot;[device address=0x%016llx] [size=%llu bytes] &quot;</span>
			   <span class="s">&quot;[cpu alloc address=0x%016llx] &quot;</span>
			   <span class="s">&quot;[cpu free address=0x%016llx]&quot;</span><span class="p">,</span>
			   <span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">sg_call_ents</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">dma_debug_sg</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ref</span><span class="o">-&gt;</span><span class="n">sg_call_ents</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">sg_call_ents</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver frees &quot;</span>
			   <span class="s">&quot;DMA sg list with different entry count &quot;</span>
			   <span class="s">&quot;[map count=%d] [unmap count=%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">entry</span><span class="o">-&gt;</span><span class="n">sg_call_ents</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">sg_call_ents</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This may be no bug in reality - but most implementations of the</span>
<span class="cm">	 * DMA API don&#39;t handle this properly, so check for it here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver frees &quot;</span>
			   <span class="s">&quot;DMA memory with different direction &quot;</span>
			   <span class="s">&quot;[device address=0x%016llx] [size=%llu bytes] &quot;</span>
			   <span class="s">&quot;[mapped with %s] [unmapped with %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			   <span class="n">dir2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">],</span>
			   <span class="n">dir2name</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">hash_bucket_del</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">dma_entry_free</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">put_hash_bucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_for_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">object_is_on_stack</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver maps memory from&quot;</span>
				<span class="s">&quot;stack [addr=%p]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">overlap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">b1</span> <span class="o">&lt;=</span> <span class="n">a2</span> <span class="o">||</span> <span class="n">a1</span> <span class="o">&gt;=</span> <span class="n">b2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_for_illegal_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">overlap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">_text</span><span class="p">,</span> <span class="n">_etext</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">overlap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">__start_rodata</span><span class="p">,</span> <span class="n">__end_rodata</span><span class="p">))</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span>
		       <span class="n">bool</span> <span class="n">to_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="n">get_hash_bucket</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">bucket_find_contain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bucket</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver tries &quot;</span>
				<span class="s">&quot;to sync DMA memory it has not allocated &quot;</span>
				<span class="s">&quot;[device address=0x%016llx] [size=%llu bytes]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver syncs&quot;</span>
				<span class="s">&quot; DMA memory outside allocated range &quot;</span>
				<span class="s">&quot;[device address=0x%016llx] &quot;</span>
				<span class="s">&quot;[allocation size=%llu bytes] &quot;</span>
				<span class="s">&quot;[sync offset+size=%llu]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				<span class="n">ref</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver syncs &quot;</span>
				<span class="s">&quot;DMA memory with different direction &quot;</span>
				<span class="s">&quot;[device address=0x%016llx] [size=%llu bytes] &quot;</span>
				<span class="s">&quot;[mapped with %s] [synced with %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				<span class="n">dir2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">],</span>
				<span class="n">dir2name</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_cpu</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		      <span class="o">!</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">))</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver syncs &quot;</span>
				<span class="s">&quot;device read-only DMA memory for cpu &quot;</span>
				<span class="s">&quot;[device address=0x%016llx] [size=%llu bytes] &quot;</span>
				<span class="s">&quot;[mapped with %s] [synced with %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				<span class="n">dir2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">],</span>
				<span class="n">dir2name</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to_cpu</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">))</span>
		<span class="n">err_printk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="s">&quot;DMA-API: device driver syncs &quot;</span>
				<span class="s">&quot;device write-only DMA memory to device &quot;</span>
				<span class="s">&quot;[device address=0x%016llx] [size=%llu bytes] &quot;</span>
				<span class="s">&quot;[mapped with %s] [synced with %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				<span class="n">dir2name</span><span class="p">[</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">],</span>
				<span class="n">dir2name</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">direction</span><span class="p">]);</span>

<span class="nl">out:</span>
	<span class="n">put_hash_bucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_dma_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">map_single</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">dma_entry_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span>       <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span>      <span class="o">=</span> <span class="n">dma_debug_page</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span>     <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev_addr</span>  <span class="o">=</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span>      <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_single</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">dma_debug_single</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">check_for_stack</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">check_for_illegal_area</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">add_dma_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_map_page</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_unmap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="n">bool</span> <span class="n">map_single</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">type</span>           <span class="o">=</span> <span class="n">dma_debug_page</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dev</span>            <span class="o">=</span> <span class="n">dev</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dev_addr</span>       <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">size</span>           <span class="o">=</span> <span class="n">size</span><span class="p">,</span>
		<span class="p">.</span><span class="n">direction</span>      <span class="o">=</span> <span class="n">direction</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_single</span><span class="p">)</span>
		<span class="n">ref</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">dma_debug_single</span><span class="p">;</span>

	<span class="n">check_unmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_unmap_page</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">nents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mapped_ents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">mapped_ents</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">dma_entry_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span>           <span class="o">=</span> <span class="n">dma_debug_sg</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span>            <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span>          <span class="o">=</span> <span class="n">sg_phys</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span>           <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev_addr</span>       <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span>      <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">sg_call_ents</span>   <span class="o">=</span> <span class="n">nents</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">sg_mapped_ents</span> <span class="o">=</span> <span class="n">mapped_ents</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">check_for_stack</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
			<span class="n">check_for_illegal_area</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">add_dma_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_map_sg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_nr_mapped_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hash_bucket</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mapped_ents</span><span class="p">;</span>

	<span class="n">bucket</span>       <span class="o">=</span> <span class="n">get_hash_bucket</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">entry</span>        <span class="o">=</span> <span class="n">bucket_find_exact</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
	<span class="n">mapped_ents</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">mapped_ents</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">sg_mapped_ents</span><span class="p">;</span>
	<span class="n">put_hash_bucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mapped_ents</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_dma_unmap_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sglist</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mapped_ents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sglist</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">type</span>           <span class="o">=</span> <span class="n">dma_debug_sg</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dev</span>            <span class="o">=</span> <span class="n">dev</span><span class="p">,</span>
			<span class="p">.</span><span class="n">paddr</span>          <span class="o">=</span> <span class="n">sg_phys</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">dev_addr</span>       <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">size</span>           <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">direction</span>      <span class="o">=</span> <span class="n">dir</span><span class="p">,</span>
			<span class="p">.</span><span class="n">sg_call_ents</span>   <span class="o">=</span> <span class="n">nelems</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mapped_ents</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">mapped_ents</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
			<span class="n">mapped_ents</span> <span class="o">=</span> <span class="n">get_nr_mapped_entries</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>

		<span class="n">check_unmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_unmap_sg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			      <span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">virt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">dma_entry_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span>      <span class="o">=</span> <span class="n">dma_debug_coherent</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev</span>       <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">paddr</span>     <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">virt</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">size</span>      <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">dev_addr</span>  <span class="o">=</span> <span class="n">dma_addr</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">direction</span> <span class="o">=</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">;</span>

	<span class="n">add_dma_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_alloc_coherent</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">type</span>           <span class="o">=</span> <span class="n">dma_debug_coherent</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dev</span>            <span class="o">=</span> <span class="n">dev</span><span class="p">,</span>
		<span class="p">.</span><span class="n">paddr</span>          <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">virt</span><span class="p">),</span>
		<span class="p">.</span><span class="n">dev_addr</span>       <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">size</span>           <span class="o">=</span> <span class="n">size</span><span class="p">,</span>
		<span class="p">.</span><span class="n">direction</span>      <span class="o">=</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">check_unmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_free_coherent</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_sync_single_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ref</span><span class="p">.</span><span class="n">type</span>         <span class="o">=</span> <span class="n">dma_debug_single</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">dev</span>          <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">dev_addr</span>     <span class="o">=</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">size</span>         <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">direction</span>    <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">sg_call_ents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">check_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_sync_single_for_cpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_sync_single_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ref</span><span class="p">.</span><span class="n">type</span>         <span class="o">=</span> <span class="n">dma_debug_single</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">dev</span>          <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">dev_addr</span>     <span class="o">=</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">size</span>         <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">direction</span>    <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">sg_call_ents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">check_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_sync_single_for_device</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_sync_single_range_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ref</span><span class="p">.</span><span class="n">type</span>         <span class="o">=</span> <span class="n">dma_debug_single</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">dev</span>          <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">dev_addr</span>     <span class="o">=</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">size</span>         <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">direction</span>    <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">sg_call_ents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">check_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_sync_single_range_for_cpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_sync_single_range_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
					    <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ref</span><span class="p">.</span><span class="n">type</span>         <span class="o">=</span> <span class="n">dma_debug_single</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">dev</span>          <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">dev_addr</span>     <span class="o">=</span> <span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">size</span>         <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">direction</span>    <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">ref</span><span class="p">.</span><span class="n">sg_call_ents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">check_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_sync_single_range_for_device</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_sync_sg_for_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mapped_ents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">type</span>           <span class="o">=</span> <span class="n">dma_debug_sg</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dev</span>            <span class="o">=</span> <span class="n">dev</span><span class="p">,</span>
			<span class="p">.</span><span class="n">paddr</span>          <span class="o">=</span> <span class="n">sg_phys</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">dev_addr</span>       <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">size</span>           <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">direction</span>      <span class="o">=</span> <span class="n">direction</span><span class="p">,</span>
			<span class="p">.</span><span class="n">sg_call_ents</span>   <span class="o">=</span> <span class="n">nelems</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
			<span class="n">mapped_ents</span> <span class="o">=</span> <span class="n">get_nr_mapped_entries</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">mapped_ents</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">check_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_sync_sg_for_cpu</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">debug_dma_sync_sg_for_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">nelems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mapped_ents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">global_disable</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nelems</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">dma_debug_entry</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">type</span>           <span class="o">=</span> <span class="n">dma_debug_sg</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dev</span>            <span class="o">=</span> <span class="n">dev</span><span class="p">,</span>
			<span class="p">.</span><span class="n">paddr</span>          <span class="o">=</span> <span class="n">sg_phys</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">dev_addr</span>       <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">size</span>           <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
			<span class="p">.</span><span class="n">direction</span>      <span class="o">=</span> <span class="n">direction</span><span class="p">,</span>
			<span class="p">.</span><span class="n">sg_call_ents</span>   <span class="o">=</span> <span class="n">nelems</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
			<span class="n">mapped_ents</span> <span class="o">=</span> <span class="n">get_nr_mapped_entries</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">mapped_ents</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">check_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">debug_dma_sync_sg_for_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dma_debug_driver_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NAME_MAX_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_driver_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current_driver_name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DMA-API: enable driver filter for driver [%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current_driver_name</span><span class="p">);</span>


	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;dma_debug_driver=&quot;</span><span class="p">,</span> <span class="n">dma_debug_driver_setup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
