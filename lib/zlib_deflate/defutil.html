<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › zlib_deflate › defutil.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>defutil.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#define Assert(err, str) </span>
<span class="cp">#define Trace(dummy) </span>
<span class="cp">#define Tracev(dummy) </span>
<span class="cp">#define Tracecv(err, dummy) </span>
<span class="cp">#define Tracevv(dummy) </span>



<span class="cp">#define LENGTH_CODES 29</span>
<span class="cm">/* number of length codes, not counting the special END_BLOCK code */</span>

<span class="cp">#define LITERALS  256</span>
<span class="cm">/* number of literal bytes 0..255 */</span>

<span class="cp">#define L_CODES (LITERALS+1+LENGTH_CODES)</span>
<span class="cm">/* number of Literal or Length codes, including the END_BLOCK code */</span>

<span class="cp">#define D_CODES   30</span>
<span class="cm">/* number of distance codes */</span>

<span class="cp">#define BL_CODES  19</span>
<span class="cm">/* number of codes used to transfer the bit lengths */</span>

<span class="cp">#define HEAP_SIZE (2*L_CODES+1)</span>
<span class="cm">/* maximum heap size */</span>

<span class="cp">#define MAX_BITS 15</span>
<span class="cm">/* All codes must not exceed MAX_BITS bits */</span>

<span class="cp">#define INIT_STATE    42</span>
<span class="cp">#define BUSY_STATE   113</span>
<span class="cp">#define FINISH_STATE 666</span>
<span class="cm">/* Stream status */</span>


<span class="cm">/* Data structure describing a single value and its code string. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ct_data_s</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">ush</span>  <span class="n">freq</span><span class="p">;</span>       <span class="cm">/* frequency count */</span>
        <span class="n">ush</span>  <span class="n">code</span><span class="p">;</span>       <span class="cm">/* bit string */</span>
    <span class="p">}</span> <span class="n">fc</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">ush</span>  <span class="n">dad</span><span class="p">;</span>        <span class="cm">/* father node in Huffman tree */</span>
        <span class="n">ush</span>  <span class="n">len</span><span class="p">;</span>        <span class="cm">/* length of bit string */</span>
    <span class="p">}</span> <span class="n">dl</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ct_data</span><span class="p">;</span>

<span class="cp">#define Freq fc.freq</span>
<span class="cp">#define Code fc.code</span>
<span class="cp">#define Dad  dl.dad</span>
<span class="cp">#define Len  dl.len</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">static_tree_desc_s</span>  <span class="n">static_tree_desc</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tree_desc_s</span> <span class="p">{</span>
    <span class="n">ct_data</span> <span class="o">*</span><span class="n">dyn_tree</span><span class="p">;</span>           <span class="cm">/* the dynamic tree */</span>
    <span class="kt">int</span>     <span class="n">max_code</span><span class="p">;</span>            <span class="cm">/* largest code with non zero frequency */</span>
    <span class="n">static_tree_desc</span> <span class="o">*</span><span class="n">stat_desc</span><span class="p">;</span> <span class="cm">/* the corresponding static tree */</span>
<span class="p">}</span> <span class="n">tree_desc</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">ush</span> <span class="n">Pos</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">IPos</span><span class="p">;</span>

<span class="cm">/* A Pos is an index in the character window. We use short instead of int to</span>
<span class="cm"> * save space in the various tables. IPos is used only for parameter passing.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">deflate_state</span> <span class="p">{</span>
    <span class="n">z_streamp</span> <span class="n">strm</span><span class="p">;</span>      <span class="cm">/* pointer back to this zlib stream */</span>
    <span class="kt">int</span>   <span class="n">status</span><span class="p">;</span>        <span class="cm">/* as the name implies */</span>
    <span class="n">Byte</span> <span class="o">*</span><span class="n">pending_buf</span><span class="p">;</span>   <span class="cm">/* output still pending */</span>
    <span class="n">ulg</span>   <span class="n">pending_buf_size</span><span class="p">;</span> <span class="cm">/* size of pending_buf */</span>
    <span class="n">Byte</span> <span class="o">*</span><span class="n">pending_out</span><span class="p">;</span>   <span class="cm">/* next pending byte to output to the stream */</span>
    <span class="kt">int</span>   <span class="n">pending</span><span class="p">;</span>       <span class="cm">/* nb of bytes in the pending buffer */</span>
    <span class="kt">int</span>   <span class="n">noheader</span><span class="p">;</span>      <span class="cm">/* suppress zlib header and adler32 */</span>
    <span class="n">Byte</span>  <span class="n">data_type</span><span class="p">;</span>     <span class="cm">/* UNKNOWN, BINARY or ASCII */</span>
    <span class="n">Byte</span>  <span class="n">method</span><span class="p">;</span>        <span class="cm">/* STORED (for zip only) or DEFLATED */</span>
    <span class="kt">int</span>   <span class="n">last_flush</span><span class="p">;</span>    <span class="cm">/* value of flush param for previous deflate call */</span>

                <span class="cm">/* used by deflate.c: */</span>

    <span class="n">uInt</span>  <span class="n">w_size</span><span class="p">;</span>        <span class="cm">/* LZ77 window size (32K by default) */</span>
    <span class="n">uInt</span>  <span class="n">w_bits</span><span class="p">;</span>        <span class="cm">/* log2(w_size)  (8..16) */</span>
    <span class="n">uInt</span>  <span class="n">w_mask</span><span class="p">;</span>        <span class="cm">/* w_size - 1 */</span>

    <span class="n">Byte</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
    <span class="cm">/* Sliding window. Input bytes are read into the second half of the window,</span>
<span class="cm">     * and move to the first half later to keep a dictionary of at least wSize</span>
<span class="cm">     * bytes. With this organization, matches are limited to a distance of</span>
<span class="cm">     * wSize-MAX_MATCH bytes, but this ensures that IO is always</span>
<span class="cm">     * performed with a length multiple of the block size. Also, it limits</span>
<span class="cm">     * the window size to 64K, which is quite useful on MSDOS.</span>
<span class="cm">     * To do: use the user input buffer as sliding window.</span>
<span class="cm">     */</span>

    <span class="n">ulg</span> <span class="n">window_size</span><span class="p">;</span>
    <span class="cm">/* Actual size of window: 2*wSize, except when the user input buffer</span>
<span class="cm">     * is directly used as sliding window.</span>
<span class="cm">     */</span>

    <span class="n">Pos</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="cm">/* Link to older string with same hash index. To limit the size of this</span>
<span class="cm">     * array to 64K, this link is maintained only for the last 32K strings.</span>
<span class="cm">     * An index in this array is thus a window index modulo 32K.</span>
<span class="cm">     */</span>

    <span class="n">Pos</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span> <span class="cm">/* Heads of the hash chains or NIL. */</span>

    <span class="n">uInt</span>  <span class="n">ins_h</span><span class="p">;</span>          <span class="cm">/* hash index of string to be inserted */</span>
    <span class="n">uInt</span>  <span class="n">hash_size</span><span class="p">;</span>      <span class="cm">/* number of elements in hash table */</span>
    <span class="n">uInt</span>  <span class="n">hash_bits</span><span class="p">;</span>      <span class="cm">/* log2(hash_size) */</span>
    <span class="n">uInt</span>  <span class="n">hash_mask</span><span class="p">;</span>      <span class="cm">/* hash_size-1 */</span>

    <span class="n">uInt</span>  <span class="n">hash_shift</span><span class="p">;</span>
    <span class="cm">/* Number of bits by which ins_h must be shifted at each input</span>
<span class="cm">     * step. It must be such that after MIN_MATCH steps, the oldest</span>
<span class="cm">     * byte no longer takes part in the hash key, that is:</span>
<span class="cm">     *   hash_shift * MIN_MATCH &gt;= hash_bits</span>
<span class="cm">     */</span>

    <span class="kt">long</span> <span class="n">block_start</span><span class="p">;</span>
    <span class="cm">/* Window position at the beginning of the current output block. Gets</span>
<span class="cm">     * negative when the window is moved backwards.</span>
<span class="cm">     */</span>

    <span class="n">uInt</span> <span class="n">match_length</span><span class="p">;</span>           <span class="cm">/* length of best match */</span>
    <span class="n">IPos</span> <span class="n">prev_match</span><span class="p">;</span>             <span class="cm">/* previous match */</span>
    <span class="kt">int</span> <span class="n">match_available</span><span class="p">;</span>         <span class="cm">/* set if previous match exists */</span>
    <span class="n">uInt</span> <span class="n">strstart</span><span class="p">;</span>               <span class="cm">/* start of string to insert */</span>
    <span class="n">uInt</span> <span class="n">match_start</span><span class="p">;</span>            <span class="cm">/* start of matching string */</span>
    <span class="n">uInt</span> <span class="n">lookahead</span><span class="p">;</span>              <span class="cm">/* number of valid bytes ahead in window */</span>

    <span class="n">uInt</span> <span class="n">prev_length</span><span class="p">;</span>
    <span class="cm">/* Length of the best match at previous step. Matches not greater than this</span>
<span class="cm">     * are discarded. This is used in the lazy match evaluation.</span>
<span class="cm">     */</span>

    <span class="n">uInt</span> <span class="n">max_chain_length</span><span class="p">;</span>
    <span class="cm">/* To speed up deflation, hash chains are never searched beyond this</span>
<span class="cm">     * length.  A higher limit improves compression ratio but degrades the</span>
<span class="cm">     * speed.</span>
<span class="cm">     */</span>

    <span class="n">uInt</span> <span class="n">max_lazy_match</span><span class="p">;</span>
    <span class="cm">/* Attempt to find a better match only when the current match is strictly</span>
<span class="cm">     * smaller than this value. This mechanism is used only for compression</span>
<span class="cm">     * levels &gt;= 4.</span>
<span class="cm">     */</span>
<span class="cp">#   define max_insert_length  max_lazy_match</span>
    <span class="cm">/* Insert new strings in the hash table only if the match length is not</span>
<span class="cm">     * greater than this length. This saves time but degrades compression.</span>
<span class="cm">     * max_insert_length is used only for compression levels &lt;= 3.</span>
<span class="cm">     */</span>

    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>    <span class="cm">/* compression level (1..9) */</span>
    <span class="kt">int</span> <span class="n">strategy</span><span class="p">;</span> <span class="cm">/* favor or force Huffman coding*/</span>

    <span class="n">uInt</span> <span class="n">good_match</span><span class="p">;</span>
    <span class="cm">/* Use a faster search when the previous match is longer than this */</span>

    <span class="kt">int</span> <span class="n">nice_match</span><span class="p">;</span> <span class="cm">/* Stop searching when current match exceeds this */</span>

                <span class="cm">/* used by trees.c: */</span>
    <span class="cm">/* Didn&#39;t use ct_data typedef below to suppress compiler warning */</span>
    <span class="k">struct</span> <span class="n">ct_data_s</span> <span class="n">dyn_ltree</span><span class="p">[</span><span class="n">HEAP_SIZE</span><span class="p">];</span>   <span class="cm">/* literal and length tree */</span>
    <span class="k">struct</span> <span class="n">ct_data_s</span> <span class="n">dyn_dtree</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">D_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* distance tree */</span>
    <span class="k">struct</span> <span class="n">ct_data_s</span> <span class="n">bl_tree</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">BL_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* Huffman tree for bit lengths */</span>

    <span class="k">struct</span> <span class="n">tree_desc_s</span> <span class="n">l_desc</span><span class="p">;</span>               <span class="cm">/* desc. for literal tree */</span>
    <span class="k">struct</span> <span class="n">tree_desc_s</span> <span class="n">d_desc</span><span class="p">;</span>               <span class="cm">/* desc. for distance tree */</span>
    <span class="k">struct</span> <span class="n">tree_desc_s</span> <span class="n">bl_desc</span><span class="p">;</span>              <span class="cm">/* desc. for bit length tree */</span>

    <span class="n">ush</span> <span class="n">bl_count</span><span class="p">[</span><span class="n">MAX_BITS</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="cm">/* number of codes at each bit length for an optimal tree */</span>

    <span class="kt">int</span> <span class="n">heap</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">L_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>      <span class="cm">/* heap used to build the Huffman trees */</span>
    <span class="kt">int</span> <span class="n">heap_len</span><span class="p">;</span>               <span class="cm">/* number of elements in the heap */</span>
    <span class="kt">int</span> <span class="n">heap_max</span><span class="p">;</span>               <span class="cm">/* element of largest frequency */</span>
    <span class="cm">/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.</span>
<span class="cm">     * The same heap array is used to build all trees.</span>
<span class="cm">     */</span>

    <span class="n">uch</span> <span class="n">depth</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">L_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="cm">/* Depth of each subtree used as tie breaker for trees of equal frequency</span>
<span class="cm">     */</span>

    <span class="n">uch</span> <span class="o">*</span><span class="n">l_buf</span><span class="p">;</span>          <span class="cm">/* buffer for literals or lengths */</span>

    <span class="n">uInt</span>  <span class="n">lit_bufsize</span><span class="p">;</span>
    <span class="cm">/* Size of match buffer for literals/lengths.  There are 4 reasons for</span>
<span class="cm">     * limiting lit_bufsize to 64K:</span>
<span class="cm">     *   - frequencies can be kept in 16 bit counters</span>
<span class="cm">     *   - if compression is not successful for the first block, all input</span>
<span class="cm">     *     data is still in the window so we can still emit a stored block even</span>
<span class="cm">     *     when input comes from standard input.  (This can also be done for</span>
<span class="cm">     *     all blocks if lit_bufsize is not greater than 32K.)</span>
<span class="cm">     *   - if compression is not successful for a file smaller than 64K, we can</span>
<span class="cm">     *     even emit a stored file instead of a stored block (saving 5 bytes).</span>
<span class="cm">     *     This is applicable only for zip (not gzip or zlib).</span>
<span class="cm">     *   - creating new Huffman trees less frequently may not provide fast</span>
<span class="cm">     *     adaptation to changes in the input data statistics. (Take for</span>
<span class="cm">     *     example a binary file with poorly compressible code followed by</span>
<span class="cm">     *     a highly compressible string table.) Smaller buffer sizes give</span>
<span class="cm">     *     fast adaptation but have of course the overhead of transmitting</span>
<span class="cm">     *     trees more frequently.</span>
<span class="cm">     *   - I can&#39;t count above 4</span>
<span class="cm">     */</span>

    <span class="n">uInt</span> <span class="n">last_lit</span><span class="p">;</span>      <span class="cm">/* running index in l_buf */</span>

    <span class="n">ush</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">;</span>
    <span class="cm">/* Buffer for distances. To simplify the code, d_buf and l_buf have</span>
<span class="cm">     * the same number of elements. To use different lengths, an extra flag</span>
<span class="cm">     * array would be necessary.</span>
<span class="cm">     */</span>

    <span class="n">ulg</span> <span class="n">opt_len</span><span class="p">;</span>        <span class="cm">/* bit length of current block with optimal trees */</span>
    <span class="n">ulg</span> <span class="n">static_len</span><span class="p">;</span>     <span class="cm">/* bit length of current block with static trees */</span>
    <span class="n">ulg</span> <span class="n">compressed_len</span><span class="p">;</span> <span class="cm">/* total bit length of compressed file */</span>
    <span class="n">uInt</span> <span class="n">matches</span><span class="p">;</span>       <span class="cm">/* number of string matches in current block */</span>
    <span class="kt">int</span> <span class="n">last_eob_len</span><span class="p">;</span>   <span class="cm">/* bit length of EOB code for last block */</span>

<span class="cp">#ifdef DEBUG_ZLIB</span>
    <span class="n">ulg</span> <span class="n">bits_sent</span><span class="p">;</span>      <span class="cm">/* bit length of the compressed data */</span>
<span class="cp">#endif</span>

    <span class="n">ush</span> <span class="n">bi_buf</span><span class="p">;</span>
    <span class="cm">/* Output buffer. bits are inserted starting at the bottom (least</span>
<span class="cm">     * significant bits).</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">bi_valid</span><span class="p">;</span>
    <span class="cm">/* Number of valid bits in bi_buf.  All bits above the last valid bit</span>
<span class="cm">     * are always zero.</span>
<span class="cm">     */</span>

<span class="p">}</span> <span class="n">deflate_state</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">deflate_workspace</span> <span class="p">{</span>
    <span class="cm">/* State memory for the deflator */</span>
    <span class="n">deflate_state</span> <span class="n">deflate_memory</span><span class="p">;</span>
    <span class="n">Byte</span> <span class="o">*</span><span class="n">window_memory</span><span class="p">;</span>
    <span class="n">Pos</span> <span class="o">*</span><span class="n">prev_memory</span><span class="p">;</span>
    <span class="n">Pos</span> <span class="o">*</span><span class="n">head_memory</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">overlay_memory</span><span class="p">;</span>
<span class="p">}</span> <span class="n">deflate_workspace</span><span class="p">;</span>

<span class="cp">#define zlib_deflate_window_memsize(windowBits) \</span>
<span class="cp">	(2 * (1 &lt;&lt; (windowBits)) * sizeof(Byte))</span>
<span class="cp">#define zlib_deflate_prev_memsize(windowBits) \</span>
<span class="cp">	((1 &lt;&lt; (windowBits)) * sizeof(Pos))</span>
<span class="cp">#define zlib_deflate_head_memsize(memLevel) \</span>
<span class="cp">	((1 &lt;&lt; ((memLevel)+7)) * sizeof(Pos))</span>
<span class="cp">#define zlib_deflate_overlay_memsize(memLevel) \</span>
<span class="cp">	((1 &lt;&lt; ((memLevel)+6)) * (sizeof(ush)+2))</span>

<span class="cm">/* Output a byte on the stream.</span>
<span class="cm"> * IN assertion: there is enough room in pending_buf.</span>
<span class="cm"> */</span>
<span class="cp">#define put_byte(s, c) {s-&gt;pending_buf[s-&gt;pending++] = (c);}</span>


<span class="cp">#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)</span>
<span class="cm">/* Minimum amount of lookahead, except at the end of the input file.</span>
<span class="cm"> * See deflate.c for comments about the MIN_MATCH+1.</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_DIST(s)  ((s)-&gt;w_size-MIN_LOOKAHEAD)</span>
<span class="cm">/* In order to simplify the code, particularly on 16 bit machines, match</span>
<span class="cm"> * distances are limited to MAX_DIST instead of WSIZE.</span>
<span class="cm"> */</span>

        <span class="cm">/* in trees.c */</span>
<span class="kt">void</span> <span class="n">zlib_tr_init</span>         <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">int</span>  <span class="n">zlib_tr_tally</span>        <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">lc</span><span class="p">);</span>
<span class="n">ulg</span>  <span class="n">zlib_tr_flush_block</span>  <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">ulg</span> <span class="n">stored_len</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">eof</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">zlib_tr_align</span>        <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">zlib_tr_stored_block</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">ulg</span> <span class="n">stored_len</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">eof</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">zlib_tr_stored_type_only</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Output a short LSB first on the stream.</span>
<span class="cm"> * IN assertion: there is enough room in pendingBuf.</span>
<span class="cm"> */</span>
<span class="cp">#define put_short(s, w) { \</span>
<span class="cp">    put_byte(s, (uch)((w) &amp; 0xff)); \</span>
<span class="cp">    put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); \</span>
<span class="cp">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Reverse the first len bits of a code, using straightforward code (a faster</span>
<span class="cm"> * method would use a table)</span>
<span class="cm"> * IN assertion: 1 &lt;= len &lt;= 15</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">bi_reverse</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">code</span><span class="p">,</span> <span class="cm">/* the value to invert */</span>
				  <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>       <span class="cm">/* its bit length */</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">|=</span> <span class="n">code</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">code</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Flush the bit buffer, keeping at most 7 bits in it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bi_flush</span><span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">put_short</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">put_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">Byte</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Flush the bit buffer and align the output on a byte boundary</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bi_windup</span><span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">put_short</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">put_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">Byte</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_ZLIB</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
