<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › zlib_deflate › deftree.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>deftree.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* +++ trees.c */</span>
<span class="cm">/* trees.c -- output deflated data using Huffman coding</span>
<span class="cm"> * Copyright (C) 1995-1996 Jean-loup Gailly</span>
<span class="cm"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  ALGORITHM</span>
<span class="cm"> *</span>
<span class="cm"> *      The &quot;deflation&quot; process uses several Huffman trees. The more</span>
<span class="cm"> *      common source values are represented by shorter bit sequences.</span>
<span class="cm"> *</span>
<span class="cm"> *      Each code tree is stored in a compressed form which is itself</span>
<span class="cm"> * a Huffman encoding of the lengths of all the code strings (in</span>
<span class="cm"> * ascending order by source values).  The actual code strings are</span>
<span class="cm"> * reconstructed from the lengths in the inflate process, as described</span>
<span class="cm"> * in the deflate specification.</span>
<span class="cm"> *</span>
<span class="cm"> *  REFERENCES</span>
<span class="cm"> *</span>
<span class="cm"> *      Deutsch, L.P.,&quot;&#39;Deflate&#39; Compressed Data Format Specification&quot;.</span>
<span class="cm"> *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc</span>
<span class="cm"> *</span>
<span class="cm"> *      Storer, James A.</span>
<span class="cm"> *          Data Compression:  Methods and Theory, pp. 49-50.</span>
<span class="cm"> *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.</span>
<span class="cm"> *</span>
<span class="cm"> *      Sedgewick, R.</span>
<span class="cm"> *          Algorithms, p290.</span>
<span class="cm"> *          Addison-Wesley, 1983. ISBN 0-201-06672-6.</span>
<span class="cm"> */</span>

<span class="cm">/* From: trees.c,v 1.11 1996/07/24 13:41:06 me Exp $ */</span>

<span class="cm">/* #include &quot;deflate.h&quot; */</span>

<span class="cp">#include &lt;linux/zutil.h&gt;</span>
<span class="cp">#include &quot;defutil.h&quot;</span>

<span class="cp">#ifdef DEBUG_ZLIB</span>
<span class="cp">#  include &lt;ctype.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Constants</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_BL_BITS 7</span>
<span class="cm">/* Bit length codes must not exceed MAX_BL_BITS bits */</span>

<span class="cp">#define END_BLOCK 256</span>
<span class="cm">/* end of block literal code */</span>

<span class="cp">#define REP_3_6      16</span>
<span class="cm">/* repeat previous bit length 3-6 times (2 bits of repeat count) */</span>

<span class="cp">#define REPZ_3_10    17</span>
<span class="cm">/* repeat a zero length 3-10 times  (3 bits of repeat count) */</span>

<span class="cp">#define REPZ_11_138  18</span>
<span class="cm">/* repeat a zero length 11-138 times  (7 bits of repeat count) */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">extra_lbits</span><span class="p">[</span><span class="n">LENGTH_CODES</span><span class="p">]</span> <span class="cm">/* extra bits for each length code */</span>
   <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">extra_dbits</span><span class="p">[</span><span class="n">D_CODES</span><span class="p">]</span> <span class="cm">/* extra bits for each distance code */</span>
   <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">13</span><span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">extra_blbits</span><span class="p">[</span><span class="n">BL_CODES</span><span class="p">]</span><span class="cm">/* extra bits for each bit length code */</span>
   <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">uch</span> <span class="n">bl_order</span><span class="p">[</span><span class="n">BL_CODES</span><span class="p">]</span>
   <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">};</span>
<span class="cm">/* The lengths of the bit length codes are sent in order of decreasing</span>
<span class="cm"> * probability, to avoid transmitting the lengths for unused bit length codes.</span>
<span class="cm"> */</span>

<span class="cp">#define Buf_size (8 * 2*sizeof(char))</span>
<span class="cm">/* Number of bits used within bi_buf. (bi_buf might be implemented on</span>
<span class="cm"> * more than 16 bits on some systems.)</span>
<span class="cm"> */</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Local data. These are initialized only once.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">ct_data</span> <span class="n">static_ltree</span><span class="p">[</span><span class="n">L_CODES</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
<span class="cm">/* The static literal tree. Since the bit lengths are imposed, there is no</span>
<span class="cm"> * need for the L_CODES extra codes used during heap construction. However</span>
<span class="cm"> * The codes 286 and 287 are needed to build a canonical tree (see zlib_tr_init</span>
<span class="cm"> * below).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">ct_data</span> <span class="n">static_dtree</span><span class="p">[</span><span class="n">D_CODES</span><span class="p">];</span>
<span class="cm">/* The static distance tree. (Actually a trivial tree since all codes use</span>
<span class="cm"> * 5 bits.)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">uch</span> <span class="n">dist_code</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="cm">/* distance codes. The first 256 values correspond to the distances</span>
<span class="cm"> * 3 .. 258, the last 256 values correspond to the top 8 bits of</span>
<span class="cm"> * the 15 bit distances.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">uch</span> <span class="n">length_code</span><span class="p">[</span><span class="n">MAX_MATCH</span><span class="o">-</span><span class="n">MIN_MATCH</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="cm">/* length code for each normalized match length (0 == MIN_MATCH) */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">base_length</span><span class="p">[</span><span class="n">LENGTH_CODES</span><span class="p">];</span>
<span class="cm">/* First normalized length for each code (0 = MIN_MATCH) */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">base_dist</span><span class="p">[</span><span class="n">D_CODES</span><span class="p">];</span>
<span class="cm">/* First normalized distance for each code (0 = distance of 1) */</span>

<span class="k">struct</span> <span class="n">static_tree_desc_s</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ct_data</span> <span class="o">*</span><span class="n">static_tree</span><span class="p">;</span>  <span class="cm">/* static tree or NULL */</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">extra_bits</span><span class="p">;</span>       <span class="cm">/* extra bits for each code or NULL */</span>
    <span class="kt">int</span>     <span class="n">extra_base</span><span class="p">;</span>          <span class="cm">/* base index for extra_bits */</span>
    <span class="kt">int</span>     <span class="n">elems</span><span class="p">;</span>               <span class="cm">/* max number of elements in the tree */</span>
    <span class="kt">int</span>     <span class="n">max_length</span><span class="p">;</span>          <span class="cm">/* max bit length for the codes */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">static_tree_desc</span>  <span class="n">static_l_desc</span> <span class="o">=</span>
<span class="p">{</span><span class="n">static_ltree</span><span class="p">,</span> <span class="n">extra_lbits</span><span class="p">,</span> <span class="n">LITERALS</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">L_CODES</span><span class="p">,</span> <span class="n">MAX_BITS</span><span class="p">};</span>

<span class="k">static</span> <span class="n">static_tree_desc</span>  <span class="n">static_d_desc</span> <span class="o">=</span>
<span class="p">{</span><span class="n">static_dtree</span><span class="p">,</span> <span class="n">extra_dbits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>          <span class="n">D_CODES</span><span class="p">,</span> <span class="n">MAX_BITS</span><span class="p">};</span>

<span class="k">static</span> <span class="n">static_tree_desc</span>  <span class="n">static_bl_desc</span> <span class="o">=</span>
<span class="p">{(</span><span class="k">const</span> <span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="n">extra_blbits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="n">BL_CODES</span><span class="p">,</span> <span class="n">MAX_BL_BITS</span><span class="p">};</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Local (static) routines in this file.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">tr_static_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">init_block</span>     <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pqdownheap</span>     <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gen_bitlen</span>     <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">tree_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">gen_codes</span>      <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_code</span><span class="p">,</span> <span class="n">ush</span> <span class="o">*</span><span class="n">bl_count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">build_tree</span>     <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">tree_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scan_tree</span>      <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_code</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">send_tree</span>      <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_code</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">build_bl_tree</span>  <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">send_all_trees</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lcodes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dcodes</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">blcodes</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">compress_block</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">ct_data</span> <span class="o">*</span><span class="n">ltree</span><span class="p">,</span>
                           <span class="n">ct_data</span> <span class="o">*</span><span class="n">dtree</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_data_type</span>  <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">bi_reverse</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">bi_windup</span>      <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">bi_flush</span>       <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">copy_block</span>     <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">header</span><span class="p">);</span>

<span class="cp">#ifndef DEBUG_ZLIB</span>
<span class="cp">#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)</span>
   <span class="cm">/* Send a code of the given tree. c and tree must not have side effects */</span>

<span class="cp">#else </span><span class="cm">/* DEBUG_ZLIB */</span><span class="cp"></span>
<span class="cp">#  define send_code(s, c, tree) \</span>
<span class="cp">     { if (z_verbose&gt;2) fprintf(stderr,&quot;\ncd %3d &quot;,(c)); \</span>
<span class="cp">       send_bits(s, tree[c].Code, tree[c].Len); }</span>
<span class="cp">#endif</span>

<span class="cp">#define d_code(dist) \</span>
<span class="cp">   ((dist) &lt; 256 ? dist_code[dist] : dist_code[256+((dist)&gt;&gt;7)])</span>
<span class="cm">/* Mapping from a distance to a distance code. dist is the distance - 1 and</span>
<span class="cm"> * must not have side effects. dist_code[256] and dist_code[257] are never</span>
<span class="cm"> * used.</span>
<span class="cm"> */</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Send a value on a given number of bits.</span>
<span class="cm"> * IN assertion: length &lt;= 16 and value fits in length bits.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef DEBUG_ZLIB</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">send_bits</span>      <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_bits</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">,</span>  <span class="cm">/* value to send */</span>
	<span class="kt">int</span> <span class="n">length</span>  <span class="cm">/* number of bits */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">Tracevv</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot; l %2d v %4x &quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">value</span><span class="p">));</span>
    <span class="n">Assert</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">,</span> <span class="s">&quot;invalid length&quot;</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">length</span><span class="p">;</span>

    <span class="cm">/* If not enough room in bi_buf, use (valid) bits from bi_buf and</span>
<span class="cm">     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))</span>
<span class="cm">     * unused bits in value.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Buf_size</span> <span class="o">-</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span> <span class="o">|=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span><span class="p">);</span>
        <span class="n">put_short</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">Buf_size</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">+=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">Buf_size</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span> <span class="o">|=</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !DEBUG_ZLIB */</span><span class="cp"></span>

<span class="cp">#define send_bits(s, value, length) \</span>
<span class="cp">{ int len = length;\</span>
<span class="cp">  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {\</span>
<span class="cp">    int val = value;\</span>
<span class="cp">    s-&gt;bi_buf |= (val &lt;&lt; s-&gt;bi_valid);\</span>
<span class="cp">    put_short(s, s-&gt;bi_buf);\</span>
<span class="cp">    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);\</span>
<span class="cp">    s-&gt;bi_valid += len - Buf_size;\</span>
<span class="cp">  } else {\</span>
<span class="cp">    s-&gt;bi_buf |= (value) &lt;&lt; s-&gt;bi_valid;\</span>
<span class="cp">    s-&gt;bi_valid += len;\</span>
<span class="cp">  }\</span>
<span class="cp">}</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG_ZLIB */</span><span class="cp"></span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Initialize the various &#39;constant&#39; tables. In a multi-threaded environment,</span>
<span class="cm"> * this function may be called by two threads concurrently, but this is</span>
<span class="cm"> * harmless since both invocations do exactly the same thing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tr_static_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">static_init_done</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>        <span class="cm">/* iterates over tree elements */</span>
    <span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>     <span class="cm">/* bit counter */</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>   <span class="cm">/* length value */</span>
    <span class="kt">int</span> <span class="n">code</span><span class="p">;</span>     <span class="cm">/* code value */</span>
    <span class="kt">int</span> <span class="n">dist</span><span class="p">;</span>     <span class="cm">/* distance index */</span>
    <span class="n">ush</span> <span class="n">bl_count</span><span class="p">[</span><span class="n">MAX_BITS</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="cm">/* number of codes at each bit length for an optimal tree */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">static_init_done</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* Initialize the mapping length (0..255) -&gt; length code (0..28) */</span>
    <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="n">LENGTH_CODES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">code</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">base_length</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">extra_lbits</span><span class="p">[</span><span class="n">code</span><span class="p">]);</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">length_code</span><span class="p">[</span><span class="n">length</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uch</span><span class="p">)</span><span class="n">code</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Assert</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">256</span><span class="p">,</span> <span class="s">&quot;tr_static_init: length != 256&quot;</span><span class="p">);</span>
    <span class="cm">/* Note that the length 255 (match length 258) can be represented</span>
<span class="cm">     * in two different ways: code 284 + 5 bits or code 285, so we</span>
<span class="cm">     * overwrite length_code[255] to use the best encoding:</span>
<span class="cm">     */</span>
    <span class="n">length_code</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uch</span><span class="p">)</span><span class="n">code</span><span class="p">;</span>

    <span class="cm">/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">code</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">code</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">base_dist</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">extra_dbits</span><span class="p">[</span><span class="n">code</span><span class="p">]);</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist_code</span><span class="p">[</span><span class="n">dist</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uch</span><span class="p">)</span><span class="n">code</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Assert</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">256</span><span class="p">,</span> <span class="s">&quot;tr_static_init: dist != 256&quot;</span><span class="p">);</span>
    <span class="n">dist</span> <span class="o">&gt;&gt;=</span> <span class="mi">7</span><span class="p">;</span> <span class="cm">/* from now on, all distances are divided by 128 */</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="n">D_CODES</span><span class="p">;</span> <span class="n">code</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">base_dist</span><span class="p">[</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">extra_dbits</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">-</span><span class="mi">7</span><span class="p">));</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist_code</span><span class="p">[</span><span class="mi">256</span> <span class="o">+</span> <span class="n">dist</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uch</span><span class="p">)</span><span class="n">code</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Assert</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">256</span><span class="p">,</span> <span class="s">&quot;tr_static_init: 256+dist != 512&quot;</span><span class="p">);</span>

    <span class="cm">/* Construct the codes of the static literal tree */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bits</span> <span class="o">&lt;=</span> <span class="n">MAX_BITS</span><span class="p">;</span> <span class="n">bits</span><span class="o">++</span><span class="p">)</span> <span class="n">bl_count</span><span class="p">[</span><span class="n">bits</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">143</span><span class="p">)</span> <span class="n">static_ltree</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">bl_count</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span> <span class="n">static_ltree</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">bl_count</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">279</span><span class="p">)</span> <span class="n">static_ltree</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">bl_count</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">287</span><span class="p">)</span> <span class="n">static_ltree</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">bl_count</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="cm">/* Codes 286 and 287 do not exist, but we must include them in the</span>
<span class="cm">     * tree construction to get a canonical Huffman tree (longest code</span>
<span class="cm">     * all ones)</span>
<span class="cm">     */</span>
    <span class="n">gen_codes</span><span class="p">((</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">static_ltree</span><span class="p">,</span> <span class="n">L_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bl_count</span><span class="p">);</span>

    <span class="cm">/* The static distance tree is trivial: */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">D_CODES</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">static_dtree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="n">static_dtree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Code</span> <span class="o">=</span> <span class="n">bi_reverse</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">static_init_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Initialize the tree data structures for a new zlib stream.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">zlib_tr_init</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tr_static_init</span><span class="p">();</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">l_desc</span><span class="p">.</span><span class="n">dyn_tree</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">l_desc</span><span class="p">.</span><span class="n">stat_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">static_l_desc</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">d_desc</span><span class="p">.</span><span class="n">dyn_tree</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_dtree</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">d_desc</span><span class="p">.</span><span class="n">stat_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">static_d_desc</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_desc</span><span class="p">.</span><span class="n">dyn_tree</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_desc</span><span class="p">.</span><span class="n">stat_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">static_bl_desc</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_eob_len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* enough lookahead for inflate */</span>
<span class="cp">#ifdef DEBUG_ZLIB</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="cm">/* Initialize the first block of the first file: */</span>
    <span class="n">init_block</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Initialize a new block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_block</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="cm">/* iterates over tree elements */</span>

    <span class="cm">/* Initialize the trees. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">L_CODES</span><span class="p">;</span>  <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">D_CODES</span><span class="p">;</span>  <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_dtree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">BL_CODES</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">[</span><span class="n">END_BLOCK</span><span class="p">].</span><span class="n">Freq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SMALLEST 1</span>
<span class="cm">/* Index within the heap array of least frequent node in the Huffman tree */</span>


<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Remove the smallest element from the heap and recreate the heap with</span>
<span class="cm"> * one less element. Updates heap and heap_len.</span>
<span class="cm"> */</span>
<span class="cp">#define pqremove(s, tree, top) \</span>
<span class="cp">{\</span>
<span class="cp">    top = s-&gt;heap[SMALLEST]; \</span>
<span class="cp">    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \</span>
<span class="cp">    pqdownheap(s, tree, SMALLEST); \</span>
<span class="cp">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Compares to subtrees, using the tree depth as tie breaker when</span>
<span class="cm"> * the subtrees have equal frequency. This minimizes the worst case length.</span>
<span class="cm"> */</span>
<span class="cp">#define smaller(tree, n, m, depth) \</span>
<span class="cp">   (tree[n].Freq &lt; tree[m].Freq || \</span>
<span class="cp">   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Restore the heap property by moving down the tree starting at node k,</span>
<span class="cm"> * exchanging a node with the smallest of its two sons if necessary, stopping</span>
<span class="cm"> * when the heap property is re-established (each father smaller than its</span>
<span class="cm"> * two sons).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pqdownheap</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span>  <span class="cm">/* the tree to restore */</span>
	<span class="kt">int</span> <span class="n">k</span>		<span class="cm">/* node to move down */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* left son of k */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_len</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Set j to the smallest of the two sons: */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_len</span> <span class="o">&amp;&amp;</span>
            <span class="n">smaller</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* Exit if v is smaller than both sons */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">smaller</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>

        <span class="cm">/* Exchange v with the smallest son */</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>  <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>

        <span class="cm">/* And continue down the tree, setting j to the left son of k */</span>
        <span class="n">j</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Compute the optimal bit lengths for a tree and update the total bit length</span>
<span class="cm"> * for the current block.</span>
<span class="cm"> * IN assertion: the fields freq and dad are set, heap[heap_max] and</span>
<span class="cm"> *    above are the tree nodes sorted by increasing frequency.</span>
<span class="cm"> * OUT assertions: the field len is set to the optimal bit length, the</span>
<span class="cm"> *     array bl_count contains the frequencies for each bit length.</span>
<span class="cm"> *     The length opt_len is updated; static_len is also updated if stree is</span>
<span class="cm"> *     not null.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gen_bitlen</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">tree_desc</span> <span class="o">*</span><span class="n">desc</span>    <span class="cm">/* the tree descriptor */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span>        <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">dyn_tree</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_code</span>         <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">max_code</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">ct_data</span> <span class="o">*</span><span class="n">stree</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">stat_desc</span><span class="o">-&gt;</span><span class="n">static_tree</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">extra</span>     <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">stat_desc</span><span class="o">-&gt;</span><span class="n">extra_bits</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">base</span>             <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">stat_desc</span><span class="o">-&gt;</span><span class="n">extra_base</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_length</span>       <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">stat_desc</span><span class="o">-&gt;</span><span class="n">max_length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>              <span class="cm">/* heap index */</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>           <span class="cm">/* iterate over the tree elements */</span>
    <span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>           <span class="cm">/* bit length */</span>
    <span class="kt">int</span> <span class="n">xbits</span><span class="p">;</span>          <span class="cm">/* extra bits */</span>
    <span class="n">ush</span> <span class="n">f</span><span class="p">;</span>              <span class="cm">/* frequency */</span>
    <span class="kt">int</span> <span class="n">overflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* number of elements with bit length too large */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bits</span> <span class="o">&lt;=</span> <span class="n">MAX_BITS</span><span class="p">;</span> <span class="n">bits</span><span class="o">++</span><span class="p">)</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_count</span><span class="p">[</span><span class="n">bits</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* In a first pass, compute the optimal bit lengths (which may</span>
<span class="cm">     * overflow in the case of the bit length tree).</span>
<span class="cm">     */</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_max</span><span class="p">]].</span><span class="n">Len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* root of the heap */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_max</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">HEAP_SIZE</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Dad</span><span class="p">].</span><span class="n">Len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">)</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">max_length</span><span class="p">,</span> <span class="n">overflow</span><span class="o">++</span><span class="p">;</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">bits</span><span class="p">;</span>
        <span class="cm">/* We overwrite tree[n].Dad which is no longer needed */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">max_code</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="cm">/* not a leaf node */</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_count</span><span class="p">[</span><span class="n">bits</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="n">xbits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">base</span><span class="p">)</span> <span class="n">xbits</span> <span class="o">=</span> <span class="n">extra</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">base</span><span class="p">];</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Freq</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">bits</span> <span class="o">+</span> <span class="n">xbits</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stree</span><span class="p">)</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">stree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Len</span> <span class="o">+</span> <span class="n">xbits</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">overflow</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">Trace</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">bit length overflow</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
    <span class="cm">/* This happens for example on obj2 and pic of the Calgary corpus */</span>

    <span class="cm">/* Find the first bit length which could increase: */</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">max_length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_count</span><span class="p">[</span><span class="n">bits</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">bits</span><span class="o">--</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_count</span><span class="p">[</span><span class="n">bits</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>      <span class="cm">/* move one leaf down the tree */</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_count</span><span class="p">[</span><span class="n">bits</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* move one overflow item as its brother */</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_count</span><span class="p">[</span><span class="n">max_length</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="cm">/* The brother of the overflow item also moves one step up,</span>
<span class="cm">         * but this does not affect bl_count[max_length]</span>
<span class="cm">         */</span>
        <span class="n">overflow</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">overflow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="cm">/* Now recompute all bit lengths, scanning in increasing frequency.</span>
<span class="cm">     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all</span>
<span class="cm">     * lengths instead of fixing only the wrong ones. This idea is taken</span>
<span class="cm">     * from &#39;ar&#39; written by Haruhiko Okumura.)</span>
<span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">bits</span> <span class="o">=</span> <span class="n">max_length</span><span class="p">;</span> <span class="n">bits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bits</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_count</span><span class="p">[</span><span class="n">bits</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="o">--</span><span class="n">h</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">max_code</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">Len</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Trace</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;code %d bits %d-&gt;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">Len</span><span class="p">,</span> <span class="n">bits</span><span class="p">));</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">bits</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">tree</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">Len</span><span class="p">)</span>
                              <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">tree</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">Freq</span><span class="p">;</span>
                <span class="n">tree</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">bits</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">n</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Generate the codes for a given tree and bit counts (which need not be</span>
<span class="cm"> * optimal).</span>
<span class="cm"> * IN assertion: the array bl_count contains the bit length statistics for</span>
<span class="cm"> * the given tree and the field len is set for all tree elements.</span>
<span class="cm"> * OUT assertion: the field code is set for all tree elements of non</span>
<span class="cm"> *     zero code length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gen_codes</span><span class="p">(</span>
	<span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span>             <span class="cm">/* the tree to decorate */</span>
	<span class="kt">int</span> <span class="n">max_code</span><span class="p">,</span>              <span class="cm">/* largest code with non zero frequency */</span>
	<span class="n">ush</span> <span class="o">*</span><span class="n">bl_count</span>             <span class="cm">/* number of codes at each bit length */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">ush</span> <span class="n">next_code</span><span class="p">[</span><span class="n">MAX_BITS</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* next code value for each bit length */</span>
    <span class="n">ush</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>              <span class="cm">/* running code value */</span>
    <span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>                  <span class="cm">/* bit index */</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                     <span class="cm">/* code index */</span>

    <span class="cm">/* The distribution counts are first used to generate the code values</span>
<span class="cm">     * without bit reversal.</span>
<span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">bits</span> <span class="o">&lt;=</span> <span class="n">MAX_BITS</span><span class="p">;</span> <span class="n">bits</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">next_code</span><span class="p">[</span><span class="n">bits</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span> <span class="o">+</span> <span class="n">bl_count</span><span class="p">[</span><span class="n">bits</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Check that the bit counts in bl_count are consistent. The last code</span>
<span class="cm">     * must be all ones.</span>
<span class="cm">     */</span>
    <span class="n">Assert</span> <span class="p">(</span><span class="n">code</span> <span class="o">+</span> <span class="n">bl_count</span><span class="p">[</span><span class="n">MAX_BITS</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">MAX_BITS</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="s">&quot;inconsistent bit counts&quot;</span><span class="p">);</span>
    <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">gen_codes: max_code %d &quot;</span><span class="p">,</span> <span class="n">max_code</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">max_code</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="cm">/* Now reverse the bits */</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Code</span> <span class="o">=</span> <span class="n">bi_reverse</span><span class="p">(</span><span class="n">next_code</span><span class="p">[</span><span class="n">len</span><span class="p">]</span><span class="o">++</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

        <span class="n">Tracecv</span><span class="p">(</span><span class="n">tree</span> <span class="o">!=</span> <span class="n">static_ltree</span><span class="p">,</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">n %3d %c l %2d c %4x (%x) &quot;</span><span class="p">,</span>
             <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">isgraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Code</span><span class="p">,</span> <span class="n">next_code</span><span class="p">[</span><span class="n">len</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Construct one Huffman tree and assigns the code bit strings and lengths.</span>
<span class="cm"> * Update the total bit length for the current block.</span>
<span class="cm"> * IN assertion: the field freq is set for all tree elements.</span>
<span class="cm"> * OUT assertions: the fields len and code are set to the optimal bit length</span>
<span class="cm"> *     and corresponding code. The length opt_len is updated; static_len is</span>
<span class="cm"> *     also updated if stree is not null. The field max_code is set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">build_tree</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">tree_desc</span> <span class="o">*</span><span class="n">desc</span>	 <span class="cm">/* the tree descriptor */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span>         <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">dyn_tree</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">ct_data</span> <span class="o">*</span><span class="n">stree</span>  <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">stat_desc</span><span class="o">-&gt;</span><span class="n">static_tree</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">elems</span>             <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">stat_desc</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>          <span class="cm">/* iterate over heap elements */</span>
    <span class="kt">int</span> <span class="n">max_code</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* largest code with non zero frequency */</span>
    <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>          <span class="cm">/* new node being created */</span>

    <span class="cm">/* Construct the initial heap, with least frequent element in</span>
<span class="cm">     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].</span>
<span class="cm">     * heap[0] is not used.</span>
<span class="cm">     */</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_max</span> <span class="o">=</span> <span class="n">HEAP_SIZE</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">elems</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Freq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="o">++</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_len</span><span class="p">)]</span> <span class="o">=</span> <span class="n">max_code</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* The pkzip format requires that at least one distance code exists,</span>
<span class="cm">     * and that at least one bit should be sent even if there is only one</span>
<span class="cm">     * possible code. So to avoid special checks later on we force at least</span>
<span class="cm">     * two codes of non zero frequency.</span>
<span class="cm">     */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="o">++</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_len</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_code</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="o">++</span><span class="n">max_code</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">Freq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span><span class="o">--</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">stree</span><span class="p">)</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span> <span class="o">-=</span> <span class="n">stree</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">Len</span><span class="p">;</span>
        <span class="cm">/* node is 0 or 1 so it does not have extra bits */</span>
    <span class="p">}</span>
    <span class="n">desc</span><span class="o">-&gt;</span><span class="n">max_code</span> <span class="o">=</span> <span class="n">max_code</span><span class="p">;</span>

    <span class="cm">/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,</span>
<span class="cm">     * establish sub-heaps of increasing lengths:</span>
<span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="n">pqdownheap</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="cm">/* Construct the Huffman tree by repeatedly combining the least two</span>
<span class="cm">     * frequent nodes.</span>
<span class="cm">     */</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">elems</span><span class="p">;</span>              <span class="cm">/* next internal node of the tree */</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">pqremove</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  <span class="cm">/* n = node of least frequency */</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">SMALLEST</span><span class="p">];</span> <span class="cm">/* m = node of next least frequency */</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_max</span><span class="p">)]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="cm">/* keep the nodes sorted by frequency */</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_max</span><span class="p">)]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>

        <span class="cm">/* Create a new node father of n and m */</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">Freq</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Freq</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">Freq</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uch</span><span class="p">)</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Dad</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">Dad</span> <span class="o">=</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">node</span><span class="p">;</span>
<span class="cp">#ifdef DUMP_BL_TREE</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">node %d(%d), sons %d(%d) %d(%d)&quot;</span><span class="p">,</span>
                    <span class="n">node</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">Freq</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Freq</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">Freq</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#endif</span>
        <span class="cm">/* and insert the new node in the heap */</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">SMALLEST</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">++</span><span class="p">;</span>
        <span class="n">pqdownheap</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">SMALLEST</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_len</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">heap_max</span><span class="p">)]</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">SMALLEST</span><span class="p">];</span>

    <span class="cm">/* At this point, the fields freq and dad are set. We can now</span>
<span class="cm">     * generate the bit lengths.</span>
<span class="cm">     */</span>
    <span class="n">gen_bitlen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">tree_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="p">);</span>

    <span class="cm">/* The field len is now set, we can generate the bit codes */</span>
    <span class="n">gen_codes</span> <span class="p">((</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">tree</span><span class="p">,</span> <span class="n">max_code</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Scan a literal or distance tree to determine the frequencies of the codes</span>
<span class="cm"> * in the bit length tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_tree</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span>   <span class="cm">/* the tree to be scanned */</span>
	<span class="kt">int</span> <span class="n">max_code</span>     <span class="cm">/* and its largest code of non zero frequency */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                     <span class="cm">/* iterates over all tree elements */</span>
    <span class="kt">int</span> <span class="n">prevlen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>          <span class="cm">/* last emitted length */</span>
    <span class="kt">int</span> <span class="n">curlen</span><span class="p">;</span>                <span class="cm">/* length of current code */</span>
    <span class="kt">int</span> <span class="n">nextlen</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Len</span><span class="p">;</span> <span class="cm">/* length of next code */</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>             <span class="cm">/* repeat count of the current code */</span>
    <span class="kt">int</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>         <span class="cm">/* max repeat count */</span>
    <span class="kt">int</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>         <span class="cm">/* min repeat count */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nextlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">138</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">tree</span><span class="p">[</span><span class="n">max_code</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">Len</span> <span class="o">=</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="mh">0xffff</span><span class="p">;</span> <span class="cm">/* guard */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">max_code</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">curlen</span> <span class="o">=</span> <span class="n">nextlen</span><span class="p">;</span> <span class="n">nextlen</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">Len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">max_count</span> <span class="o">&amp;&amp;</span> <span class="n">curlen</span> <span class="o">==</span> <span class="n">nextlen</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">min_count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">[</span><span class="n">curlen</span><span class="p">].</span><span class="n">Freq</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">curlen</span> <span class="o">!=</span> <span class="n">prevlen</span><span class="p">)</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">[</span><span class="n">curlen</span><span class="p">].</span><span class="n">Freq</span><span class="o">++</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">[</span><span class="n">REP_3_6</span><span class="p">].</span><span class="n">Freq</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">[</span><span class="n">REPZ_3_10</span><span class="p">].</span><span class="n">Freq</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">[</span><span class="n">REPZ_11_138</span><span class="p">].</span><span class="n">Freq</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">prevlen</span> <span class="o">=</span> <span class="n">curlen</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="mi">138</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curlen</span> <span class="o">==</span> <span class="n">nextlen</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Send a literal or distance tree in compressed form, using the codes in</span>
<span class="cm"> * bl_tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_tree</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">ct_data</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="cm">/* the tree to be scanned */</span>
	<span class="kt">int</span> <span class="n">max_code</span>   <span class="cm">/* and its largest code of non zero frequency */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                     <span class="cm">/* iterates over all tree elements */</span>
    <span class="kt">int</span> <span class="n">prevlen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>          <span class="cm">/* last emitted length */</span>
    <span class="kt">int</span> <span class="n">curlen</span><span class="p">;</span>                <span class="cm">/* length of current code */</span>
    <span class="kt">int</span> <span class="n">nextlen</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Len</span><span class="p">;</span> <span class="cm">/* length of next code */</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>             <span class="cm">/* repeat count of the current code */</span>
    <span class="kt">int</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>         <span class="cm">/* max repeat count */</span>
    <span class="kt">int</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>         <span class="cm">/* min repeat count */</span>

    <span class="cm">/* tree[max_code+1].Len = -1; */</span>  <span class="cm">/* guard already set */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">138</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">max_code</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">curlen</span> <span class="o">=</span> <span class="n">nextlen</span><span class="p">;</span> <span class="n">nextlen</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">Len</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">max_count</span> <span class="o">&amp;&amp;</span> <span class="n">curlen</span> <span class="o">==</span> <span class="n">nextlen</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">min_count</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">do</span> <span class="p">{</span> <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">curlen</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">);</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">curlen</span> <span class="o">!=</span> <span class="n">prevlen</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">curlen</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">);</span> <span class="n">count</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Assert</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">,</span> <span class="s">&quot; 3_6?&quot;</span><span class="p">);</span>
            <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">REP_3_6</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">);</span> <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">REPZ_3_10</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">);</span> <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">REPZ_11_138</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">);</span> <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">prevlen</span> <span class="o">=</span> <span class="n">curlen</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="mi">138</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curlen</span> <span class="o">==</span> <span class="n">nextlen</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">min_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Construct the Huffman tree for the bit lengths and return the index in</span>
<span class="cm"> * bl_order of the last bit length code to send.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">build_bl_tree</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">max_blindex</span><span class="p">;</span>  <span class="cm">/* index of last bit length code of non zero freq */</span>

    <span class="cm">/* Determine the bit length frequencies for literal and distance trees */</span>
    <span class="n">scan_tree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">l_desc</span><span class="p">.</span><span class="n">max_code</span><span class="p">);</span>
    <span class="n">scan_tree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_dtree</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">d_desc</span><span class="p">.</span><span class="n">max_code</span><span class="p">);</span>

    <span class="cm">/* Build the bit length tree: */</span>
    <span class="n">build_tree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">tree_desc</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_desc</span><span class="p">)));</span>
    <span class="cm">/* opt_len now includes the length of the tree representations, except</span>
<span class="cm">     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.</span>
<span class="cm">     */</span>

    <span class="cm">/* Determine the number of bit length codes to send. The pkzip format</span>
<span class="cm">     * requires that at least 4 bit length codes be sent. (appnote.txt says</span>
<span class="cm">     * 3 but the actual value used is 4.)</span>
<span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">max_blindex</span> <span class="o">=</span> <span class="n">BL_CODES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">max_blindex</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">max_blindex</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">[</span><span class="n">bl_order</span><span class="p">[</span><span class="n">max_blindex</span><span class="p">]].</span><span class="n">Len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Update opt_len to include the bit length tree and counts */</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">max_blindex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">+</span><span class="mi">5</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">dyn trees: dyn %ld, stat %ld&quot;</span><span class="p">,</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">max_blindex</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Send the header for a block using dynamic Huffman trees: the counts, the</span>
<span class="cm"> * lengths of the bit length codes, the literal tree and the distance tree.</span>
<span class="cm"> * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_all_trees</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">lcodes</span><span class="p">,</span>  <span class="cm">/* number of codes for each tree */</span>
	<span class="kt">int</span> <span class="n">dcodes</span><span class="p">,</span>  <span class="cm">/* number of codes for each tree */</span>
	<span class="kt">int</span> <span class="n">blcodes</span>  <span class="cm">/* number of codes for each tree */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">rank</span><span class="p">;</span>                    <span class="cm">/* index in bl_order */</span>

    <span class="n">Assert</span> <span class="p">(</span><span class="n">lcodes</span> <span class="o">&gt;=</span> <span class="mi">257</span> <span class="o">&amp;&amp;</span> <span class="n">dcodes</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">blcodes</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;not enough codes&quot;</span><span class="p">);</span>
    <span class="n">Assert</span> <span class="p">(</span><span class="n">lcodes</span> <span class="o">&lt;=</span> <span class="n">L_CODES</span> <span class="o">&amp;&amp;</span> <span class="n">dcodes</span> <span class="o">&lt;=</span> <span class="n">D_CODES</span> <span class="o">&amp;&amp;</span> <span class="n">blcodes</span> <span class="o">&lt;=</span> <span class="n">BL_CODES</span><span class="p">,</span>
            <span class="s">&quot;too many codes&quot;</span><span class="p">);</span>
    <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">bl counts: &quot;</span><span class="p">));</span>
    <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">lcodes</span><span class="o">-</span><span class="mi">257</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="cm">/* not +255 as stated in appnote.txt */</span>
    <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dcodes</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>   <span class="mi">5</span><span class="p">);</span>
    <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">blcodes</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span>  <span class="mi">4</span><span class="p">);</span> <span class="cm">/* not -3 as stated in appnote.txt */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="n">blcodes</span><span class="p">;</span> <span class="n">rank</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">bl code %2d &quot;</span><span class="p">,</span> <span class="n">bl_order</span><span class="p">[</span><span class="n">rank</span><span class="p">]));</span>
        <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bl_tree</span><span class="p">[</span><span class="n">bl_order</span><span class="p">[</span><span class="n">rank</span><span class="p">]].</span><span class="n">Len</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">bl tree: sent %ld&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span><span class="p">));</span>

    <span class="n">send_tree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">,</span> <span class="n">lcodes</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* literal tree */</span>
    <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">lit tree: sent %ld&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span><span class="p">));</span>

    <span class="n">send_tree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_dtree</span><span class="p">,</span> <span class="n">dcodes</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* distance tree */</span>
    <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">dist tree: sent %ld&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Send a stored block</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">zlib_tr_stored_block</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>        <span class="cm">/* input block */</span>
	<span class="n">ulg</span> <span class="n">stored_len</span><span class="p">,</span>   <span class="cm">/* length of input block */</span>
	<span class="kt">int</span> <span class="n">eof</span>           <span class="cm">/* true if this is the last block for a file */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">STORED_BLOCK</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">eof</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>  <span class="cm">/* send block type */</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="o">~</span><span class="mi">7L</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">stored_len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">copy_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">stored_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* with header */</span>
<span class="p">}</span>

<span class="cm">/* Send just the `stored block&#39; type code without any length bytes or data.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">zlib_tr_stored_type_only</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">STORED_BLOCK</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">bi_windup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7L</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Send one empty static block to give enough lookahead for inflate.</span>
<span class="cm"> * This takes 10 bits, of which 7 may remain in the bit buffer.</span>
<span class="cm"> * The current inflate code requires 9 bits of lookahead. If the</span>
<span class="cm"> * last two codes for the previous block (real code plus EOB) were coded</span>
<span class="cm"> * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode</span>
<span class="cm"> * the last real code. In this case we send two empty static blocks instead</span>
<span class="cm"> * of one. (There are no problems if the previous block is stored or fixed.)</span>
<span class="cm"> * To simplify the code, we assume the worst case of last real code encoded</span>
<span class="cm"> * on one bit only.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">zlib_tr_align</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">STATIC_TREES</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">END_BLOCK</span><span class="p">,</span> <span class="n">static_ltree</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">+=</span> <span class="mi">10L</span><span class="p">;</span> <span class="cm">/* 3 for block type, 7 for EOB */</span>
    <span class="n">bi_flush</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="cm">/* Of the 10 bits for the empty block, we have already sent</span>
<span class="cm">     * (10 - bi_valid) bits. The lookahead for the last real code (before</span>
<span class="cm">     * the EOB of the previous block) was thus at least one plus the length</span>
<span class="cm">     * of the EOB plus what we have just sent of the empty static block.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_eob_len</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bi_valid</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">STATIC_TREES</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">END_BLOCK</span><span class="p">,</span> <span class="n">static_ltree</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">+=</span> <span class="mi">10L</span><span class="p">;</span>
        <span class="n">bi_flush</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_eob_len</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Determine the best encoding for the current block: dynamic trees, static</span>
<span class="cm"> * trees or store, and output the encoded block to the zip file. This function</span>
<span class="cm"> * returns the total compressed length for the file so far.</span>
<span class="cm"> */</span>
<span class="n">ulg</span> <span class="nf">zlib_tr_flush_block</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>        <span class="cm">/* input block, or NULL if too old */</span>
	<span class="n">ulg</span> <span class="n">stored_len</span><span class="p">,</span>   <span class="cm">/* length of input block */</span>
	<span class="kt">int</span> <span class="n">eof</span>           <span class="cm">/* true if this is the last block for a file */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">ulg</span> <span class="n">opt_lenb</span><span class="p">,</span> <span class="n">static_lenb</span><span class="p">;</span> <span class="cm">/* opt_len and static_len in bytes */</span>
    <span class="kt">int</span> <span class="n">max_blindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* index of last bit length code of non zero freq */</span>

    <span class="cm">/* Build the Huffman trees unless a stored block is forced */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

	 <span class="cm">/* Check if the file is ascii or binary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">Z_UNKNOWN</span><span class="p">)</span> <span class="n">set_data_type</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/* Construct the literal and distance trees */</span>
	<span class="n">build_tree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">tree_desc</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">l_desc</span><span class="p">)));</span>
	<span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">lit data: dyn %ld, stat %ld&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span><span class="p">,</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span><span class="p">));</span>

	<span class="n">build_tree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">tree_desc</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">d_desc</span><span class="p">)));</span>
	<span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">dist data: dyn %ld, stat %ld&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span><span class="p">,</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span><span class="p">));</span>
	<span class="cm">/* At this point, opt_len and static_len are the total bit lengths of</span>
<span class="cm">	 * the compressed block data, excluding the tree representations.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Build the bit length tree for the above two trees, and get the index</span>
<span class="cm">	 * in bl_order of the last bit length code to send.</span>
<span class="cm">	 */</span>
	<span class="n">max_blindex</span> <span class="o">=</span> <span class="n">build_bl_tree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/* Determine the best encoding. Compute first the block length in bytes*/</span>
	<span class="n">opt_lenb</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">static_lenb</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">;</span>

	<span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">opt %lu(%lu) stat %lu(%lu) stored %lu lit %u &quot;</span><span class="p">,</span>
		<span class="n">opt_lenb</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span><span class="p">,</span> <span class="n">static_lenb</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span><span class="p">,</span> <span class="n">stored_len</span><span class="p">,</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">static_lenb</span> <span class="o">&lt;=</span> <span class="n">opt_lenb</span><span class="p">)</span> <span class="n">opt_lenb</span> <span class="o">=</span> <span class="n">static_lenb</span><span class="p">;</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;lost buf&quot;</span><span class="p">);</span>
	<span class="n">opt_lenb</span> <span class="o">=</span> <span class="n">static_lenb</span> <span class="o">=</span> <span class="n">stored_len</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="cm">/* force a stored block */</span>
    <span class="p">}</span>

    <span class="cm">/* If compression failed and this is the first and last block,</span>
<span class="cm">     * and if the .zip file can be seeked (to rewrite the local header),</span>
<span class="cm">     * the whole file is transformed into a stored file:</span>
<span class="cm">     */</span>
<span class="cp">#ifdef STORED_FILE_OK</span>
<span class="cp">#  ifdef FORCE_STORED_FILE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eof</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">==</span> <span class="mi">0L</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* force stored file */</span>
<span class="cp">#  else</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stored_len</span> <span class="o">&lt;=</span> <span class="n">opt_lenb</span> <span class="o">&amp;&amp;</span> <span class="n">eof</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span><span class="o">==</span><span class="mi">0L</span> <span class="o">&amp;&amp;</span> <span class="n">seekable</span><span class="p">())</span> <span class="p">{</span>
<span class="cp">#  endif</span>
        <span class="cm">/* Since LIT_BUFSIZE &lt;= 2*WSIZE, the input data must be there: */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="n">error</span> <span class="p">(</span><span class="s">&quot;block vanished&quot;</span><span class="p">);</span>

        <span class="n">copy_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">stored_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* without header */</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">=</span> <span class="n">stored_len</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">method</span> <span class="o">=</span> <span class="n">STORED</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif </span><span class="cm">/* STORED_FILE_OK */</span><span class="cp"></span>

<span class="cp">#ifdef FORCE_STORED</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* force stored block */</span>
<span class="cp">#else</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stored_len</span><span class="o">+</span><span class="mi">4</span> <span class="o">&lt;=</span> <span class="n">opt_lenb</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                       <span class="cm">/* 4: two words for the lengths */</span>
<span class="cp">#endif</span>
        <span class="cm">/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.</span>
<span class="cm">         * Otherwise we can&#39;t have processed more than WSIZE input bytes since</span>
<span class="cm">         * the last block flush, because compression would have been</span>
<span class="cm">         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to</span>
<span class="cm">         * transform a block into a stored block.</span>
<span class="cm">         */</span>
        <span class="n">zlib_tr_stored_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">stored_len</span><span class="p">,</span> <span class="n">eof</span><span class="p">);</span>

<span class="cp">#ifdef FORCE_STATIC</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">static_lenb</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* force static trees */</span>
<span class="cp">#else</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">static_lenb</span> <span class="o">==</span> <span class="n">opt_lenb</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif</span>
        <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">STATIC_TREES</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">eof</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">compress_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">static_ltree</span><span class="p">,</span> <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">static_dtree</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">static_len</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">DYN_TREES</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">eof</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">send_all_trees</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">l_desc</span><span class="p">.</span><span class="n">max_code</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">d_desc</span><span class="p">.</span><span class="n">max_code</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">max_blindex</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">compress_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">,</span> <span class="p">(</span><span class="n">ct_data</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_dtree</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">opt_len</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Assert</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">==</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span><span class="p">,</span> <span class="s">&quot;bad compressed size&quot;</span><span class="p">);</span>
    <span class="n">init_block</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">eof</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bi_windup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>  <span class="cm">/* align on byte boundary */</span>
    <span class="p">}</span>
    <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">comprlen %lu(%lu) &quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">,</span>
           <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span><span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="n">eof</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">compressed_len</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Save the match info and tally the frequency counts. Return true if</span>
<span class="cm"> * the current block must be flushed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">zlib_tr_tally</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">dist</span><span class="p">,</span>  <span class="cm">/* distance of matched string */</span>
	<span class="kt">unsigned</span> <span class="n">lc</span>     <span class="cm">/* match length-MIN_MATCH or unmatched char (if dist==0) */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">d_buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">dist</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">l_buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uch</span><span class="p">)</span><span class="n">lc</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* lc is the unmatched char */</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">[</span><span class="n">lc</span><span class="p">].</span><span class="n">Freq</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">matches</span><span class="o">++</span><span class="p">;</span>
        <span class="cm">/* Here, lc is the match length - MIN_MATCH */</span>
        <span class="n">dist</span><span class="o">--</span><span class="p">;</span>             <span class="cm">/* dist = match distance - 1 */</span>
        <span class="n">Assert</span><span class="p">((</span><span class="n">ush</span><span class="p">)</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">MAX_DIST</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
               <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">lc</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">ush</span><span class="p">)(</span><span class="n">MAX_MATCH</span><span class="o">-</span><span class="n">MIN_MATCH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
               <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">d_code</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">D_CODES</span><span class="p">,</span>  <span class="s">&quot;zlib_tr_tally: bad match&quot;</span><span class="p">);</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">[</span><span class="n">length_code</span><span class="p">[</span><span class="n">lc</span><span class="p">]</span><span class="o">+</span><span class="n">LITERALS</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">Freq</span><span class="o">++</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_dtree</span><span class="p">[</span><span class="n">d_code</span><span class="p">(</span><span class="n">dist</span><span class="p">)].</span><span class="n">Freq</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Try to guess if it is profitable to stop the current block here */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Compute an upper bound for the compressed length */</span>
        <span class="n">ulg</span> <span class="n">out_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span><span class="o">*</span><span class="mi">8L</span><span class="p">;</span>
        <span class="n">ulg</span> <span class="n">in_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)((</span><span class="kt">long</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_start</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">dcode</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">dcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dcode</span> <span class="o">&lt;</span> <span class="n">D_CODES</span><span class="p">;</span> <span class="n">dcode</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">out_length</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_dtree</span><span class="p">[</span><span class="n">dcode</span><span class="p">].</span><span class="n">Freq</span> <span class="o">*</span>
                <span class="p">(</span><span class="mi">5L</span><span class="o">+</span><span class="n">extra_dbits</span><span class="p">[</span><span class="n">dcode</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">out_length</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">Tracev</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">last_lit %u, in %ld, out ~%ld(%ld%%) &quot;</span><span class="p">,</span>
               <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span><span class="p">,</span> <span class="n">in_length</span><span class="p">,</span> <span class="n">out_length</span><span class="p">,</span>
               <span class="mi">100L</span> <span class="o">-</span> <span class="n">out_length</span><span class="o">*</span><span class="mi">100L</span><span class="o">/</span><span class="n">in_length</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">matches</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">out_length</span> <span class="o">&lt;</span> <span class="n">in_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span> <span class="o">==</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_bufsize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="cm">/* We avoid equality with lit_bufsize because of wraparound at 64K</span>
<span class="cm">     * on 16 bit machines and because stored blocks are restricted to</span>
<span class="cm">     * 64K-1 bytes.</span>
<span class="cm">     */</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Send the block data compressed using the given Huffman trees</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">compress_block</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">ct_data</span> <span class="o">*</span><span class="n">ltree</span><span class="p">,</span> <span class="cm">/* literal tree */</span>
	<span class="n">ct_data</span> <span class="o">*</span><span class="n">dtree</span>  <span class="cm">/* distance tree */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">dist</span><span class="p">;</span>      <span class="cm">/* distance of matched string */</span>
    <span class="kt">int</span> <span class="n">lc</span><span class="p">;</span>             <span class="cm">/* match length or unmatched char (if dist == 0) */</span>
    <span class="kt">unsigned</span> <span class="n">lx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="cm">/* running index in l_buf */</span>
    <span class="kt">unsigned</span> <span class="n">code</span><span class="p">;</span>      <span class="cm">/* the code to send */</span>
    <span class="kt">int</span> <span class="n">extra</span><span class="p">;</span>          <span class="cm">/* number of extra bits to send */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="p">{</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">d_buf</span><span class="p">[</span><span class="n">lx</span><span class="p">];</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">l_buf</span><span class="p">[</span><span class="n">lx</span><span class="o">++</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">ltree</span><span class="p">);</span> <span class="cm">/* send a literal byte */</span>
            <span class="n">Tracecv</span><span class="p">(</span><span class="n">isgraph</span><span class="p">(</span><span class="n">lc</span><span class="p">),</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot; &#39;%c&#39; &quot;</span><span class="p">,</span> <span class="n">lc</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* Here, lc is the match length - MIN_MATCH */</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">length_code</span><span class="p">[</span><span class="n">lc</span><span class="p">];</span>
            <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">code</span><span class="o">+</span><span class="n">LITERALS</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ltree</span><span class="p">);</span> <span class="cm">/* send the length code */</span>
            <span class="n">extra</span> <span class="o">=</span> <span class="n">extra_lbits</span><span class="p">[</span><span class="n">code</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">extra</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">lc</span> <span class="o">-=</span> <span class="n">base_length</span><span class="p">[</span><span class="n">code</span><span class="p">];</span>
                <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">extra</span><span class="p">);</span>       <span class="cm">/* send the extra length bits */</span>
            <span class="p">}</span>
            <span class="n">dist</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* dist is now the match distance - 1 */</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">d_code</span><span class="p">(</span><span class="n">dist</span><span class="p">);</span>
            <span class="n">Assert</span> <span class="p">(</span><span class="n">code</span> <span class="o">&lt;</span> <span class="n">D_CODES</span><span class="p">,</span> <span class="s">&quot;bad d_code&quot;</span><span class="p">);</span>

            <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">dtree</span><span class="p">);</span>       <span class="cm">/* send the distance code */</span>
            <span class="n">extra</span> <span class="o">=</span> <span class="n">extra_dbits</span><span class="p">[</span><span class="n">code</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">extra</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dist</span> <span class="o">-=</span> <span class="n">base_dist</span><span class="p">[</span><span class="n">code</span><span class="p">];</span>
                <span class="n">send_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">extra</span><span class="p">);</span>   <span class="cm">/* send the extra distance bits */</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="cm">/* literal or match pair ? */</span>

        <span class="cm">/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_bufsize</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">lx</span><span class="p">,</span> <span class="s">&quot;pendingBuf overflow&quot;</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">lx</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_lit</span><span class="p">);</span>

    <span class="n">send_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">END_BLOCK</span><span class="p">,</span> <span class="n">ltree</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_eob_len</span> <span class="o">=</span> <span class="n">ltree</span><span class="p">[</span><span class="n">END_BLOCK</span><span class="p">].</span><span class="n">Len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Set the data type to ASCII or BINARY, using a crude approximation:</span>
<span class="cm"> * binary if more than 20% of the bytes are &lt;= 6 or &gt;= 128, ascii otherwise.</span>
<span class="cm"> * IN assertion: the fields freq of dyn_ltree are set and the total of all</span>
<span class="cm"> * frequencies does not exceed 64K (to fit in an int on 16 bit machines).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">set_data_type</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">ascii_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">bin_freq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">)</span>        <span class="n">bin_freq</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">Freq</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>    <span class="n">ascii_freq</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">Freq</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">LITERALS</span><span class="p">)</span> <span class="n">bin_freq</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dyn_ltree</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">].</span><span class="n">Freq</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">data_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">Byte</span><span class="p">)(</span><span class="n">bin_freq</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ascii_freq</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">Z_BINARY</span> <span class="o">:</span> <span class="n">Z_ASCII</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Copy a stored block, storing first the length and its</span>
<span class="cm"> * one&#39;s complement if requested.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">copy_block</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">char</span>    <span class="o">*</span><span class="n">buf</span><span class="p">,</span>     <span class="cm">/* the input data */</span>
	<span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>     <span class="cm">/* its length */</span>
	<span class="kt">int</span>      <span class="n">header</span>   <span class="cm">/* true if block header must be written */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">bi_windup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>        <span class="cm">/* align on byte boundary */</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_eob_len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* enough lookahead for inflate */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">put_short</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>   
        <span class="n">put_short</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="o">~</span><span class="n">len</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_ZLIB</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">16</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
<span class="cp">#ifdef DEBUG_ZLIB</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">bits_sent</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">len</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="cm">/* bundle up the put_byte(s, *buf++) calls */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
