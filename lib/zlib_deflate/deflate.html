<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › zlib_deflate › deflate.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>deflate.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* +++ deflate.c */</span>
<span class="cm">/* deflate.c -- compress data using the deflation algorithm</span>
<span class="cm"> * Copyright (C) 1995-1996 Jean-loup Gailly.</span>
<span class="cm"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  ALGORITHM</span>
<span class="cm"> *</span>
<span class="cm"> *      The &quot;deflation&quot; process depends on being able to identify portions</span>
<span class="cm"> *      of the input text which are identical to earlier input (within a</span>
<span class="cm"> *      sliding window trailing behind the input currently being processed).</span>
<span class="cm"> *</span>
<span class="cm"> *      The most straightforward technique turns out to be the fastest for</span>
<span class="cm"> *      most input files: try all possible matches and select the longest.</span>
<span class="cm"> *      The key feature of this algorithm is that insertions into the string</span>
<span class="cm"> *      dictionary are very simple and thus fast, and deletions are avoided</span>
<span class="cm"> *      completely. Insertions are performed at each input character, whereas</span>
<span class="cm"> *      string matches are performed only when the previous match ends. So it</span>
<span class="cm"> *      is preferable to spend more time in matches to allow very fast string</span>
<span class="cm"> *      insertions and avoid deletions. The matching algorithm for small</span>
<span class="cm"> *      strings is inspired from that of Rabin &amp; Karp. A brute force approach</span>
<span class="cm"> *      is used to find longer strings when a small match has been found.</span>
<span class="cm"> *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze</span>
<span class="cm"> *      (by Leonid Broukhis).</span>
<span class="cm"> *         A previous version of this file used a more sophisticated algorithm</span>
<span class="cm"> *      (by Fiala and Greene) which is guaranteed to run in linear amortized</span>
<span class="cm"> *      time, but has a larger average cost, uses more memory and is patented.</span>
<span class="cm"> *      However the F&amp;G algorithm may be faster for some highly redundant</span>
<span class="cm"> *      files if the parameter max_chain_length (described below) is too large.</span>
<span class="cm"> *</span>
<span class="cm"> *  ACKNOWLEDGEMENTS</span>
<span class="cm"> *</span>
<span class="cm"> *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and</span>
<span class="cm"> *      I found it in &#39;freeze&#39; written by Leonid Broukhis.</span>
<span class="cm"> *      Thanks to many people for bug reports and testing.</span>
<span class="cm"> *</span>
<span class="cm"> *  REFERENCES</span>
<span class="cm"> *</span>
<span class="cm"> *      Deutsch, L.P.,&quot;DEFLATE Compressed Data Format Specification&quot;.</span>
<span class="cm"> *      Available in ftp://ds.internic.net/rfc/rfc1951.txt</span>
<span class="cm"> *</span>
<span class="cm"> *      A description of the Rabin and Karp algorithm is given in the book</span>
<span class="cm"> *         &quot;Algorithms&quot; by R. Sedgewick, Addison-Wesley, p252.</span>
<span class="cm"> *</span>
<span class="cm"> *      Fiala,E.R., and Greene,D.H.</span>
<span class="cm"> *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/zutil.h&gt;</span>
<span class="cp">#include &quot;defutil.h&quot;</span>


<span class="cm">/* ===========================================================================</span>
<span class="cm"> *  Function prototypes.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">need_more</span><span class="p">,</span>      <span class="cm">/* block not completed, need more input or more output */</span>
    <span class="n">block_done</span><span class="p">,</span>     <span class="cm">/* block flush performed */</span>
    <span class="n">finish_started</span><span class="p">,</span> <span class="cm">/* finish started, need only more output at next deflate */</span>
    <span class="n">finish_done</span>     <span class="cm">/* finish done, accept no more input or output */</span>
<span class="p">}</span> <span class="n">block_state</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">block_state</span> <span class="p">(</span><span class="o">*</span><span class="n">compress_func</span><span class="p">)</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">);</span>
<span class="cm">/* Compression function. Returns the block state after the call. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">fill_window</span>    <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="n">block_state</span> <span class="n">deflate_stored</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">);</span>
<span class="k">static</span> <span class="n">block_state</span> <span class="n">deflate_fast</span>   <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">);</span>
<span class="k">static</span> <span class="n">block_state</span> <span class="n">deflate_slow</span>   <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lm_init</span>        <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">putShortMSB</span>    <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">uInt</span> <span class="n">b</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">flush_pending</span>  <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">read_buf</span>        <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span> <span class="n">Byte</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="n">uInt</span> <span class="n">longest_match</span>  <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">IPos</span> <span class="n">cur_match</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_ZLIB</span>
<span class="k">static</span>  <span class="kt">void</span> <span class="n">check_match</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">IPos</span> <span class="n">start</span><span class="p">,</span> <span class="n">IPos</span> <span class="n">match</span><span class="p">,</span>
                         <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Local data</span>
<span class="cm"> */</span>

<span class="cp">#define NIL 0</span>
<span class="cm">/* Tail of hash chains */</span>

<span class="cp">#ifndef TOO_FAR</span>
<span class="cp">#  define TOO_FAR 4096</span>
<span class="cp">#endif</span>
<span class="cm">/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */</span>

<span class="cp">#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)</span>
<span class="cm">/* Minimum amount of lookahead, except at the end of the input file.</span>
<span class="cm"> * See deflate.c for comments about the MIN_MATCH+1.</span>
<span class="cm"> */</span>

<span class="cm">/* Values for max_lazy_match, good_match and max_chain_length, depending on</span>
<span class="cm"> * the desired pack level (0..9). The values given below have been tuned to</span>
<span class="cm"> * exclude worst case performance for pathological files. Better values may be</span>
<span class="cm"> * found for specific files.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">config_s</span> <span class="p">{</span>
   <span class="n">ush</span> <span class="n">good_length</span><span class="p">;</span> <span class="cm">/* reduce lazy search above this match length */</span>
   <span class="n">ush</span> <span class="n">max_lazy</span><span class="p">;</span>    <span class="cm">/* do not perform lazy search above this match length */</span>
   <span class="n">ush</span> <span class="n">nice_length</span><span class="p">;</span> <span class="cm">/* quit search above this match length */</span>
   <span class="n">ush</span> <span class="n">max_chain</span><span class="p">;</span>
   <span class="n">compress_func</span> <span class="n">func</span><span class="p">;</span>
<span class="p">}</span> <span class="n">config</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">config</span> <span class="n">configuration_table</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*      good lazy nice chain */</span>
<span class="cm">/* 0 */</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span> <span class="n">deflate_stored</span><span class="p">},</span>  <span class="cm">/* store only */</span>
<span class="cm">/* 1 */</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span>    <span class="mi">4</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>    <span class="mi">4</span><span class="p">,</span> <span class="n">deflate_fast</span><span class="p">},</span> <span class="cm">/* maximum speed, no lazy matches */</span>
<span class="cm">/* 2 */</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span>    <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>    <span class="mi">8</span><span class="p">,</span> <span class="n">deflate_fast</span><span class="p">},</span>
<span class="cm">/* 3 */</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span>    <span class="mi">6</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span>   <span class="mi">32</span><span class="p">,</span> <span class="n">deflate_fast</span><span class="p">},</span>

<span class="cm">/* 4 */</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span>    <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>   <span class="mi">16</span><span class="p">,</span> <span class="n">deflate_slow</span><span class="p">},</span>  <span class="cm">/* lazy matches */</span>
<span class="cm">/* 5 */</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span>   <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span>   <span class="mi">32</span><span class="p">,</span> <span class="n">deflate_slow</span><span class="p">},</span>
<span class="cm">/* 6 */</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span>   <span class="mi">16</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">deflate_slow</span><span class="p">},</span>
<span class="cm">/* 7 */</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span>   <span class="mi">32</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">deflate_slow</span><span class="p">},</span>
<span class="cm">/* 8 */</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">258</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">deflate_slow</span><span class="p">},</span>
<span class="cm">/* 9 */</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span> <span class="mi">258</span><span class="p">,</span> <span class="mi">258</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">deflate_slow</span><span class="p">}};</span> <span class="cm">/* maximum compression */</span>

<span class="cm">/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4</span>
<span class="cm"> * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different</span>
<span class="cm"> * meaning.</span>
<span class="cm"> */</span>

<span class="cp">#define EQUAL 0</span>
<span class="cm">/* result of memcmp for equal strings */</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Update a hash value with the given input byte</span>
<span class="cm"> * IN  assertion: all calls to UPDATE_HASH are made with consecutive</span>
<span class="cm"> *    input characters, so that a running hash key can be computed from the</span>
<span class="cm"> *    previous key instead of complete recalculation each time.</span>
<span class="cm"> */</span>
<span class="cp">#define UPDATE_HASH(s,h,c) (h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)</span>


<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Insert string str in the dictionary and set match_head to the previous head</span>
<span class="cm"> * of the hash chain (the most recent string with same hash key). Return</span>
<span class="cm"> * the previous length of the hash chain.</span>
<span class="cm"> * IN  assertion: all calls to INSERT_STRING are made with consecutive</span>
<span class="cm"> *    input characters and the first MIN_MATCH bytes of str are valid</span>
<span class="cm"> *    (except for the last MIN_MATCH-1 bytes of the input file).</span>
<span class="cm"> */</span>
<span class="cp">#define INSERT_STRING(s, str, match_head) \</span>
<span class="cp">   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \</span>
<span class="cp">    s-&gt;prev[(str) &amp; s-&gt;w_mask] = match_head = s-&gt;head[s-&gt;ins_h], \</span>
<span class="cp">    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Initialize the hash table (avoiding 64K overflow for 16 bit systems).</span>
<span class="cm"> * prev[] will be initialized on the fly.</span>
<span class="cm"> */</span>
<span class="cp">#define CLEAR_HASH(s) \</span>
<span class="cp">    s-&gt;head[s-&gt;hash_size-1] = NIL; \</span>
<span class="cp">    memset((char *)s-&gt;head, 0, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));</span>

<span class="cm">/* ========================================================================= */</span>
<span class="kt">int</span> <span class="nf">zlib_deflateInit2</span><span class="p">(</span>
	<span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span>
	<span class="kt">int</span>  <span class="n">level</span><span class="p">,</span>
	<span class="kt">int</span>  <span class="n">method</span><span class="p">,</span>
	<span class="kt">int</span>  <span class="n">windowBits</span><span class="p">,</span>
	<span class="kt">int</span>  <span class="n">memLevel</span><span class="p">,</span>
	<span class="kt">int</span>  <span class="n">strategy</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">noheader</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">deflate_workspace</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

    <span class="n">ush</span> <span class="o">*</span><span class="n">overlay</span><span class="p">;</span>
    <span class="cm">/* We overlay pending_buf and d_buf+l_buf. This works since the average</span>
<span class="cm">     * output size for (length,distance) codes is &lt;= 24 bits.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>

    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">Z_DEFAULT_COMPRESSION</span><span class="p">)</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

    <span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">deflate_workspace</span> <span class="o">*</span><span class="p">)</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">workspace</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">windowBits</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* undocumented feature: suppress zlib header */</span>
        <span class="n">noheader</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">windowBits</span> <span class="o">=</span> <span class="o">-</span><span class="n">windowBits</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memLevel</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">memLevel</span> <span class="o">&gt;</span> <span class="n">MAX_MEM_LEVEL</span> <span class="o">||</span> <span class="n">method</span> <span class="o">!=</span> <span class="n">Z_DEFLATED</span> <span class="o">||</span>
        <span class="n">windowBits</span> <span class="o">&lt;</span> <span class="mi">9</span> <span class="o">||</span> <span class="n">windowBits</span> <span class="o">&gt;</span> <span class="mi">15</span> <span class="o">||</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">9</span> <span class="o">||</span>
	<span class="n">strategy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">strategy</span> <span class="o">&gt;</span> <span class="n">Z_HUFFMAN_ONLY</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * Direct the workspace&#39;s pointers to the chunks that were allocated</span>
<span class="cm">     * along with the deflate_workspace struct.</span>
<span class="cm">     */</span>
    <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">mem</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mem</span><span class="p">);</span>
    <span class="n">mem</span><span class="o">-&gt;</span><span class="n">window_memory</span> <span class="o">=</span> <span class="p">(</span><span class="n">Byte</span> <span class="o">*</span><span class="p">)</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">+=</span> <span class="n">zlib_deflate_window_memsize</span><span class="p">(</span><span class="n">windowBits</span><span class="p">);</span>
    <span class="n">mem</span><span class="o">-&gt;</span><span class="n">prev_memory</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pos</span> <span class="o">*</span><span class="p">)</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">+=</span> <span class="n">zlib_deflate_prev_memsize</span><span class="p">(</span><span class="n">windowBits</span><span class="p">);</span>
    <span class="n">mem</span><span class="o">-&gt;</span><span class="n">head_memory</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pos</span> <span class="o">*</span><span class="p">)</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">+=</span> <span class="n">zlib_deflate_head_memsize</span><span class="p">(</span><span class="n">memLevel</span><span class="p">);</span>
    <span class="n">mem</span><span class="o">-&gt;</span><span class="n">overlay_memory</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">deflate_memory</span><span class="p">);</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">internal_state</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">strm</span> <span class="o">=</span> <span class="n">strm</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">noheader</span> <span class="o">=</span> <span class="n">noheader</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">w_bits</span> <span class="o">=</span> <span class="n">windowBits</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">w_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">w_bits</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">w_mask</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">w_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_bits</span> <span class="o">=</span> <span class="n">memLevel</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_bits</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_mask</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_shift</span> <span class="o">=</span>  <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_bits</span><span class="o">+</span><span class="n">MIN_MATCH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">MIN_MATCH</span><span class="p">);</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="p">(</span><span class="n">Byte</span> <span class="o">*</span><span class="p">)</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">window_memory</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev</span>   <span class="o">=</span> <span class="p">(</span><span class="n">Pos</span> <span class="o">*</span><span class="p">)</span>  <span class="n">mem</span><span class="o">-&gt;</span><span class="n">prev_memory</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">head</span>   <span class="o">=</span> <span class="p">(</span><span class="n">Pos</span> <span class="o">*</span><span class="p">)</span>  <span class="n">mem</span><span class="o">-&gt;</span><span class="n">head_memory</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_bufsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">memLevel</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span> <span class="cm">/* 16K elements by default */</span>

    <span class="n">overlay</span> <span class="o">=</span> <span class="p">(</span><span class="n">ush</span> <span class="o">*</span><span class="p">)</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">overlay_memory</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">uch</span> <span class="o">*</span><span class="p">)</span> <span class="n">overlay</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_buf_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_bufsize</span> <span class="o">*</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ush</span><span class="p">)</span><span class="o">+</span><span class="mi">2L</span><span class="p">);</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">d_buf</span> <span class="o">=</span> <span class="n">overlay</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_bufsize</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ush</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">l_buf</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_buf</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ush</span><span class="p">))</span><span class="o">*</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lit_bufsize</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">method</span> <span class="o">=</span> <span class="p">(</span><span class="n">Byte</span><span class="p">)</span><span class="n">method</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">zlib_deflateReset</span><span class="p">(</span><span class="n">strm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ========================================================================= */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int zlib_deflateSetDictionary(</span>
<span class="c">	z_streamp strm,</span>
<span class="c">	const Byte *dictionary,</span>
<span class="c">	uInt  dictLength</span>
<span class="c">)</span>
<span class="c">{</span>
<span class="c">    deflate_state *s;</span>
<span class="c">    uInt length = dictLength;</span>
<span class="c">    uInt n;</span>
<span class="c">    IPos hash_head = 0;</span>

<span class="c">    if (strm == NULL || strm-&gt;state == NULL || dictionary == NULL)</span>
<span class="c">	return Z_STREAM_ERROR;</span>

<span class="c">    s = (deflate_state *) strm-&gt;state;</span>
<span class="c">    if (s-&gt;status != INIT_STATE) return Z_STREAM_ERROR;</span>

<span class="c">    strm-&gt;adler = zlib_adler32(strm-&gt;adler, dictionary, dictLength);</span>

<span class="c">    if (length &lt; MIN_MATCH) return Z_OK;</span>
<span class="c">    if (length &gt; MAX_DIST(s)) {</span>
<span class="c">	length = MAX_DIST(s);</span>
<span class="cp">#ifndef USE_DICT_HEAD</span>
<span class="c">	dictionary += dictLength - length; /* use the tail of the dictionary */</span>
<span class="cp">#endif</span>
<span class="c">    }</span>
<span class="c">    memcpy((char *)s-&gt;window, dictionary, length);</span>
<span class="c">    s-&gt;strstart = length;</span>
<span class="c">    s-&gt;block_start = (long)length;</span>

<span class="c">    /* Insert all strings in the hash table (except for the last two bytes).</span>
<span class="c">     * s-&gt;lookahead stays null, so s-&gt;ins_h will be recomputed at the next</span>
<span class="c">     * call of fill_window.</span>
<span class="c">     */</span>
<span class="c">    s-&gt;ins_h = s-&gt;window[0];</span>
<span class="c">    UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[1]);</span>
<span class="c">    for (n = 0; n &lt;= length - MIN_MATCH; n++) {</span>
<span class="c">	INSERT_STRING(s, n, hash_head);</span>
<span class="c">    }</span>
<span class="c">    if (hash_head) hash_head = 0;  /* to make compiler happy */</span>
<span class="c">    return Z_OK;</span>
<span class="c">}</span>
<span class="cp">#endif  /*  0  */</span>

<span class="cm">/* ========================================================================= */</span>
<span class="kt">int</span> <span class="nf">zlib_deflateReset</span><span class="p">(</span>
	<span class="n">z_streamp</span> <span class="n">strm</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>

    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_in</span> <span class="o">=</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">Z_UNKNOWN</span><span class="p">;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="p">)</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_out</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_buf</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">noheader</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">noheader</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* was set to -1 by deflate(..., Z_FINISH); */</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">noheader</span> <span class="o">?</span> <span class="n">BUSY_STATE</span> <span class="o">:</span> <span class="n">INIT_STATE</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_flush</span> <span class="o">=</span> <span class="n">Z_NO_FLUSH</span><span class="p">;</span>

    <span class="n">zlib_tr_init</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">lm_init</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ========================================================================= */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int zlib_deflateParams(</span>
<span class="c">	z_streamp strm,</span>
<span class="c">	int level,</span>
<span class="c">	int strategy</span>
<span class="c">)</span>
<span class="c">{</span>
<span class="c">    deflate_state *s;</span>
<span class="c">    compress_func func;</span>
<span class="c">    int err = Z_OK;</span>

<span class="c">    if (strm == NULL || strm-&gt;state == NULL) return Z_STREAM_ERROR;</span>
<span class="c">    s = (deflate_state *) strm-&gt;state;</span>

<span class="c">    if (level == Z_DEFAULT_COMPRESSION) {</span>
<span class="c">	level = 6;</span>
<span class="c">    }</span>
<span class="c">    if (level &lt; 0 || level &gt; 9 || strategy &lt; 0 || strategy &gt; Z_HUFFMAN_ONLY) {</span>
<span class="c">	return Z_STREAM_ERROR;</span>
<span class="c">    }</span>
<span class="c">    func = configuration_table[s-&gt;level].func;</span>

<span class="c">    if (func != configuration_table[level].func &amp;&amp; strm-&gt;total_in != 0) {</span>
<span class="c">	/* Flush the last buffer: */</span>
<span class="c">	err = zlib_deflate(strm, Z_PARTIAL_FLUSH);</span>
<span class="c">    }</span>
<span class="c">    if (s-&gt;level != level) {</span>
<span class="c">	s-&gt;level = level;</span>
<span class="c">	s-&gt;max_lazy_match   = configuration_table[level].max_lazy;</span>
<span class="c">	s-&gt;good_match       = configuration_table[level].good_length;</span>
<span class="c">	s-&gt;nice_match       = configuration_table[level].nice_length;</span>
<span class="c">	s-&gt;max_chain_length = configuration_table[level].max_chain;</span>
<span class="c">    }</span>
<span class="c">    s-&gt;strategy = strategy;</span>
<span class="c">    return err;</span>
<span class="c">}</span>
<span class="cp">#endif  /*  0  */</span>

<span class="cm">/* =========================================================================</span>
<span class="cm"> * Put a short in the pending buffer. The 16-bit value is put in MSB order.</span>
<span class="cm"> * IN assertion: the stream state is correct and there is enough room in</span>
<span class="cm"> * pending_buf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">putShortMSB</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">uInt</span> <span class="n">b</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">put_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">Byte</span><span class="p">)(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">));</span>
    <span class="n">put_byte</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">Byte</span><span class="p">)(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">));</span>
<span class="p">}</span>   

<span class="cm">/* =========================================================================</span>
<span class="cm"> * Flush as much pending output as possible. All deflate() output goes</span>
<span class="cm"> * through this function so some applications may wish to modify it</span>
<span class="cm"> * to avoid allocating a large strm-&gt;next_out buffer and copying into it.</span>
<span class="cm"> * (See also read_buf()).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_pending</span><span class="p">(</span>
	<span class="n">z_streamp</span> <span class="n">strm</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="p">)</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span><span class="p">)</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_out</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_out</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_out</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_out</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span>  <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_out</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_buf</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ========================================================================= */</span>
<span class="kt">int</span> <span class="nf">zlib_deflate</span><span class="p">(</span>
	<span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flush</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">old_flush</span><span class="p">;</span> <span class="cm">/* value of flush param for previous deflate call */</span>
    <span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
	<span class="n">flush</span> <span class="o">&gt;</span> <span class="n">Z_FINISH</span> <span class="o">||</span> <span class="n">flush</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="p">)</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_in</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	<span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">FINISH_STATE</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span> <span class="o">!=</span> <span class="n">Z_FINISH</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">Z_BUF_ERROR</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">strm</span> <span class="o">=</span> <span class="n">strm</span><span class="p">;</span> <span class="cm">/* just in case */</span>
    <span class="n">old_flush</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_flush</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_flush</span> <span class="o">=</span> <span class="n">flush</span><span class="p">;</span>

    <span class="cm">/* Write the zlib header */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">INIT_STATE</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">uInt</span> <span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z_DEFLATED</span> <span class="o">+</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">w_bits</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">uInt</span> <span class="n">level_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">level_flags</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="n">level_flags</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">header</span> <span class="o">|=</span> <span class="p">(</span><span class="n">level_flags</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">header</span> <span class="o">|=</span> <span class="n">PRESET_DICT</span><span class="p">;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="mi">31</span> <span class="o">-</span> <span class="p">(</span><span class="n">header</span> <span class="o">%</span> <span class="mi">31</span><span class="p">);</span>

        <span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">BUSY_STATE</span><span class="p">;</span>
        <span class="n">putShortMSB</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>

	<span class="cm">/* Save the adler32 of the preset dictionary: */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">putShortMSB</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">uInt</span><span class="p">)(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
	    <span class="n">putShortMSB</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">uInt</span><span class="p">)(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="mi">1L</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Flush as much pending output as possible */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flush_pending</span><span class="p">(</span><span class="n">strm</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	    <span class="cm">/* Since avail_out is 0, deflate will be called again with</span>
<span class="cm">	     * more output space, but possibly with both pending and</span>
<span class="cm">	     * avail_in equal to zero. There won&#39;t be anything to do,</span>
<span class="cm">	     * but this is not an error situation so make sure we</span>
<span class="cm">	     * return OK instead of BUF_ERROR at next call of deflate:</span>
<span class="cm">             */</span>
	    <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_flush</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	    <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
	<span class="p">}</span>

    <span class="cm">/* Make sure there is something to do and avoid duplicate consecutive</span>
<span class="cm">     * flushes. For repeated and useless calls with Z_FINISH, we keep</span>
<span class="cm">     * returning Z_STREAM_END instead of Z_BUFF_ERROR.</span>
<span class="cm">     */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span> <span class="o">&lt;=</span> <span class="n">old_flush</span> <span class="o">&amp;&amp;</span>
	       <span class="n">flush</span> <span class="o">!=</span> <span class="n">Z_FINISH</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Z_BUF_ERROR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* User must not provide more input after the first FINISH: */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">FINISH_STATE</span> <span class="o">&amp;&amp;</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Z_BUF_ERROR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Start a new block or continue the current one.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">flush</span> <span class="o">!=</span> <span class="n">Z_NO_FLUSH</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">FINISH_STATE</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">block_state</span> <span class="n">bstate</span><span class="p">;</span>

	<span class="n">bstate</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">configuration_table</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">func</span><span class="p">))(</span><span class="n">s</span><span class="p">,</span> <span class="n">flush</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">bstate</span> <span class="o">==</span> <span class="n">finish_started</span> <span class="o">||</span> <span class="n">bstate</span> <span class="o">==</span> <span class="n">finish_done</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">FINISH_STATE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bstate</span> <span class="o">==</span> <span class="n">need_more</span> <span class="o">||</span> <span class="n">bstate</span> <span class="o">==</span> <span class="n">finish_started</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_flush</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* avoid BUF_ERROR next call, see above */</span>
	    <span class="p">}</span>
	    <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
	    <span class="cm">/* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call</span>
<span class="cm">	     * of deflate should use the same flush parameter to make sure</span>
<span class="cm">	     * that the flush is complete. So we don&#39;t have to output an</span>
<span class="cm">	     * empty block here, this will be done at next call. This also</span>
<span class="cm">	     * ensures that for a very small output buffer, we emit at most</span>
<span class="cm">	     * one empty block.</span>
<span class="cm">	     */</span>
	<span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bstate</span> <span class="o">==</span> <span class="n">block_done</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">==</span> <span class="n">Z_PARTIAL_FLUSH</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">zlib_tr_align</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">==</span> <span class="n">Z_PACKET_FLUSH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Output just the 3-bit `stored&#39; block type value,</span>
<span class="cm">		   but not a zero length. */</span>
		<span class="n">zlib_tr_stored_type_only</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* FULL_FLUSH or SYNC_FLUSH */</span>
                <span class="n">zlib_tr_stored_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0L</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="cm">/* For a full flush, this empty block will be recognized</span>
<span class="cm">                 * as a special marker by inflate_sync().</span>
<span class="cm">                 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">==</span> <span class="n">Z_FULL_FLUSH</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">CLEAR_HASH</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>             <span class="cm">/* forget history */</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">flush_pending</span><span class="p">(</span><span class="n">strm</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	      <span class="n">s</span><span class="o">-&gt;</span><span class="n">last_flush</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* avoid BUF_ERROR at next call, see above */</span>
	      <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
	    <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Assert</span><span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;bug2&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">!=</span> <span class="n">Z_FINISH</span><span class="p">)</span> <span class="k">return</span> <span class="n">Z_OK</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">noheader</span><span class="p">)</span> <span class="k">return</span> <span class="n">Z_STREAM_END</span><span class="p">;</span>

    <span class="cm">/* Write the zlib trailer (adler32) */</span>
    <span class="n">putShortMSB</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">uInt</span><span class="p">)(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
    <span class="n">putShortMSB</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">uInt</span><span class="p">)(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
    <span class="n">flush_pending</span><span class="p">(</span><span class="n">strm</span><span class="p">);</span>
    <span class="cm">/* If avail_out is zero, the application will call deflate again</span>
<span class="cm">     * to flush the rest.</span>
<span class="cm">     */</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">noheader</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* write the trailer only once! */</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">Z_OK</span> <span class="o">:</span> <span class="n">Z_STREAM_END</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ========================================================================= */</span>
<span class="kt">int</span> <span class="nf">zlib_deflateEnd</span><span class="p">(</span>
	<span class="n">z_streamp</span> <span class="n">strm</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strm</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">deflate_state</span> <span class="o">*</span><span class="p">)</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">INIT_STATE</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">!=</span> <span class="n">BUSY_STATE</span> <span class="o">&amp;&amp;</span>
	<span class="n">status</span> <span class="o">!=</span> <span class="n">FINISH_STATE</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Z_STREAM_ERROR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">status</span> <span class="o">==</span> <span class="n">BUSY_STATE</span> <span class="o">?</span> <span class="n">Z_DATA_ERROR</span> <span class="o">:</span> <span class="n">Z_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* =========================================================================</span>
<span class="cm"> * Copy the source state to the destination state.</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int zlib_deflateCopy (</span>
<span class="c">	z_streamp dest,</span>
<span class="c">	z_streamp source</span>
<span class="c">)</span>
<span class="c">{</span>
<span class="cp">#ifdef MAXSEG_64K</span>
<span class="c">    return Z_STREAM_ERROR;</span>
<span class="cp">#else</span>
<span class="c">    deflate_state *ds;</span>
<span class="c">    deflate_state *ss;</span>
<span class="c">    ush *overlay;</span>
<span class="c">    deflate_workspace *mem;</span>


<span class="c">    if (source == NULL || dest == NULL || source-&gt;state == NULL) {</span>
<span class="c">        return Z_STREAM_ERROR;</span>
<span class="c">    }</span>

<span class="c">    ss = (deflate_state *) source-&gt;state;</span>

<span class="c">    *dest = *source;</span>

<span class="c">    mem = (deflate_workspace *) dest-&gt;workspace;</span>

<span class="c">    ds = &amp;(mem-&gt;deflate_memory);</span>

<span class="c">    dest-&gt;state = (struct internal_state *) ds;</span>
<span class="c">    *ds = *ss;</span>
<span class="c">    ds-&gt;strm = dest;</span>

<span class="c">    ds-&gt;window = (Byte *) mem-&gt;window_memory;</span>
<span class="c">    ds-&gt;prev   = (Pos *)  mem-&gt;prev_memory;</span>
<span class="c">    ds-&gt;head   = (Pos *)  mem-&gt;head_memory;</span>
<span class="c">    overlay = (ush *) mem-&gt;overlay_memory;</span>
<span class="c">    ds-&gt;pending_buf = (uch *) overlay;</span>

<span class="c">    memcpy(ds-&gt;window, ss-&gt;window, ds-&gt;w_size * 2 * sizeof(Byte));</span>
<span class="c">    memcpy(ds-&gt;prev, ss-&gt;prev, ds-&gt;w_size * sizeof(Pos));</span>
<span class="c">    memcpy(ds-&gt;head, ss-&gt;head, ds-&gt;hash_size * sizeof(Pos));</span>
<span class="c">    memcpy(ds-&gt;pending_buf, ss-&gt;pending_buf, (uInt)ds-&gt;pending_buf_size);</span>

<span class="c">    ds-&gt;pending_out = ds-&gt;pending_buf + (ss-&gt;pending_out - ss-&gt;pending_buf);</span>
<span class="c">    ds-&gt;d_buf = overlay + ds-&gt;lit_bufsize/sizeof(ush);</span>
<span class="c">    ds-&gt;l_buf = ds-&gt;pending_buf + (1+sizeof(ush))*ds-&gt;lit_bufsize;</span>

<span class="c">    ds-&gt;l_desc.dyn_tree = ds-&gt;dyn_ltree;</span>
<span class="c">    ds-&gt;d_desc.dyn_tree = ds-&gt;dyn_dtree;</span>
<span class="c">    ds-&gt;bl_desc.dyn_tree = ds-&gt;bl_tree;</span>

<span class="c">    return Z_OK;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif  </span><span class="cm">/*  0  */</span><span class="cp"></span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Read a new buffer from the current input stream, update the adler32</span>
<span class="cm"> * and total number of bytes read.  All deflate() input goes through</span>
<span class="cm"> * this function so some applications may wish to modify it to avoid</span>
<span class="cm"> * allocating a large strm-&gt;next_in buffer and copying from it.</span>
<span class="cm"> * (See also flush_pending()).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">read_buf</span><span class="p">(</span>
	<span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span>
	<span class="n">Byte</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">size</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="n">len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span>  <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">deflate_state</span> <span class="o">*</span><span class="p">)(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">noheader</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span> <span class="o">=</span> <span class="n">zlib_adler32</span><span class="p">(</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">adler</span><span class="p">,</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_in</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_in</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">next_in</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">strm</span><span class="o">-&gt;</span><span class="n">total_in</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Initialize the &quot;longest match&quot; routines for a new zlib stream</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lm_init</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">window_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="mi">2L</span><span class="o">*</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">w_size</span><span class="p">;</span>

    <span class="n">CLEAR_HASH</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

    <span class="cm">/* Set the default configuration parameters:</span>
<span class="cm">     */</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_lazy_match</span>   <span class="o">=</span> <span class="n">configuration_table</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">max_lazy</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">good_match</span>       <span class="o">=</span> <span class="n">configuration_table</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">good_length</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">nice_match</span>       <span class="o">=</span> <span class="n">configuration_table</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">nice_length</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_chain_length</span> <span class="o">=</span> <span class="n">configuration_table</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">max_chain</span><span class="p">;</span>

    <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span> <span class="o">=</span> <span class="n">MIN_MATCH</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">ins_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Set match_start to the longest match starting at the given string and</span>
<span class="cm"> * return its length. Matches shorter or equal to prev_length are discarded,</span>
<span class="cm"> * in which case the result is equal to prev_length and match_start is</span>
<span class="cm"> * garbage.</span>
<span class="cm"> * IN assertions: cur_match is the head of the hash chain for the current</span>
<span class="cm"> *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1</span>
<span class="cm"> * OUT assertion: the match length is not greater than s-&gt;lookahead.</span>
<span class="cm"> */</span>
<span class="cm">/* For 80x86 and 680x0, an optimized version will be provided in match.asm or</span>
<span class="cm"> * match.S. The code will be functionally equivalent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">uInt</span> <span class="n">longest_match</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">IPos</span> <span class="n">cur_match</span>			<span class="cm">/* current match */</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">chain_length</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_chain_length</span><span class="p">;</span><span class="cm">/* max hash chain length */</span>
    <span class="k">register</span> <span class="n">Byte</span> <span class="o">*</span><span class="n">scan</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">;</span> <span class="cm">/* current string */</span>
    <span class="k">register</span> <span class="n">Byte</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>                       <span class="cm">/* matched string */</span>
    <span class="k">register</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>                           <span class="cm">/* length of current match */</span>
    <span class="kt">int</span> <span class="n">best_len</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span><span class="p">;</span>              <span class="cm">/* best match length so far */</span>
    <span class="kt">int</span> <span class="n">nice_match</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nice_match</span><span class="p">;</span>             <span class="cm">/* stop if match long enough */</span>
    <span class="n">IPos</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">IPos</span><span class="p">)</span><span class="n">MAX_DIST</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">?</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span> <span class="p">(</span><span class="n">IPos</span><span class="p">)</span><span class="n">MAX_DIST</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">NIL</span><span class="p">;</span>
    <span class="cm">/* Stop when cur_match becomes &lt;= limit. To simplify the code,</span>
<span class="cm">     * we prevent matches with the string of window index 0.</span>
<span class="cm">     */</span>
    <span class="n">Pos</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">uInt</span> <span class="n">wmask</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">w_mask</span><span class="p">;</span>

<span class="cp">#ifdef UNALIGNED_OK</span>
    <span class="cm">/* Compare two bytes at a time. Note: this is not always beneficial.</span>
<span class="cm">     * Try with and without -DUNALIGNED_OK to check.</span>
<span class="cm">     */</span>
    <span class="k">register</span> <span class="n">Byte</span> <span class="o">*</span><span class="n">strend</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">+</span> <span class="n">MAX_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">register</span> <span class="n">ush</span> <span class="n">scan_start</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)</span><span class="n">scan</span><span class="p">;</span>
    <span class="k">register</span> <span class="n">ush</span> <span class="n">scan_end</span>   <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">scan</span><span class="o">+</span><span class="n">best_len</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="k">register</span> <span class="n">Byte</span> <span class="o">*</span><span class="n">strend</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">+</span> <span class="n">MAX_MATCH</span><span class="p">;</span>
    <span class="k">register</span> <span class="n">Byte</span> <span class="n">scan_end1</span>  <span class="o">=</span> <span class="n">scan</span><span class="p">[</span><span class="n">best_len</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">register</span> <span class="n">Byte</span> <span class="n">scan_end</span>   <span class="o">=</span> <span class="n">scan</span><span class="p">[</span><span class="n">best_len</span><span class="p">];</span>
<span class="cp">#endif</span>

    <span class="cm">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.</span>
<span class="cm">     * It is easy to get rid of this optimization if necessary.</span>
<span class="cm">     */</span>
    <span class="n">Assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_bits</span> <span class="o">&gt;=</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">MAX_MATCH</span> <span class="o">==</span> <span class="mi">258</span><span class="p">,</span> <span class="s">&quot;Code too clever&quot;</span><span class="p">);</span>

    <span class="cm">/* Do not waste too much time if we already have a good match: */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">good_match</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">chain_length</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Do not look for matches beyond the end of the input. This is necessary</span>
<span class="cm">     * to make deflate deterministic.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">uInt</span><span class="p">)</span><span class="n">nice_match</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="p">)</span> <span class="n">nice_match</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="p">;</span>

    <span class="n">Assert</span><span class="p">((</span><span class="n">ulg</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="o">-</span><span class="n">MIN_LOOKAHEAD</span><span class="p">,</span> <span class="s">&quot;need lookahead&quot;</span><span class="p">);</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">cur_match</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">,</span> <span class="s">&quot;no future&quot;</span><span class="p">);</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="n">cur_match</span><span class="p">;</span>

        <span class="cm">/* Skip to next match if the match length cannot increase</span>
<span class="cm">         * or if the match length is less than 2:</span>
<span class="cm">         */</span>
<span class="cp">#if (defined(UNALIGNED_OK) &amp;&amp; MAX_MATCH == 258)</span>
        <span class="cm">/* This code assumes sizeof(unsigned short) == 2. Do not use</span>
<span class="cm">         * UNALIGNED_OK if your compiler uses a different size.</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">match</span><span class="o">+</span><span class="n">best_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">scan_end</span> <span class="o">||</span>
            <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)</span><span class="n">match</span> <span class="o">!=</span> <span class="n">scan_start</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* It is not necessary to compare scan[2] and match[2] since they are</span>
<span class="cm">         * always equal when the other bytes match, given that the hash keys</span>
<span class="cm">         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at</span>
<span class="cm">         * strstart+3, +5, ... up to strstart+257. We check for insufficient</span>
<span class="cm">         * lookahead only every 4th comparison; the 128th check will be made</span>
<span class="cm">         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is</span>
<span class="cm">         * necessary to put more guard bytes at the end of the window, or</span>
<span class="cm">         * to check more often for insufficient lookahead.</span>
<span class="cm">         */</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">scan</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;scan[2]?&quot;</span><span class="p">);</span>
        <span class="n">scan</span><span class="o">++</span><span class="p">,</span> <span class="n">match</span><span class="o">++</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">scan</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">match</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                 <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">scan</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">match</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                 <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">scan</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">match</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                 <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">scan</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">match</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                 <span class="n">scan</span> <span class="o">&lt;</span> <span class="n">strend</span><span class="p">);</span>
        <span class="cm">/* The funny &quot;do {}&quot; generates better code on most compilers */</span>

        <span class="cm">/* Here, scan &lt;= window+strstart+257 */</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">scan</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="o">+</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s">&quot;wild scan&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*</span><span class="n">match</span><span class="p">)</span> <span class="n">scan</span><span class="o">++</span><span class="p">;</span>

        <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">MAX_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">strend</span><span class="o">-</span><span class="n">scan</span><span class="p">);</span>
        <span class="n">scan</span> <span class="o">=</span> <span class="n">strend</span> <span class="o">-</span> <span class="p">(</span><span class="n">MAX_MATCH</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* UNALIGNED_OK */</span><span class="cp"></span>

        <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">best_len</span><span class="p">]</span>   <span class="o">!=</span> <span class="n">scan_end</span>  <span class="o">||</span>
            <span class="n">match</span><span class="p">[</span><span class="n">best_len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">scan_end1</span> <span class="o">||</span>
            <span class="o">*</span><span class="n">match</span>            <span class="o">!=</span> <span class="o">*</span><span class="n">scan</span>     <span class="o">||</span>
            <span class="o">*++</span><span class="n">match</span>          <span class="o">!=</span> <span class="n">scan</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>      <span class="k">continue</span><span class="p">;</span>

        <span class="cm">/* The check at best_len-1 can be removed because it will be made</span>
<span class="cm">         * again later. (This heuristic is not always a win.)</span>
<span class="cm">         * It is not necessary to compare scan[2] and match[2] since they</span>
<span class="cm">         * are always equal when the other bytes match, given that</span>
<span class="cm">         * the hash keys are equal and that HASH_BITS &gt;= 8.</span>
<span class="cm">         */</span>
        <span class="n">scan</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">match</span><span class="o">++</span><span class="p">;</span>
        <span class="n">Assert</span><span class="p">(</span><span class="o">*</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*</span><span class="n">match</span><span class="p">,</span> <span class="s">&quot;match[2]?&quot;</span><span class="p">);</span>

        <span class="cm">/* We check for insufficient lookahead only every 8th comparison;</span>
<span class="cm">         * the 256th check will be made at strstart+258.</span>
<span class="cm">         */</span>
        <span class="k">do</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*++</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*++</span><span class="n">match</span> <span class="o">&amp;&amp;</span> <span class="o">*++</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*++</span><span class="n">match</span> <span class="o">&amp;&amp;</span>
                 <span class="o">*++</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*++</span><span class="n">match</span> <span class="o">&amp;&amp;</span> <span class="o">*++</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*++</span><span class="n">match</span> <span class="o">&amp;&amp;</span>
                 <span class="o">*++</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*++</span><span class="n">match</span> <span class="o">&amp;&amp;</span> <span class="o">*++</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*++</span><span class="n">match</span> <span class="o">&amp;&amp;</span>
                 <span class="o">*++</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*++</span><span class="n">match</span> <span class="o">&amp;&amp;</span> <span class="o">*++</span><span class="n">scan</span> <span class="o">==</span> <span class="o">*++</span><span class="n">match</span> <span class="o">&amp;&amp;</span>
                 <span class="n">scan</span> <span class="o">&lt;</span> <span class="n">strend</span><span class="p">);</span>

        <span class="n">Assert</span><span class="p">(</span><span class="n">scan</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="o">+</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">window_size</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s">&quot;wild scan&quot;</span><span class="p">);</span>

        <span class="n">len</span> <span class="o">=</span> <span class="n">MAX_MATCH</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">strend</span> <span class="o">-</span> <span class="n">scan</span><span class="p">);</span>
        <span class="n">scan</span> <span class="o">=</span> <span class="n">strend</span> <span class="o">-</span> <span class="n">MAX_MATCH</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* UNALIGNED_OK */</span><span class="cp"></span>

        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">best_len</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_start</span> <span class="o">=</span> <span class="n">cur_match</span><span class="p">;</span>
            <span class="n">best_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">nice_match</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef UNALIGNED_OK</span>
            <span class="n">scan_end</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ush</span><span class="o">*</span><span class="p">)(</span><span class="n">scan</span><span class="o">+</span><span class="n">best_len</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#else</span>
            <span class="n">scan_end1</span>  <span class="o">=</span> <span class="n">scan</span><span class="p">[</span><span class="n">best_len</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">scan_end</span>   <span class="o">=</span> <span class="n">scan</span><span class="p">[</span><span class="n">best_len</span><span class="p">];</span>
<span class="cp">#endif</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">cur_match</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">cur_match</span> <span class="o">&amp;</span> <span class="n">wmask</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">limit</span>
             <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">chain_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">uInt</span><span class="p">)</span><span class="n">best_len</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="p">)</span> <span class="k">return</span> <span class="n">best_len</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DEBUG_ZLIB</span>
<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Check that the match at match_start is indeed a match.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">check_match</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="n">IPos</span> <span class="n">start</span><span class="p">,</span>
	<span class="n">IPos</span> <span class="n">match</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">length</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* check that the match is indeed a match */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="n">match</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EQUAL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot; start %u, match %u, length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">start</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
        <span class="k">do</span> <span class="p">{</span>
	    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%c%c&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">match</span><span class="o">++</span><span class="p">],</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">start</span><span class="o">++</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">z_error</span><span class="p">(</span><span class="s">&quot;invalid match&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">z_verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">[%d,%d]&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">-</span><span class="n">match</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
        <span class="k">do</span> <span class="p">{</span> <span class="n">putc</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">start</span><span class="o">++</span><span class="p">],</span> <span class="n">stderr</span><span class="p">);</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#  define check_match(s, start, match, length)</span>
<span class="cp">#endif</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Fill the window when the lookahead becomes insufficient.</span>
<span class="cm"> * Updates strstart and lookahead.</span>
<span class="cm"> *</span>
<span class="cm"> * IN assertion: lookahead &lt; MIN_LOOKAHEAD</span>
<span class="cm"> * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD</span>
<span class="cm"> *    At least one byte has been read, or avail_in == 0; reads are</span>
<span class="cm"> *    performed for at least two bytes (required for the zip translate_eol</span>
<span class="cm"> *    option -- not supported here).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">fill_window</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">register</span> <span class="n">Pos</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">more</span><span class="p">;</span>    <span class="cm">/* Amount of free space at the end of the window. */</span>
    <span class="n">uInt</span> <span class="n">wsize</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">w_size</span><span class="p">;</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="n">more</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">window_size</span> <span class="o">-</span><span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">-</span><span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">);</span>

        <span class="cm">/* Deal with !@#$% 64K limit: */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">more</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">more</span> <span class="o">=</span> <span class="n">wsize</span><span class="p">;</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">more</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* Very unlikely, but possible on 16 bit machine if strstart == 0</span>
<span class="cm">             * and lookahead == 1 (input done one byte at time)</span>
<span class="cm">             */</span>
            <span class="n">more</span><span class="o">--</span><span class="p">;</span>

        <span class="cm">/* If the window is almost full and there is insufficient lookahead,</span>
<span class="cm">         * move the upper half to the lower one to make room in the upper half.</span>
<span class="cm">         */</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">&gt;=</span> <span class="n">wsize</span><span class="o">+</span><span class="n">MAX_DIST</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>

            <span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="o">+</span><span class="n">wsize</span><span class="p">,</span>
                   <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">wsize</span><span class="p">);</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_start</span> <span class="o">-=</span> <span class="n">wsize</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span>    <span class="o">-=</span> <span class="n">wsize</span><span class="p">;</span> <span class="cm">/* we now have strstart &gt;= MAX_DIST */</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">wsize</span><span class="p">;</span>

            <span class="cm">/* Slide the hash table (could be avoided with 32 bit values</span>
<span class="cm">               at the expense of memory usage). We slide even when level == 0</span>
<span class="cm">               to keep the hash table consistent if we switch back to level &gt; 0</span>
<span class="cm">               later. (Using level 0 permanently is not an optimal usage of</span>
<span class="cm">               zlib, so we don&#39;t care about this pathological case.)</span>
<span class="cm">             */</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="n">m</span> <span class="o">=</span> <span class="o">*--</span><span class="n">p</span><span class="p">;</span>
                <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pos</span><span class="p">)(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">wsize</span> <span class="o">?</span> <span class="n">m</span><span class="o">-</span><span class="n">wsize</span> <span class="o">:</span> <span class="n">NIL</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span><span class="p">);</span>

            <span class="n">n</span> <span class="o">=</span> <span class="n">wsize</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="n">m</span> <span class="o">=</span> <span class="o">*--</span><span class="n">p</span><span class="p">;</span>
                <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pos</span><span class="p">)(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">wsize</span> <span class="o">?</span> <span class="n">m</span><span class="o">-</span><span class="n">wsize</span> <span class="o">:</span> <span class="n">NIL</span><span class="p">);</span>
                <span class="cm">/* If n is not on any hash chain, prev[n] is garbage but</span>
<span class="cm">                 * its value will never be used.</span>
<span class="cm">                 */</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span><span class="p">);</span>
            <span class="n">more</span> <span class="o">+=</span> <span class="n">wsize</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="cm">/* If there was no sliding:</span>
<span class="cm">         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;</span>
<span class="cm">         *    more == window_size - lookahead - strstart</span>
<span class="cm">         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)</span>
<span class="cm">         * =&gt; more &gt;= window_size - 2*WSIZE + 2</span>
<span class="cm">         * In the BIG_MEM or MMAP case (not yet supported),</span>
<span class="cm">         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;</span>
<span class="cm">         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.</span>
<span class="cm">         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.</span>
<span class="cm">         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.</span>
<span class="cm">         */</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">more</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;more &lt; 2&quot;</span><span class="p">);</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">read_buf</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strm</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="p">,</span> <span class="n">more</span><span class="p">);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

        <span class="cm">/* Initialize the hash value now that we have some input: */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&gt;=</span> <span class="n">MIN_MATCH</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">ins_h</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">];</span>
            <span class="n">UPDATE_HASH</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ins_h</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="cp">#if MIN_MATCH != 3</span>
            <span class="n">Call</span> <span class="n">UPDATE_HASH</span><span class="p">()</span> <span class="n">MIN_MATCH</span><span class="o">-</span><span class="mi">3</span> <span class="n">more</span> <span class="n">times</span>
<span class="cp">#endif</span>
        <span class="p">}</span>
        <span class="cm">/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,</span>
<span class="cm">         * but this is not important since only literal bytes will be emitted.</span>
<span class="cm">         */</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&lt;</span> <span class="n">MIN_LOOKAHEAD</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_in</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Flush the current block, with given end-of-file flag.</span>
<span class="cm"> * IN assertion: strstart is set to the end of the current match.</span>
<span class="cm"> */</span>
<span class="cp">#define FLUSH_BLOCK_ONLY(s, eof) { \</span>
<span class="cp">   zlib_tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? \</span>
<span class="cp">                   (char *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : \</span>
<span class="cp">                   NULL), \</span>
<span class="cp">		(ulg)((long)s-&gt;strstart - s-&gt;block_start), \</span>
<span class="cp">		(eof)); \</span>
<span class="cp">   s-&gt;block_start = s-&gt;strstart; \</span>
<span class="cp">   flush_pending(s-&gt;strm); \</span>
<span class="cp">   Tracev((stderr,&quot;[FLUSH]&quot;)); \</span>
<span class="cp">}</span>

<span class="cm">/* Same but force premature exit if necessary. */</span>
<span class="cp">#define FLUSH_BLOCK(s, eof) { \</span>
<span class="cp">   FLUSH_BLOCK_ONLY(s, eof); \</span>
<span class="cp">   if (s-&gt;strm-&gt;avail_out == 0) return (eof) ? finish_started : need_more; \</span>
<span class="cp">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Copy without compression as much as possible from the input stream, return</span>
<span class="cm"> * the current block state.</span>
<span class="cm"> * This function does not insert new strings in the dictionary since</span>
<span class="cm"> * uncompressible data is probably not useful. This function is used</span>
<span class="cm"> * only for the level=0 compression option.</span>
<span class="cm"> * NOTE: this function should be optimized to avoid extra copying from</span>
<span class="cm"> * window to pending_buf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">block_state</span> <span class="n">deflate_stored</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flush</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Stored blocks are limited to 0xffff bytes, pending_buf is limited</span>
<span class="cm">     * to pending_buf_size, and each stored block has a 5 byte header:</span>
<span class="cm">     */</span>
    <span class="n">ulg</span> <span class="n">max_block_size</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="n">ulg</span> <span class="n">max_start</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">max_block_size</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_buf_size</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_block_size</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pending_buf_size</span> <span class="o">-</span> <span class="mi">5</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Copy as much as possible from input to output: */</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* Fill the window as much as possible: */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

            <span class="n">Assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">w_size</span><span class="o">+</span><span class="n">MAX_DIST</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">||</span>
		   <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">w_size</span><span class="p">,</span> <span class="s">&quot;slide too late&quot;</span><span class="p">);</span>

            <span class="n">fill_window</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_NO_FLUSH</span><span class="p">)</span> <span class="k">return</span> <span class="n">need_more</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* flush the current block */</span>
        <span class="p">}</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&gt;=</span> <span class="mi">0L</span><span class="p">,</span> <span class="s">&quot;block gone&quot;</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Emit a stored block if pending_buf will be full: */</span>
 	<span class="n">max_start</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">+</span> <span class="n">max_block_size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">ulg</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">&gt;=</span> <span class="n">max_start</span><span class="p">)</span> <span class="p">{</span>
	    <span class="cm">/* strstart == 0 is possible when wraparound on 16-bit machine */</span>
	    <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">=</span> <span class="p">(</span><span class="n">uInt</span><span class="p">)(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span> <span class="n">max_start</span><span class="p">);</span>
	    <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">uInt</span><span class="p">)</span><span class="n">max_start</span><span class="p">;</span>
            <span class="n">FLUSH_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Flush if we may have to slide, otherwise block_start may become</span>
<span class="cm">         * negative and the data will be gone:</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span> <span class="p">(</span><span class="n">uInt</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">MAX_DIST</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">FLUSH_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FLUSH_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_FINISH</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_FINISH</span> <span class="o">?</span> <span class="n">finish_done</span> <span class="o">:</span> <span class="n">block_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Compress as much as possible from the input stream, return the current</span>
<span class="cm"> * block state.</span>
<span class="cm"> * This function does not perform lazy evaluation of matches and inserts</span>
<span class="cm"> * new strings in the dictionary only for unmatched strings or for short</span>
<span class="cm"> * matches. It is used only for the fast compression options.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">block_state</span> <span class="n">deflate_fast</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flush</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">IPos</span> <span class="n">hash_head</span> <span class="o">=</span> <span class="n">NIL</span><span class="p">;</span> <span class="cm">/* head of the hash chain */</span>
    <span class="kt">int</span> <span class="n">bflush</span><span class="p">;</span>           <span class="cm">/* set if current block must be flushed */</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* Make sure that we always have enough lookahead, except</span>
<span class="cm">         * at the end of the input file. We need MAX_MATCH bytes</span>
<span class="cm">         * for the next match, plus MIN_MATCH bytes to insert the</span>
<span class="cm">         * string following the next match.</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&lt;</span> <span class="n">MIN_LOOKAHEAD</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fill_window</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&lt;</span> <span class="n">MIN_LOOKAHEAD</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_NO_FLUSH</span><span class="p">)</span> <span class="p">{</span>
	        <span class="k">return</span> <span class="n">need_more</span><span class="p">;</span>
	    <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* flush the current block */</span>
        <span class="p">}</span>

        <span class="cm">/* Insert the string window[strstart .. strstart+2] in the</span>
<span class="cm">         * dictionary, and set hash_head to the head of the hash chain:</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&gt;=</span> <span class="n">MIN_MATCH</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">INSERT_STRING</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Find the longest match, discarding those &lt;= prev_length.</span>
<span class="cm">         * At this point we have always match_length &lt; MIN_MATCH</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash_head</span> <span class="o">!=</span> <span class="n">NIL</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span> <span class="n">hash_head</span> <span class="o">&lt;=</span> <span class="n">MAX_DIST</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* To simplify the code, we prevent matches with the string</span>
<span class="cm">             * of window index 0 (in particular we have to avoid a match</span>
<span class="cm">             * of the string with itself at the start of the input file).</span>
<span class="cm">             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strategy</span> <span class="o">!=</span> <span class="n">Z_HUFFMAN_ONLY</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">=</span> <span class="n">longest_match</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="cm">/* longest_match() sets match_start */</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">&gt;=</span> <span class="n">MIN_MATCH</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">check_match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_start</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span><span class="p">);</span>

            <span class="n">bflush</span> <span class="o">=</span> <span class="n">zlib_tr_tally</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_start</span><span class="p">,</span>
                               <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">-</span> <span class="n">MIN_MATCH</span><span class="p">);</span>

            <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">-=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span><span class="p">;</span>

            <span class="cm">/* Insert new strings in the hash table only if the match length</span>
<span class="cm">             * is not too large. This saves time but degrades compression.</span>
<span class="cm">             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_insert_length</span> <span class="o">&amp;&amp;</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&gt;=</span> <span class="n">MIN_MATCH</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* string at strstart already in hash table */</span>
                <span class="k">do</span> <span class="p">{</span>
                    <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">INSERT_STRING</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">);</span>
                    <span class="cm">/* strstart never exceeds WSIZE-MAX_MATCH, so there are</span>
<span class="cm">                     * always MIN_MATCH bytes ahead.</span>
<span class="cm">                     */</span>
                <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">++</span><span class="p">;</span> 
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span><span class="p">;</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">ins_h</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">];</span>
                <span class="n">UPDATE_HASH</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ins_h</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="cp">#if MIN_MATCH != 3</span>
                <span class="n">Call</span> <span class="n">UPDATE_HASH</span><span class="p">()</span> <span class="n">MIN_MATCH</span><span class="o">-</span><span class="mi">3</span> <span class="n">more</span> <span class="n">times</span>
<span class="cp">#endif</span>
                <span class="cm">/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not</span>
<span class="cm">                 * matter since it will be recomputed at next deflate call.</span>
<span class="cm">                 */</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* No match, output a literal byte */</span>
            <span class="n">Tracevv</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">]));</span>
            <span class="n">bflush</span> <span class="o">=</span> <span class="n">zlib_tr_tally</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">]);</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="o">--</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">++</span><span class="p">;</span> 
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bflush</span><span class="p">)</span> <span class="n">FLUSH_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">FLUSH_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_FINISH</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_FINISH</span> <span class="o">?</span> <span class="n">finish_done</span> <span class="o">:</span> <span class="n">block_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ===========================================================================</span>
<span class="cm"> * Same as above, but achieves better compression. We use a lazy</span>
<span class="cm"> * evaluation for matches: a match is finally adopted only if there is</span>
<span class="cm"> * no better match at the next window position.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">block_state</span> <span class="n">deflate_slow</span><span class="p">(</span>
	<span class="n">deflate_state</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flush</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">IPos</span> <span class="n">hash_head</span> <span class="o">=</span> <span class="n">NIL</span><span class="p">;</span>    <span class="cm">/* head of hash chain */</span>
    <span class="kt">int</span> <span class="n">bflush</span><span class="p">;</span>              <span class="cm">/* set if current block must be flushed */</span>

    <span class="cm">/* Process the input block. */</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* Make sure that we always have enough lookahead, except</span>
<span class="cm">         * at the end of the input file. We need MAX_MATCH bytes</span>
<span class="cm">         * for the next match, plus MIN_MATCH bytes to insert the</span>
<span class="cm">         * string following the next match.</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&lt;</span> <span class="n">MIN_LOOKAHEAD</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fill_window</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&lt;</span> <span class="n">MIN_LOOKAHEAD</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_NO_FLUSH</span><span class="p">)</span> <span class="p">{</span>
	        <span class="k">return</span> <span class="n">need_more</span><span class="p">;</span>
	    <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* flush the current block */</span>
        <span class="p">}</span>

        <span class="cm">/* Insert the string window[strstart .. strstart+2] in the</span>
<span class="cm">         * dictionary, and set hash_head to the head of the hash chain:</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">&gt;=</span> <span class="n">MIN_MATCH</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">INSERT_STRING</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* Find the longest match, discarding those &lt;= prev_length.</span>
<span class="cm">         */</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_match</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_start</span><span class="p">;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">=</span> <span class="n">MIN_MATCH</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">hash_head</span> <span class="o">!=</span> <span class="n">NIL</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">max_lazy_match</span> <span class="o">&amp;&amp;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span> <span class="n">hash_head</span> <span class="o">&lt;=</span> <span class="n">MAX_DIST</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* To simplify the code, we prevent matches with the string</span>
<span class="cm">             * of window index 0 (in particular we have to avoid a match</span>
<span class="cm">             * of the string with itself at the start of the input file).</span>
<span class="cm">             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strategy</span> <span class="o">!=</span> <span class="n">Z_HUFFMAN_ONLY</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">=</span> <span class="n">longest_match</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="cm">/* longest_match() sets match_start */</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strategy</span> <span class="o">==</span> <span class="n">Z_FILTERED</span> <span class="o">||</span>
                 <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">==</span> <span class="n">MIN_MATCH</span> <span class="o">&amp;&amp;</span>
                  <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_start</span> <span class="o">&gt;</span> <span class="n">TOO_FAR</span><span class="p">)))</span> <span class="p">{</span>

                <span class="cm">/* If prev_match is also MIN_MATCH, match_start is garbage</span>
<span class="cm">                 * but we will ignore the current match anyway.</span>
<span class="cm">                 */</span>
                <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">=</span> <span class="n">MIN_MATCH</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* If there was a match at the previous step and the current</span>
<span class="cm">         * match is not better, output the previous match:</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span> <span class="o">&gt;=</span> <span class="n">MIN_MATCH</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">uInt</span> <span class="n">max_insert</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">-</span> <span class="n">MIN_MATCH</span><span class="p">;</span>
            <span class="cm">/* Do not insert strings in hash table beyond this. */</span>

            <span class="n">check_match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_match</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span><span class="p">);</span>

            <span class="n">bflush</span> <span class="o">=</span> <span class="n">zlib_tr_tally</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_match</span><span class="p">,</span>
				   <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span> <span class="o">-</span> <span class="n">MIN_MATCH</span><span class="p">);</span>

            <span class="cm">/* Insert in hash table all strings up to the end of the match.</span>
<span class="cm">             * strstart-1 and strstart are already inserted. If there is not</span>
<span class="cm">             * enough lookahead, the last two strings are not inserted in</span>
<span class="cm">             * the hash table.</span>
<span class="cm">             */</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span> <span class="o">-=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span> <span class="o">&lt;=</span> <span class="n">max_insert</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">INSERT_STRING</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="p">,</span> <span class="n">hash_head</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">prev_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_length</span> <span class="o">=</span> <span class="n">MIN_MATCH</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">++</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">bflush</span><span class="p">)</span> <span class="n">FLUSH_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">match_available</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* If there was no match at the previous position, output a</span>
<span class="cm">             * single literal. If there was a match but the current match</span>
<span class="cm">             * is longer, truncate the previous match to a single literal.</span>
<span class="cm">             */</span>
            <span class="n">Tracevv</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">-</span><span class="mi">1</span><span class="p">]));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">zlib_tr_tally</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
                <span class="n">FLUSH_BLOCK_ONLY</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">++</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="o">--</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strm</span><span class="o">-&gt;</span><span class="n">avail_out</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">need_more</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* There is no previous match to compare with, wait for</span>
<span class="cm">             * the next step to decide.</span>
<span class="cm">             */</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_available</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">++</span><span class="p">;</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">lookahead</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Assert</span> <span class="p">(</span><span class="n">flush</span> <span class="o">!=</span> <span class="n">Z_NO_FLUSH</span><span class="p">,</span> <span class="s">&quot;no flush?&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">match_available</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Tracevv</span><span class="p">((</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">-</span><span class="mi">1</span><span class="p">]));</span>
        <span class="n">zlib_tr_tally</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">strstart</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">match_available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">FLUSH_BLOCK</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_FINISH</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">flush</span> <span class="o">==</span> <span class="n">Z_FINISH</span> <span class="o">?</span> <span class="n">finish_done</span> <span class="o">:</span> <span class="n">block_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">zlib_deflate_workspacesize</span><span class="p">(</span><span class="kt">int</span> <span class="n">windowBits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">memLevel</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">windowBits</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* undocumented feature: suppress zlib header */</span>
        <span class="n">windowBits</span> <span class="o">=</span> <span class="o">-</span><span class="n">windowBits</span><span class="p">;</span>

    <span class="cm">/* Since the return value is typically passed to vmalloc() unchecked... */</span>
    <span class="n">BUG_ON</span><span class="p">(</span><span class="n">memLevel</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">memLevel</span> <span class="o">&gt;</span> <span class="n">MAX_MEM_LEVEL</span> <span class="o">||</span> <span class="n">windowBits</span> <span class="o">&lt;</span> <span class="mi">9</span> <span class="o">||</span>
							<span class="n">windowBits</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">deflate_workspace</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">zlib_deflate_window_memsize</span><span class="p">(</span><span class="n">windowBits</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">zlib_deflate_prev_memsize</span><span class="p">(</span><span class="n">windowBits</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">zlib_deflate_head_memsize</span><span class="p">(</span><span class="n">memLevel</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">zlib_deflate_overlay_memsize</span><span class="p">(</span><span class="n">memLevel</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
