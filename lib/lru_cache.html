<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › lru_cache.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>lru_cache.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">   lru_cache.c</span>

<span class="cm">   This file is part of DRBD by Philipp Reisner and Lars Ellenberg.</span>

<span class="cm">   Copyright (C) 2003-2008, LINBIT Information Technologies GmbH.</span>
<span class="cm">   Copyright (C) 2003-2008, Philipp Reisner &lt;philipp.reisner@linbit.com&gt;.</span>
<span class="cm">   Copyright (C) 2003-2008, Lars Ellenberg &lt;lars.ellenberg@linbit.com&gt;.</span>

<span class="cm">   drbd is free software; you can redistribute it and/or modify</span>
<span class="cm">   it under the terms of the GNU General Public License as published by</span>
<span class="cm">   the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm">   any later version.</span>

<span class="cm">   drbd is distributed in the hope that it will be useful,</span>
<span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">   GNU General Public License for more details.</span>

<span class="cm">   You should have received a copy of the GNU General Public License</span>
<span class="cm">   along with drbd; see the file COPYING.  If not, write to</span>
<span class="cm">   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt; </span><span class="cm">/* for memset */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/seq_file.h&gt; </span><span class="cm">/* for seq_printf */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/lru_cache.h&gt;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Philipp Reisner &lt;phil@linbit.com&gt;, &quot;</span>
	      <span class="s">&quot;Lars Ellenberg &lt;lars@linbit.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;lru_cache - Track sets of hot objects&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* this is developers aid only.</span>
<span class="cm"> * it catches concurrent access (lack of locking on the users part) */</span>
<span class="cp">#define PARANOIA_ENTRY() do {		\</span>
<span class="cp">	BUG_ON(!lc);			\</span>
<span class="cp">	BUG_ON(!lc-&gt;nr_elements);	\</span>
<span class="cp">	BUG_ON(test_and_set_bit(__LC_PARANOIA, &amp;lc-&gt;flags)); \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define RETURN(x...)     do { \</span>
<span class="cp">	clear_bit(__LC_PARANOIA, &amp;lc-&gt;flags); \</span>
<span class="cp">	smp_mb__after_clear_bit(); return x ; } while (0)</span>

<span class="cm">/* BUG() if e is not one of the elements tracked by lc */</span>
<span class="cp">#define PARANOIA_LC_ELEMENT(lc, e) do {	\</span>
<span class="cp">	struct lru_cache *lc_ = (lc);	\</span>
<span class="cp">	struct lc_element *e_ = (e);	\</span>
<span class="cp">	unsigned i = e_-&gt;lc_index;	\</span>
<span class="cp">	BUG_ON(i &gt;= lc_-&gt;nr_elements);	\</span>
<span class="cp">	BUG_ON(lc_-&gt;lc_element[i] != e_); } while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * lc_create - prepares to track objects in an active set</span>
<span class="cm"> * @name: descriptive name only used in lc_seq_printf_stats and lc_seq_dump_details</span>
<span class="cm"> * @e_count: number of elements allowed to be active simultaneously</span>
<span class="cm"> * @e_size: size of the tracked objects</span>
<span class="cm"> * @e_off: offset to the &amp;struct lc_element member in a tracked object</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to a newly initialized struct lru_cache on success,</span>
<span class="cm"> * or NULL on (allocation) failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="nf">lc_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">e_count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">e_size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">e_off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">**</span><span class="n">element</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cache_obj_size</span> <span class="o">=</span> <span class="n">kmem_cache_size</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cache_obj_size</span> <span class="o">&lt;</span> <span class="n">e_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_obj_size</span> <span class="o">&lt;</span> <span class="n">e_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* e_count too big; would probably fail the allocation below anyways.</span>
<span class="cm">	 * for typical use cases, e_count should be few thousand at most. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e_count</span> <span class="o">&gt;</span> <span class="n">LC_MAX_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">e_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="n">element</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">e_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">element</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">lc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>

	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">element_size</span> <span class="o">=</span> <span class="n">e_size</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">element_off</span> <span class="o">=</span> <span class="n">e_off</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span> <span class="o">=</span> <span class="n">e_count</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">new_number</span> <span class="o">=</span> <span class="n">LC_FREE</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_cache</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_element</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>

	<span class="cm">/* preallocate all objects */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">element_size</span><span class="p">);</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">e_off</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_number</span> <span class="o">=</span> <span class="n">LC_FREE</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
		<span class="n">element</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">e_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lc</span><span class="p">;</span>

	<span class="cm">/* else: could not allocate all elements, give up */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">element</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">e_off</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>
<span class="nl">out_fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">lc_free_by_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_element</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">-=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">element_off</span><span class="p">;</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_cache</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_destroy - frees memory allocated by lc_create()</span>
<span class="cm"> * @lc: the lru cache to destroy</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lc_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lc_free_by_index</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_element</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_slot</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_reset - does a full reset for @lc and the hash table slots.</span>
<span class="cm"> * @lc: the lru cache to operate on</span>
<span class="cm"> *</span>
<span class="cm"> * It is roughly the equivalent of re-allocating a fresh lru_cache object,</span>
<span class="cm"> * basically a short cut to lc_destroy(lc); lc = lc_create(...);</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lc_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">hits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">misses</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">starving</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">changing_element</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">new_number</span> <span class="o">=</span> <span class="n">LC_FREE</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_slot</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_element</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">-=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">element_off</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">element_size</span><span class="p">);</span>
		<span class="cm">/* re-init it */</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_number</span> <span class="o">=</span> <span class="n">LC_FREE</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_seq_printf_stats - print stats about @lc into @seq</span>
<span class="cm"> * @seq: the seq_file to print into</span>
<span class="cm"> * @lc: the lru cache to print statistics of</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">lc_seq_printf_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* NOTE:</span>
<span class="cm">	 * total calls to lc_get are</span>
<span class="cm">	 * (starving + hits + misses)</span>
<span class="cm">	 * misses include &quot;dirty&quot; count (update from an other thread in</span>
<span class="cm">	 * progress) and &quot;changed&quot;, when this in fact lead to an successful</span>
<span class="cm">	 * update of the cache.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%s: used:%u/%u &quot;</span>
		<span class="s">&quot;hits:%lu misses:%lu starving:%lu dirty:%lu changed:%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">lc</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">,</span>
		<span class="n">lc</span><span class="o">-&gt;</span><span class="n">hits</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">misses</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">starving</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">changed</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="nf">lc_hash_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>  <span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_slot</span> <span class="o">+</span> <span class="p">(</span><span class="n">enr</span> <span class="o">%</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lc_find - find element by label, if present in the hash table</span>
<span class="cm"> * @lc: The lru_cache object</span>
<span class="cm"> * @enr: element number</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the pointer to an element, if the element with the requested</span>
<span class="cm"> * &quot;label&quot; or element number is present in the hash table,</span>
<span class="cm"> * or NULL if not found. Does not change the refcnt.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="nf">lc_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">lc</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">lc_hash_slot</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">enr</span><span class="p">),</span> <span class="n">colision</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_number</span> <span class="o">==</span> <span class="n">enr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returned element will be &quot;recycled&quot; immediately */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="nf">lc_evict</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lc_element</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">PARANOIA_LC_ELEMENT</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">colision</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_del - removes an element from the cache</span>
<span class="cm"> * @lc: The lru_cache object</span>
<span class="cm"> * @e: The element to remove</span>
<span class="cm"> *</span>
<span class="cm"> * @e must be unused (refcnt == 0). Moves @e from &quot;lru&quot; to &quot;free&quot; list,</span>
<span class="cm"> * sets @e-&gt;enr to %LC_FREE.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lc_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PARANOIA_ENTRY</span><span class="p">();</span>
	<span class="n">PARANOIA_LC_ELEMENT</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_number</span> <span class="o">=</span> <span class="n">LC_FREE</span><span class="p">;</span>
	<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">colision</span><span class="p">);</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="n">RETURN</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="nf">lc_get_unused_element</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">lc_evict</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lc_element</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lc_unused_element_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* something on the free list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* something to evict */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lc_get - get element by label, maybe change the active set</span>
<span class="cm"> * @lc: the lru cache to operate on</span>
<span class="cm"> * @enr: the label to look up</span>
<span class="cm"> *</span>
<span class="cm"> * Finds an element in the cache, increases its usage count,</span>
<span class="cm"> * &quot;touches&quot; and returns it.</span>
<span class="cm"> *</span>
<span class="cm"> * In case the requested number is not present, it needs to be added to the</span>
<span class="cm"> * cache. Therefore it is possible that an other element becomes evicted from</span>
<span class="cm"> * the cache. In either case, the user is notified so he is able to e.g. keep</span>
<span class="cm"> * a persistent log of the cache changes, and therefore the objects in use.</span>
<span class="cm"> *</span>
<span class="cm"> * Return values:</span>
<span class="cm"> *  NULL</span>
<span class="cm"> *     The cache was marked %LC_STARVING,</span>
<span class="cm"> *     or the requested label was not in the active set</span>
<span class="cm"> *     and a changing transaction is still pending (@lc was marked %LC_DIRTY).</span>
<span class="cm"> *     Or no unused or free element could be recycled (@lc will be marked as</span>
<span class="cm"> *     %LC_STARVING, blocking further lc_get() operations).</span>
<span class="cm"> *</span>
<span class="cm"> *  pointer to the element with the REQUESTED element number.</span>
<span class="cm"> *     In this case, it can be used right away</span>
<span class="cm"> *</span>
<span class="cm"> *  pointer to an UNUSED element with some different element number,</span>
<span class="cm"> *          where that different number may also be %LC_FREE.</span>
<span class="cm"> *</span>
<span class="cm"> *          In this case, the cache is marked %LC_DIRTY (blocking further changes),</span>
<span class="cm"> *          and the returned element pointer is removed from the lru list and</span>
<span class="cm"> *          hash collision chains.  The user now should do whatever housekeeping</span>
<span class="cm"> *          is necessary.</span>
<span class="cm"> *          Then he must call lc_changed(lc,element_pointer), to finish</span>
<span class="cm"> *          the change.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The user needs to check the lc_number on EACH use, so he recognizes</span>
<span class="cm"> *       any cache set change.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="nf">lc_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">PARANOIA_ENTRY</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LC_STARVING</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">starving</span><span class="p">;</span>
		<span class="n">RETURN</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">lc_find</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">enr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">hits</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lc</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">);</span> <span class="cm">/* Not evictable... */</span>
		<span class="n">RETURN</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">misses</span><span class="p">;</span>

	<span class="cm">/* In case there is nothing available and we can not kick out</span>
<span class="cm">	 * the LRU element, we have to wait ...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lc_unused_element_available</span><span class="p">(</span><span class="n">lc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">__LC_STARVING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">RETURN</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* it was not present in the active set.</span>
<span class="cm">	 * we are going to recycle an unused (or even &quot;free&quot;) element.</span>
<span class="cm">	 * user may need to commit a transaction to record that change.</span>
<span class="cm">	 * we serialize on flags &amp; TF_DIRTY */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__LC_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
		<span class="n">RETURN</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">lc_get_unused_element</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__LC_STARVING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">++</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>

	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">changing_element</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">new_number</span> <span class="o">=</span> <span class="n">enr</span><span class="p">;</span>

	<span class="n">RETURN</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* similar to lc_get,</span>
<span class="cm"> * but only gets a new reference on an existing element.</span>
<span class="cm"> * you either get the requested element, or NULL.</span>
<span class="cm"> * will be consolidated into one function.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="nf">lc_try_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">PARANOIA_ENTRY</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LC_STARVING</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">starving</span><span class="p">;</span>
		<span class="n">RETURN</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">lc_find</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">enr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">hits</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lc</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">);</span> <span class="cm">/* Not evictable... */</span>
	<span class="p">}</span>
	<span class="n">RETURN</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_changed - tell @lc that the change has been recorded</span>
<span class="cm"> * @lc: the lru cache to operate on</span>
<span class="cm"> * @e: the element pending label change</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lc_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PARANOIA_ENTRY</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">changing_element</span><span class="p">);</span>
	<span class="n">PARANOIA_LC_ELEMENT</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="o">++</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">changed</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_number</span> <span class="o">=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">new_number</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_use</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">colision</span><span class="p">,</span> <span class="n">lc_hash_slot</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">new_number</span><span class="p">));</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">changing_element</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lc</span><span class="o">-&gt;</span><span class="n">new_number</span> <span class="o">=</span> <span class="n">LC_FREE</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__LC_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">RETURN</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lc_put - give up refcnt of @e</span>
<span class="cm"> * @lc: the lru cache to operate on</span>
<span class="cm"> * @e: the element to put</span>
<span class="cm"> *</span>
<span class="cm"> * If refcnt reaches zero, the element is moved to the lru list,</span>
<span class="cm"> * and a %LC_STARVING (if set) is cleared.</span>
<span class="cm"> * Returns the new (post-decrement) refcnt.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">lc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PARANOIA_ENTRY</span><span class="p">();</span>
	<span class="n">PARANOIA_LC_ELEMENT</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">changing_element</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* move it to the front of LRU. */</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">lc</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">__LC_STARVING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">RETURN</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_element_by_index</span>
<span class="cm"> * @lc: the lru cache to operate on</span>
<span class="cm"> * @i: the index of the element to return</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="nf">lc_element_by_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_element</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_element</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lc_index</span> <span class="o">!=</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">lc_element</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_index_of</span>
<span class="cm"> * @lc: the lru cache to operate on</span>
<span class="cm"> * @e: the element to query for its index position in lc-&gt;element</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">lc_index_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PARANOIA_LC_ELEMENT</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_set - associate index with label</span>
<span class="cm"> * @lc: the lru cache to operate on</span>
<span class="cm"> * @enr: the label to set</span>
<span class="cm"> * @index: the element index to associate label with.</span>
<span class="cm"> *</span>
<span class="cm"> * Used to initialize the active set to some previously recorded state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lc_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">lc_element_by_index</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_number</span> <span class="o">=</span> <span class="n">enr</span><span class="p">;</span>

	<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">colision</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">colision</span><span class="p">,</span> <span class="n">lc_hash_slot</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">enr</span><span class="p">));</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">in_use</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">lc</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lc_dump - Dump a complete LRU cache to seq in textual form.</span>
<span class="cm"> * @lc: the lru cache to operate on</span>
<span class="cm"> * @seq: the &amp;struct seq_file pointer to seq_printf into</span>
<span class="cm"> * @utext: user supplied &quot;heading&quot; or other info</span>
<span class="cm"> * @detail: function pointer the user may provide to dump further details</span>
<span class="cm"> * of the object the lc_element is embedded in.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lc_seq_dump_details</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lru_cache</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">utext</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">detail</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_elements</span> <span class="o">=</span> <span class="n">lc</span><span class="o">-&gt;</span><span class="n">nr_elements</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lc_element</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nn: lc_number refcnt %s</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span> <span class="n">utext</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_elements</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">lc_element_by_index</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_number</span> <span class="o">==</span> <span class="n">LC_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%2d: FREE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%2d: %4u %4u    &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				   <span class="n">e</span><span class="o">-&gt;</span><span class="n">lc_number</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
			<span class="n">detail</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_create</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_reset</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_destroy</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_set</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_del</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_try_get</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_find</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_get</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_put</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_changed</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_element_by_index</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_index_of</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_seq_printf_stats</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lc_seq_dump_details</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
