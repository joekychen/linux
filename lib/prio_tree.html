<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › prio_tree.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>prio_tree.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * lib/prio_tree.c - priority search tree</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004, Rajesh Venkatasubramanian &lt;vrajesh@umich.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL v2.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on the radix priority search tree proposed by Edward M. McCreight</span>
<span class="cm"> * SIAM Journal of Computing, vol. 14, no.2, pages 257-276, May 1985</span>
<span class="cm"> *</span>
<span class="cm"> * 02Feb2004	Initial version</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/prio_tree.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * A clever mix of heap and radix trees forms a radix priority search tree (PST)</span>
<span class="cm"> * which is useful for storing intervals, e.g, we can consider a vma as a closed</span>
<span class="cm"> * interval of file pages [offset_begin, offset_end], and store all vmas that</span>
<span class="cm"> * map a file in a PST. Then, using the PST, we can answer a stabbing query,</span>
<span class="cm"> * i.e., selecting a set of stored intervals (vmas) that overlap with (map) a</span>
<span class="cm"> * given input interval X (a set of consecutive file pages), in &quot;O(log n + m)&quot;</span>
<span class="cm"> * time where &#39;log n&#39; is the height of the PST, and &#39;m&#39; is the number of stored</span>
<span class="cm"> * intervals (vmas) that overlap (map) with the input interval X (the set of</span>
<span class="cm"> * consecutive file pages).</span>
<span class="cm"> *</span>
<span class="cm"> * In our implementation, we store closed intervals of the form [radix_index,</span>
<span class="cm"> * heap_index]. We assume that always radix_index &lt;= heap_index. McCreight&#39;s PST</span>
<span class="cm"> * is designed for storing intervals with unique radix indices, i.e., each</span>
<span class="cm"> * interval have different radix_index. However, this limitation can be easily</span>
<span class="cm"> * overcome by using the size, i.e., heap_index - radix_index, as part of the</span>
<span class="cm"> * index, so we index the tree using [(radix_index,size), heap_index].</span>
<span class="cm"> *</span>
<span class="cm"> * When the above-mentioned indexing scheme is used, theoretically, in a 32 bit</span>
<span class="cm"> * machine, the maximum height of a PST can be 64. We can use a balanced version</span>
<span class="cm"> * of the priority search tree to optimize the tree height, but the balanced</span>
<span class="cm"> * tree proposed by McCreight is too complex and memory-hungry for our purpose.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The following macros are used for implementing prio_tree for i_mmap</span>
<span class="cm"> */</span>

<span class="cp">#define RADIX_INDEX(vma)  ((vma)-&gt;vm_pgoff)</span>
<span class="cp">#define VMA_SIZE(vma)	  (((vma)-&gt;vm_end - (vma)-&gt;vm_start) &gt;&gt; PAGE_SHIFT)</span>
<span class="cm">/* avoid overflow */</span>
<span class="cp">#define HEAP_INDEX(vma)	  ((vma)-&gt;vm_pgoff + (VMA_SIZE(vma) - 1))</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_index</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">radix</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">heap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">prio_tree_entry</span><span class="p">(</span>
		    <span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">prio_tree_node</span><span class="p">);</span>

		<span class="o">*</span><span class="n">radix</span> <span class="o">=</span> <span class="n">RADIX_INDEX</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="n">HEAP_INDEX</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">radix</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index_bits_to_maxindex</span><span class="p">[</span><span class="n">BITS_PER_LONG</span><span class="p">];</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">prio_tree_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">index_bits_to_maxindex</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">index_bits_to_maxindex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">index_bits_to_maxindex</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">index_bits_to_maxindex</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum heap_index that can be stored in a PST with index_bits bits</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">prio_tree_maxindex</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">index_bits_to_maxindex</span><span class="p">[</span><span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prio_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="n">bool</span> <span class="n">left</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span>
		<span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>

	<span class="n">child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Extend a priority search tree so that it can store a node with heap_index</span>
<span class="cm"> * max_heap_index. In the worst case, this algorithm takes O((log n)^2).</span>
<span class="cm"> * However, this function is used rarely and the common case performance is</span>
<span class="cm"> * not bad.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="nf">prio_tree_expand</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_heap_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_heap_index</span> <span class="o">&gt;</span> <span class="n">prio_tree_maxindex</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">index_bits</span><span class="p">))</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">index_bits</span><span class="o">++</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">INIT_PRIO_TREE_NODE</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">max_heap_index</span> <span class="o">&gt;</span> <span class="n">prio_tree_maxindex</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">index_bits</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span><span class="p">;</span>

		<span class="n">root</span><span class="o">-&gt;</span><span class="n">index_bits</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_empty</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">prio_tree_remove</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span><span class="p">);</span>
		<span class="n">INIT_PRIO_TREE_NODE</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

		<span class="n">prio_set_parent</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prio_tree_empty</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="n">prio_set_parent</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Replace a prio_tree_node with a new node and return the old node</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="nf">prio_tree_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_PRIO_TREE_NODE</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_root</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span> <span class="o">!=</span> <span class="n">old</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can reduce root-&gt;index_bits here. However, it is complex</span>
<span class="cm">		 * and does not help much to improve performance (IMO).</span>
<span class="cm">		 */</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">prio_set_parent</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">old</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prio_tree_left_empty</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
		<span class="n">prio_set_parent</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prio_tree_right_empty</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
		<span class="n">prio_set_parent</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Insert a prio_tree_node @node into a radix priority search tree @root. The</span>
<span class="cm"> * algorithm typically takes O(log n) time where &#39;log n&#39; is the number of bits</span>
<span class="cm"> * required to represent the maximum heap_index. In the worst case, the algo</span>
<span class="cm"> * can take O((log n)^2) - check prio_tree_expand.</span>
<span class="cm"> *</span>
<span class="cm"> * If a prior node with same radix_index and heap_index is already found in</span>
<span class="cm"> * the tree, then returns the address of the prior node. Otherwise, inserts</span>
<span class="cm"> * @node into the tree and returns @node.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="nf">prio_tree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">radix_index</span><span class="p">,</span> <span class="n">heap_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">get_index</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">radix_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_empty</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">heap_index</span> <span class="o">&gt;</span> <span class="n">prio_tree_maxindex</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">index_bits</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">prio_tree_expand</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">heap_index</span><span class="p">);</span>

	<span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">index_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_index</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h_index</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r_index</span> <span class="o">==</span> <span class="n">radix_index</span> <span class="o">&amp;&amp;</span> <span class="n">h_index</span> <span class="o">==</span> <span class="n">heap_index</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cur</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">h_index</span> <span class="o">&lt;</span> <span class="n">heap_index</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">h_index</span> <span class="o">==</span> <span class="n">heap_index</span> <span class="o">&amp;&amp;</span> <span class="n">r_index</span> <span class="o">&gt;</span> <span class="n">radix_index</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">prio_tree_replace</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="cm">/* swap indices */</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">r_index</span><span class="p">;</span>
			<span class="n">r_index</span> <span class="o">=</span> <span class="n">radix_index</span><span class="p">;</span>
			<span class="n">radix_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">h_index</span><span class="p">;</span>
			<span class="n">h_index</span> <span class="o">=</span> <span class="n">heap_index</span><span class="p">;</span>
			<span class="n">heap_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size_flag</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">heap_index</span> <span class="o">-</span> <span class="n">radix_index</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">radix_index</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_right_empty</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">INIT_PRIO_TREE_NODE</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
				<span class="n">prio_set_parent</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_left_empty</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">INIT_PRIO_TREE_NODE</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
				<span class="n">prio_set_parent</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">size_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Should not reach here */</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a prio_tree_node @node from a radix priority search tree @root. The</span>
<span class="cm"> * algorithm takes O(log n) time where &#39;log n&#39; is the number of bits required</span>
<span class="cm"> * to represent the maximum heap_index.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">prio_tree_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index_right</span><span class="p">,</span> <span class="n">h_index_left</span><span class="p">;</span>

	<span class="n">cur</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">prio_tree_left_empty</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">prio_tree_right_empty</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prio_tree_left_empty</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span>
			<span class="n">get_index</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h_index_left</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prio_tree_right_empty</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span>
			<span class="n">get_index</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h_index_right</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* both h_index_left and h_index_right cannot be 0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h_index_left</span> <span class="o">&gt;=</span> <span class="n">h_index_right</span><span class="p">)</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_root</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span> <span class="o">!=</span> <span class="n">cur</span><span class="p">);</span>
		<span class="n">__INIT_PRIO_TREE_ROOT</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="n">cur</span><span class="p">)</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">prio_tree_replace</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iter_walk_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span><span class="p">)</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">prio_tree_left_empty</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">prio_tree_right_empty</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">));</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span><span class="o">++</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iter_walk_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">==</span> <span class="n">ULONG_MAX</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">))</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">^=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Following functions help to enumerate all prio_tree_nodes in the tree that</span>
<span class="cm"> * overlap with the input interval X [radix_index, heap_index]. The enumeration</span>
<span class="cm"> * takes O(log n + m) time where &#39;log n&#39; is the height of the tree (which is</span>
<span class="cm"> * proportional to # of bits required to represent the maximum heap_index) and</span>
<span class="cm"> * &#39;m&#39; is the number of prio_tree_nodes that overlap the interval X.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="nf">prio_tree_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">r_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">h_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_left_empty</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">get_index</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">r_index</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">h_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
		<span class="n">iter_walk_down</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="nf">prio_tree_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">r_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">h_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_right_empty</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">size_level</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">|</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">h_index</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">get_index</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">r_index</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">h_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
		<span class="n">iter_walk_down</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="nf">prio_tree_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">iter_walk_up</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r_index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">h_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">h_index</span> <span class="o">&gt;=</span> <span class="n">r_index</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">r_index</span> <span class="o">&lt;=</span> <span class="n">h_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * prio_tree_first:</span>
<span class="cm"> *</span>
<span class="cm"> * Get the first prio_tree_node that overlaps with the interval [radix_index,</span>
<span class="cm"> * heap_index]. Note that always radix_index &lt;= heap_index. We do a pre-order</span>
<span class="cm"> * traversal of the tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="nf">prio_tree_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index</span><span class="p">;</span>

	<span class="n">INIT_PRIO_TREE_ITER</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_empty</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">get_index</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">r_index</span> <span class="o">&gt;</span> <span class="n">h_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">index_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">prio_tree_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">overlap</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_left</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h_index</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_right</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h_index</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * prio_tree_next:</span>
<span class="cm"> *</span>
<span class="cm"> * Get the next prio_tree_node that overlaps with the input interval in iter</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">prio_tree_node</span> <span class="o">*</span><span class="nf">prio_tree_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">prio_tree_first</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

<span class="nl">repeat:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">prio_tree_left</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h_index</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">overlap</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">prio_tree_right</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h_index</span><span class="p">))</span> <span class="p">{</span>
	    	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">prio_tree_root</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">)</span>
			<span class="n">prio_tree_parent</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prio_tree_root</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">prio_tree_parent</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">overlap</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">r_index</span><span class="p">,</span> <span class="n">h_index</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
