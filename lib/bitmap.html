<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › bitmap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>bitmap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * lib/bitmap.c</span>
<span class="cm"> * Helper functions for bitmap.h.</span>
<span class="cm"> *</span>
<span class="cm"> * This source code is licensed under the GNU General Public License,</span>
<span class="cm"> * Version 2.  See the file COPYING for more details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * bitmaps provide an array of bits, implemented using an an</span>
<span class="cm"> * array of unsigned longs.  The number of valid bits in a</span>
<span class="cm"> * given bitmap does _not_ need to be an exact multiple of</span>
<span class="cm"> * BITS_PER_LONG.</span>
<span class="cm"> *</span>
<span class="cm"> * The possible unused bits in the last, partially used word</span>
<span class="cm"> * of a bitmap are &#39;don&#39;t care&#39;.  The implementation makes</span>
<span class="cm"> * no particular effort to keep them zero.  It ensures that</span>
<span class="cm"> * their value will not affect the results of any operation.</span>
<span class="cm"> * The bitmap operations that return Boolean (bitmap_empty,</span>
<span class="cm"> * for example) or scalar (bitmap_weight, for example) results</span>
<span class="cm"> * carefully filter out these unused bits from impacting their</span>
<span class="cm"> * results.</span>
<span class="cm"> *</span>
<span class="cm"> * These operations actually hold to a slightly stronger rule:</span>
<span class="cm"> * if you don&#39;t input any bitmaps to these ops that have some</span>
<span class="cm"> * unused bits set, then they won&#39;t output any set unused bits</span>
<span class="cm"> * in output bitmaps.</span>
<span class="cm"> *</span>
<span class="cm"> * The byte ordering of bitmaps is more natural on little</span>
<span class="cm"> * endian architectures.  See the big-endian headers</span>
<span class="cm"> * include/asm-ppc64/bitops.h and include/asm-s390/bitops.h</span>
<span class="cm"> * for the best explanations of this ordering.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">__bitmap_empty</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">bits</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">bits</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_empty</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__bitmap_full</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">bits</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">bitmap</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">bitmap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">bits</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_full</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__bitmap_equal</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap1</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">bits</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">^</span> <span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">bits</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_equal</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__bitmap_complement</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">bits</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">src</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">src</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_complement</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __bitmap_shift_right - logical right shift of the bits in a bitmap</span>
<span class="cm"> *   @dst : destination bitmap</span>
<span class="cm"> *   @src : source bitmap</span>
<span class="cm"> *   @shift : shift by this many bits</span>
<span class="cm"> *   @bits : bitmap size, in bits</span>
<span class="cm"> *</span>
<span class="cm"> * Shifting right (dividing) means moving bits in the MS -&gt; LS bit</span>
<span class="cm"> * direction.  Zeros are fed into the vacated MS positions and the</span>
<span class="cm"> * LS bits shifted off the bottom are lost.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__bitmap_shift_right</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">bits</span><span class="p">),</span> <span class="n">left</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">shift</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">off</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If shift is not word aligned, take lower rem bits of</span>
<span class="cm">		 * word above and make them the top rem bits of result.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rem</span> <span class="o">||</span> <span class="n">off</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">lim</span><span class="p">)</span>
			<span class="n">upper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">upper</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">off</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">lim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="p">)</span>
				<span class="n">upper</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lower</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">off</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">off</span> <span class="o">+</span> <span class="n">k</span> <span class="o">==</span> <span class="n">lim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">lower</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">upper</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">rem</span><span class="p">)</span> <span class="o">|</span> <span class="n">lower</span> <span class="o">&gt;&gt;</span> <span class="n">rem</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">==</span> <span class="n">lim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">lim</span> <span class="o">-</span> <span class="n">off</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">off</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_shift_right</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * __bitmap_shift_left - logical left shift of the bits in a bitmap</span>
<span class="cm"> *   @dst : destination bitmap</span>
<span class="cm"> *   @src : source bitmap</span>
<span class="cm"> *   @shift : shift by this many bits</span>
<span class="cm"> *   @bits : bitmap size, in bits</span>
<span class="cm"> *</span>
<span class="cm"> * Shifting left (multiplying) means moving bits in the LS -&gt; MS</span>
<span class="cm"> * direction.  Zeros are fed into the vacated LS bit positions</span>
<span class="cm"> * and those MS bits shifted off the top are lost.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">__bitmap_shift_left</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">bits</span><span class="p">),</span> <span class="n">left</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">shift</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">lim</span> <span class="o">-</span> <span class="n">off</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If shift is not word aligned, take upper rem bits of</span>
<span class="cm">		 * word below and make them the bottom rem bits of result.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lower</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">upper</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">==</span> <span class="n">lim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">upper</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="n">lower</span>  <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="n">rem</span><span class="p">)</span> <span class="o">|</span> <span class="n">upper</span> <span class="o">&lt;&lt;</span> <span class="n">rem</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">+</span> <span class="n">off</span> <span class="o">==</span> <span class="n">lim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dst</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">off</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">off</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_shift_left</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__bitmap_and</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap1</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_and</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__bitmap_or</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap1</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">|</span> <span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_or</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__bitmap_xor</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap1</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">^</span> <span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_xor</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__bitmap_andnot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap1</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_andnot</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__bitmap_intersects</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap1</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">bits</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">bits</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_intersects</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__bitmap_subset</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap1</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">bits</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bitmap1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">bitmap2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">bits</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_subset</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__bitmap_weight</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lim</span> <span class="o">=</span> <span class="n">bits</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">w</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span>
		<span class="n">w</span> <span class="o">+=</span> <span class="n">hweight_long</span><span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">bits</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_weight</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">bitmap_set</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">map</span> <span class="o">+</span> <span class="n">BIT_WORD</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits_to_set</span> <span class="o">=</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="p">(</span><span class="n">start</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask_to_set</span> <span class="o">=</span> <span class="n">BITMAP_FIRST_WORD_MASK</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">bits_to_set</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">|=</span> <span class="n">mask_to_set</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">-=</span> <span class="n">bits_to_set</span><span class="p">;</span>
		<span class="n">bits_to_set</span> <span class="o">=</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">mask_to_set</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask_to_set</span> <span class="o">&amp;=</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">|=</span> <span class="n">mask_to_set</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_set</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">bitmap_clear</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">map</span> <span class="o">+</span> <span class="n">BIT_WORD</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits_to_clear</span> <span class="o">=</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="p">(</span><span class="n">start</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask_to_clear</span> <span class="o">=</span> <span class="n">BITMAP_FIRST_WORD_MASK</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">bits_to_clear</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask_to_clear</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">-=</span> <span class="n">bits_to_clear</span><span class="p">;</span>
		<span class="n">bits_to_clear</span> <span class="o">=</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">mask_to_clear</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mask_to_clear</span> <span class="o">&amp;=</span> <span class="n">BITMAP_LAST_WORD_MASK</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask_to_clear</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_clear</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * bitmap_find_next_zero_area - find a contiguous aligned zero area</span>
<span class="cm"> * @map: The address to base the search on</span>
<span class="cm"> * @size: The bitmap size in bits</span>
<span class="cm"> * @start: The bitnumber to start searching at</span>
<span class="cm"> * @nr: The number of zeroed bits we&#39;re looking for</span>
<span class="cm"> * @align_mask: Alignment mask for zero area</span>
<span class="cm"> *</span>
<span class="cm"> * The @align_mask should be one less than a power of 2; the effect is that</span>
<span class="cm"> * the bit offset of all zero areas this function finds is multiples of that</span>
<span class="cm"> * power of 2. A @align_mask of 0 means no alignment is required.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bitmap_find_next_zero_area</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>

	<span class="cm">/* Align allocation */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">__ALIGN_MASK</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">align_mask</span><span class="p">);</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_find_next_zero_area</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Bitmap printing &amp; parsing functions: first version by Bill Irwin,</span>
<span class="cm"> * second version by Paul Jackson, third by Joe Korty.</span>
<span class="cm"> */</span>

<span class="cp">#define CHUNKSZ				32</span>
<span class="cp">#define nbits_to_hold_value(val)	fls(val)</span>
<span class="cp">#define BASEDEC 10		</span><span class="cm">/* fancier cpuset lists input in decimal */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_scnprintf - convert bitmap to an ASCII hex string.</span>
<span class="cm"> * @buf: byte buffer into which string is placed</span>
<span class="cm"> * @buflen: reserved size of @buf, in bytes</span>
<span class="cm"> * @maskp: pointer to bitmap to convert</span>
<span class="cm"> * @nmaskbits: size of bitmap, in bits</span>
<span class="cm"> *</span>
<span class="cm"> * Exactly @nmaskbits bits are displayed.  Hex digits are grouped into</span>
<span class="cm"> * comma-separated sets of eight digits per set.  Returns the number of</span>
<span class="cm"> * characters which were written to *buf, excluding the trailing \0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bitmap_scnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">maskp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nmaskbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chunksz</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chunkmask</span><span class="p">;</span>

	<span class="n">chunksz</span> <span class="o">=</span> <span class="n">nmaskbits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CHUNKSZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunksz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">chunksz</span> <span class="o">=</span> <span class="n">CHUNKSZ</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">nmaskbits</span><span class="p">,</span> <span class="n">CHUNKSZ</span><span class="p">)</span> <span class="o">-</span> <span class="n">CHUNKSZ</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="n">CHUNKSZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunkmask</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">chunksz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">maskp</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">chunkmask</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="n">buflen</span><span class="o">-</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s%0*lx&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span>
			<span class="p">(</span><span class="n">chunksz</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">chunksz</span> <span class="o">=</span> <span class="n">CHUNKSZ</span><span class="p">;</span>
		<span class="n">sep</span> <span class="o">=</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_scnprintf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __bitmap_parse - convert an ASCII hex string into a bitmap.</span>
<span class="cm"> * @buf: pointer to buffer containing string.</span>
<span class="cm"> * @buflen: buffer size in bytes.  If string is smaller than this</span>
<span class="cm"> *    then it must be terminated with a \0.</span>
<span class="cm"> * @is_user: location of buffer, 0 indicates kernel space</span>
<span class="cm"> * @maskp: pointer to bitmap array that will contain result.</span>
<span class="cm"> * @nmaskbits: size of bitmap, in bits.</span>
<span class="cm"> *</span>
<span class="cm"> * Commas group hex digits into chunks.  Each chunk defines exactly 32</span>
<span class="cm"> * bits of the resultant bitmask.  No chunk may specify a value larger</span>
<span class="cm"> * than 32 bits (%-EOVERFLOW), and if a chunk specifies a smaller value</span>
<span class="cm"> * then leading 0-bits are prepended.  %-EINVAL is returned for illegal</span>
<span class="cm"> * characters and for grouping errors such as &quot;1,,5&quot;, &quot;,44&quot;, &quot;,&quot; and &quot;&quot;.</span>
<span class="cm"> * Leading and trailing whitespace accepted, but not embedded whitespace.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__bitmap_parse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">is_user</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">maskp</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">nmaskbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">old_c</span><span class="p">,</span> <span class="n">totaldigits</span><span class="p">,</span> <span class="n">ndigits</span><span class="p">,</span> <span class="n">nchunks</span><span class="p">,</span> <span class="n">nbits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">chunk</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="n">ubuf</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">maskp</span><span class="p">,</span> <span class="n">nmaskbits</span><span class="p">);</span>

	<span class="n">nchunks</span> <span class="o">=</span> <span class="n">nbits</span> <span class="o">=</span> <span class="n">totaldigits</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">ndigits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Get the next chunk of the bitmap */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">old_c</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_user</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubuf</span><span class="o">++</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
			<span class="n">buflen</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the last character was a space and the current</span>
<span class="cm">			 * character isn&#39;t &#39;\0&#39;, we&#39;ve got embedded whitespace.</span>
<span class="cm">			 * This is a no-no, so throw an error.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">totaldigits</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">isspace</span><span class="p">(</span><span class="n">old_c</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="cm">/* A &#39;\0&#39; or a &#39;,&#39; signal the end of the chunk */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isxdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Make sure there are at least 4 free bits in &#39;chunk&#39;.</span>
<span class="cm">			 * If not, this hexdigit will overflow &#39;chunk&#39;, so</span>
<span class="cm">			 * throw an error.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">CHUNKSZ</span> <span class="o">-</span> <span class="mi">4</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

			<span class="n">chunk</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">ndigits</span><span class="o">++</span><span class="p">;</span> <span class="n">totaldigits</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndigits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nchunks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">__bitmap_shift_left</span><span class="p">(</span><span class="n">maskp</span><span class="p">,</span> <span class="n">maskp</span><span class="p">,</span> <span class="n">CHUNKSZ</span><span class="p">,</span> <span class="n">nmaskbits</span><span class="p">);</span>
		<span class="o">*</span><span class="n">maskp</span> <span class="o">|=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">nchunks</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nbits</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nchunks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">nbits_to_hold_value</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">:</span> <span class="n">CHUNKSZ</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">&gt;</span> <span class="n">nmaskbits</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bitmap_parse</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_parse_user - convert an ASCII hex string in a user buffer into a bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * @ubuf: pointer to user buffer containing string.</span>
<span class="cm"> * @ulen: buffer size in bytes.  If string is smaller than this</span>
<span class="cm"> *    then it must be terminated with a \0.</span>
<span class="cm"> * @maskp: pointer to bitmap array that will contain result.</span>
<span class="cm"> * @nmaskbits: size of bitmap, in bits.</span>
<span class="cm"> *</span>
<span class="cm"> * Wrapper for __bitmap_parse(), providing it with user buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * We cannot have this as an inline function in bitmap.h because it needs</span>
<span class="cm"> * linux/uaccess.h to get the access_ok() declaration and this causes</span>
<span class="cm"> * cyclic dependencies.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bitmap_parse_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ulen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">maskp</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nmaskbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">ulen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__bitmap_parse</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">ubuf</span><span class="p">,</span>
				<span class="n">ulen</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maskp</span><span class="p">,</span> <span class="n">nmaskbits</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_parse_user</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * bscnl_emit(buf, buflen, rbot, rtop, bp)</span>
<span class="cm"> *</span>
<span class="cm"> * Helper routine for bitmap_scnlistprintf().  Write decimal number</span>
<span class="cm"> * or range to buf, suppressing output past buf+buflen, with optional</span>
<span class="cm"> * comma-prefix.  Return len of what was written to *buf, excluding the</span>
<span class="cm"> * trailing \0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bscnl_emit</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rbot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rtop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rbot</span> <span class="o">==</span> <span class="n">rtop</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">rbot</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%d-%d&quot;</span><span class="p">,</span> <span class="n">rbot</span><span class="p">,</span> <span class="n">rtop</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_scnlistprintf - convert bitmap to list format ASCII string</span>
<span class="cm"> * @buf: byte buffer into which string is placed</span>
<span class="cm"> * @buflen: reserved size of @buf, in bytes</span>
<span class="cm"> * @maskp: pointer to bitmap to convert</span>
<span class="cm"> * @nmaskbits: size of bitmap, in bits</span>
<span class="cm"> *</span>
<span class="cm"> * Output format is a comma-separated list of decimal numbers and</span>
<span class="cm"> * ranges.  Consecutively set bits are shown as two hyphen-separated</span>
<span class="cm"> * decimal numbers, the smallest and largest bit numbers set in</span>
<span class="cm"> * the range.  Output format is compatible with the format</span>
<span class="cm"> * accepted as input by bitmap_parselist().</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is the number of characters which were written to *buf</span>
<span class="cm"> * excluding the trailing &#39;\0&#39;, as per ISO C99&#39;s scnprintf.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bitmap_scnlistprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">maskp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nmaskbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* current bit is &#39;cur&#39;, most recently seen range is [rbot, rtop] */</span>
	<span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="n">rbot</span><span class="p">,</span> <span class="n">rtop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rbot</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">maskp</span><span class="p">,</span> <span class="n">nmaskbits</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">nmaskbits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtop</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">maskp</span><span class="p">,</span> <span class="n">nmaskbits</span><span class="p">,</span> <span class="n">cur</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="n">nmaskbits</span> <span class="o">||</span> <span class="n">cur</span> <span class="o">&gt;</span> <span class="n">rtop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bscnl_emit</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">rbot</span><span class="p">,</span> <span class="n">rtop</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">rbot</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_scnlistprintf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __bitmap_parselist - convert list format ASCII string to bitmap</span>
<span class="cm"> * @buf: read nul-terminated user string from this buffer</span>
<span class="cm"> * @buflen: buffer size in bytes.  If string is smaller than this</span>
<span class="cm"> *    then it must be terminated with a \0.</span>
<span class="cm"> * @is_user: location of buffer, 0 indicates kernel space</span>
<span class="cm"> * @maskp: write resulting mask here</span>
<span class="cm"> * @nmaskbits: number of bits in mask to be written</span>
<span class="cm"> *</span>
<span class="cm"> * Input format is a comma-separated list of decimal numbers and</span>
<span class="cm"> * ranges.  Consecutively set bits are shown as two hyphen-separated</span>
<span class="cm"> * decimal numbers, the smallest and largest bit numbers set in</span>
<span class="cm"> * the range.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -errno on invalid input strings.</span>
<span class="cm"> * Error values:</span>
<span class="cm"> *    %-EINVAL: second number in range smaller than first</span>
<span class="cm"> *    %-EINVAL: invalid character in string</span>
<span class="cm"> *    %-ERANGE: bit number specified too large for mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__bitmap_parselist</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">is_user</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">maskp</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">nmaskbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">old_c</span><span class="p">,</span> <span class="n">totaldigits</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="n">ubuf</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exp_digit</span><span class="p">,</span> <span class="n">in_range</span><span class="p">;</span>

	<span class="n">totaldigits</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">maskp</span><span class="p">,</span> <span class="n">nmaskbits</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">exp_digit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">in_range</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Get the next cpu# or a range of cpu#&#39;s */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">old_c</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_user</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubuf</span><span class="o">++</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
			<span class="n">buflen</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the last character was a space and the current</span>
<span class="cm">			 * character isn&#39;t &#39;\0&#39;, we&#39;ve got embedded whitespace.</span>
<span class="cm">			 * This is a no-no, so throw an error.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">totaldigits</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">isspace</span><span class="p">(</span><span class="n">old_c</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="cm">/* A &#39;\0&#39; or a &#39;,&#39; signal the end of a cpu# or range */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">exp_digit</span> <span class="o">||</span> <span class="n">in_range</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">in_range</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">exp_digit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_range</span><span class="p">)</span>
				<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
			<span class="n">exp_digit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">totaldigits</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="n">nmaskbits</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">maskp</span><span class="p">);</span>
			<span class="n">a</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bitmap_parselist</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">maskp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nmaskbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">nl</span>  <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nl</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">nl</span> <span class="o">-</span> <span class="n">bp</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__bitmap_parselist</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maskp</span><span class="p">,</span> <span class="n">nmaskbits</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_parselist</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * bitmap_parselist_user()</span>
<span class="cm"> *</span>
<span class="cm"> * @ubuf: pointer to user buffer containing string.</span>
<span class="cm"> * @ulen: buffer size in bytes.  If string is smaller than this</span>
<span class="cm"> *    then it must be terminated with a \0.</span>
<span class="cm"> * @maskp: pointer to bitmap array that will contain result.</span>
<span class="cm"> * @nmaskbits: size of bitmap, in bits.</span>
<span class="cm"> *</span>
<span class="cm"> * Wrapper for bitmap_parselist(), providing it with user buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * We cannot have this as an inline function in bitmap.h because it needs</span>
<span class="cm"> * linux/uaccess.h to get the access_ok() declaration and this causes</span>
<span class="cm"> * cyclic dependencies.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bitmap_parselist_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ulen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">maskp</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nmaskbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">ulen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__bitmap_parselist</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">ubuf</span><span class="p">,</span>
					<span class="n">ulen</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maskp</span><span class="p">,</span> <span class="n">nmaskbits</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_parselist_user</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * bitmap_pos_to_ord - find ordinal of set bit at given position in bitmap</span>
<span class="cm"> *	@buf: pointer to a bitmap</span>
<span class="cm"> *	@pos: a bit position in @buf (0 &lt;= @pos &lt; @bits)</span>
<span class="cm"> *	@bits: number of valid bit positions in @buf</span>
<span class="cm"> *</span>
<span class="cm"> * Map the bit at position @pos in @buf (of length @bits) to the</span>
<span class="cm"> * ordinal of which set bit it is.  If it is not set or if @pos</span>
<span class="cm"> * is not a valid bit position, map to -1.</span>
<span class="cm"> *</span>
<span class="cm"> * If for example, just bits 4 through 7 are set in @buf, then @pos</span>
<span class="cm"> * values 4 through 7 will get mapped to 0 through 3, respectively,</span>
<span class="cm"> * and other @pos values will get mapped to 0.  When @pos value 7</span>
<span class="cm"> * gets mapped to (returns) @ord value 3 in this example, that means</span>
<span class="cm"> * that bit 7 is the 3rd (starting with 0th) set bit in @buf.</span>
<span class="cm"> *</span>
<span class="cm"> * The bit positions 0 through @bits are valid positions in @buf.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bitmap_pos_to_ord</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ord</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">bits</span> <span class="o">||</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="n">ord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	     	<span class="n">ord</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ord</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_ord_to_pos - find position of n-th set bit in bitmap</span>
<span class="cm"> *	@buf: pointer to bitmap</span>
<span class="cm"> *	@ord: ordinal bit position (n-th set bit, n &gt;= 0)</span>
<span class="cm"> *	@bits: number of valid bit positions in @buf</span>
<span class="cm"> *</span>
<span class="cm"> * Map the ordinal offset of bit @ord in @buf to its position in @buf.</span>
<span class="cm"> * Value of @ord should be in range 0 &lt;= @ord &lt; weight(buf), else</span>
<span class="cm"> * results are undefined.</span>
<span class="cm"> *</span>
<span class="cm"> * If for example, just bits 4 through 7 are set in @buf, then @ord</span>
<span class="cm"> * values 0 through 3 will get mapped to 4 through 7, respectively,</span>
<span class="cm"> * and all other @ord values return undefined values.  When @ord value 3</span>
<span class="cm"> * gets mapped to (returns) @pos value 7 in this example, that means</span>
<span class="cm"> * that the 3rd set bit (starting with 0th) is at position 7 in @buf.</span>
<span class="cm"> *</span>
<span class="cm"> * The bit positions 0 through @bits are valid positions in @buf.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bitmap_ord_to_pos</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ord</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ord</span> <span class="o">&lt;</span> <span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
		     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bits</span> <span class="o">&amp;&amp;</span> <span class="n">ord</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">i</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
	     		<span class="n">ord</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">bits</span> <span class="o">&amp;&amp;</span> <span class="n">ord</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_remap - Apply map defined by a pair of bitmaps to another bitmap</span>
<span class="cm"> *	@dst: remapped result</span>
<span class="cm"> *	@src: subset to be remapped</span>
<span class="cm"> *	@old: defines domain of map</span>
<span class="cm"> *	@new: defines range of map</span>
<span class="cm"> *	@bits: number of bits in each of these bitmaps</span>
<span class="cm"> *</span>
<span class="cm"> * Let @old and @new define a mapping of bit positions, such that</span>
<span class="cm"> * whatever position is held by the n-th set bit in @old is mapped</span>
<span class="cm"> * to the n-th set bit in @new.  In the more general case, allowing</span>
<span class="cm"> * for the possibility that the weight &#39;w&#39; of @new is less than the</span>
<span class="cm"> * weight of @old, map the position of the n-th set bit in @old to</span>
<span class="cm"> * the position of the m-th set bit in @new, where m == n % w.</span>
<span class="cm"> *</span>
<span class="cm"> * If either of the @old and @new bitmaps are empty, or if @src and</span>
<span class="cm"> * @dst point to the same location, then this routine copies @src</span>
<span class="cm"> * to @dst.</span>
<span class="cm"> *</span>
<span class="cm"> * The positions of unset bits in @old are mapped to themselves</span>
<span class="cm"> * (the identify map).</span>
<span class="cm"> *</span>
<span class="cm"> * Apply the above specified mapping to @src, placing the result in</span>
<span class="cm"> * @dst, clearing any bits previously set in @dst.</span>
<span class="cm"> *</span>
<span class="cm"> * For example, lets say that @old has bits 4 through 7 set, and</span>
<span class="cm"> * @new has bits 12 through 15 set.  This defines the mapping of bit</span>
<span class="cm"> * position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other</span>
<span class="cm"> * bit positions unchanged.  So if say @src comes into this routine</span>
<span class="cm"> * with bits 1, 5 and 7 set, then @dst should leave with bits 1,</span>
<span class="cm"> * 13 and 15 set.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bitmap_remap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">oldbit</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">==</span> <span class="n">src</span><span class="p">)</span>		<span class="cm">/* following doesn&#39;t handle inplace remaps */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>

	<span class="n">w</span> <span class="o">=</span> <span class="n">bitmap_weight</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">oldbit</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
	     	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bitmap_pos_to_ord</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">oldbit</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">oldbit</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>	<span class="cm">/* identity map */</span>
		<span class="k">else</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">bitmap_ord_to_pos</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">w</span><span class="p">,</span> <span class="n">bits</span><span class="p">),</span> <span class="n">dst</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_remap</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_bitremap - Apply map defined by a pair of bitmaps to a single bit</span>
<span class="cm"> *	@oldbit: bit position to be mapped</span>
<span class="cm"> *	@old: defines domain of map</span>
<span class="cm"> *	@new: defines range of map</span>
<span class="cm"> *	@bits: number of bits in each of these bitmaps</span>
<span class="cm"> *</span>
<span class="cm"> * Let @old and @new define a mapping of bit positions, such that</span>
<span class="cm"> * whatever position is held by the n-th set bit in @old is mapped</span>
<span class="cm"> * to the n-th set bit in @new.  In the more general case, allowing</span>
<span class="cm"> * for the possibility that the weight &#39;w&#39; of @new is less than the</span>
<span class="cm"> * weight of @old, map the position of the n-th set bit in @old to</span>
<span class="cm"> * the position of the m-th set bit in @new, where m == n % w.</span>
<span class="cm"> *</span>
<span class="cm"> * The positions of unset bits in @old are mapped to themselves</span>
<span class="cm"> * (the identify map).</span>
<span class="cm"> *</span>
<span class="cm"> * Apply the above specified mapping to bit position @oldbit, returning</span>
<span class="cm"> * the new bit position.</span>
<span class="cm"> *</span>
<span class="cm"> * For example, lets say that @old has bits 4 through 7 set, and</span>
<span class="cm"> * @new has bits 12 through 15 set.  This defines the mapping of bit</span>
<span class="cm"> * position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other</span>
<span class="cm"> * bit positions unchanged.  So if say @oldbit is 5, then this routine</span>
<span class="cm"> * returns 13.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bitmap_bitremap</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldbit</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">bitmap_weight</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bitmap_pos_to_ord</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">oldbit</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">oldbit</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">bitmap_ord_to_pos</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">w</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_bitremap</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_onto - translate one bitmap relative to another</span>
<span class="cm"> *	@dst: resulting translated bitmap</span>
<span class="cm"> * 	@orig: original untranslated bitmap</span>
<span class="cm"> * 	@relmap: bitmap relative to which translated</span>
<span class="cm"> *	@bits: number of bits in each of these bitmaps</span>
<span class="cm"> *</span>
<span class="cm"> * Set the n-th bit of @dst iff there exists some m such that the</span>
<span class="cm"> * n-th bit of @relmap is set, the m-th bit of @orig is set, and</span>
<span class="cm"> * the n-th bit of @relmap is also the m-th _set_ bit of @relmap.</span>
<span class="cm"> * (If you understood the previous sentence the first time your</span>
<span class="cm"> * read it, you&#39;re overqualified for your current job.)</span>
<span class="cm"> *</span>
<span class="cm"> * In other words, @orig is mapped onto (surjectively) @dst,</span>
<span class="cm"> * using the the map { &lt;n, m&gt; | the n-th bit of @relmap is the</span>
<span class="cm"> * m-th set bit of @relmap }.</span>
<span class="cm"> *</span>
<span class="cm"> * Any set bits in @orig above bit number W, where W is the</span>
<span class="cm"> * weight of (number of set bits in) @relmap are mapped nowhere.</span>
<span class="cm"> * In particular, if for all bits m set in @orig, m &gt;= W, then</span>
<span class="cm"> * @dst will end up empty.  In situations where the possibility</span>
<span class="cm"> * of such an empty result is not desired, one way to avoid it is</span>
<span class="cm"> * to use the bitmap_fold() operator, below, to first fold the</span>
<span class="cm"> * @orig bitmap over itself so that all its set bits x are in the</span>
<span class="cm"> * range 0 &lt;= x &lt; W.  The bitmap_fold() operator does this by</span>
<span class="cm"> * setting the bit (m % W) in @dst, for each bit (m) set in @orig.</span>
<span class="cm"> *</span>
<span class="cm"> * Example [1] for bitmap_onto():</span>
<span class="cm"> *  Let&#39;s say @relmap has bits 30-39 set, and @orig has bits</span>
<span class="cm"> *  1, 3, 5, 7, 9 and 11 set.  Then on return from this routine,</span>
<span class="cm"> *  @dst will have bits 31, 33, 35, 37 and 39 set.</span>
<span class="cm"> *</span>
<span class="cm"> *  When bit 0 is set in @orig, it means turn on the bit in</span>
<span class="cm"> *  @dst corresponding to whatever is the first bit (if any)</span>
<span class="cm"> *  that is turned on in @relmap.  Since bit 0 was off in the</span>
<span class="cm"> *  above example, we leave off that bit (bit 30) in @dst.</span>
<span class="cm"> *</span>
<span class="cm"> *  When bit 1 is set in @orig (as in the above example), it</span>
<span class="cm"> *  means turn on the bit in @dst corresponding to whatever</span>
<span class="cm"> *  is the second bit that is turned on in @relmap.  The second</span>
<span class="cm"> *  bit in @relmap that was turned on in the above example was</span>
<span class="cm"> *  bit 31, so we turned on bit 31 in @dst.</span>
<span class="cm"> *</span>
<span class="cm"> *  Similarly, we turned on bits 33, 35, 37 and 39 in @dst,</span>
<span class="cm"> *  because they were the 4th, 6th, 8th and 10th set bits</span>
<span class="cm"> *  set in @relmap, and the 4th, 6th, 8th and 10th bits of</span>
<span class="cm"> *  @orig (i.e. bits 3, 5, 7 and 9) were also set.</span>
<span class="cm"> *</span>
<span class="cm"> *  When bit 11 is set in @orig, it means turn on the bit in</span>
<span class="cm"> *  @dst corresponding to whatever is the twelfth bit that is</span>
<span class="cm"> *  turned on in @relmap.  In the above example, there were</span>
<span class="cm"> *  only ten bits turned on in @relmap (30..39), so that bit</span>
<span class="cm"> *  11 was set in @orig had no affect on @dst.</span>
<span class="cm"> *</span>
<span class="cm"> * Example [2] for bitmap_fold() + bitmap_onto():</span>
<span class="cm"> *  Let&#39;s say @relmap has these ten bits set:</span>
<span class="cm"> *		40 41 42 43 45 48 53 61 74 95</span>
<span class="cm"> *  (for the curious, that&#39;s 40 plus the first ten terms of the</span>
<span class="cm"> *  Fibonacci sequence.)</span>
<span class="cm"> *</span>
<span class="cm"> *  Further lets say we use the following code, invoking</span>
<span class="cm"> *  bitmap_fold() then bitmap_onto, as suggested above to</span>
<span class="cm"> *  avoid the possitility of an empty @dst result:</span>
<span class="cm"> *</span>
<span class="cm"> *	unsigned long *tmp;	// a temporary bitmap&#39;s bits</span>
<span class="cm"> *</span>
<span class="cm"> *	bitmap_fold(tmp, orig, bitmap_weight(relmap, bits), bits);</span>
<span class="cm"> *	bitmap_onto(dst, tmp, relmap, bits);</span>
<span class="cm"> *</span>
<span class="cm"> *  Then this table shows what various values of @dst would be, for</span>
<span class="cm"> *  various @orig&#39;s.  I list the zero-based positions of each set bit.</span>
<span class="cm"> *  The tmp column shows the intermediate result, as computed by</span>
<span class="cm"> *  using bitmap_fold() to fold the @orig bitmap modulo ten</span>
<span class="cm"> *  (the weight of @relmap).</span>
<span class="cm"> *</span>
<span class="cm"> *      @orig           tmp            @dst</span>
<span class="cm"> *      0                0             40</span>
<span class="cm"> *      1                1             41</span>
<span class="cm"> *      9                9             95</span>
<span class="cm"> *      10               0             40 (*)</span>
<span class="cm"> *      1 3 5 7          1 3 5 7       41 43 48 61</span>
<span class="cm"> *      0 1 2 3 4        0 1 2 3 4     40 41 42 43 45</span>
<span class="cm"> *      0 9 18 27        0 9 8 7       40 61 74 95</span>
<span class="cm"> *      0 10 20 30       0             40</span>
<span class="cm"> *      0 11 22 33       0 1 2 3       40 41 42 43</span>
<span class="cm"> *      0 12 24 36       0 2 4 6       40 42 45 53</span>
<span class="cm"> *      78 102 211       1 2 8         41 42 74 (*)</span>
<span class="cm"> *</span>
<span class="cm"> * (*) For these marked lines, if we hadn&#39;t first done bitmap_fold()</span>
<span class="cm"> *     into tmp, then the @dst result would have been empty.</span>
<span class="cm"> *</span>
<span class="cm"> * If either of @orig or @relmap is empty (no set bits), then @dst</span>
<span class="cm"> * will be returned empty.</span>
<span class="cm"> *</span>
<span class="cm"> * If (as explained above) the only set bits in @orig are in positions</span>
<span class="cm"> * m where m &gt;= W, (where W is the weight of @relmap) then @dst will</span>
<span class="cm"> * once again be returned empty.</span>
<span class="cm"> *</span>
<span class="cm"> * All bits in @dst not set by the above rule are cleared.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bitmap_onto</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">relmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>       	<span class="cm">/* same meaning as in above comment */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">==</span> <span class="n">orig</span><span class="p">)</span>	<span class="cm">/* following doesn&#39;t handle inplace mappings */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following code is a more efficient, but less</span>
<span class="cm">	 * obvious, equivalent to the loop:</span>
<span class="cm">	 *	for (m = 0; m &lt; bitmap_weight(relmap, bits); m++) {</span>
<span class="cm">	 *		n = bitmap_ord_to_pos(orig, m, bits);</span>
<span class="cm">	 *		if (test_bit(m, orig))</span>
<span class="cm">	 *			set_bit(n, dst);</span>
<span class="cm">	 *	}</span>
<span class="cm">	 */</span>

	<span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">relmap</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* m == bitmap_pos_to_ord(relmap, n, bits) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">orig</span><span class="p">))</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
		<span class="n">m</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_onto</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_fold - fold larger bitmap into smaller, modulo specified size</span>
<span class="cm"> *	@dst: resulting smaller bitmap</span>
<span class="cm"> *	@orig: original larger bitmap</span>
<span class="cm"> *	@sz: specified size</span>
<span class="cm"> *	@bits: number of bits in each of these bitmaps</span>
<span class="cm"> *</span>
<span class="cm"> * For each bit oldbit in @orig, set bit oldbit mod @sz in @dst.</span>
<span class="cm"> * Clear all other bits in @dst.  See further the comment and</span>
<span class="cm"> * Example [2] for bitmap_onto() for why and how to use this.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bitmap_fold</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">oldbit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">==</span> <span class="n">orig</span><span class="p">)</span>	<span class="cm">/* following doesn&#39;t handle inplace mappings */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">oldbit</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">oldbit</span> <span class="o">%</span> <span class="n">sz</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_fold</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Common code for bitmap_*_region() routines.</span>
<span class="cm"> *	bitmap: array of unsigned longs corresponding to the bitmap</span>
<span class="cm"> *	pos: the beginning of the region</span>
<span class="cm"> *	order: region size (log base 2 of number of bits)</span>
<span class="cm"> *	reg_op: operation(s) to perform on that region of bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * Can set, verify and/or release a region of bits in a bitmap,</span>
<span class="cm"> * depending on which combination of REG_OP_* flag bits is set.</span>
<span class="cm"> *</span>
<span class="cm"> * A region of a bitmap is a sequence of bits in the bitmap, of</span>
<span class="cm"> * some size &#39;1 &lt;&lt; order&#39; (a power of two), aligned to that same</span>
<span class="cm"> * &#39;1 &lt;&lt; order&#39; power of two.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if REG_OP_ISFREE succeeds (region is all zero bits).</span>
<span class="cm"> * Returns 0 in all other cases and reg_ops.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">REG_OP_ISFREE</span><span class="p">,</span>		<span class="cm">/* true if region is all zero bits */</span>
	<span class="n">REG_OP_ALLOC</span><span class="p">,</span>		<span class="cm">/* set all bits in region */</span>
	<span class="n">REG_OP_RELEASE</span><span class="p">,</span>		<span class="cm">/* clear all bits in region */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__reg_op</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nbits_reg</span><span class="p">;</span>		<span class="cm">/* number of bits in region */</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* index first long of region in bitmap */</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>		<span class="cm">/* bit offset region in bitmap[index] */</span>
	<span class="kt">int</span> <span class="n">nlongs_reg</span><span class="p">;</span>		<span class="cm">/* num longs spanned by region in bitmap */</span>
	<span class="kt">int</span> <span class="n">nbitsinlong</span><span class="p">;</span>	<span class="cm">/* num bits of region in each spanned long */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>	<span class="cm">/* bitmask for one long of region */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>			<span class="cm">/* scans bitmap by longs */</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* return value */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Either nlongs_reg == 1 (for small orders that fit in one long)</span>
<span class="cm">	 * or (offset == 0 &amp;&amp; mask == ~0UL) (for larger multiword orders.)</span>
<span class="cm">	 */</span>
	<span class="n">nbits_reg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>
	<span class="n">nlongs_reg</span> <span class="o">=</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">nbits_reg</span><span class="p">);</span>
	<span class="n">nbitsinlong</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nbits_reg</span><span class="p">,</span>  <span class="n">BITS_PER_LONG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t do &quot;mask = (1UL &lt;&lt; nbitsinlong) - 1&quot;, as that</span>
<span class="cm">	 * overflows if nbitsinlong == BITS_PER_LONG.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">nbitsinlong</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">mask</span> <span class="o">+=</span> <span class="n">mask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reg_op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">REG_OP_ISFREE</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlongs_reg</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* all bits in region free (zero) */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">REG_OP_ALLOC</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlongs_reg</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bitmap</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">REG_OP_RELEASE</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlongs_reg</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">bitmap</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_find_free_region - find a contiguous aligned mem region</span>
<span class="cm"> *	@bitmap: array of unsigned longs corresponding to the bitmap</span>
<span class="cm"> *	@bits: number of bits in the bitmap</span>
<span class="cm"> *	@order: region size (log base 2 of number of bits) to find</span>
<span class="cm"> *</span>
<span class="cm"> * Find a region of free (zero) bits in a @bitmap of @bits bits and</span>
<span class="cm"> * allocate them (set them to one).  Only consider regions of length</span>
<span class="cm"> * a power (@order) of two, aligned to that power of two, which</span>
<span class="cm"> * makes the search algorithm much faster.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the bit offset in bitmap of the allocated region,</span>
<span class="cm"> * or -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bitmap_find_free_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>		<span class="cm">/* scans bitmap by regions of size order */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">(</span><span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">bits</span><span class="p">;</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__reg_op</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">REG_OP_ISFREE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">__reg_op</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">REG_OP_ALLOC</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_find_free_region</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_release_region - release allocated bitmap region</span>
<span class="cm"> *	@bitmap: array of unsigned longs corresponding to the bitmap</span>
<span class="cm"> *	@pos: beginning of bit region to release</span>
<span class="cm"> *	@order: region size (log base 2 of number of bits) to release</span>
<span class="cm"> *</span>
<span class="cm"> * This is the complement to __bitmap_find_free_region() and releases</span>
<span class="cm"> * the found region (by clearing it in the bitmap).</span>
<span class="cm"> *</span>
<span class="cm"> * No return value.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bitmap_release_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__reg_op</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">REG_OP_RELEASE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_release_region</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_allocate_region - allocate bitmap region</span>
<span class="cm"> *	@bitmap: array of unsigned longs corresponding to the bitmap</span>
<span class="cm"> *	@pos: beginning of bit region to allocate</span>
<span class="cm"> *	@order: region size (log base 2 of number of bits) to allocate</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate (set bits in) a specified region of a bitmap.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, or %-EBUSY if specified region wasn&#39;t</span>
<span class="cm"> * free (not all bits were zero).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bitmap_allocate_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__reg_op</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">REG_OP_ISFREE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">__reg_op</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">REG_OP_ALLOC</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_allocate_region</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bitmap_copy_le - copy a bitmap, putting the bits into little-endian order.</span>
<span class="cm"> * @dst:   destination buffer</span>
<span class="cm"> * @src:   bitmap to copy</span>
<span class="cm"> * @nbits: number of bits in the bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * Require nbits % BITS_PER_LONG == 0.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bitmap_copy_le</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="o">/</span><span class="n">BITS_PER_LONG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span>
			<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bitmap_copy_le</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
