<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › decompress_unlzo.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>decompress_unlzo.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * LZO decompressor for the Linux kernel. Code borrowed from the lzo</span>
<span class="cm"> * implementation by Markus Franz Xaver Johannes Oberhumer.</span>
<span class="cm"> *</span>
<span class="cm"> * Linux kernel adaptation:</span>
<span class="cm"> * Copyright (C) 2009</span>
<span class="cm"> * Albin Tonnerre, Free Electrons &lt;albin.tonnerre@free-electrons.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Original code:</span>
<span class="cm"> * Copyright (C) 1996-2005 Markus Franz Xaver Johannes Oberhumer</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * lzop and the LZO library are free software; you can redistribute them</span>
<span class="cm"> * and/or modify them under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> * the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; see the file COPYING.</span>
<span class="cm"> * If not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Markus F.X.J. Oberhumer</span>
<span class="cm"> * &lt;markus@oberhumer.com&gt;</span>
<span class="cm"> * http://www.oberhumer.com/opensource/lzop/</span>
<span class="cm"> */</span>

<span class="cp">#ifdef STATIC</span>
<span class="cp">#include &quot;lzo/lzo1x_decompress.c&quot;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;linux/decompress/unlzo.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/lzo.h&gt;</span>
<span class="cp">#include &lt;linux/decompress/mm.h&gt;</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lzop_magic</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x89</span><span class="p">,</span> <span class="mh">0x4c</span><span class="p">,</span> <span class="mh">0x5a</span><span class="p">,</span> <span class="mh">0x4f</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x0d</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x1a</span><span class="p">,</span> <span class="mh">0x0a</span> <span class="p">};</span>

<span class="cp">#define LZO_BLOCK_SIZE        (256*1024l)</span>
<span class="cp">#define HEADER_HAS_FILTER      0x00000800L</span>
<span class="cp">#define HEADER_SIZE_MIN       (9 + 7     + 4 + 8     + 1       + 4)</span>
<span class="cp">#define HEADER_SIZE_MAX       (9 + 7 + 1 + 8 + 8 + 4 + 1 + 255 + 4)</span>

<span class="n">STATIC</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">parse_header</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">skip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">parse</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">input</span> <span class="o">+</span> <span class="n">in_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">version</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that there&#39;s enough input to possibly have a valid header.</span>
<span class="cm">	 * Then it is possible to parse several fields until the minimum</span>
<span class="cm">	 * size may have been used.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_len</span> <span class="o">&lt;</span> <span class="n">HEADER_SIZE_MIN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* read magic: 9 first bits */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">parse</span><span class="o">++</span> <span class="o">!=</span> <span class="n">lzop_magic</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* get version (2bytes), skip library version (2),</span>
<span class="cm">	 * &#39;need to be extracted&#39; version (2) and</span>
<span class="cm">	 * method (1) */</span>
	<span class="n">version</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="n">parse</span><span class="p">);</span>
	<span class="n">parse</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x0940</span><span class="p">)</span>
		<span class="n">level</span> <span class="o">=</span> <span class="o">*</span><span class="n">parse</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_unaligned_be32</span><span class="p">(</span><span class="n">parse</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HEADER_HAS_FILTER</span><span class="p">)</span>
		<span class="n">parse</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* flags + filter info */</span>
	<span class="k">else</span>
		<span class="n">parse</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* flags */</span>

	<span class="cm">/*</span>
<span class="cm">	 * At least mode, mtime_low, filename length, and checksum must</span>
<span class="cm">	 * be left to be parsed. If also mtime_high is present, it&#39;s OK</span>
<span class="cm">	 * because the next input buffer check is after reading the</span>
<span class="cm">	 * filename length.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">parse</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* skip mode and mtime_low */</span>
	<span class="n">parse</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="mh">0x0940</span><span class="p">)</span>
		<span class="n">parse</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* skip mtime_high */</span>

	<span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">parse</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* don&#39;t care about the file name, and skip checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">parse</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">parse</span> <span class="o">+=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

	<span class="o">*</span><span class="n">skip</span> <span class="o">=</span> <span class="n">parse</span> <span class="o">-</span> <span class="n">input</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STATIC</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">unlzo</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_len</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
				<span class="n">u8</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">posp</span><span class="p">,</span>
				<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src_len</span><span class="p">,</span> <span class="n">dst_len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">in_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">in_buf_save</span><span class="p">,</span> <span class="o">*</span><span class="n">out_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_buf</span> <span class="o">=</span> <span class="n">output</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">&quot;NULL output pointer and no flush function provided&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">out_buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">LZO_BLOCK_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span><span class="p">(</span><span class="s">&quot;Could not allocate output buffer&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">&amp;&amp;</span> <span class="n">fill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">&quot;Both input pointer and fill function provided, don&#39;t know what to do&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">in_buf</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">&quot;NULL input pointer and missing fill function&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">in_buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">lzo1x_worst_compress</span><span class="p">(</span><span class="n">LZO_BLOCK_SIZE</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span><span class="p">(</span><span class="s">&quot;Could not allocate input buffer&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">in_buf_save</span> <span class="o">=</span> <span class="n">in_buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">posp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">posp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fill</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Start from in_buf + HEADER_SIZE_MAX to make it possible</span>
<span class="cm">		 * to use memcpy() to copy the unused data to the beginning</span>
<span class="cm">		 * of the buffer. This way memmove() isn&#39;t needed which</span>
<span class="cm">		 * is missing from pre-boot environments of most archs.</span>
<span class="cm">		 */</span>
		<span class="n">in_buf</span> <span class="o">+=</span> <span class="n">HEADER_SIZE_MAX</span><span class="p">;</span>
		<span class="n">in_len</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="n">in_buf</span><span class="p">,</span> <span class="n">HEADER_SIZE_MAX</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_header</span><span class="p">(</span><span class="n">in_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skip</span><span class="p">,</span> <span class="n">in_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">&quot;invalid header&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">in_buf</span> <span class="o">+=</span> <span class="n">skip</span><span class="p">;</span>
	<span class="n">in_len</span> <span class="o">-=</span> <span class="n">skip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fill</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Move the unused data to the beginning of the buffer. */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">in_buf_save</span><span class="p">,</span> <span class="n">in_buf</span><span class="p">,</span> <span class="n">in_len</span><span class="p">);</span>
		<span class="n">in_buf</span> <span class="o">=</span> <span class="n">in_buf_save</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">posp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">posp</span> <span class="o">=</span> <span class="n">skip</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* read uncompressed block size */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fill</span> <span class="o">&amp;&amp;</span> <span class="n">in_len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skip</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="n">in_buf</span> <span class="o">+</span> <span class="n">in_len</span><span class="p">,</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">in_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">in_len</span> <span class="o">+=</span> <span class="n">skip</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span><span class="p">(</span><span class="s">&quot;file corrupted&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dst_len</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="n">in_buf</span><span class="p">);</span>
		<span class="n">in_buf</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">in_len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="cm">/* exit if last block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dst_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">posp</span><span class="p">)</span>
				<span class="o">*</span><span class="n">posp</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dst_len</span> <span class="o">&gt;</span> <span class="n">LZO_BLOCK_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span><span class="p">(</span><span class="s">&quot;dest len longer than block size&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* read compressed block size, and skip block checksum info */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fill</span> <span class="o">&amp;&amp;</span> <span class="n">in_len</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skip</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="n">in_buf</span> <span class="o">+</span> <span class="n">in_len</span><span class="p">,</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">in_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">in_len</span> <span class="o">+=</span> <span class="n">skip</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_len</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span><span class="p">(</span><span class="s">&quot;file corrupted&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">src_len</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="n">in_buf</span><span class="p">);</span>
		<span class="n">in_buf</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">in_len</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">src_len</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">src_len</span> <span class="o">&gt;</span> <span class="n">dst_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span><span class="p">(</span><span class="s">&quot;file corrupted&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* decompress */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fill</span> <span class="o">&amp;&amp;</span> <span class="n">in_len</span> <span class="o">&lt;</span> <span class="n">src_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skip</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="n">in_buf</span> <span class="o">+</span> <span class="n">in_len</span><span class="p">,</span> <span class="n">src_len</span> <span class="o">-</span> <span class="n">in_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">in_len</span> <span class="o">+=</span> <span class="n">skip</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_len</span> <span class="o">&lt;</span> <span class="n">src_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span><span class="p">(</span><span class="s">&quot;file corrupted&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">dst_len</span><span class="p">;</span>

		<span class="cm">/* When the input data is not compressed at all,</span>
<span class="cm">		 * lzo1x_decompress_safe will fail, so call memcpy()</span>
<span class="cm">		 * instead */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dst_len</span> <span class="o">==</span> <span class="n">src_len</span><span class="p">))</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">out_buf</span><span class="p">,</span> <span class="n">in_buf</span><span class="p">,</span> <span class="n">src_len</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">lzo1x_decompress_safe</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">in_buf</span><span class="p">,</span> <span class="n">src_len</span><span class="p">,</span>
						<span class="n">out_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">LZO_E_OK</span> <span class="o">||</span> <span class="n">dst_len</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span><span class="p">(</span><span class="s">&quot;Compressed data violation&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">exit_2</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span><span class="p">(</span><span class="n">out_buf</span><span class="p">,</span> <span class="n">dst_len</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dst_len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span>
			<span class="n">out_buf</span> <span class="o">+=</span> <span class="n">dst_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">posp</span><span class="p">)</span>
			<span class="o">*</span><span class="n">posp</span> <span class="o">+=</span> <span class="n">src_len</span> <span class="o">+</span> <span class="mi">12</span><span class="p">;</span>

		<span class="n">in_buf</span> <span class="o">+=</span> <span class="n">src_len</span><span class="p">;</span>
		<span class="n">in_len</span> <span class="o">-=</span> <span class="n">src_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fill</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If there happens to still be unused data left in</span>
<span class="cm">			 * in_buf, move it to the beginning of the buffer.</span>
<span class="cm">			 * Use a loop to avoid memmove() dependency.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">in_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">skip</span> <span class="o">&lt;</span> <span class="n">in_len</span><span class="p">;</span> <span class="o">++</span><span class="n">skip</span><span class="p">)</span>
					<span class="n">in_buf_save</span><span class="p">[</span><span class="n">skip</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_buf</span><span class="p">[</span><span class="n">skip</span><span class="p">];</span>
			<span class="n">in_buf</span> <span class="o">=</span> <span class="n">in_buf_save</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">exit_2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">input</span><span class="p">)</span>
		<span class="n">free</span><span class="p">(</span><span class="n">in_buf_save</span><span class="p">);</span>
<span class="nl">exit_1:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">output</span><span class="p">)</span>
		<span class="n">free</span><span class="p">(</span><span class="n">out_buf</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define decompress unlzo</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
