<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › bch.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>bch.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Generic binary BCH encoding/decoding library</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2011 Parrot S.A.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Ivan Djelic &lt;ivan.djelic@parrot.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *</span>
<span class="cm"> * This library provides runtime configurable encoding/decoding of binary</span>
<span class="cm"> * Bose-Chaudhuri-Hocquenghem (BCH) codes.</span>
<span class="cm"> *</span>
<span class="cm"> * Call init_bch to get a pointer to a newly allocated bch_control structure for</span>
<span class="cm"> * the given m (Galois field order), t (error correction capability) and</span>
<span class="cm"> * (optional) primitive polynomial parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * Call encode_bch to compute and store ecc parity bytes to a given buffer.</span>
<span class="cm"> * Call decode_bch to detect and locate errors in received data.</span>
<span class="cm"> *</span>
<span class="cm"> * On systems supporting hw BCH features, intermediate results may be provided</span>
<span class="cm"> * to decode_bch in order to skip certain steps. See decode_bch() documentation</span>
<span class="cm"> * for details.</span>
<span class="cm"> *</span>
<span class="cm"> * Option CONFIG_BCH_CONST_PARAMS can be used to force fixed values of</span>
<span class="cm"> * parameters m and t; thus allowing extra compiler optimizations and providing</span>
<span class="cm"> * better (up to 2x) encoding performance. Using this option makes sense when</span>
<span class="cm"> * (m,t) are fixed and known in advance, e.g. when using BCH error correction</span>
<span class="cm"> * on a particular NAND flash device.</span>
<span class="cm"> *</span>
<span class="cm"> * Algorithmic details:</span>
<span class="cm"> *</span>
<span class="cm"> * Encoding is performed by processing 32 input bits in parallel, using 4</span>
<span class="cm"> * remainder lookup tables.</span>
<span class="cm"> *</span>
<span class="cm"> * The final stage of decoding involves the following internal steps:</span>
<span class="cm"> * a. Syndrome computation</span>
<span class="cm"> * b. Error locator polynomial computation using Berlekamp-Massey algorithm</span>
<span class="cm"> * c. Error locator root finding (by far the most expensive step)</span>
<span class="cm"> *</span>
<span class="cm"> * In this implementation, step c is not performed using the usual Chien search.</span>
<span class="cm"> * Instead, an alternative approach described in [1] is used. It consists in</span>
<span class="cm"> * factoring the error locator polynomial using the Berlekamp Trace algorithm</span>
<span class="cm"> * (BTA) down to a certain degree (4), after which ad hoc low-degree polynomial</span>
<span class="cm"> * solving techniques [2] are used. The resulting algorithm, called BTZ, yields</span>
<span class="cm"> * much better performance than Chien search for usual (m,t) values (typically</span>
<span class="cm"> * m &gt;= 13, t &lt; 32, see [1]).</span>
<span class="cm"> *</span>
<span class="cm"> * [1] B. Biswas, V. Herbert. Efficient root finding of polynomials over fields</span>
<span class="cm"> * of characteristic 2, in: Western European Workshop on Research in Cryptology</span>
<span class="cm"> * - WEWoRC 2009, Graz, Austria, LNCS, Springer, July 2009, to appear.</span>
<span class="cm"> * [2] [Zin96] V.A. Zinoviev. On the solution of equations of degree 10 over</span>
<span class="cm"> * finite fields GF(2^q). In Rapport de recherche INRIA no 2829, 1996.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;linux/bch.h&gt;</span>

<span class="cp">#if defined(CONFIG_BCH_CONST_PARAMS)</span>
<span class="cp">#define GF_M(_p)               (CONFIG_BCH_CONST_M)</span>
<span class="cp">#define GF_T(_p)               (CONFIG_BCH_CONST_T)</span>
<span class="cp">#define GF_N(_p)               ((1 &lt;&lt; (CONFIG_BCH_CONST_M))-1)</span>
<span class="cp">#else</span>
<span class="cp">#define GF_M(_p)               ((_p)-&gt;m)</span>
<span class="cp">#define GF_T(_p)               ((_p)-&gt;t)</span>
<span class="cp">#define GF_N(_p)               ((_p)-&gt;n)</span>
<span class="cp">#endif</span>

<span class="cp">#define BCH_ECC_WORDS(_p)      DIV_ROUND_UP(GF_M(_p)*GF_T(_p), 32)</span>
<span class="cp">#define BCH_ECC_BYTES(_p)      DIV_ROUND_UP(GF_M(_p)*GF_T(_p), 8)</span>

<span class="cp">#ifndef dbg</span>
<span class="cp">#define dbg(_fmt, args...)     do {} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * represent a polynomial over GF(2^m)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gf_poly</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">deg</span><span class="p">;</span>    <span class="cm">/* polynomial degree */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>   <span class="cm">/* polynomial terms */</span>
<span class="p">};</span>

<span class="cm">/* given its degree, compute a polynomial size in bytes */</span>
<span class="cp">#define GF_POLY_SZ(_d) (sizeof(struct gf_poly)+((_d)+1)*sizeof(unsigned int))</span>

<span class="cm">/* polynomial of degree 1 */</span>
<span class="k">struct</span> <span class="n">gf_poly_deg1</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="n">poly</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * same as encode_bch(), but process input data one byte at a time</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_bch_unaligned</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">ecc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">BCH_ECC_WORDS</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">mod8_tab</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">++</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ecc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">ecc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">))</span><span class="o">^</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>

		<span class="n">ecc</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ecc</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * convert ecc bytes to aligned, zero-padded 32-bit ecc words</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">load_ecc8</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">pad</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nwords</span> <span class="o">=</span> <span class="n">BCH_ECC_WORDS</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nwords</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">src</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="n">src</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">BCH_ECC_BYTES</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">nwords</span><span class="p">);</span>
	<span class="n">dst</span><span class="p">[</span><span class="n">nwords</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">pad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">pad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="n">pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * convert 32-bit ecc words to ecc bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">store_ecc8</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">pad</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nwords</span> <span class="o">=</span> <span class="n">BCH_ECC_WORDS</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nwords</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">nwords</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">pad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">nwords</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">pad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">nwords</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">pad</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">nwords</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">BCH_ECC_BYTES</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">nwords</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * encode_bch - calculate BCH ecc parity of data</span>
<span class="cm"> * @bch:   BCH control structure</span>
<span class="cm"> * @data:  data to encode</span>
<span class="cm"> * @len:   data length in bytes</span>
<span class="cm"> * @ecc:   ecc parity data, must be initialized by caller</span>
<span class="cm"> *</span>
<span class="cm"> * The @ecc parity array is used both as input and output parameter, in order to</span>
<span class="cm"> * allow incremental computations. It should be of the size indicated by member</span>
<span class="cm"> * @ecc_bytes of @bch, and should be initialized to 0 before the first call.</span>
<span class="cm"> *</span>
<span class="cm"> * The exact number of computed ecc parity bits is given by member @ecc_bits of</span>
<span class="cm"> * @bch; it may be less than m*t for large values of t.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">encode_bch</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ecc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">BCH_ECC_WORDS</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">mlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">w</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">tab0</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">mod8_tab</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">tab1</span> <span class="o">=</span> <span class="n">tab0</span> <span class="o">+</span> <span class="mi">256</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">tab2</span> <span class="o">=</span> <span class="n">tab1</span> <span class="o">+</span> <span class="mi">256</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">tab3</span> <span class="o">=</span> <span class="n">tab2</span> <span class="o">+</span> <span class="mi">256</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pdata</span><span class="p">,</span> <span class="o">*</span><span class="n">p0</span><span class="p">,</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">,</span> <span class="o">*</span><span class="n">p3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ecc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* load ecc parity bytes into internal 32-bit buffer */</span>
		<span class="n">load_ecc8</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">,</span> <span class="n">ecc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* process first unaligned data bytes */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">-</span><span class="n">m</span><span class="p">))</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="mi">4</span><span class="o">-</span><span class="n">m</span><span class="p">;</span>
		<span class="n">encode_bch_unaligned</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mlen</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">mlen</span><span class="p">;</span>
		<span class="n">len</span>  <span class="o">-=</span> <span class="n">mlen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* process 32-bit aligned data words */</span>
	<span class="n">pdata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">mlen</span>  <span class="o">=</span> <span class="n">len</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="n">mlen</span><span class="p">;</span>
	<span class="n">len</span>  <span class="o">-=</span> <span class="mi">4</span><span class="o">*</span><span class="n">mlen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * split each 32-bit word into 4 polynomials of weight 8 as follows:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 31 ...24  23 ...16  15 ... 8  7 ... 0</span>
<span class="cm">	 * xxxxxxxx  yyyyyyyy  zzzzzzzz  tttttttt</span>
<span class="cm">	 *                               tttttttt  mod g = r0 (precomputed)</span>
<span class="cm">	 *                     zzzzzzzz  00000000  mod g = r1 (precomputed)</span>
<span class="cm">	 *           yyyyyyyy  00000000  00000000  mod g = r2 (precomputed)</span>
<span class="cm">	 * xxxxxxxx  00000000  00000000  00000000  mod g = r3 (precomputed)</span>
<span class="cm">	 * xxxxxxxx  yyyyyyyy  zzzzzzzz  tttttttt  mod g = r0^r1^r2^r3</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mlen</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* input data is read in big-endian format */</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="o">*</span><span class="n">pdata</span><span class="o">++</span><span class="p">);</span>
		<span class="n">p0</span> <span class="o">=</span> <span class="n">tab0</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">w</span> <span class="o">&gt;&gt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">p1</span> <span class="o">=</span> <span class="n">tab1</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">w</span> <span class="o">&gt;&gt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">p2</span> <span class="o">=</span> <span class="n">tab2</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">w</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">p3</span> <span class="o">=</span> <span class="n">tab3</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">w</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="n">p0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="n">p3</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">r</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">p0</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">^</span><span class="n">p1</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">^</span><span class="n">p2</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">^</span><span class="n">p3</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>

	<span class="cm">/* process last unaligned bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
		<span class="n">encode_bch_unaligned</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">);</span>

	<span class="cm">/* store ecc parity bytes into original parity buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ecc</span><span class="p">)</span>
		<span class="n">store_ecc8</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">ecc</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">encode_bch</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">modulo</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">GF_M</span><span class="p">(</span><span class="n">bch</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * shorter and faster modulo function, only works when v &lt; 2N.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mod_s</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">?</span> <span class="n">v</span> <span class="o">:</span> <span class="n">v</span><span class="o">-</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">deg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">poly</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* polynomial degree is the most-significant bit index */</span>
	<span class="k">return</span> <span class="n">fls</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">parity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * public domain code snippet, lifted from</span>
<span class="cm">	 * http://www-graphics.stanford.edu/~seander/bithacks.html</span>
<span class="cm">	 */</span>
	<span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">x</span> <span class="o">^=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x11111111U</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x11111111U</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Galois field basic operations: multiply, divide, inverse, etc. */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gf_mul</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">+</span>
					       <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">b</span><span class="p">])]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gf_sqr</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">?</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">a</span><span class="p">])]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gf_div</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">?</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">+</span>
					<span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">b</span><span class="p">])]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gf_inv</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">a</span><span class="p">]];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">a_pow</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">modulo</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">i</span><span class="p">)];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">a_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">a_ilog</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute 2t syndromes of ecc polynomial, i.e. ecc(a^j) for j=1..2t</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">compute_syndromes</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">ecc</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">syn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">poly</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">GF_T</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_bits</span><span class="p">;</span>

	<span class="cm">/* make sure extra bits in last ecc word are cleared */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">31</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">ecc</span><span class="p">[</span><span class="n">s</span><span class="o">/</span><span class="mi">32</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">m</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">syn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">syn</span><span class="p">));</span>

	<span class="cm">/* compute v(a^j) for j=1 .. 2t-1 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">poly</span> <span class="o">=</span> <span class="o">*</span><span class="n">ecc</span><span class="o">++</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">-=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">deg</span><span class="p">(</span><span class="n">poly</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">syn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^=</span> <span class="n">a_pow</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">s</span><span class="p">));</span>

			<span class="n">poly</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* v(a^(2j)) = v(a^j)^2 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="n">syn</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gf_sqr</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">syn</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gf_poly_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">GF_POLY_SZ</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compute_error_locator_polynomial</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">syn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">GF_T</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">syn</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">elp</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">elp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">pelp</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">elp_copy</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">pelp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GF_POLY_SZ</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">elp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GF_POLY_SZ</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>

	<span class="n">pelp</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pelp</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">elp</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">elp</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* use simplified binary Berlekamp-Massey algorithm */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">elp</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="n">pp</span><span class="p">;</span>
			<span class="n">gf_poly_copy</span><span class="p">(</span><span class="n">elp_copy</span><span class="p">,</span> <span class="n">elp</span><span class="p">);</span>
			<span class="cm">/* e[i+1](X) = e[i](X)+di*dp^-1*X^2(i-p)*e[p](X) */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">pelp</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pelp</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">l</span> <span class="o">=</span> <span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">pelp</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
					<span class="n">elp</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">^=</span> <span class="n">a_pow</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">tmp</span><span class="o">+</span><span class="n">l</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/* compute l[i+1] = max(l[i]-&gt;c[l[p]+2*(i-p]) */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">pelp</span><span class="o">-&gt;</span><span class="n">deg</span><span class="o">+</span><span class="n">k</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">elp</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">elp</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="n">gf_poly_copy</span><span class="p">(</span><span class="n">pelp</span><span class="p">,</span> <span class="n">elp_copy</span><span class="p">);</span>
				<span class="n">pd</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
				<span class="n">pp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* di+1 = S(2i+3)+elp[i+1].1*S(2i+2)+...+elp[i+1].lS(2i+3-l) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">syn</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">elp</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">d</span> <span class="o">^=</span> <span class="n">gf_mul</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">elp</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">syn</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">-</span><span class="n">j</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;elp=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gf_poly_str</span><span class="p">(</span><span class="n">elp</span><span class="p">));</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">elp</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">elp</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * solve a m x m linear system in GF(2) with an expected number of solutions,</span>
<span class="cm"> * and return the number of found solutions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">solve_linear_system</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rows</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">GF_M</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rem</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">param</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>

	<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">;</span>

	<span class="cm">/* Gaussian elimination */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-</span><span class="n">k</span><span class="p">;</span>
		<span class="cm">/* find suitable row for elimination */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">tmp</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
					<span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
					<span class="n">rows</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">rem</span> <span class="o">=</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rem</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* perform elimination on remaining rows */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">rem</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
					<span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">^=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* elimination not needed, store defective row index */</span>
			<span class="n">param</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* rewrite system, inserting fake parameter rows */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
				<span class="cm">/* system has no solution */</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">param</span><span class="p">[</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">?</span>
				<span class="n">p</span><span class="o">--</span><span class="p">,</span> <span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nsol</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">))</span>
		<span class="cm">/* unexpected number of solutions */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">nsol</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set parameters for p-th solution */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
			<span class="n">rows</span><span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="p">((</span><span class="n">p</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* compute unique solution */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tmp</span><span class="o">|</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="n">parity</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="n">r</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sol</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nsol</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this function builds and solves a linear system for finding roots of a degree</span>
<span class="cm"> * 4 affine monic polynomial X^4+aX^2+bX+c over GF(2^m).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_affine4_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">roots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">GF_M</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">rows</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>

	<span class="n">j</span> <span class="o">=</span> <span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

	<span class="cm">/* buid linear system to solve X^4+aX^2+bX+c = 0 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">^</span>
			<span class="p">(</span><span class="n">a</span> <span class="o">?</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span><span class="o">^</span>
			<span class="p">(</span><span class="n">b</span> <span class="o">?</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="n">k</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * transpose 16x16 matrix before passing it to linear solver</span>
<span class="cm">	 * warning: this code assumes m &lt; 16</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span> <span class="o">^=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span> <span class="o">=</span> <span class="p">((</span><span class="n">rows</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">j</span><span class="p">)</span><span class="o">^</span><span class="n">rows</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
			<span class="n">rows</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">^=</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">);</span>
			<span class="n">rows</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">^=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute root r of a degree 1 polynomial over GF(2^m) (returned as log(1/r))</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_poly_deg1_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">poly</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">roots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="cm">/* poly[X] = bX+c with c!=0, root=c/b */</span>
		<span class="n">roots</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span>
				   <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]);</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute roots of a degree 2 polynomial over GF(2^m)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_poly_deg2_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">poly</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">roots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>

		<span class="n">l0</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
		<span class="n">l1</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
		<span class="n">l2</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span>

		<span class="cm">/* using z=a/bX, transform aX^2+bX+c into z^2+z+u (u=ac/b^2) */</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">a_pow</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">l0</span><span class="o">+</span><span class="n">l2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">l1</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * let u = sum(li.a^i) i=0..m-1; then compute r = sum(li.xi):</span>
<span class="cm">		 * r^2+r = sum(li.(xi^2+xi)) = sum(li.(a^i+Tr(a^i).a^k)) =</span>
<span class="cm">		 * u + sum(li.Tr(a^i).a^k) = u+a^k.Tr(sum(li.a^i)) = u+a^k.Tr(u)</span>
<span class="cm">		 * i.e. r and r+1 are roots iff Tr(u)=0</span>
<span class="cm">		 */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">deg</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
			<span class="n">r</span> <span class="o">^=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">xi_tab</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">v</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* verify root */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">gf_sqr</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span><span class="o">^</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* reverse z=a/bX transformation and compute log(1/r) */</span>
			<span class="n">roots</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">l1</span><span class="o">-</span>
					    <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">+</span><span class="n">l2</span><span class="p">);</span>
			<span class="n">roots</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">l1</span><span class="o">-</span>
					    <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">r</span><span class="o">^</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">l2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute roots of a degree 3 polynomial over GF(2^m)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_poly_deg3_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">poly</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">roots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">e3</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/* transform polynomial into monic X^3 + a2X^2 + b2X + c2 */</span>
		<span class="n">e3</span> <span class="o">=</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">c2</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e3</span><span class="p">);</span>
		<span class="n">b2</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">e3</span><span class="p">);</span>
		<span class="n">a2</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e3</span><span class="p">);</span>

		<span class="cm">/* (X+a2)(X^3+a2X^2+b2X+c2) = X^4+aX^2+bX+c (affine) */</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">gf_mul</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">c2</span><span class="p">);</span>           <span class="cm">/* c = a2c2      */</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">gf_mul</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span><span class="o">^</span><span class="n">c2</span><span class="p">;</span>        <span class="cm">/* b = a2b2 + c2 */</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">gf_sqr</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span><span class="o">^</span><span class="n">b2</span><span class="p">;</span>            <span class="cm">/* a = a2^2 + b2 */</span>

		<span class="cm">/* find the 4 roots of this affine polynomial */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">find_affine4_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* remove a2 from final list of roots */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a2</span><span class="p">)</span>
					<span class="n">roots</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_ilog</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute roots of a degree 4 polynomial over GF(2^m)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_poly_deg4_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">poly</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">roots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">e4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* transform polynomial into monic X^4 + aX^3 + bX^2 + cX + d */</span>
	<span class="n">e4</span> <span class="o">=</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">d</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e4</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">e4</span><span class="p">);</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e4</span><span class="p">);</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">e4</span><span class="p">);</span>

	<span class="cm">/* use Y=1/X transformation to get an affine polynomial */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* first, eliminate cX by using z=X+e with ae^2+c=0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* compute e such that e^2 = c/a */</span>
			<span class="n">f</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
			<span class="n">l</span> <span class="o">+=</span> <span class="p">(</span><span class="n">l</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">a_pow</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * use transformation z=X+e:</span>
<span class="cm">			 * z^4+e^4 + a(z^3+ez^2+e^2z+e^3) + b(z^2+e^2) +cz+ce+d</span>
<span class="cm">			 * z^4 + az^3 + (ae+b)z^2 + (ae^2+c)z+e^4+be^2+ae^3+ce+d</span>
<span class="cm">			 * z^4 + az^3 + (ae+b)z^2 + e^4+be^2+d</span>
<span class="cm">			 * z^4 + az^3 +     b&#39;z^2 + d&#39;</span>
<span class="cm">			 */</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">a_pow</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="p">)</span><span class="o">^</span><span class="n">gf_mul</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span><span class="o">^</span><span class="n">d</span><span class="p">;</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">gf_mul</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span><span class="o">^</span><span class="n">b</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* now, use Y=1/X to get Y^4 + b/dY^2 + a/dY + 1/d */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* assume all roots have multiplicity 1 */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">c2</span> <span class="o">=</span> <span class="n">gf_inv</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="n">b2</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="n">a2</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* polynomial is already affine */</span>
		<span class="n">c2</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
		<span class="n">b2</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">a2</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* find the 4 roots of this affine polynomial */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_affine4_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">roots</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* post-process roots (reverse transformations) */</span>
			<span class="n">f</span> <span class="o">=</span> <span class="n">a</span> <span class="o">?</span> <span class="n">gf_inv</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">roots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">:</span> <span class="n">roots</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">roots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_ilog</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">f</span><span class="o">^</span><span class="n">e</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * build monic, log-based representation of a polynomial</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gf_poly_logrep</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">]);</span>

	<span class="cm">/* represent 0 values with -1; warning, rep[d] is not set to 1 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="n">l</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute polynomial Euclidean division remainder in GF(2^m)[X]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gf_poly_mod</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">la</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* reuse or compute log representation of denominator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rep</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">;</span>
		<span class="n">gf_poly_logrep</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rep</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">la</span> <span class="o">=</span> <span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="n">d</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">m</span> <span class="o">=</span> <span class="n">rep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">^=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span>
								     <span class="n">m</span><span class="o">+</span><span class="n">la</span><span class="p">)];</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span>
		<span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute polynomial Euclidean division quotient in GF(2^m)[X]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gf_poly_div</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span><span class="o">-</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span>
		<span class="cm">/* compute a mod b (modifies a) */</span>
		<span class="n">gf_poly_mod</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* quotient is stored in upper part of polynomial a */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute polynomial GCD (Greatest Common Divisor) in GF(2^m)[X]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="nf">gf_poly_gcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;gcd(%s,%s)=&quot;</span><span class="p">,</span> <span class="n">gf_poly_str</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">gf_poly_str</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gf_poly_mod</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gf_poly_str</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a polynomial f and an integer k, compute Tr(a^kX) mod f</span>
<span class="cm"> * This is used in Berlekamp Trace algorithm for splitting polynomials</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">compute_trace_bk_mod</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">z</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">GF_M</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* z contains z^2j mod f */</span>
	<span class="n">z</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">z</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">z</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

	<span class="n">out</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GF_POLY_SZ</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">));</span>

	<span class="cm">/* compute f log representation only once */</span>
	<span class="n">gf_poly_logrep</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* add a^(k*2^i)(z^(2^i) mod f) and compute (z^(2^i) mod f)^2 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">out</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="n">z</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">gf_sqr</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="n">z</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&gt;</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span>
			<span class="n">out</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">z</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="cm">/* z^(2(i+1)) mod f = (z^(2^i) mod f)^2 mod f */</span>
			<span class="n">gf_poly_mod</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span>
		<span class="n">out</span><span class="o">-&gt;</span><span class="n">deg</span><span class="o">--</span><span class="p">;</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;Tr(a^%d.X) mod f = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">gf_poly_str</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * factor a polynomial using Berlekamp Trace algorithm (BTA)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">factor_polynomial</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">**</span><span class="n">g</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">**</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">f2</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">q</span>  <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">tk</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">z</span>  <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">gcd</span><span class="p">;</span>

	<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;factoring %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gf_poly_str</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>

	<span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
	<span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* tk = Tr(a^k.X) mod f */</span>
	<span class="n">compute_trace_bk_mod</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">tk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tk</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* compute g = gcd(f, tk) (destructive operation) */</span>
		<span class="n">gf_poly_copy</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="n">gcd</span> <span class="o">=</span> <span class="n">gf_poly_gcd</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">tk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gcd</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* compute h=f/gcd(f,tk); this will modify f and q */</span>
			<span class="n">gf_poly_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">gcd</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
			<span class="cm">/* store g and h in-place (clobbering f) */</span>
			<span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">gf_poly_deg1</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="p">)[</span><span class="n">gcd</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">].</span><span class="n">poly</span><span class="p">;</span>
			<span class="n">gf_poly_copy</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="n">gcd</span><span class="p">);</span>
			<span class="n">gf_poly_copy</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find roots of a polynomial, using BTZ algorithm; see the beginning of this</span>
<span class="cm"> * file for details</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_poly_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">poly</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">roots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">f1</span><span class="p">,</span> <span class="o">*</span><span class="n">f2</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* handle low degree polynomials with ad hoc techniques */</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">find_poly_deg1_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">roots</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">find_poly_deg2_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">roots</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">find_poly_deg3_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">roots</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">find_poly_deg4_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">roots</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* factor polynomial using Berlekamp Trace Algorithm (BTA) */</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">poly</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">GF_M</span><span class="p">(</span><span class="n">bch</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">factor_polynomial</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f1</span><span class="p">)</span>
				<span class="n">cnt</span> <span class="o">+=</span> <span class="n">find_poly_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">roots</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f2</span><span class="p">)</span>
				<span class="n">cnt</span> <span class="o">+=</span> <span class="n">find_poly_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">roots</span><span class="o">+</span><span class="n">cnt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(USE_CHIEN_SEARCH)</span>
<span class="cm">/*</span>
<span class="cm"> * exhaustive root search (Chien) implementation - not used, included only for</span>
<span class="cm"> * reference/comparison tests</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">chien_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">roots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">syn</span><span class="p">,</span> <span class="n">syn0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="n">len</span><span class="o">+</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_bits</span><span class="p">;</span>

	<span class="cm">/* use a log-based representation of polynomial */</span>
	<span class="n">gf_poly_logrep</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">syn0</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* compute elp(a^i) */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">syn</span> <span class="o">=</span> <span class="n">syn0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">syn</span> <span class="o">^=</span> <span class="n">a_pow</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">roots</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">)</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define find_poly_roots(_p, _k, _elp, _loc) chien_search(_p, len, _elp, _loc)</span>
<span class="cp">#endif </span><span class="cm">/* USE_CHIEN_SEARCH */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * decode_bch - decode received codeword and find bit error locations</span>
<span class="cm"> * @bch:      BCH control structure</span>
<span class="cm"> * @data:     received data, ignored if @calc_ecc is provided</span>
<span class="cm"> * @len:      data length in bytes, must always be provided</span>
<span class="cm"> * @recv_ecc: received ecc, if NULL then assume it was XORed in @calc_ecc</span>
<span class="cm"> * @calc_ecc: calculated ecc, if NULL then calc_ecc is computed from @data</span>
<span class="cm"> * @syn:      hw computed syndrome data (if NULL, syndrome is calculated)</span>
<span class="cm"> * @errloc:   output array of error locations</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  The number of errors found, or -EBADMSG if decoding failed, or -EINVAL if</span>
<span class="cm"> *  invalid parameters were provided</span>
<span class="cm"> *</span>
<span class="cm"> * Depending on the available hw BCH support and the need to compute @calc_ecc</span>
<span class="cm"> * separately (using encode_bch()), this function should be called with one of</span>
<span class="cm"> * the following parameter configurations -</span>
<span class="cm"> *</span>
<span class="cm"> * by providing @data and @recv_ecc only:</span>
<span class="cm"> *   decode_bch(@bch, @data, @len, @recv_ecc, NULL, NULL, @errloc)</span>
<span class="cm"> *</span>
<span class="cm"> * by providing @recv_ecc and @calc_ecc:</span>
<span class="cm"> *   decode_bch(@bch, NULL, @len, @recv_ecc, @calc_ecc, NULL, @errloc)</span>
<span class="cm"> *</span>
<span class="cm"> * by providing ecc = recv_ecc XOR calc_ecc:</span>
<span class="cm"> *   decode_bch(@bch, NULL, @len, NULL, ecc, NULL, @errloc)</span>
<span class="cm"> *</span>
<span class="cm"> * by providing syndrome results @syn:</span>
<span class="cm"> *   decode_bch(@bch, NULL, @len, NULL, NULL, @syn, @errloc)</span>
<span class="cm"> *</span>
<span class="cm"> * Once decode_bch() has successfully returned with a positive value, error</span>
<span class="cm"> * locations returned in array @errloc should be interpreted as follows -</span>
<span class="cm"> *</span>
<span class="cm"> * if (errloc[n] &gt;= 8*len), then n-th error is located in ecc (no need for</span>
<span class="cm"> * data correction)</span>
<span class="cm"> *</span>
<span class="cm"> * if (errloc[n] &lt; 8*len), then n-th error is located in data and can be</span>
<span class="cm"> * corrected with statement data[errloc[n]/8] ^= 1 &lt;&lt; (errloc[n] % 8);</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function does not perform any data correction by itself, it</span>
<span class="cm"> * merely indicates error locations.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">decode_bch</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">recv_ecc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">calc_ecc</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">syn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecc_words</span> <span class="o">=</span> <span class="n">BCH_ECC_WORDS</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">nroots</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">sum</span><span class="p">;</span>

	<span class="cm">/* sanity check: make sure data length can be handled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">n</span><span class="o">-</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_bits</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* if caller does not provide syndromes, compute them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">syn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">calc_ecc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* compute received data ecc into an internal buffer */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span> <span class="o">||</span> <span class="o">!</span><span class="n">recv_ecc</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">encode_bch</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* load provided calculated ecc */</span>
			<span class="n">load_ecc8</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">,</span> <span class="n">calc_ecc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* load received ecc or assume it was XORed in calc_ecc */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">recv_ecc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">load_ecc8</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf2</span><span class="p">,</span> <span class="n">recv_ecc</span><span class="p">);</span>
			<span class="cm">/* XOR received and calculated ecc */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ecc_words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">sum</span> <span class="o">|=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sum</span><span class="p">)</span>
				<span class="cm">/* no error found */</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">compute_syndromes</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">);</span>
		<span class="n">syn</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">compute_error_locator_polynomial</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">syn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nroots</span> <span class="o">=</span> <span class="n">find_poly_roots</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">elp</span><span class="p">,</span> <span class="n">errloc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">nroots</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* post-process raw error locations for easier correction */</span>
		<span class="n">nbits</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_bits</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">err</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">errloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nbits</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">errloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbits</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">errloc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">errloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">errloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">7</span><span class="o">-</span><span class="p">(</span><span class="n">errloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">decode_bch</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * generate Galois field lookup tables</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">build_gf_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">poly</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">deg</span><span class="p">(</span><span class="n">poly</span><span class="p">);</span>

	<span class="cm">/* primitive polynomial must be of degree m */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">GF_M</span><span class="p">(</span><span class="n">bch</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
			<span class="cm">/* polynomial is not primitive (a^i=1 with 0&lt;i&lt;2^m-1) */</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span>
			<span class="n">x</span> <span class="o">^=</span> <span class="n">poly</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute generator polynomial remainder tables for fast encoding</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">build_mod8_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">data</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="o">*</span><span class="n">tab</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">BCH_ECC_WORDS</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">plen</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_bits</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">ecclen</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_bits</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">mod8_tab</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">256</span><span class="o">*</span><span class="n">l</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">mod8_tab</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* p(X)=i is a small polynomial of weight &lt;= 8 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we want to compute (p(X).X^(8*b+deg(g))) mod g(X) */</span>
			<span class="n">tab</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">mod8_tab</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="mi">256</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">l</span><span class="p">;</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">b</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">d</span> <span class="o">=</span> <span class="n">deg</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
				<span class="cm">/* subtract X^d.g(X) from p(X).X^(8*b+deg(g)) */</span>
				<span class="n">data</span> <span class="o">^=</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">d</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ecclen</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">?</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">plen</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">tab</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">^=</span> <span class="n">hi</span><span class="o">|</span><span class="n">lo</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * build a base for factoring degree 2 polynomials</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">build_deg2_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">GF_M</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">ak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xi</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>

	<span class="cm">/* find k s.t. Tr(a^k) = 1 and 0 &lt;= k &lt; m */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">sum</span> <span class="o">^=</span> <span class="n">a_pow</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ak</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* find xi, i=0..m-1 such that xi^2+xi = a^i+Tr(a^i).a^k */</span>
	<span class="n">remaining</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xi</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">remaining</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">y</span> <span class="o">=</span> <span class="n">gf_sqr</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="n">x</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">a_log</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xi</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">bch</span><span class="o">-&gt;</span><span class="n">xi_tab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
				<span class="n">xi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">remaining</span><span class="o">--</span><span class="p">;</span>
				<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;x%d = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">y</span> <span class="o">^=</span> <span class="n">ak</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* should not happen but check anyway */</span>
	<span class="k">return</span> <span class="n">remaining</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">bch_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compute generator polynomial for given (m,t) parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="nf">compute_generator_polynomial</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">GF_M</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">GF_T</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="o">*</span><span class="n">roots</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gf_poly</span> <span class="o">*</span><span class="n">g</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">genpoly</span><span class="p">;</span>

	<span class="n">g</span> <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="n">GF_POLY_SZ</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">roots</span> <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">((</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">roots</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">genpoly</span> <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">genpoly</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">genpoly</span><span class="p">);</span>
		<span class="n">genpoly</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* enumerate all roots of g(X) */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">roots</span> <span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">roots</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">roots</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">mod_s</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* build generator polynomial g(X) */</span>
	<span class="n">g</span><span class="o">-&gt;</span><span class="n">deg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">g</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">GF_N</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* multiply g(X) by (X+root) */</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">g</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">deg</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
				<span class="n">g</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">gf_mul</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">r</span><span class="p">)</span><span class="o">^</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

			<span class="n">g</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gf_mul</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">);</span>
			<span class="n">g</span><span class="o">-&gt;</span><span class="n">deg</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* store left-justified binary representation of g(X) */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">deg</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nbits</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">?</span> <span class="mi">32</span> <span class="o">:</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">])</span>
				<span class="n">word</span> <span class="o">|=</span> <span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">j</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">genpoly</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="n">nbits</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_bits</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">deg</span><span class="p">;</span>

<span class="nl">finish:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">roots</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">genpoly</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_bch - initialize a BCH encoder/decoder</span>
<span class="cm"> * @m:          Galois field order, should be in the range 5-15</span>
<span class="cm"> * @t:          maximum error correction capability, in bits</span>
<span class="cm"> * @prim_poly:  user-provided primitive polynomial (or 0 to use default)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  a newly allocated BCH control structure if successful, NULL otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * This initialization can take some time, as lookup tables are built for fast</span>
<span class="cm"> * encoding/decoding; make sure not to call this function from a time critical</span>
<span class="cm"> * path. Usually, init_bch() should be called on module/driver init and</span>
<span class="cm"> * free_bch() should be called to release memory on exit.</span>
<span class="cm"> *</span>
<span class="cm"> * You may provide your own primitive polynomial of degree @m in argument</span>
<span class="cm"> * @prim_poly, or let init_bch() use its default polynomial.</span>
<span class="cm"> *</span>
<span class="cm"> * Once init_bch() has successfully returned a pointer to a newly allocated</span>
<span class="cm"> * BCH control structure, ecc length in bytes is given by member @ecc_bytes of</span>
<span class="cm"> * the structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="nf">init_bch</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prim_poly</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">words</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">genpoly</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">int</span> <span class="n">min_m</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">max_m</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>

	<span class="cm">/* default primitive polynomials */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prim_poly_tab</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0x11d</span><span class="p">,</span> <span class="mh">0x211</span><span class="p">,</span> <span class="mh">0x409</span><span class="p">,</span> <span class="mh">0x805</span><span class="p">,</span> <span class="mh">0x1053</span><span class="p">,</span> <span class="mh">0x201b</span><span class="p">,</span>
		<span class="mh">0x402b</span><span class="p">,</span> <span class="mh">0x8003</span><span class="p">,</span>
	<span class="p">};</span>

<span class="cp">#if defined(CONFIG_BCH_CONST_PARAMS)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">m</span> <span class="o">!=</span> <span class="p">(</span><span class="n">CONFIG_BCH_CONST_M</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="p">(</span><span class="n">CONFIG_BCH_CONST_T</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;bch encoder/decoder was configured to support &quot;</span>
		       <span class="s">&quot;parameters m=%d, t=%d only!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">CONFIG_BCH_CONST_M</span><span class="p">,</span> <span class="n">CONFIG_BCH_CONST_T</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">min_m</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">max_m</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * values of m greater than 15 are not currently supported;</span>
<span class="cm">		 * supporting m &gt; 15 would require changing table base type</span>
<span class="cm">		 * (uint16_t) and a small patch in matrix transposition</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* sanity checks */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
		<span class="cm">/* invalid t value */</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* select a primitive polynomial for generating GF(2^m) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prim_poly</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">prim_poly</span> <span class="o">=</span> <span class="n">prim_poly_tab</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">min_m</span><span class="p">];</span>

	<span class="n">bch</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">words</span>  <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_bytes</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span> <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span> <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">mod8_tab</span>  <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="n">words</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">mod8_tab</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span>   <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="n">words</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf2</span>  <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="n">words</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf2</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">xi_tab</span>    <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">xi_tab</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">syn</span>       <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span>     <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">bch</span><span class="o">-&gt;</span><span class="n">elp</span>       <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">((</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gf_poly_deg1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bch_alloc</span><span class="p">(</span><span class="n">GF_POLY_SZ</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">build_gf_tables</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">prim_poly</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* use generator polynomial for computing encoding tables */</span>
	<span class="n">genpoly</span> <span class="o">=</span> <span class="n">compute_generator_polynomial</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">genpoly</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">build_mod8_tables</span><span class="p">(</span><span class="n">bch</span><span class="p">,</span> <span class="n">genpoly</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">genpoly</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">build_deg2_base</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bch</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">free_bch</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">init_bch</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  free_bch - free the BCH control structure</span>
<span class="cm"> *  @bch:    BCH control structure to release</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">free_bch</span><span class="p">(</span><span class="k">struct</span> <span class="n">bch_control</span> <span class="o">*</span><span class="n">bch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_pow_tab</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">a_log_tab</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">mod8_tab</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">ecc_buf2</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">xi_tab</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">cache</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">elp</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="o">-&gt;</span><span class="n">poly_2t</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">bch</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">free_bch</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Ivan Djelic &lt;ivan.djelic@parrot.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Binary BCH encoder/decoder&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
