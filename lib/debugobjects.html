<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › debugobjects.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>debugobjects.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Generic infrastructure for lifetime debugging of objects.</span>
<span class="cm"> *</span>
<span class="cm"> * Started by Thomas Gleixner</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008, Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * For licencing details see kernel-base/COPYING</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/debugobjects.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>

<span class="cp">#define ODEBUG_HASH_BITS	14</span>
<span class="cp">#define ODEBUG_HASH_SIZE	(1 &lt;&lt; ODEBUG_HASH_BITS)</span>

<span class="cp">#define ODEBUG_POOL_SIZE	512</span>
<span class="cp">#define ODEBUG_POOL_MIN_LEVEL	256</span>

<span class="cp">#define ODEBUG_CHUNK_SHIFT	PAGE_SHIFT</span>
<span class="cp">#define ODEBUG_CHUNK_SIZE	(1 &lt;&lt; ODEBUG_CHUNK_SHIFT)</span>
<span class="cp">#define ODEBUG_CHUNK_MASK	(~(ODEBUG_CHUNK_SIZE - 1))</span>

<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="n">raw_spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_bucket</span>	<span class="n">obj_hash</span><span class="p">[</span><span class="n">ODEBUG_HASH_SIZE</span><span class="p">];</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj</span>		<span class="n">obj_static_pool</span><span class="p">[</span><span class="n">ODEBUG_POOL_SIZE</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">pool_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="n">HLIST_HEAD</span><span class="p">(</span><span class="n">obj_pool</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>			<span class="n">obj_pool_min_free</span> <span class="o">=</span> <span class="n">ODEBUG_POOL_SIZE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">obj_pool_free</span> <span class="o">=</span> <span class="n">ODEBUG_POOL_SIZE</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">obj_pool_used</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">obj_pool_max_used</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span>	<span class="o">*</span><span class="n">obj_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span>			<span class="n">debug_objects_maxchain</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">debug_objects_fixups</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">debug_objects_warnings</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span>			<span class="n">debug_objects_enabled</span> <span class="n">__read_mostly</span>
				<span class="o">=</span> <span class="n">CONFIG_DEBUG_OBJECTS_ENABLE_DEFAULT</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span>	<span class="o">*</span><span class="n">descr_test</span>  <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">free_obj_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">debug_obj_work</span><span class="p">,</span> <span class="n">free_obj_work</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">enable_object_debug</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_objects_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">disable_object_debug</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debug_objects_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;debug_objects&quot;</span><span class="p">,</span> <span class="n">enable_object_debug</span><span class="p">);</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;no_debug_objects&quot;</span><span class="p">,</span> <span class="n">disable_object_debug</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">obj_states</span><span class="p">[</span><span class="n">ODEBUG_STATE_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">ODEBUG_STATE_NONE</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;none&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ODEBUG_STATE_INIT</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;initialized&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ODEBUG_STATE_INACTIVE</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;inactive&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ODEBUG_STATE_ACTIVE</span><span class="p">]</span>		<span class="o">=</span> <span class="s">&quot;active&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ODEBUG_STATE_DESTROYED</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;destroyed&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ODEBUG_STATE_NOTAVAILABLE</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;not available&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gfp_t</span> <span class="n">gfp</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">obj_pool_free</span> <span class="o">&gt;=</span> <span class="n">ODEBUG_POOL_MIN_LEVEL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">obj_cache</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">obj_pool_free</span> <span class="o">&lt;</span> <span class="n">ODEBUG_POOL_MIN_LEVEL</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">new</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">obj_cache</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_pool</span><span class="p">);</span>
		<span class="n">obj_pool_free</span><span class="o">++</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup an object in the hash bucket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="nf">lookup_object</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">object</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">debug_objects_maxchain</span><span class="p">)</span>
		<span class="n">debug_objects_maxchain</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new object. If the pool is empty, switch off the debugger.</span>
<span class="cm"> * Must be called with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span>
<span class="nf">alloc_object</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj_pool</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">obj</span>	    <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">obj_pool</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="p">),</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">object</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">descr</span>  <span class="o">=</span> <span class="n">descr</span><span class="p">;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span>  <span class="o">=</span> <span class="n">ODEBUG_STATE_NONE</span><span class="p">;</span>
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">astate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">obj_pool_used</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj_pool_used</span> <span class="o">&gt;</span> <span class="n">obj_pool_max_used</span><span class="p">)</span>
			<span class="n">obj_pool_max_used</span> <span class="o">=</span> <span class="n">obj_pool_used</span><span class="p">;</span>

		<span class="n">obj_pool_free</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj_pool_free</span> <span class="o">&lt;</span> <span class="n">obj_pool_min_free</span><span class="p">)</span>
			<span class="n">obj_pool_min_free</span> <span class="o">=</span> <span class="n">obj_pool_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * workqueue function to free objects.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_obj_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">obj_pool_free</span> <span class="o">&gt;</span> <span class="n">ODEBUG_POOL_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">obj_pool</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="p">),</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">obj_pool_free</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We release pool_lock across kmem_cache_free() to</span>
<span class="cm">		 * avoid contention on pool_lock.</span>
<span class="cm">		 */</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">obj_cache</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Put the object back into the pool and schedule work to free objects</span>
<span class="cm"> * if necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * schedule work when the pool is filled and the cache is</span>
<span class="cm">	 * initialized:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj_pool_free</span> <span class="o">&gt;</span> <span class="n">ODEBUG_POOL_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">obj_cache</span><span class="p">)</span>
		<span class="n">sched</span> <span class="o">=</span> <span class="n">keventd_up</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">debug_obj_work</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_pool</span><span class="p">);</span>
	<span class="n">obj_pool_free</span><span class="o">++</span><span class="p">;</span>
	<span class="n">obj_pool_used</span><span class="o">--</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sched</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">debug_obj_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We run out of memory. That means we probably have tons of objects</span>
<span class="cm"> * allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">debug_objects_oom</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span> <span class="o">=</span> <span class="n">obj_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">HLIST_HEAD</span><span class="p">(</span><span class="n">freelist</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ODEBUG: Out of memory. ODEBUG disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ODEBUG_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">db</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hlist_move_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freelist</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Now free them */</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">free_object</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We use the pfn of the address for the hash. That way we can check</span>
<span class="cm"> * for freed objects simply by checking the affected bucket.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="nf">get_bucket</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">hash_long</span><span class="p">((</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="n">ODEBUG_CHUNK_SHIFT</span><span class="p">),</span> <span class="n">ODEBUG_HASH_BITS</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">obj_hash</span><span class="p">[</span><span class="n">hash</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">debug_print_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">descr</span> <span class="o">!=</span> <span class="n">descr_test</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">hint</span> <span class="o">=</span> <span class="n">descr</span><span class="o">-&gt;</span><span class="n">debug_hint</span> <span class="o">?</span>
			<span class="n">descr</span><span class="o">-&gt;</span><span class="n">debug_hint</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">object</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">limit</span><span class="o">++</span><span class="p">;</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;ODEBUG: %s %s (active state %u) &quot;</span>
				 <span class="s">&quot;object type: %s hint: %pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">msg</span><span class="p">,</span> <span class="n">obj_states</span><span class="p">[</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">],</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">astate</span><span class="p">,</span>
			<span class="n">descr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">hint</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">debug_objects_warnings</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to repair the damage, so we have a better chance to get useful</span>
<span class="cm"> * debug output.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">debug_object_fixup</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fixup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">),</span>
		   <span class="kt">void</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fixed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fixup</span><span class="p">)</span>
		<span class="n">fixed</span> <span class="o">=</span> <span class="n">fixup</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="n">debug_objects_fixups</span> <span class="o">+=</span> <span class="n">fixed</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fixed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">debug_object_is_on_stack</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">is_on_stack</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">is_on_stack</span> <span class="o">=</span> <span class="n">object_is_on_stack</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_on_stack</span> <span class="o">==</span> <span class="n">onstack</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">limit</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_on_stack</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;ODEBUG: object is on stack, but not annotated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;ODEBUG: object is not on stack, but annotated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__debug_object_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onstack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">fill_pool</span><span class="p">();</span>

	<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">alloc_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">descr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debug_objects_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">debug_objects_oom</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">debug_object_is_on_stack</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">onstack</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_NONE</span>:
	<span class="k">case</span> <span class="n">ODEBUG_STATE_INIT</span>:
	<span class="k">case</span> <span class="n">ODEBUG_STATE_INACTIVE</span>:
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ODEBUG_STATE_INIT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;init&quot;</span><span class="p">);</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">debug_object_fixup</span><span class="p">(</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">fixup_init</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_DESTROYED</span>:
		<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;init&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * debug_object_init - debug checks when an object is initialized</span>
<span class="cm"> * @addr:	address of the object</span>
<span class="cm"> * @descr:	pointer to an object specific debug description structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_object_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__debug_object_init</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">descr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * debug_object_init_on_stack - debug checks when an object on stack is</span>
<span class="cm"> *				initialized</span>
<span class="cm"> * @addr:	address of the object</span>
<span class="cm"> * @descr:	pointer to an object specific debug description structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_object_init_on_stack</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">__debug_object_init</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">descr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * debug_object_activate - debug checks when an object is activated</span>
<span class="cm"> * @addr:	address of the object</span>
<span class="cm"> * @descr:	pointer to an object specific debug description structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_object_activate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="n">o</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
			       <span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span><span class="p">,</span>
			       <span class="p">.</span><span class="n">descr</span> <span class="o">=</span> <span class="n">descr</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ODEBUG_STATE_INIT</span>:
		<span class="k">case</span> <span class="n">ODEBUG_STATE_INACTIVE</span>:
			<span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ODEBUG_STATE_ACTIVE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
			<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;activate&quot;</span><span class="p">);</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">debug_object_fixup</span><span class="p">(</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">fixup_activate</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ODEBUG_STATE_DESTROYED</span>:
			<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;activate&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This happens when a static object is activated. We</span>
<span class="cm">	 * let the type specific code decide whether this is</span>
<span class="cm">	 * true or not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_object_fixup</span><span class="p">(</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">fixup_activate</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
			   <span class="n">ODEBUG_STATE_NOTAVAILABLE</span><span class="p">))</span>
		<span class="n">debug_print_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="p">,</span> <span class="s">&quot;activate&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * debug_object_deactivate - debug checks when an object is deactivated</span>
<span class="cm"> * @addr:	address of the object</span>
<span class="cm"> * @descr:	pointer to an object specific debug description structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_object_deactivate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ODEBUG_STATE_INIT</span>:
		<span class="k">case</span> <span class="n">ODEBUG_STATE_INACTIVE</span>:
		<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">astate</span><span class="p">)</span>
				<span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ODEBUG_STATE_INACTIVE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;deactivate&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ODEBUG_STATE_DESTROYED</span>:
			<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;deactivate&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">debug_obj</span> <span class="n">o</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
				       <span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span><span class="p">,</span>
				       <span class="p">.</span><span class="n">descr</span> <span class="o">=</span> <span class="n">descr</span> <span class="p">};</span>

		<span class="n">debug_print_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="p">,</span> <span class="s">&quot;deactivate&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * debug_object_destroy - debug checks when an object is destroyed</span>
<span class="cm"> * @addr:	address of the object</span>
<span class="cm"> * @descr:	pointer to an object specific debug description structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_object_destroy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_NONE</span>:
	<span class="k">case</span> <span class="n">ODEBUG_STATE_INIT</span>:
	<span class="k">case</span> <span class="n">ODEBUG_STATE_INACTIVE</span>:
		<span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">ODEBUG_STATE_DESTROYED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;destroy&quot;</span><span class="p">);</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">debug_object_fixup</span><span class="p">(</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">fixup_destroy</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_DESTROYED</span>:
		<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;destroy&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * debug_object_free - debug checks when an object is freed</span>
<span class="cm"> * @addr:	address of the object</span>
<span class="cm"> * @descr:	pointer to an object specific debug description structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_object_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;free&quot;</span><span class="p">);</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">debug_object_fixup</span><span class="p">(</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">fixup_free</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">free_object</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * debug_object_assert_init - debug checks when object should be init-ed</span>
<span class="cm"> * @addr:	address of the object</span>
<span class="cm"> * @descr:	pointer to an object specific debug description structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">debug_object_assert_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">debug_obj</span> <span class="n">o</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
				       <span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span><span class="p">,</span>
				       <span class="p">.</span><span class="n">descr</span> <span class="o">=</span> <span class="n">descr</span> <span class="p">};</span>

		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Maybe the object is static.  Let the type specific</span>
<span class="cm">		 * code decide what to do.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug_object_fixup</span><span class="p">(</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">fixup_assert_init</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
				       <span class="n">ODEBUG_STATE_NOTAVAILABLE</span><span class="p">))</span>
			<span class="n">debug_print_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="p">,</span> <span class="s">&quot;assert_init&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * debug_object_active_state - debug checks object usage state machine</span>
<span class="cm"> * @addr:	address of the object</span>
<span class="cm"> * @descr:	pointer to an object specific debug description structure</span>
<span class="cm"> * @expect:	expected state</span>
<span class="cm"> * @next:	state to move to if expected state is found</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">debug_object_active_state</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">expect</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">astate</span> <span class="o">==</span> <span class="n">expect</span><span class="p">)</span>
				<span class="n">obj</span><span class="o">-&gt;</span><span class="n">astate</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;active_state&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;active_state&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">debug_obj</span> <span class="n">o</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span>
				       <span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span><span class="p">,</span>
				       <span class="p">.</span><span class="n">descr</span> <span class="o">=</span> <span class="n">descr</span> <span class="p">};</span>

		<span class="n">debug_print_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="p">,</span> <span class="s">&quot;active_state&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_FREE</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__debug_check_no_obj_freed</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">oaddr</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">eaddr</span><span class="p">,</span> <span class="n">paddr</span><span class="p">,</span> <span class="n">chunks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">HLIST_HEAD</span><span class="p">(</span><span class="n">freelist</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">saddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">eaddr</span> <span class="o">=</span> <span class="n">saddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">paddr</span> <span class="o">=</span> <span class="n">saddr</span> <span class="o">&amp;</span> <span class="n">ODEBUG_CHUNK_MASK</span><span class="p">;</span>
	<span class="n">chunks</span> <span class="o">=</span> <span class="p">((</span><span class="n">eaddr</span> <span class="o">-</span> <span class="n">paddr</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ODEBUG_CHUNK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">chunks</span> <span class="o">&gt;&gt;=</span> <span class="n">ODEBUG_CHUNK_SHIFT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span><span class="n">chunks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chunks</span><span class="o">--</span><span class="p">,</span> <span class="n">paddr</span> <span class="o">+=</span> <span class="n">ODEBUG_CHUNK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">(</span><span class="n">paddr</span><span class="p">);</span>

<span class="nl">repeat:</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">oaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">object</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oaddr</span> <span class="o">&lt;</span> <span class="n">saddr</span> <span class="o">||</span> <span class="n">oaddr</span> <span class="o">&gt;=</span> <span class="n">eaddr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
				<span class="n">debug_print_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&quot;free&quot;</span><span class="p">);</span>
				<span class="n">descr</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">;</span>
				<span class="n">state</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
				<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">debug_object_fixup</span><span class="p">(</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">fixup_free</span><span class="p">,</span>
						   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">oaddr</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
				<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freelist</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Now free them */</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">free_object</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">debug_objects_maxchain</span><span class="p">)</span>
			<span class="n">debug_objects_maxchain</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">debug_check_no_obj_freed</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="n">__debug_check_no_obj_freed</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">debug_stats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;max_chain     :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">debug_objects_maxchain</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;warnings      :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">debug_objects_warnings</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;fixups        :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">debug_objects_fixups</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool_free     :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">obj_pool_free</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool_min_free :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">obj_pool_min_free</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool_used     :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">obj_pool_used</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;pool_max_used :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">obj_pool_max_used</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">debug_stats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">debug_stats_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">debug_stats_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">debug_stats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">debug_objects_init_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dbgdir</span><span class="p">,</span> <span class="o">*</span><span class="n">dbgstats</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dbgdir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;debug_objects&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbgdir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dbgstats</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;stats&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">dbgdir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">debug_stats_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbgstats</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">dbgdir</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">debug_objects_init_debugfs</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_objects_init_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_SELFTEST</span>

<span class="cm">/* Random data structure for the self test */</span>
<span class="k">struct</span> <span class="n">self_test</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dummy1</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">int</span>		<span class="n">static_init</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dummy2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">descr_type_test</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_init is called when:</span>
<span class="cm"> * - an active object is initialized</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fixup_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">self_test</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
		<span class="n">debug_object_init</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_activate is called when:</span>
<span class="cm"> * - an active object is activated</span>
<span class="cm"> * - an unknown object is activated (might be a statically initialized object)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fixup_activate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">self_test</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_NOTAVAILABLE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">static_init</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">debug_object_init</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
			<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
		<span class="n">debug_object_activate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_destroy is called when:</span>
<span class="cm"> * - an active object is destroyed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fixup_destroy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">self_test</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
		<span class="n">debug_object_destroy</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fixup_free is called when:</span>
<span class="cm"> * - an active object is freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fixup_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">self_test</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ODEBUG_STATE_ACTIVE</span>:
		<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
		<span class="n">debug_object_free</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">check_results</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">debug_obj_state</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fixups</span><span class="p">,</span> <span class="kt">int</span> <span class="n">warnings</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">db</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">obj</span> <span class="o">=</span> <span class="n">lookup_object</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">ODEBUG_STATE_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;ODEBUG: selftest object not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;ODEBUG: selftest wrong state: %d != %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">obj</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fixups</span> <span class="o">!=</span> <span class="n">debug_objects_fixups</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;ODEBUG: selftest fixups failed %d != %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fixups</span><span class="p">,</span> <span class="n">debug_objects_fixups</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">warnings</span> <span class="o">!=</span> <span class="n">debug_objects_warnings</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;ODEBUG: selftest warnings failed %d != %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">warnings</span><span class="p">,</span> <span class="n">debug_objects_warnings</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">debug_objects_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="k">struct</span> <span class="n">debug_obj_descr</span> <span class="n">descr_type_test</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;selftest&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_init</span>		<span class="o">=</span> <span class="n">fixup_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_activate</span>		<span class="o">=</span> <span class="n">fixup_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_destroy</span>		<span class="o">=</span> <span class="n">fixup_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fixup_free</span>		<span class="o">=</span> <span class="n">fixup_free</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="k">struct</span> <span class="n">self_test</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">static_init</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">debug_objects_selftest</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">oldfixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">,</span> <span class="n">oldwarnings</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">fixups</span> <span class="o">=</span> <span class="n">oldfixups</span> <span class="o">=</span> <span class="n">debug_objects_fixups</span><span class="p">;</span>
	<span class="n">warnings</span> <span class="o">=</span> <span class="n">oldwarnings</span> <span class="o">=</span> <span class="n">debug_objects_warnings</span><span class="p">;</span>
	<span class="n">descr_test</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">;</span>

	<span class="n">debug_object_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_INIT</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_ACTIVE</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_ACTIVE</span><span class="p">,</span> <span class="o">++</span><span class="n">fixups</span><span class="p">,</span> <span class="o">++</span><span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_INACTIVE</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_DESTROYED</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_DESTROYED</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="o">++</span><span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_DESTROYED</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="o">++</span><span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_deactivate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_DESTROYED</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="o">++</span><span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_NONE</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">obj</span><span class="p">.</span><span class="n">static_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">debug_object_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_ACTIVE</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_INIT</span><span class="p">,</span> <span class="o">++</span><span class="n">fixups</span><span class="p">,</span> <span class="o">++</span><span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_NONE</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_FREE</span>
	<span class="n">debug_object_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_INIT</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">debug_object_activate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descr_type_test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_ACTIVE</span><span class="p">,</span> <span class="n">fixups</span><span class="p">,</span> <span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">__debug_check_no_obj_freed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_results</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="n">ODEBUG_STATE_NONE</span><span class="p">,</span> <span class="o">++</span><span class="n">fixups</span><span class="p">,</span> <span class="o">++</span><span class="n">warnings</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;ODEBUG: selftest passed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">debug_objects_fixups</span> <span class="o">=</span> <span class="n">oldfixups</span><span class="p">;</span>
	<span class="n">debug_objects_warnings</span> <span class="o">=</span> <span class="n">oldwarnings</span><span class="p">;</span>
	<span class="n">descr_test</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">debug_objects_selftest</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Called during early boot to initialize the hash buckets and link</span>
<span class="cm"> * the static object pool objects into the poll list. After this call</span>
<span class="cm"> * the object tracker is fully operational.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">debug_objects_early_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ODEBUG_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj_hash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ODEBUG_POOL_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj_static_pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert the statically allocated objects to dynamic ones:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">debug_objects_replace_static_objects</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">debug_bucket</span> <span class="o">*</span><span class="n">db</span> <span class="o">=</span> <span class="n">obj_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">debug_obj</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="n">HLIST_HEAD</span><span class="p">(</span><span class="n">objects</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ODEBUG_POOL_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">obj_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
		<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When debug_objects_mem_init() is called we know that only</span>
<span class="cm">	 * one CPU is up, so disabling interrupts is enough</span>
<span class="cm">	 * protection. This avoids the lockdep hell of lock ordering.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="cm">/* Remove the statically allocated objects from the pool */</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_pool</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="cm">/* Move the allocated objects to the pool */</span>
	<span class="n">hlist_move_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objects</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_pool</span><span class="p">);</span>

	<span class="cm">/* Replace the active object references */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ODEBUG_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">db</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_move_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">);</span>

		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">obj_pool</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="p">),</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="cm">/* copy object data */</span>
			<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
			<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;ODEBUG: %d of %d active objects replaced</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span>
	       <span class="n">obj_pool_used</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">free:</span>
	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">obj_cache</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called after the kmem_caches are functional to setup a dedicated</span>
<span class="cm"> * cache pool, which has the SLAB_DEBUG_OBJECTS flag set. This flag</span>
<span class="cm"> * prevents that the debug code is called on kmem_cache_free() for the</span>
<span class="cm"> * debug tracker objects to avoid recursive calls.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">debug_objects_mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">debug_objects_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">obj_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;debug_objects_cache&quot;</span><span class="p">,</span>
				      <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">debug_obj</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="n">SLAB_DEBUG_OBJECTS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj_cache</span> <span class="o">||</span> <span class="n">debug_objects_replace_static_objects</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">debug_objects_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj_cache</span><span class="p">)</span>
			<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">obj_cache</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ODEBUG: out of memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">debug_objects_selftest</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
