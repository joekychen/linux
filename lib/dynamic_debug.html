<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › dynamic_debug.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>dynamic_debug.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * lib/dynamic_debug.c</span>
<span class="cm"> *</span>
<span class="cm"> * make pr_debug()/dev_dbg() calls runtime configurable based upon their</span>
<span class="cm"> * source module.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008 Jason Baron &lt;jbaron@redhat.com&gt;</span>
<span class="cm"> * By Greg Banks &lt;gnb@melbourne.sgi.com&gt;</span>
<span class="cm"> * Copyright (c) 2008 Silicon Graphics Inc.  All Rights Reserved.</span>
<span class="cm"> * Copyright (C) 2011 Bart Van Assche.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;:%s: &quot; fmt, __func__</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/dynamic_debug.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/jump_label.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">_ddebug</span> <span class="n">__start___verbose</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">_ddebug</span> <span class="n">__stop___verbose</span><span class="p">[];</span>

<span class="k">struct</span> <span class="n">ddebug_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_ddebugs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">ddebugs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ddebug_query</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_lineno</span><span class="p">,</span> <span class="n">last_lineno</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ddebug_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ddebug_table</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ddebug_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ddebug_tables</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="cm">/* Return the last part of a pathname */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">basename</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tail</span> <span class="o">?</span> <span class="n">tail</span><span class="o">+</span><span class="mi">1</span> <span class="o">:</span> <span class="n">path</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the path relative to source root */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">trim_prefix</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">skip</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">__FILE__</span><span class="p">)</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;lib/dynamic_debug.c&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">skip</span><span class="p">))</span>
		<span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* prefix mismatch, don&#39;t skip */</span>

	<span class="k">return</span> <span class="n">path</span> <span class="o">+</span> <span class="n">skip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">unsigned</span> <span class="n">flag</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span> <span class="kt">char</span> <span class="n">opt_char</span><span class="p">;</span> <span class="p">}</span> <span class="n">opt_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">_DPRINTK_FLAGS_PRINT</span><span class="p">,</span> <span class="sc">&#39;p&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">_DPRINTK_FLAGS_INCL_MODNAME</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">_DPRINTK_FLAGS_INCL_FUNCNAME</span><span class="p">,</span> <span class="sc">&#39;f&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">_DPRINTK_FLAGS_INCL_LINENO</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">_DPRINTK_FLAGS_INCL_TID</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">_DPRINTK_FLAGS_NONE</span><span class="p">,</span> <span class="sc">&#39;_&#39;</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* format a string into buf[] which describes the _ddebug&#39;s flags */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ddebug_describe_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">maxlen</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">opt_array</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">opt_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag</span><span class="p">)</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">opt_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">opt_char</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">buf</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define vpr_info(fmt, ...) \</span>
<span class="cp">	if (verbose) do { pr_info(fmt, ##__VA_ARGS__); } while (0)</span>

<span class="cp">#define vpr_info_dq(q, msg)					\</span>
<span class="cp">do {								\</span>
<span class="cp">	</span><span class="cm">/* trim last char off format print */</span><span class="cp">			\</span>
<span class="cp">	vpr_info(&quot;%s: func=\&quot;%s\&quot; file=\&quot;%s\&quot; &quot;			\</span>
<span class="cp">		&quot;module=\&quot;%s\&quot; format=\&quot;%.*s\&quot; &quot;		\</span>
<span class="cp">		&quot;lineno=%u-%u&quot;,					\</span>
<span class="cp">		msg,						\</span>
<span class="cp">		q-&gt;function ? q-&gt;function : &quot;&quot;,			\</span>
<span class="cp">		q-&gt;filename ? q-&gt;filename : &quot;&quot;,			\</span>
<span class="cp">		q-&gt;module ? q-&gt;module : &quot;&quot;,			\</span>
<span class="cp">		(int)(q-&gt;format ? strlen(q-&gt;format) - 1 : 0),	\</span>
<span class="cp">		q-&gt;format ? q-&gt;format : &quot;&quot;,			\</span>
<span class="cp">		q-&gt;first_lineno, q-&gt;last_lineno);		\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Search the tables for _ddebug&#39;s which match the given `query&#39; and</span>
<span class="cm"> * apply the `flags&#39; and `mask&#39; to them.  Returns number of matching</span>
<span class="cm"> * callsites, normally the same as number of changes.  If verbose,</span>
<span class="cm"> * logs the changes.  Takes ddebug_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_change</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ddebug_query</span> <span class="o">*</span><span class="n">query</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ddebug_table</span> <span class="o">*</span><span class="n">dt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">newflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">flagbuf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="cm">/* search for matching ddebugs */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddebug_tables</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* match against the module name */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">,</span> <span class="n">dt</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dt</span><span class="o">-&gt;</span><span class="n">num_ddebugs</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">ddebugs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/* match against the source filename */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">filename</span> <span class="o">&amp;&amp;</span>
			    <span class="n">strcmp</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">strcmp</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">basename</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="n">strcmp</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">trim_prefix</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* match against the function */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">&amp;&amp;</span>
			    <span class="n">strcmp</span><span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* match against the format */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">format</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">strstr</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="n">query</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* match against the line number range */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">first_lineno</span> <span class="o">&amp;&amp;</span>
			    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">lineno</span> <span class="o">&lt;</span> <span class="n">query</span><span class="o">-&gt;</span><span class="n">first_lineno</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">last_lineno</span> <span class="o">&amp;&amp;</span>
			    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">lineno</span> <span class="o">&gt;</span> <span class="n">query</span><span class="o">-&gt;</span><span class="n">last_lineno</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">nfound</span><span class="o">++</span><span class="p">;</span>

			<span class="n">newflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newflags</span> <span class="o">==</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">newflags</span><span class="p">;</span>
			<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;changed %s:%d [%s]%s =%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">trim_prefix</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">),</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">lineno</span><span class="p">,</span>
				<span class="n">dt</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span>
				<span class="n">ddebug_describe_flags</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">flagbuf</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">flagbuf</span><span class="p">)));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfound</span> <span class="o">&amp;&amp;</span> <span class="n">verbose</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;no matches for query</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nfound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split the buffer `buf&#39; into space-separated words.</span>
<span class="cm"> * Handles simple &quot; and &#39; quoting, i.e. without nested,</span>
<span class="cm"> * embedded or escaped \&quot;.  Return the number of words</span>
<span class="cm"> * or &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_tokenize</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">words</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">maxwords</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nwords</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

		<span class="cm">/* Skip leading whitespace */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">buf</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* oh, it was trailing whitespace */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* token starts comment, skip rest of line */</span>

		<span class="cm">/* find `end&#39; of word, whitespace separated or quoted */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">&#39;\&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">quote</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">end</span> <span class="o">=</span> <span class="n">buf</span> <span class="p">;</span> <span class="o">*</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">end</span> <span class="o">!=</span> <span class="n">quote</span> <span class="p">;</span> <span class="n">end</span><span class="o">++</span><span class="p">)</span>
				<span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">end</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	<span class="cm">/* unclosed quote */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">end</span> <span class="o">=</span> <span class="n">buf</span> <span class="p">;</span> <span class="o">*</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span> <span class="p">;</span> <span class="n">end</span><span class="o">++</span><span class="p">)</span>
				<span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* `buf&#39; is start of word, `end&#39; is one past its end */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nwords</span> <span class="o">==</span> <span class="n">maxwords</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	<span class="cm">/* ran out of words[] before bytes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span>
			<span class="o">*</span><span class="n">end</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>	<span class="cm">/* terminate the word */</span>
		<span class="n">words</span><span class="p">[</span><span class="n">nwords</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;split into words:&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nwords</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nwords</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse a single line number.  Note that the empty string &quot;&quot;</span>
<span class="cm"> * is treated as a special case and converted to zero, which</span>
<span class="cm"> * is later treated as a &quot;don&#39;t care&quot; value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">parse_lineno</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">end</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">end</span> <span class="o">==</span> <span class="n">str</span> <span class="o">||</span> <span class="o">*</span><span class="n">end</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Undo octal escaping in a string, inplace.  This is useful to</span>
<span class="cm"> * allow the user to express a query which matches a format</span>
<span class="cm"> * containing embedded spaces.</span>
<span class="cm"> */</span>
<span class="cp">#define isodigit(c)		((c) &gt;= &#39;0&#39; &amp;&amp; (c) &lt;= &#39;7&#39;)</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">unescape</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">in</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">in</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\\&#39;</span><span class="p">;</span>
				<span class="n">in</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;t&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\t&#39;</span><span class="p">;</span>
				<span class="n">in</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;n&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
				<span class="n">in</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isodigit</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			         <span class="n">isodigit</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			         <span class="n">isodigit</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="p">((</span><span class="n">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">)</span> <span class="o">|</span>
				          <span class="p">((</span><span class="n">in</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="o">|</span>
				          <span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
				<span class="n">in</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">in</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">dest</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;match-spec:%s val:%s overridden by %s&quot;</span><span class="p">,</span>
			<span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse words[] as a ddebug query specification, which is a series</span>
<span class="cm"> * of (keyword, value) pairs chosen from these possibilities:</span>
<span class="cm"> *</span>
<span class="cm"> * func &lt;function-name&gt;</span>
<span class="cm"> * file &lt;full-pathname&gt;</span>
<span class="cm"> * file &lt;base-filename&gt;</span>
<span class="cm"> * module &lt;module-name&gt;</span>
<span class="cm"> * format &lt;escaped-string-to-find-in-format&gt;</span>
<span class="cm"> * line &lt;lineno&gt;</span>
<span class="cm"> * line &lt;first-lineno&gt;-&lt;last-lineno&gt; // where either may be empty</span>
<span class="cm"> *</span>
<span class="cm"> * Only 1 of each type is allowed.</span>
<span class="cm"> * Returns 0 on success, &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_parse_query</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">words</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">nwords</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ddebug_query</span> <span class="o">*</span><span class="n">query</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* check we have an even number of words */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nwords</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">query</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">modname</span><span class="p">)</span>
		<span class="cm">/* support $modname.dyndbg=&lt;multiple queries&gt; */</span>
		<span class="n">query</span><span class="o">-&gt;</span><span class="n">module</span> <span class="o">=</span> <span class="n">modname</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nwords</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;func&quot;</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">check_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;func&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;file&quot;</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">check_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;file&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;module&quot;</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">check_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;module&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;format&quot;</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">check_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="n">unescape</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span>
				<span class="s">&quot;format&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;line&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">first_lineno</span> <span class="o">||</span> <span class="n">query</span><span class="o">-&gt;</span><span class="n">last_lineno</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;match-spec:line given 2 times</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
				<span class="o">*</span><span class="n">last</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parse_lineno</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">first_lineno</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* range &lt;first&gt;-&lt;last&gt; */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">parse_lineno</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">query</span><span class="o">-&gt;</span><span class="n">last_lineno</span><span class="p">)</span>
				    <span class="o">&lt;</span> <span class="n">query</span><span class="o">-&gt;</span><span class="n">first_lineno</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;last-line &lt; 1st-line</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">query</span><span class="o">-&gt;</span><span class="n">last_lineno</span> <span class="o">=</span> <span class="n">query</span><span class="o">-&gt;</span><span class="n">first_lineno</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;unknown keyword </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vpr_info_dq</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="s">&quot;parsed&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse `str&#39; as a flags specification, format [-+=][p]+.</span>
<span class="cm"> * Sets up *maskp and *flagsp to be used when changing the</span>
<span class="cm"> * flags fields of matched _ddebug&#39;s.  Returns 0 on success</span>
<span class="cm"> * or &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_parse_flags</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flagsp</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">maskp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">op</span> <span class="o">=</span> <span class="sc">&#39;=&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;+&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;-&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;=&#39;</span>:
		<span class="n">op</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;op=&#39;%c&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="o">*</span><span class="n">str</span> <span class="p">;</span> <span class="o">++</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">opt_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="n">opt_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">opt_char</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flags</span> <span class="o">|=</span> <span class="n">opt_array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flag</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;flags=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* calculate final *flagsp, *maskp according to mask and op */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;=&#39;</span>:
		<span class="o">*</span><span class="n">maskp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">flagsp</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;+&#39;</span>:
		<span class="o">*</span><span class="n">maskp</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
		<span class="o">*</span><span class="n">flagsp</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;-&#39;</span>:
		<span class="o">*</span><span class="n">maskp</span> <span class="o">=</span> <span class="o">~</span><span class="n">flags</span><span class="p">;</span>
		<span class="o">*</span><span class="n">flagsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;*flagsp=0x%x *maskp=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">flagsp</span><span class="p">,</span> <span class="o">*</span><span class="n">maskp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_exec_query</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">query_string</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ddebug_query</span> <span class="n">query</span><span class="p">;</span>
<span class="cp">#define MAXWORDS 9</span>
	<span class="kt">int</span> <span class="n">nwords</span><span class="p">,</span> <span class="n">nfound</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">words</span><span class="p">[</span><span class="n">MAXWORDS</span><span class="p">];</span>

	<span class="n">nwords</span> <span class="o">=</span> <span class="n">ddebug_tokenize</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">MAXWORDS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nwords</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ddebug_parse_query</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">nwords</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">,</span> <span class="n">modname</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ddebug_parse_flags</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">nwords</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* actually go and implement the change */</span>
	<span class="n">nfound</span> <span class="o">=</span> <span class="n">ddebug_change</span><span class="p">(</span><span class="o">&amp;</span><span class="n">query</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="n">vpr_info_dq</span><span class="p">((</span><span class="o">&amp;</span><span class="n">query</span><span class="p">),</span> <span class="p">(</span><span class="n">nfound</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;applied&quot;</span> <span class="o">:</span> <span class="s">&quot;no-match&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nfound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* handle multiple queries in query string, continue on error, return</span>
<span class="cm">   last error or number of matching callsites.  Module name is either</span>
<span class="cm">   in param (for boot arg) or perhaps in query string.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_exec_queries</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">query</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">split</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">errs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">exitcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">nfound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">query</span><span class="p">;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">split</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">split</span> <span class="o">=</span> <span class="n">strpbrk</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="s">&quot;;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">split</span><span class="p">)</span>
			<span class="o">*</span><span class="n">split</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="n">query</span> <span class="o">=</span> <span class="n">skip_spaces</span><span class="p">(</span><span class="n">query</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">query</span> <span class="o">||</span> <span class="o">!*</span><span class="n">query</span> <span class="o">||</span> <span class="o">*</span><span class="n">query</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;query %d: </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">query</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">ddebug_exec_query</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">modname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">errs</span><span class="o">++</span><span class="p">;</span>
			<span class="n">exitcode</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">nfound</span> <span class="o">+=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;processed %d queries, with %d matches, %d errs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">i</span><span class="p">,</span> <span class="n">nfound</span><span class="p">,</span> <span class="n">errs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exitcode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">exitcode</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nfound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PREFIX_SIZE 64</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remaining</span><span class="p">(</span><span class="kt">int</span> <span class="n">wrote</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PREFIX_SIZE</span> <span class="o">-</span> <span class="n">wrote</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PREFIX_SIZE</span> <span class="o">-</span> <span class="n">wrote</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dynamic_emit_prefix</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos_after_tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_DPRINTK_FLAGS_INCL_TID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span>
						<span class="s">&quot;&lt;intr&gt;&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="s">&quot;[%d] &quot;</span><span class="p">,</span>
						<span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">pos_after_tid</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_DPRINTK_FLAGS_INCL_MODNAME</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="s">&quot;%s:&quot;</span><span class="p">,</span>
					<span class="n">desc</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_DPRINTK_FLAGS_INCL_FUNCNAME</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="s">&quot;%s:&quot;</span><span class="p">,</span>
					<span class="n">desc</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_DPRINTK_FLAGS_INCL_LINENO</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="s">&quot;%d:&quot;</span><span class="p">,</span>
					<span class="n">desc</span><span class="o">-&gt;</span><span class="n">lineno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">pos_after_tid</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">remaining</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">PREFIX_SIZE</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">PREFIX_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__dynamic_pr_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">PREFIX_SIZE</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="p">);</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s%pV&quot;</span><span class="p">,</span> <span class="n">dynamic_emit_prefix</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__dynamic_pr_debug</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__dynamic_dev_dbg</span><span class="p">(</span><span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">PREFIX_SIZE</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="p">);</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__dev_printk</span><span class="p">(</span><span class="n">dynamic_emit_prefix</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">buf</span><span class="p">),</span> <span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__dynamic_dev_dbg</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET</span>

<span class="kt">int</span> <span class="nf">__dynamic_netdev_dbg</span><span class="p">(</span><span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">PREFIX_SIZE</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="p">);</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__netdev_printk</span><span class="p">(</span><span class="n">dynamic_emit_prefix</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">buf</span><span class="p">),</span> <span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__dynamic_netdev_dbg</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cp">#define DDEBUG_STRING_SIZE 1024</span>
<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">char</span> <span class="n">ddebug_setup_string</span><span class="p">[</span><span class="n">DDEBUG_STRING_SIZE</span><span class="p">];</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">ddebug_setup_query</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">DDEBUG_STRING_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;ddebug boot param string too large</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">ddebug_setup_string</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">DDEBUG_STRING_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;ddebug_query=&quot;</span><span class="p">,</span> <span class="n">ddebug_setup_query</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * File_ops-&gt;write method for &lt;debugfs&gt;/dynamic_debug/conrol.  Gathers the</span>
<span class="cm"> * command text from userspace, parses and executes it.</span>
<span class="cm"> */</span>
<span class="cp">#define USER_BUF_PAGE 4096</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ddebug_proc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmpbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">USER_BUF_PAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;expected &lt;%d bytes into control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">USER_BUF_PAGE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tmpbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmpbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tmpbuf</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;read %d bytes from userspace</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ddebug_exec_queries</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">*</span><span class="n">offp</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the iterator to point to the first _ddebug object</span>
<span class="cm"> * and return a pointer to that first object.  Returns</span>
<span class="cm"> * NULL if there are no _ddebugs at all.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="nf">ddebug_iter_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">ddebug_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_tables</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ddebug_tables</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ddebug_table</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">ddebugs</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Advance the iterator to point to the next _ddebug</span>
<span class="cm"> * object from the one the iterator currently points at,</span>
<span class="cm"> * and returns a pointer to the new _ddebug.  Returns</span>
<span class="cm"> * NULL if the iterator has seen all the _ddebugs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="nf">ddebug_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ddebug_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">==</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_ddebugs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* iterate to next table */</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddebug_tables</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ddebug_table</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">ddebugs</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_ops start method.  Called at the start of every</span>
<span class="cm"> * read() call from userspace.  Takes the ddebug_lock and</span>
<span class="cm"> * seeks the seq_file&#39;s iterator to the given position.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ddebug_proc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ddebug_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;called m=%p *pos=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">ddebug_iter_first</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="n">ddebug_iter_next</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_ops next method.  Called several times within a read()</span>
<span class="cm"> * call from userspace, with ddebug_lock held.  Walks to the</span>
<span class="cm"> * next _ddebug object with a special case for the header line.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ddebug_proc_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ddebug_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>

	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;called m=%p p=%p *pos=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">pos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="n">ddebug_iter_first</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="n">ddebug_iter_next</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_ops show method.  Called several times within a read()</span>
<span class="cm"> * call from userspace, with ddebug_lock held.  Formats the</span>
<span class="cm"> * current _ddebug as a single human-readable line, with a</span>
<span class="cm"> * special case for the header line.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ddebug_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">flagsbuf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;called m=%p p=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			<span class="s">&quot;# filename:lineno [module]function flags format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s:%u [%s]%s =%s </span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">trim_prefix</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">),</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">lineno</span><span class="p">,</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">,</span>
		<span class="n">ddebug_describe_flags</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">flagsbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flagsbuf</span><span class="p">)));</span>
	<span class="n">seq_escape</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t\r\n\&quot;</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Seq_ops stop method.  Called at the end of each read()</span>
<span class="cm"> * call from userspace.  Drops ddebug_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ddebug_proc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;called m=%p p=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">ddebug_proc_seqops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ddebug_proc_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ddebug_proc_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">ddebug_proc_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">ddebug_proc_stop</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * File_ops-&gt;open method for &lt;debugfs&gt;/dynamic_debug/control.  Does</span>
<span class="cm"> * the seq_file setup dance, and also creates an iterator to walk the</span>
<span class="cm"> * _ddebugs.  Note that we create a seq_file always, even for O_WRONLY</span>
<span class="cm"> * files where it&#39;s not needed, as doing so simplifies the -&gt;release</span>
<span class="cm"> * method.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ddebug_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddebug_proc_seqops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ddebug_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">ddebug_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release_private</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">ddebug_proc_write</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new ddebug_table for the given module</span>
<span class="cm"> * and add it to the global list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ddebug_add_module</span><span class="p">(</span><span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">tab</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ddebug_table</span> <span class="o">*</span><span class="n">dt</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">new_name</span><span class="p">;</span>

	<span class="n">dt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dt</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">new_name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">mod_name</span> <span class="o">=</span> <span class="n">new_name</span><span class="p">;</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">num_ddebugs</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">dt</span><span class="o">-&gt;</span><span class="n">ddebugs</span> <span class="o">=</span> <span class="n">tab</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddebug_tables</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>

	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;%u debug prints in module %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ddebug_add_module</span><span class="p">);</span>

<span class="cm">/* helper for ddebug_dyndbg_(boot|module)_param_cb */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_dyndbg_param_cb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on_err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sep</span><span class="p">;</span>

	<span class="n">sep</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* needed only for ddebug_dyndbg_boot_param_cb */</span>
		<span class="o">*</span><span class="n">sep</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">modname</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
		<span class="n">param</span> <span class="o">=</span> <span class="n">sep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s">&quot;dyndbg&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">on_err</span><span class="p">;</span> <span class="cm">/* determined by caller */</span>

	<span class="n">ddebug_exec_queries</span><span class="p">((</span><span class="n">val</span> <span class="o">?</span> <span class="n">val</span> <span class="o">:</span> <span class="s">&quot;+p&quot;</span><span class="p">),</span> <span class="n">modname</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* query failure shouldnt stop module load */</span>
<span class="p">}</span>

<span class="cm">/* handle both dyndbg and $module.dyndbg params at boot */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddebug_dyndbg_boot_param_cb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;%s=</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ddebug_dyndbg_param_cb</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * modprobe foo finds foo.params in boot-args, strips &quot;foo.&quot;, and</span>
<span class="cm"> * passes them to load_module().  This callback gets unknown params,</span>
<span class="cm"> * processes dyndbg params, rejects others.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ddebug_dyndbg_module_param_cb</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;module: %s %s=</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ddebug_dyndbg_param_cb</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ddebug_table_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ddebug_table</span> <span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called in response to a module being unloaded.  Removes</span>
<span class="cm"> * any ddebug_table&#39;s which point at the module.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ddebug_remove_module</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ddebug_table</span> <span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="o">*</span><span class="n">nextdt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;removing module </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mod_name</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">nextdt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddebug_tables</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">mod_name</span><span class="p">,</span> <span class="n">mod_name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ddebug_table_free</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ddebug_remove_module</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ddebug_remove_all_tables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_tables</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ddebug_table</span> <span class="o">*</span><span class="n">dt</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ddebug_tables</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">ddebug_table</span><span class="p">,</span>
						      <span class="n">link</span><span class="p">);</span>
		<span class="n">ddebug_table_free</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddebug_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">int</span> <span class="n">ddebug_init_success</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dynamic_debug_init_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddebug_init_success</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;dynamic_debug&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;control&quot;</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">ddebug_proc_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dynamic_debug_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">_ddebug</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="o">*</span><span class="n">iter_start</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cmdline</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">modct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">verbose_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__start___verbose</span> <span class="o">==</span> <span class="n">__stop___verbose</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;_ddebug table is empty in a &quot;</span>
			<span class="s">&quot;CONFIG_DYNAMIC_DEBUG build&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iter</span> <span class="o">=</span> <span class="n">__start___verbose</span><span class="p">;</span>
	<span class="n">modname</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">;</span>
	<span class="n">iter_start</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">__stop___verbose</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entries</span><span class="o">++</span><span class="p">;</span>
		<span class="n">verbose_bytes</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">modct</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ddebug_add_module</span><span class="p">(</span><span class="n">iter_start</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">modname</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">modname</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">modname</span><span class="p">;</span>
			<span class="n">iter_start</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ddebug_add_module</span><span class="p">(</span><span class="n">iter_start</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">modname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">ddebug_init_success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vpr_info</span><span class="p">(</span><span class="s">&quot;%d modules, %d entries and %d bytes in ddebug tables,&quot;</span>
		<span class="s">&quot; %d bytes in (readonly) verbose section</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">modct</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span> <span class="n">modct</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ddebug_table</span><span class="p">)),</span>
		<span class="n">verbose_bytes</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">__stop___verbose</span> <span class="o">-</span> <span class="n">__start___verbose</span><span class="p">));</span>

	<span class="cm">/* apply ddebug_query boot param, dont unload tables on err */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ddebug_setup_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;ddebug_query param name is deprecated,&quot;</span>
			<span class="s">&quot; change it to dyndbg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ddebug_exec_queries</span><span class="p">(</span><span class="n">ddebug_setup_string</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Invalid ddebug boot param %s&quot;</span><span class="p">,</span>
				<span class="n">ddebug_setup_string</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%d changes by ddebug_query</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* now that ddebug tables are loaded, process all boot args</span>
<span class="cm">	 * again to find and activate queries given in dyndbg params.</span>
<span class="cm">	 * While this has already been done for known boot params, it</span>
<span class="cm">	 * ignored the unknown ones (dyndbg in particular).  Reusing</span>
<span class="cm">	 * parse_args avoids ad-hoc parsing.  This will also attempt</span>
<span class="cm">	 * to activate queries for not-yet-loaded modules, which is</span>
<span class="cm">	 * slightly noisy if verbose, but harmless.</span>
<span class="cm">	 */</span>
	<span class="n">cmdline</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">saved_command_line</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">parse_args</span><span class="p">(</span><span class="s">&quot;dyndbg params&quot;</span><span class="p">,</span> <span class="n">cmdline</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddebug_dyndbg_boot_param_cb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cmdline</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">ddebug_remove_all_tables</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Allow early initialization for boot messages via boot param */</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">dynamic_debug_init</span><span class="p">);</span>

<span class="cm">/* Debugfs setup must be done later */</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">dynamic_debug_init_debugfs</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
