<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › idr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>idr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * 2002-10-18  written by Jim Houston jim.houston@ccur.com</span>
<span class="cm"> *	Copyright (C) 2002 by Concurrent Computer Corporation</span>
<span class="cm"> *	Distributed under the GNU GPL license version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Modified by George Anzinger to reuse immediately and to use</span>
<span class="cm"> * find bit instructions.  Also removed _irq on spinlocks.</span>
<span class="cm"> *</span>
<span class="cm"> * Modified by Nadia Derbey to make it RCU safe.</span>
<span class="cm"> *</span>
<span class="cm"> * Small id to pointer translation service.</span>
<span class="cm"> *</span>
<span class="cm"> * It uses a radix tree like structure as a sparse array indexed</span>
<span class="cm"> * by the id to obtain the pointer.  The bitmap makes allocating</span>
<span class="cm"> * a new id quick.</span>
<span class="cm"> *</span>
<span class="cm"> * You call it to allocate an id (an int) an associate with that id a</span>
<span class="cm"> * pointer or what ever, we treat it as a (void *).  You can pass this</span>
<span class="cm"> * id to a user for him to pass back at a later time.  You then pass</span>
<span class="cm"> * that id to this code and it returns your pointer.</span>

<span class="cm"> * You can release ids at any time. When all ids are released, most of</span>
<span class="cm"> * the memory is returned (we keep IDR_FREE_MAX) in a local pool so we</span>
<span class="cm"> * don&#39;t need to go to the memory &quot;store&quot; during an id allocate, just</span>
<span class="cm"> * so you don&#39;t need to be too concerned about locking and conflicts</span>
<span class="cm"> * with the slab allocator.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef TEST                        </span><span class="c1">// to test in user space...</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">idr_layer_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">simple_ida_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="nf">get_from_free_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free_cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">idr_layer_rcu_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">layer</span><span class="p">;</span>

	<span class="n">layer</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">idr_layer</span><span class="p">,</span> <span class="n">rcu_head</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">idr_layer_cache</span><span class="p">,</span> <span class="n">layer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_layer</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rcu_head</span><span class="p">,</span> <span class="n">idr_layer_rcu_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* only called when idp-&gt;lock is held */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__move_to_free_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free</span><span class="p">;</span>
	<span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free_cnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_to_free_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Depends on the return element being zeroed.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__move_to_free_list</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">idr_mark_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">**</span><span class="n">pa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this layer is full mark the bit in the layer above to</span>
<span class="cm">	 * show that this part of the radix tree is full.  This may</span>
<span class="cm">	 * complete the layer above and require walking up the radix</span>
<span class="cm">	 * tree.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span> <span class="o">==</span> <span class="n">IDR_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="o">++</span><span class="n">l</span><span class="p">]))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">IDR_BITS</span><span class="p">;</span>
		<span class="n">__set_bit</span><span class="p">((</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * idr_pre_get - reserve resources for idr allocation</span>
<span class="cm"> * @idp:	idr handle</span>
<span class="cm"> * @gfp_mask:	memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called prior to calling the idr_get_new* functions.</span>
<span class="cm"> * It preallocates enough memory to satisfy the worst possible allocation. The</span>
<span class="cm"> * caller should pass in GFP_KERNEL if possible.  This of course requires that</span>
<span class="cm"> * no spinning locks be held.</span>
<span class="cm"> *</span>
<span class="cm"> * If the system is REALLY out of memory this function returns %0,</span>
<span class="cm"> * otherwise %1.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">idr_pre_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free_cnt</span> <span class="o">&lt;</span> <span class="n">IDR_FREE_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">idr_layer_cache</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">move_to_free_list</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_pre_get</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sub_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">starting_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">**</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">sh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">oid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bm</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="o">*</span><span class="n">starting_id</span><span class="p">;</span>
 <span class="nl">restart:</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">;</span>
	<span class="n">pa</span><span class="p">[</span><span class="n">l</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We run around this while until we reach the leaf node...</span>
<span class="cm">		 */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">IDR_BITS</span><span class="o">*</span><span class="n">l</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">;</span>
		<span class="n">bm</span> <span class="o">=</span> <span class="o">~</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bm</span><span class="p">,</span> <span class="n">IDR_SIZE</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">IDR_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* no space available go back to previous layer. */</span>
			<span class="n">l</span><span class="o">++</span><span class="p">;</span>
			<span class="n">oid</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
			<span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">|</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">IDR_BITS</span> <span class="o">*</span> <span class="n">l</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* if already at the top layer, we need to grow */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">*</span> <span class="n">IDR_BITS</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">starting_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">IDR_NEED_TO_GROW</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">);</span>

			<span class="cm">/* If we need to go up one layer, continue the</span>
<span class="cm">			 * loop; otherwise, restart from the top.</span>
<span class="cm">			 */</span>
			<span class="n">sh</span> <span class="o">=</span> <span class="n">IDR_BITS</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oid</span> <span class="o">&gt;&gt;</span> <span class="n">sh</span> <span class="o">==</span> <span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">sh</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sh</span> <span class="o">=</span> <span class="n">IDR_BITS</span><span class="o">*</span><span class="n">l</span><span class="p">;</span>
			<span class="n">id</span> <span class="o">=</span> <span class="p">((</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">sh</span><span class="p">)</span> <span class="o">^</span> <span class="n">n</span> <span class="o">^</span> <span class="n">m</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">sh</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">MAX_ID_BIT</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IDR_NOMORE_SPACE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Create the layer below if it is missing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">new</span> <span class="o">=</span> <span class="n">get_from_free_list</span><span class="p">(</span><span class="n">idp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">new</span><span class="o">-&gt;</span><span class="n">layer</span> <span class="o">=</span> <span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">new</span><span class="p">);</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pa</span><span class="p">[</span><span class="n">l</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">pa</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">idr_get_empty_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">starting_id</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">**</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">layers</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">starting_id</span><span class="p">;</span>
<span class="nl">build_up:</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
	<span class="n">layers</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_from_free_list</span><span class="p">(</span><span class="n">idp</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">layers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Add a new layer to the top of the tree if the requested</span>
<span class="cm">	 * id is larger than the currently allocated space.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">layers</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_LEVEL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">layers</span><span class="o">*</span><span class="n">IDR_BITS</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">layers</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* special case: if the tree is currently empty,</span>
<span class="cm">			 * then we grow the tree by moving the top node</span>
<span class="cm">			 * upwards.</span>
<span class="cm">			 */</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">layer</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">new</span> <span class="o">=</span> <span class="n">get_from_free_list</span><span class="p">(</span><span class="n">idp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The allocation failed.  If we built part of</span>
<span class="cm">			 * the structure tear it down.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">new</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span> <span class="n">new</span> <span class="o">=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">new</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">new</span><span class="o">-&gt;</span><span class="n">bitmap</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">__move_to_free_list</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">layer</span> <span class="o">=</span> <span class="n">layers</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span> <span class="o">==</span> <span class="n">IDR_FULL</span><span class="p">)</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">=</span> <span class="n">layers</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">sub_alloc</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">IDR_NEED_TO_GROW</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">build_up</span><span class="p">;</span>
	<span class="k">return</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">idr_get_new_above_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">starting_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">pa</span><span class="p">[</span><span class="n">MAX_LEVEL</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">idr_get_empty_slot</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="n">starting_id</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Successfully found an empty slot.  Install the user</span>
<span class="cm">		 * pointer and mark the slot full.</span>
<span class="cm">		 */</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">],</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
		<span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">idr_mark_full</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * idr_get_new_above - allocate new idr entry above or equal to a start id</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> * @ptr: pointer you want associated with the id</span>
<span class="cm"> * @starting_id: id to start search at</span>
<span class="cm"> * @id: pointer to the allocated handle</span>
<span class="cm"> *</span>
<span class="cm"> * This is the allocate id function.  It should be called with any</span>
<span class="cm"> * required locks.</span>
<span class="cm"> *</span>
<span class="cm"> * If allocation from IDR&#39;s private freelist fails, idr_get_new_above() will</span>
<span class="cm"> * return %-EAGAIN.  The caller should retry the idr_pre_get() call to refill</span>
<span class="cm"> * IDR&#39;s preallocation and then retry the idr_get_new_above() call.</span>
<span class="cm"> *</span>
<span class="cm"> * If the idr is full idr_get_new_above() will return %-ENOSPC.</span>
<span class="cm"> *</span>
<span class="cm"> * @id returns a value in the range @starting_id ... %0x7fffffff</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">idr_get_new_above</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">starting_id</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">idr_get_new_above_int</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">starting_id</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is a cheap hack until the IDR code can be fixed to</span>
<span class="cm">	 * return proper error values.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">_idr_rc_to_errno</span><span class="p">(</span><span class="n">rv</span><span class="p">);</span>
	<span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">rv</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_get_new_above</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * idr_get_new - allocate new idr entry</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> * @ptr: pointer you want associated with the id</span>
<span class="cm"> * @id: pointer to the allocated handle</span>
<span class="cm"> *</span>
<span class="cm"> * If allocation from IDR&#39;s private freelist fails, idr_get_new_above() will</span>
<span class="cm"> * return %-EAGAIN.  The caller should retry the idr_pre_get() call to refill</span>
<span class="cm"> * IDR&#39;s preallocation and then retry the idr_get_new_above() call.</span>
<span class="cm"> *</span>
<span class="cm"> * If the idr is full idr_get_new_above() will return %-ENOSPC.</span>
<span class="cm"> *</span>
<span class="cm"> * @id returns a value in the range %0 ... %0x7fffffff</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">idr_get_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">idr_get_new_above_int</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is a cheap hack until the IDR code can be fixed to</span>
<span class="cm">	 * return proper error values.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">_idr_rc_to_errno</span><span class="p">(</span><span class="n">rv</span><span class="p">);</span>
	<span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">rv</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_get_new</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">idr_remove_warning</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;idr_remove called for id=%d which is not allocated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sub_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">**</span><span class="n">pa</span><span class="p">[</span><span class="n">MAX_LEVEL</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">***</span><span class="n">paa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">to_free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="o">*</span><span class="n">paa</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*++</span><span class="n">paa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">;</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
		<span class="o">*++</span><span class="n">paa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">shift</span> <span class="o">-=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">id</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">))){</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">to_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">paa</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="o">--</span><span class="p">((</span><span class="o">**</span><span class="n">paa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)){</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">to_free</span><span class="p">)</span>
				<span class="n">free_layer</span><span class="p">(</span><span class="n">to_free</span><span class="p">);</span>
			<span class="n">to_free</span> <span class="o">=</span> <span class="o">**</span><span class="n">paa</span><span class="p">;</span>
			<span class="o">**</span><span class="n">paa</span><span class="o">--</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">paa</span><span class="p">)</span>
			<span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">to_free</span><span class="p">)</span>
			<span class="n">free_layer</span><span class="p">(</span><span class="n">to_free</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">idr_remove_warning</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * idr_remove - remove the given id and free its slot</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> * @id: unique key</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">idr_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">to_free</span><span class="p">;</span>

	<span class="cm">/* Mask off upper bits we don&#39;t use for the search. */</span>
	<span class="n">id</span> <span class="o">&amp;=</span> <span class="n">MAX_ID_MASK</span><span class="p">;</span>

	<span class="n">sub_remove</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">IDR_BITS</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">&amp;&amp;</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Single child at leftmost slot: we can shrink the tree.</span>
<span class="cm">		 * This level is not needed anymore since when layers are</span>
<span class="cm">		 * inserted, they are inserted at the top of the existing</span>
<span class="cm">		 * tree.</span>
<span class="cm">		 */</span>
		<span class="n">to_free</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="o">--</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span><span class="p">;</span>
		<span class="n">to_free</span><span class="o">-&gt;</span><span class="n">bitmap</span> <span class="o">=</span> <span class="n">to_free</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">free_layer</span><span class="p">(</span><span class="n">to_free</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free_cnt</span> <span class="o">&gt;=</span> <span class="n">IDR_FREE_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">get_from_free_list</span><span class="p">(</span><span class="n">idp</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note: we don&#39;t call the rcu callback here, since the only</span>
<span class="cm">		 * layers that fall into the freelist are those that have been</span>
<span class="cm">		 * preallocated.</span>
<span class="cm">		 */</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">idr_layer_cache</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_remove</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * idr_remove_all - remove all ids from the given idr tree</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> *</span>
<span class="cm"> * idr_destroy() only frees up unused, cached idp_layers, but this</span>
<span class="cm"> * function will remove all id mappings and leave all idp_layers</span>
<span class="cm"> * unused.</span>
<span class="cm"> *</span>
<span class="cm"> * A typical clean-up sequence for objects stored in an idr tree will</span>
<span class="cm"> * use idr_for_each() to free all objects, if necessay, then</span>
<span class="cm"> * idr_remove_all() to remove all ids, and idr_destroy() to free</span>
<span class="cm"> * up the cached idr_layers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">idr_remove_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bt_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">pa</span><span class="p">[</span><span class="n">MAX_LEVEL</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">**</span><span class="n">paa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">*</span> <span class="n">IDR_BITS</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">IDR_BITS</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">-=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
			<span class="o">*</span><span class="n">paa</span><span class="o">++</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="n">bt_mask</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
		<span class="n">id</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
		<span class="cm">/* Get the highest bit that the above add changed from 0-&gt;1. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">fls</span><span class="p">(</span><span class="n">id</span> <span class="o">^</span> <span class="n">bt_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
				<span class="n">free_layer</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">+=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">*--</span><span class="n">paa</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_remove_all</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * idr_destroy - release all cached layers within an idr tree</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">idr_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">id_free_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_from_free_list</span><span class="p">(</span><span class="n">idp</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">idr_layer_cache</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_destroy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * idr_find - return pointer for given id</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> * @id: lookup key</span>
<span class="cm"> *</span>
<span class="cm"> * Return the pointer given the id it has been registered with.  A %NULL</span>
<span class="cm"> * return indicates that @id is not valid or you passed %NULL in</span>
<span class="cm"> * idr_get_new().</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be called under rcu_read_lock(), given that the leaf</span>
<span class="cm"> * pointers lifetimes are correctly managed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">idr_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">layer</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">IDR_BITS</span><span class="p">;</span>

	<span class="cm">/* Mask off upper bits we don&#39;t use for the search. */</span>
	<span class="n">id</span> <span class="o">&amp;=</span> <span class="n">MAX_ID_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">layer</span><span class="o">*</span><span class="n">IDR_BITS</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_find</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * idr_for_each - iterate through all stored pointers</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> * @fn: function to be called for each pointer</span>
<span class="cm"> * @data: data passed back to callback function</span>
<span class="cm"> *</span>
<span class="cm"> * Iterate over the pointers registered with the given idr.  The</span>
<span class="cm"> * callback function will be called for each pointer currently</span>
<span class="cm"> * registered, passing the id, the pointer and the data pointer passed</span>
<span class="cm"> * to this function.  It is not safe to modify the idr tree while in</span>
<span class="cm"> * the callback, so functions such as idr_get_new and idr_remove are</span>
<span class="cm"> * not allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * We check the return of @fn each time. If it returns anything other</span>
<span class="cm"> * than %0, we break out and return that value.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must serialize idr_for_each() vs idr_get_new() and idr_remove().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">idr_for_each</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">pa</span><span class="p">[</span><span class="n">MAX_LEVEL</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">**</span><span class="n">paa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">layers</span> <span class="o">*</span> <span class="n">IDR_BITS</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">);</span>
	<span class="n">max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">-=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
			<span class="o">*</span><span class="n">paa</span><span class="o">++</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">id</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">fls</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">+=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">*--</span><span class="n">paa</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_for_each</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * idr_get_next - lookup next object of id to given id.</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> * @nextidp:  pointer to lookup key</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to registered object with id, which is next number to</span>
<span class="cm"> * given id. After being looked up, *@nextidp will be updated for the next</span>
<span class="cm"> * iteration.</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be called under rcu_read_lock(), given that the leaf</span>
<span class="cm"> * pointers lifetimes are correctly managed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">idr_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nextidp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">pa</span><span class="p">[</span><span class="n">MAX_LEVEL</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">**</span><span class="n">paa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="o">*</span><span class="n">nextidp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

	<span class="cm">/* find first ent */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">IDR_BITS</span><span class="p">;</span>
	<span class="n">max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">-=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
			<span class="o">*</span><span class="n">paa</span><span class="o">++</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">nextidp</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">id</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">fls</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">+=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">*--</span><span class="n">paa</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_get_next</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * idr_replace - replace pointer for given id</span>
<span class="cm"> * @idp: idr handle</span>
<span class="cm"> * @ptr: pointer you want associated with the id</span>
<span class="cm"> * @id: lookup key</span>
<span class="cm"> *</span>
<span class="cm"> * Replace the pointer registered with an id and return the old value.</span>
<span class="cm"> * A %-ENOENT return indicates that @id was not found.</span>
<span class="cm"> * A %-EINVAL return indicates that @id was not within valid constraints.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must serialize with writers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">idr_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">old_p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">idp</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">layer</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">IDR_BITS</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">&amp;=</span> <span class="n">MAX_ID_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">n</span> <span class="o">-=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">];</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">id</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="n">old_p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">old_p</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_replace</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">idr_init_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">idr_layer_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;idr_layer_cache&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr_layer</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * idr_init - initialize idr handle</span>
<span class="cm"> * @idp:	idr handle</span>
<span class="cm"> *</span>
<span class="cm"> * This function is use to set up the handle (@idp) that you will pass</span>
<span class="cm"> * to the rest of the functions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">idr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span> <span class="o">*</span><span class="n">idp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">idp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">idr</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">idr_init</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * DOC: IDA description</span>
<span class="cm"> * IDA - IDR based ID allocator</span>
<span class="cm"> *</span>
<span class="cm"> * This is id allocator without id -&gt; pointer translation.  Memory</span>
<span class="cm"> * usage is much lower than full blown idr because each id only</span>
<span class="cm"> * occupies a bit.  ida uses a custom leaf node which contains</span>
<span class="cm"> * IDA_BITMAP_BITS slots.</span>
<span class="cm"> *</span>
<span class="cm"> * 2007-04-25  written by Tejun Heo &lt;htejun@gmail.com&gt;</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ida_bitmap</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">free_bitmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">free_bitmap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ida</span><span class="o">-&gt;</span><span class="n">free_bitmap</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">;</span>
			<span class="n">bitmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ida_pre_get - reserve resources for ida allocation</span>
<span class="cm"> * @ida:	ida handle</span>
<span class="cm"> * @gfp_mask:	memory allocation flag</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called prior to locking and calling the</span>
<span class="cm"> * following function.  It preallocates enough memory to satisfy the</span>
<span class="cm"> * worst possible allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * If the system is REALLY out of memory this function returns %0,</span>
<span class="cm"> * otherwise %1.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ida_pre_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* allocate idr_layers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* allocate free_bitmap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">free_bitmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ida_bitmap</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>

		<span class="n">bitmap</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida_bitmap</span><span class="p">),</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">free_bitmap</span><span class="p">(</span><span class="n">ida</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ida_pre_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ida_get_new_above - allocate new ID above or equal to a start id</span>
<span class="cm"> * @ida:	ida handle</span>
<span class="cm"> * @starting_id: id to start search at</span>
<span class="cm"> * @p_id:	pointer to the allocated handle</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate new ID above or equal to @starting_id.  It should be called</span>
<span class="cm"> * with any required locks.</span>
<span class="cm"> *</span>
<span class="cm"> * If memory is required, it will return %-EAGAIN, you should unlock</span>
<span class="cm"> * and go back to the ida_pre_get() call.  If the ida is full, it will</span>
<span class="cm"> * return %-ENOSPC.</span>
<span class="cm"> *</span>
<span class="cm"> * @p_id returns a value in the range @starting_id ... %0x7fffffff.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ida_get_new_above</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">int</span> <span class="n">starting_id</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">pa</span><span class="p">[</span><span class="n">MAX_LEVEL</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ida_bitmap</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idr_id</span> <span class="o">=</span> <span class="n">starting_id</span> <span class="o">/</span> <span class="n">IDA_BITMAP_BITS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">starting_id</span> <span class="o">%</span> <span class="n">IDA_BITMAP_BITS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>

 <span class="nl">restart:</span>
	<span class="cm">/* get vacant slot */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">idr_get_empty_slot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="n">idr_id</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">_idr_rc_to_errno</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">IDA_BITMAP_BITS</span> <span class="o">&gt;=</span> <span class="n">MAX_ID_BIT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">idr_id</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">idr_id</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/* if bitmap isn&#39;t there, create a new one */</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">idr_id</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">bitmap</span> <span class="o">=</span> <span class="n">ida</span><span class="o">-&gt;</span><span class="n">free_bitmap</span><span class="p">;</span>
		<span class="n">ida</span><span class="o">-&gt;</span><span class="n">free_bitmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida_bitmap</span><span class="p">));</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">idr_id</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">],</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bitmap</span><span class="p">);</span>
		<span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* lookup for empty slot */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">IDA_BITMAP_BITS</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">IDA_BITMAP_BITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no empty slot after offset, continue to the next chunk */</span>
		<span class="n">idr_id</span><span class="o">++</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">idr_id</span> <span class="o">*</span> <span class="n">IDA_BITMAP_BITS</span> <span class="o">+</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">MAX_ID_BIT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">nr_busy</span> <span class="o">==</span> <span class="n">IDA_BITMAP_BITS</span><span class="p">)</span>
		<span class="n">idr_mark_full</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">idr_id</span><span class="p">);</span>

	<span class="o">*</span><span class="n">p_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>

	<span class="cm">/* Each leaf node can handle nearly a thousand slots and the</span>
<span class="cm">	 * whole idea of ida is to have small memory foot print.</span>
<span class="cm">	 * Throw away extra resources one by one after each successful</span>
<span class="cm">	 * allocation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">.</span><span class="n">id_free_cnt</span> <span class="o">||</span> <span class="n">ida</span><span class="o">-&gt;</span><span class="n">free_bitmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_from_free_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">idr_layer_cache</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ida_get_new_above</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ida_get_new - allocate new ID</span>
<span class="cm"> * @ida:	idr handle</span>
<span class="cm"> * @p_id:	pointer to the allocated handle</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate new ID.  It should be called with any required locks.</span>
<span class="cm"> *</span>
<span class="cm"> * If memory is required, it will return %-EAGAIN, you should unlock</span>
<span class="cm"> * and go back to the idr_pre_get() call.  If the idr is full, it will</span>
<span class="cm"> * return %-ENOSPC.</span>
<span class="cm"> *</span>
<span class="cm"> * @p_id returns a value in the range %0 ... %0x7fffffff.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ida_get_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ida_get_new_above</span><span class="p">(</span><span class="n">ida</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p_id</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ida_get_new</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ida_remove - remove the given ID</span>
<span class="cm"> * @ida:	ida handle</span>
<span class="cm"> * @id:		ID to free</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ida_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">idr_layer</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">.</span><span class="n">top</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">.</span><span class="n">layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">IDR_BITS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idr_id</span> <span class="o">=</span> <span class="n">id</span> <span class="o">/</span> <span class="n">IDA_BITMAP_BITS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">id</span> <span class="o">%</span> <span class="n">IDA_BITMAP_BITS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ida_bitmap</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>

	<span class="cm">/* clear full bits while looking up the leaf idr_layer */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">idr_id</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">;</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">shift</span> <span class="o">-=</span> <span class="n">IDR_BITS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">idr_id</span> <span class="o">&amp;</span> <span class="n">IDR_MASK</span><span class="p">;</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>

	<span class="n">bitmap</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ary</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* update bitmap and remove it if empty */</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">nr_busy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>	<span class="cm">/* to please idr_remove() */</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">,</span> <span class="n">idr_id</span><span class="p">);</span>
		<span class="n">free_bitmap</span><span class="p">(</span><span class="n">ida</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>

 <span class="nl">err:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
	       <span class="s">&quot;ida_remove called for id=%d which is not allocated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ida_remove</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ida_destroy - release all cached layers within an ida tree</span>
<span class="cm"> * @ida:		ida handle</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ida_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">free_bitmap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ida_destroy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ida_simple_get - get a new id.</span>
<span class="cm"> * @ida: the (initialized) ida.</span>
<span class="cm"> * @start: the minimum id (inclusive, &lt; 0x8000000)</span>
<span class="cm"> * @end: the maximum id (exclusive, &lt; 0x8000000 or 0)</span>
<span class="cm"> * @gfp_mask: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates an id in the range start &lt;= id &lt; end, or returns -ENOSPC.</span>
<span class="cm"> * On memory allocation failure, returns -ENOMEM.</span>
<span class="cm"> *</span>
<span class="cm"> * Use ida_simple_remove() to get rid of an id.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ida_simple_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span>
		   <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">end</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">);</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">again:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida_pre_get</span><span class="p">(</span><span class="n">ida</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">simple_ida_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ida_get_new_above</span><span class="p">(</span><span class="n">ida</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ida_remove</span><span class="p">(</span><span class="n">ida</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">simple_ida_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ida_simple_get</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ida_simple_remove - remove an allocated id.</span>
<span class="cm"> * @ida: the (initialized) ida.</span>
<span class="cm"> * @id: the id returned by ida_simple_get.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ida_simple_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">simple_ida_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="n">ida</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">simple_ida_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ida_simple_remove</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ida_init - initialize ida handle</span>
<span class="cm"> * @ida:	ida handle</span>
<span class="cm"> *</span>
<span class="cm"> * This function is use to set up the handle (@ida) that you will pass</span>
<span class="cm"> * to the rest of the functions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ida_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span> <span class="o">*</span><span class="n">ida</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ida</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ida</span><span class="p">));</span>
	<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ida</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ida_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
