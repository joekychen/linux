<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › decompress_bunzip2.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>decompress_bunzip2.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*	Small bzip2 deflate implementation, by Rob Landley (rob@landley.net).</span>

<span class="cm">	Based on bzip2 decompression code by Julian R Seward (jseward@acm.org),</span>
<span class="cm">	which also acknowledges contributions by Mike Burrows, David Wheeler,</span>
<span class="cm">	Peter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,</span>
<span class="cm">	Robert Sedgewick, and Jon L. Bentley.</span>

<span class="cm">	This code is licensed under the LGPLv2:</span>
<span class="cm">		LGPL (http://www.gnu.org/copyleft/lgpl.html</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">	Size and speed optimizations by Manuel Novoa III  (mjn3@codepoet.org).</span>

<span class="cm">	More efficient reading of Huffman codes, a streamlined read_bunzip()</span>
<span class="cm">	function, and various other tweaks.  In (limited) tests, approximately</span>
<span class="cm">	20% faster than bzcat on x86 and about 10% faster on arm.</span>

<span class="cm">	Note that about 2/3 of the time is spent in read_unzip() reversing</span>
<span class="cm">	the Burrows-Wheeler transformation.  Much of that time is delay</span>
<span class="cm">	resulting from cache misses.</span>

<span class="cm">	I would ask that anyone benefiting from this work, especially those</span>
<span class="cm">	using it in commercial products, consider making a donation to my local</span>
<span class="cm">	non-profit hospice organization in the name of the woman I loved, who</span>
<span class="cm">	passed away Feb. 12, 2003.</span>

<span class="cm">		In memory of Toni W. Hagan</span>

<span class="cm">		Hospice of Acadiana, Inc.</span>
<span class="cm">		2600 Johnston St., Suite 200</span>
<span class="cm">		Lafayette, LA 70503-3240</span>

<span class="cm">		Phone (337) 232-1234 or 1-800-738-2226</span>
<span class="cm">		Fax   (337) 232-1297</span>

<span class="cm">		http://www.hospiceacadiana.com/</span>

<span class="cm">	Manuel</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm">	Made it fit for running in Linux Kernel by Alain Knaff (alain@knaff.lu)</span>
<span class="cm">*/</span>


<span class="cp">#ifdef STATIC</span>
<span class="cp">#define PREBOOT</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;linux/decompress/bunzip2.h&gt;</span>
<span class="cp">#endif </span><span class="cm">/* STATIC */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/decompress/mm.h&gt;</span>

<span class="cp">#ifndef INT_MAX</span>
<span class="cp">#define INT_MAX 0x7fffffff</span>
<span class="cp">#endif</span>

<span class="cm">/* Constants for Huffman coding */</span>
<span class="cp">#define MAX_GROUPS		6</span>
<span class="cp">#define GROUP_SIZE   		50	</span><span class="cm">/* 64 would have been more efficient */</span><span class="cp"></span>
<span class="cp">#define MAX_HUFCODE_BITS 	20	</span><span class="cm">/* Longest Huffman code allowed */</span><span class="cp"></span>
<span class="cp">#define MAX_SYMBOLS 		258	</span><span class="cm">/* 256 literals + RUNA + RUNB */</span><span class="cp"></span>
<span class="cp">#define SYMBOL_RUNA		0</span>
<span class="cp">#define SYMBOL_RUNB		1</span>

<span class="cm">/* Status return values */</span>
<span class="cp">#define RETVAL_OK			0</span>
<span class="cp">#define RETVAL_LAST_BLOCK		(-1)</span>
<span class="cp">#define RETVAL_NOT_BZIP_DATA		(-2)</span>
<span class="cp">#define RETVAL_UNEXPECTED_INPUT_EOF	(-3)</span>
<span class="cp">#define RETVAL_UNEXPECTED_OUTPUT_EOF	(-4)</span>
<span class="cp">#define RETVAL_DATA_ERROR		(-5)</span>
<span class="cp">#define RETVAL_OUT_OF_MEMORY		(-6)</span>
<span class="cp">#define RETVAL_OBSOLETE_INPUT		(-7)</span>

<span class="cm">/* Other housekeeping constants */</span>
<span class="cp">#define BZIP2_IOBUF_SIZE		4096</span>

<span class="cm">/* This is what we know about each Huffman coding group */</span>
<span class="k">struct</span> <span class="n">group_data</span> <span class="p">{</span>
	<span class="cm">/* We have an extra slot at the end of limit[] for a sentinal value. */</span>
	<span class="kt">int</span> <span class="n">limit</span><span class="p">[</span><span class="n">MAX_HUFCODE_BITS</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">base</span><span class="p">[</span><span class="n">MAX_HUFCODE_BITS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">permute</span><span class="p">[</span><span class="n">MAX_SYMBOLS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">minLen</span><span class="p">,</span> <span class="n">maxLen</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Structure holding all the housekeeping data, including IO buffers and</span>
<span class="cm">   memory that persists between calls to bunzip */</span>
<span class="k">struct</span> <span class="n">bunzip_data</span> <span class="p">{</span>
	<span class="cm">/* State for interrupting output loop */</span>
	<span class="kt">int</span> <span class="n">writeCopies</span><span class="p">,</span> <span class="n">writePos</span><span class="p">,</span> <span class="n">writeRunCountdown</span><span class="p">,</span> <span class="n">writeCount</span><span class="p">,</span> <span class="n">writeCurrent</span><span class="p">;</span>
	<span class="cm">/* I/O tracking data (file handles, buffers, positions, etc.) */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">inbufCount</span><span class="p">,</span> <span class="n">inbufPos</span> <span class="cm">/*, outbufPos*/</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inbuf</span> <span class="cm">/*,*outbuf*/</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inbufBitCount</span><span class="p">,</span> <span class="n">inbufBits</span><span class="p">;</span>
	<span class="cm">/* The CRC values stored in the block header and calculated from the</span>
<span class="cm">	data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crc32Table</span><span class="p">[</span><span class="mi">256</span><span class="p">],</span> <span class="n">headerCRC</span><span class="p">,</span> <span class="n">totalCRC</span><span class="p">,</span> <span class="n">writeCRC</span><span class="p">;</span>
	<span class="cm">/* Intermediate buffer and its size (in bytes) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="n">dbufSize</span><span class="p">;</span>
	<span class="cm">/* These things are a bit too big to go on the stack */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">selectors</span><span class="p">[</span><span class="mi">32768</span><span class="p">];</span>		<span class="cm">/* nSelectors = 15 bits */</span>
	<span class="k">struct</span> <span class="n">group_data</span> <span class="n">groups</span><span class="p">[</span><span class="n">MAX_GROUPS</span><span class="p">];</span>	<span class="cm">/* Huffman coding tables */</span>
	<span class="kt">int</span> <span class="n">io_error</span><span class="p">;</span>			<span class="cm">/* non-zero if we have IO error */</span>
	<span class="kt">int</span> <span class="n">byteCount</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">symToByte</span><span class="p">[</span><span class="mi">256</span><span class="p">],</span> <span class="n">mtfSymbol</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="p">};</span>


<span class="cm">/* Return the next nnn bits of input.  All reads from the compressed input</span>
<span class="cm">   are done through this function.  All reads are big endian */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">get_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">bunzip_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">bits_wanted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If we need to get more data from the byte buffer, do so.</span>
<span class="cm">	   (Loop getting one byte at a time to enforce endianness and avoid</span>
<span class="cm">	   unaligned access.) */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">&lt;</span> <span class="n">bits_wanted</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we need to read more data from file into byte buffer, do</span>
<span class="cm">		   so */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufPos</span> <span class="o">==</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufCount</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufCount</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">BZIP2_IOBUF_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufCount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bd</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="n">RETVAL_UNEXPECTED_INPUT_EOF</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Avoid 32-bit overflow (dump bit buffer to top of output) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">&gt;=</span> <span class="mi">24</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bits</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBits</span><span class="o">&amp;</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">bits_wanted</span> <span class="o">-=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span><span class="p">;</span>
			<span class="n">bits</span> <span class="o">&lt;&lt;=</span> <span class="n">bits_wanted</span><span class="p">;</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Grab next 8 bits of input from buffer. */</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBits</span> <span class="o">=</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBits</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">[</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufPos</span><span class="o">++</span><span class="p">];</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Calculate result */</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">-=</span> <span class="n">bits_wanted</span><span class="p">;</span>
	<span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBits</span> <span class="o">&gt;&gt;</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span><span class="p">)</span><span class="o">&amp;</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bits_wanted</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unpacks the next block and sets up for the inverse burrows-wheeler step. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">get_next_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">bunzip_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">group_data</span> <span class="o">*</span><span class="n">hufGroup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dbufCount</span><span class="p">,</span> <span class="n">nextSym</span><span class="p">,</span> <span class="n">dbufSize</span><span class="p">,</span> <span class="n">groupCount</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span>
		<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">runPos</span><span class="p">,</span> <span class="n">symCount</span><span class="p">,</span> <span class="n">symTotal</span><span class="p">,</span> <span class="n">nSelectors</span><span class="p">,</span> <span class="o">*</span><span class="n">byteCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uc</span><span class="p">,</span> <span class="o">*</span><span class="n">symToByte</span><span class="p">,</span> <span class="o">*</span><span class="n">mtfSymbol</span><span class="p">,</span> <span class="o">*</span><span class="n">selectors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="n">origPtr</span><span class="p">;</span>

	<span class="n">dbuf</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">;</span>
	<span class="n">dbufSize</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbufSize</span><span class="p">;</span>
	<span class="n">selectors</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">selectors</span><span class="p">;</span>
	<span class="n">byteCount</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">byteCount</span><span class="p">;</span>
	<span class="n">symToByte</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">symToByte</span><span class="p">;</span>
	<span class="n">mtfSymbol</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">mtfSymbol</span><span class="p">;</span>

	<span class="cm">/* Read in header signature and CRC, then validate signature.</span>
<span class="cm">	   (last block signature means CRC is for whole file, return now) */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">j</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">headerCRC</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mh">0x177245</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mh">0x385090</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">RETVAL_LAST_BLOCK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">!=</span> <span class="mh">0x314159</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mh">0x265359</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">RETVAL_NOT_BZIP_DATA</span><span class="p">;</span>
	<span class="cm">/* We can add support for blockRandomised if anybody complains.</span>
<span class="cm">	   There was some code for this in busybox 1.0.0-pre3, but nobody ever</span>
<span class="cm">	   noticed that it didn&#39;t actually work. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">RETVAL_OBSOLETE_INPUT</span><span class="p">;</span>
	<span class="n">origPtr</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">origPtr</span> <span class="o">&gt;</span> <span class="n">dbufSize</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>
	<span class="cm">/* mapping table: if some byte values are never used (encoding things</span>
<span class="cm">	   like ascii text), the compression code removes the gaps to have fewer</span>
<span class="cm">	   symbols to deal with, and writes a sparse bitfield indicating which</span>
<span class="cm">	   values were present.  We make a translation table to convert the</span>
<span class="cm">	   symbols back to the corresponding bytes. */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">symTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="n">j</span><span class="p">)))</span>
					<span class="n">symToByte</span><span class="p">[</span><span class="n">symTotal</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* How many different Huffman coding groups does this block use? */</span>
	<span class="n">groupCount</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">groupCount</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">groupCount</span> <span class="o">&gt;</span> <span class="n">MAX_GROUPS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>
	<span class="cm">/* nSelectors: Every GROUP_SIZE many symbols we select a new</span>
<span class="cm">	   Huffman coding group.  Read in the group selector list,</span>
<span class="cm">	   which is stored as MTF encoded bit runs.  (MTF = Move To</span>
<span class="cm">	   Front, as each value is used it&#39;s moved to the start of the</span>
<span class="cm">	   list.) */</span>
	<span class="n">nSelectors</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nSelectors</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">groupCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mtfSymbol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nSelectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get next value */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">groupCount</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>
		<span class="cm">/* Decode MTF to get the next selector */</span>
		<span class="n">uc</span> <span class="o">=</span> <span class="n">mtfSymbol</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
			<span class="n">mtfSymbol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtfSymbol</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">mtfSymbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">selectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">uc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Read the Huffman coding tables for each group, which code</span>
<span class="cm">	   for symTotal literal symbols, plus two run symbols (RUNA,</span>
<span class="cm">	   RUNB) */</span>
	<span class="n">symCount</span> <span class="o">=</span> <span class="n">symTotal</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">groupCount</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">length</span><span class="p">[</span><span class="n">MAX_SYMBOLS</span><span class="p">],</span> <span class="n">temp</span><span class="p">[</span><span class="n">MAX_HUFCODE_BITS</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
		<span class="kt">int</span>	<span class="n">minLen</span><span class="p">,</span>	<span class="n">maxLen</span><span class="p">,</span> <span class="n">pp</span><span class="p">;</span>
		<span class="cm">/* Read Huffman code lengths for each symbol.  They&#39;re</span>
<span class="cm">		   stored in a way similar to mtf; record a starting</span>
<span class="cm">		   value for the first symbol, and an offset from the</span>
<span class="cm">		   previous value for everys symbol after that.</span>
<span class="cm">		   (Subtracting 1 before the loop and then adding it</span>
<span class="cm">		   back at the end is an optimization that makes the</span>
<span class="cm">		   test inside the loop simpler: symbol length 0</span>
<span class="cm">		   becomes negative, so an unsigned inequality catches</span>
<span class="cm">		   it.) */</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">symCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MAX_HUFCODE_BITS</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>

				<span class="cm">/* If first bit is 0, stop.  Else</span>
<span class="cm">				   second bit indicates whether to</span>
<span class="cm">				   increment or decrement the value.</span>
<span class="cm">				   Optimization: grab 2 bits and unget</span>
<span class="cm">				   the second if the first was 0. */</span>

				<span class="n">k</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span><span class="o">++</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* Add one if second bit 1, else</span>
<span class="cm">				 * subtract 1.  Avoids if/else */</span>
				<span class="n">t</span> <span class="o">+=</span> <span class="p">(((</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Correct for the initial -1, to get the</span>
<span class="cm">			 * final symbol length */</span>
			<span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Find largest and smallest lengths in this group */</span>
		<span class="n">minLen</span> <span class="o">=</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="n">length</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">symCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxLen</span><span class="p">)</span>
				<span class="n">maxLen</span> <span class="o">=</span> <span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minLen</span><span class="p">)</span>
				<span class="n">minLen</span> <span class="o">=</span> <span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="cm">/* Calculate permute[], base[], and limit[] tables from</span>
<span class="cm">		 * length[].</span>
<span class="cm">		 *</span>
<span class="cm">		 * permute[] is the lookup table for converting</span>
<span class="cm">		 * Huffman coded symbols into decoded symbols.  base[]</span>
<span class="cm">		 * is the amount to subtract from the value of a</span>
<span class="cm">		 * Huffman symbol of a given length when using</span>
<span class="cm">		 * permute[].</span>
<span class="cm">		 *</span>
<span class="cm">		 * limit[] indicates the largest numerical value a</span>
<span class="cm">		 * symbol with a given number of bits can have.  This</span>
<span class="cm">		 * is how the Huffman codes can vary in length: each</span>
<span class="cm">		 * code with a value &gt; limit[length] needs another</span>
<span class="cm">		 * bit.</span>
<span class="cm">		 */</span>
		<span class="n">hufGroup</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>
		<span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">minLen</span><span class="p">;</span>
		<span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">maxLen</span><span class="p">;</span>
		<span class="cm">/* Note that minLen can&#39;t be smaller than 1, so we</span>
<span class="cm">		   adjust the base and limit array pointers so we&#39;re</span>
<span class="cm">		   not always wasting the first entry.  We do this</span>
<span class="cm">		   again when using them (during symbol decoding).*/</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">limit</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Calculate permute[].  Concurrently, initialize</span>
<span class="cm">		 * temp[] and limit[]. */</span>
		<span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">minLen</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">symCount</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
					<span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">permute</span><span class="p">[</span><span class="n">pp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Count symbols coded for at each bit length */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">symCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">temp</span><span class="p">[</span><span class="n">length</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Calculate limit[] (the largest symbol-coding value</span>
<span class="cm">		 *at each bit length, which is (previous limit &lt;&lt;</span>
<span class="cm">		 *1)+symbols at this level), and base[] (number of</span>
<span class="cm">		 *symbols to ignore at each bit length, which is limit</span>
<span class="cm">		 *minus the cumulative count of symbols coded for</span>
<span class="cm">		 *already). */</span>
		<span class="n">pp</span> <span class="o">=</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">minLen</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pp</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="cm">/* We read the largest possible symbol size</span>
<span class="cm">			   and then unget bits after determining how</span>
<span class="cm">			   many we need, and those extra bits could be</span>
<span class="cm">			   set to anything.  (They&#39;re noise from</span>
<span class="cm">			   future symbols.)  At each level we&#39;re</span>
<span class="cm">			   really only interested in the first few</span>
<span class="cm">			   bits, so here we set all the trailing</span>
<span class="cm">			   to-be-ignored bits to 1 so they don&#39;t</span>
<span class="cm">			   affect the value &gt; limit[length]</span>
<span class="cm">			   comparison. */</span>
			<span class="n">limit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">maxLen</span> <span class="o">-</span> <span class="n">i</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pp</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">limit</span><span class="p">[</span><span class="n">maxLen</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span> <span class="cm">/* Sentinal value for</span>
<span class="cm">					    * reading next sym. */</span>
		<span class="n">limit</span><span class="p">[</span><span class="n">maxLen</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">+</span><span class="n">temp</span><span class="p">[</span><span class="n">maxLen</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">base</span><span class="p">[</span><span class="n">minLen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We&#39;ve finished reading and digesting the block header.  Now</span>
<span class="cm">	   read this block&#39;s Huffman coded symbols from the file and</span>
<span class="cm">	   undo the Huffman coding and run length encoding, saving the</span>
<span class="cm">	   result into dbuf[dbufCount++] = uc */</span>

	<span class="cm">/* Initialize symbol occurrence counters and symbol Move To</span>
<span class="cm">	 * Front table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">byteCount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mtfSymbol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Loop through compressed symbols. */</span>
	<span class="n">runPos</span> <span class="o">=</span> <span class="n">dbufCount</span> <span class="o">=</span> <span class="n">symCount</span> <span class="o">=</span> <span class="n">selector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* Determine which Huffman coding group to use. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">symCount</span><span class="o">--</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">symCount</span> <span class="o">=</span> <span class="n">GROUP_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">selector</span> <span class="o">&gt;=</span> <span class="n">nSelectors</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>
			<span class="n">hufGroup</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">+</span><span class="n">selectors</span><span class="p">[</span><span class="n">selector</span><span class="o">++</span><span class="p">];</span>
			<span class="n">base</span> <span class="o">=</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">limit</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Read next Huffman-coded symbol. */</span>
		<span class="cm">/* Note: It is far cheaper to read maxLen bits and</span>
<span class="cm">		   back up than it is to read minLen bits and then an</span>
<span class="cm">		   additional bit at a time, testing as we go.</span>
<span class="cm">		   Because there is a trailing last block (with file</span>
<span class="cm">		   CRC), there is no danger of the overread causing an</span>
<span class="cm">		   unexpected EOF for a valid compressed file.  As a</span>
<span class="cm">		   further optimization, we do the read inline</span>
<span class="cm">		   (falling back to a call to get_bits if the buffer</span>
<span class="cm">		   runs dry).  The following (up to got_huff_bits:) is</span>
<span class="cm">		   equivalent to j = get_bits(bd, hufGroup-&gt;maxLen);</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">&lt;</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">maxLen</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufPos</span> <span class="o">==</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufCount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">j</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">maxLen</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">got_huff_bits</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBits</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBits</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbuf</span><span class="p">[</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufPos</span><span class="o">++</span><span class="p">];</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">-=</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">maxLen</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBits</span> <span class="o">&gt;&gt;</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span><span class="p">)</span><span class="o">&amp;</span>
			<span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">maxLen</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="nl">got_huff_bits:</span>
		<span class="cm">/* Figure how how many bits are in next symbol and</span>
<span class="cm">		 * unget extras */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">minLen</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufBitCount</span> <span class="o">+=</span> <span class="p">(</span><span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">maxLen</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
		<span class="cm">/* Huffman decode value to get nextSym (with bounds checking) */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">maxLen</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">maxLen</span><span class="o">-</span><span class="n">i</span><span class="p">))</span><span class="o">-</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
				<span class="o">&gt;=</span> <span class="n">MAX_SYMBOLS</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>
		<span class="n">nextSym</span> <span class="o">=</span> <span class="n">hufGroup</span><span class="o">-&gt;</span><span class="n">permute</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="cm">/* We have now decoded the symbol, which indicates</span>
<span class="cm">		   either a new literal byte, or a repeated run of the</span>
<span class="cm">		   most recent literal byte.  First, check if nextSym</span>
<span class="cm">		   indicates a repeated run, and if so loop collecting</span>
<span class="cm">		   how many times to repeat the last literal. */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">nextSym</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">SYMBOL_RUNB</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* RUNA or RUNB */</span>
			<span class="cm">/* If this is the start of a new run, zero out</span>
<span class="cm">			 * counter */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">runPos</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">runPos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Neat trick that saves 1 symbol: instead of</span>
<span class="cm">			   or-ing 0 or 1 at each bit position, add 1</span>
<span class="cm">			   or 2 instead.  For example, 1011 is 1 &lt;&lt; 0</span>
<span class="cm">			   + 1 &lt;&lt; 1 + 2 &lt;&lt; 2.  1010 is 2 &lt;&lt; 0 + 2 &lt;&lt; 1</span>
<span class="cm">			   + 1 &lt;&lt; 2.  You can make any bit pattern</span>
<span class="cm">			   that way using 1 less symbol than the basic</span>
<span class="cm">			   or 0/1 method (except all bits 0, which</span>
<span class="cm">			   would use no symbols, but a run of length 0</span>
<span class="cm">			   doesn&#39;t mean anything in this context).</span>
<span class="cm">			   Thus space is saved. */</span>
			<span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">runPos</span> <span class="o">&lt;&lt;</span> <span class="n">nextSym</span><span class="p">);</span>
			<span class="cm">/* +runPos if RUNA; +2*runPos if RUNB */</span>

			<span class="n">runPos</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* When we hit the first non-run symbol after a run,</span>
<span class="cm">		   we now know how many times to repeat the last</span>
<span class="cm">		   literal, so append that many copies to our buffer</span>
<span class="cm">		   of decoded symbols (dbuf) now.  (The last literal</span>
<span class="cm">		   used is the one at the head of the mtfSymbol</span>
<span class="cm">		   array.) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">runPos</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">runPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dbufCount</span><span class="o">+</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">dbufSize</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>

			<span class="n">uc</span> <span class="o">=</span> <span class="n">symToByte</span><span class="p">[</span><span class="n">mtfSymbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
			<span class="n">byteCount</span><span class="p">[</span><span class="n">uc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">t</span><span class="o">--</span><span class="p">)</span>
				<span class="n">dbuf</span><span class="p">[</span><span class="n">dbufCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">uc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Is this the terminating symbol? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nextSym</span> <span class="o">&gt;</span> <span class="n">symTotal</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* At this point, nextSym indicates a new literal</span>
<span class="cm">		   character.  Subtract one to get the position in the</span>
<span class="cm">		   MTF array at which this literal is currently to be</span>
<span class="cm">		   found.  (Note that the result can&#39;t be -1 or 0,</span>
<span class="cm">		   because 0 and 1 are RUNA and RUNB.  But another</span>
<span class="cm">		   instance of the first symbol in the mtf array,</span>
<span class="cm">		   position 0, would have been handled as part of a</span>
<span class="cm">		   run above.  Therefore 1 unused mtf position minus 2</span>
<span class="cm">		   non-literal nextSym values equals -1.) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dbufCount</span> <span class="o">&gt;=</span> <span class="n">dbufSize</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">nextSym</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">uc</span> <span class="o">=</span> <span class="n">mtfSymbol</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* Adjust the MTF array.  Since we typically expect to</span>
<span class="cm">		 *move only a small number of symbols, and are bound</span>
<span class="cm">		 *by 256 in any case, using memmove here would</span>
<span class="cm">		 *typically be bigger and slower due to function call</span>
<span class="cm">		 *overhead and other assorted setup costs. */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">mtfSymbol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtfSymbol</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">);</span>
		<span class="n">mtfSymbol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">uc</span><span class="p">;</span>
		<span class="n">uc</span> <span class="o">=</span> <span class="n">symToByte</span><span class="p">[</span><span class="n">uc</span><span class="p">];</span>
		<span class="cm">/* We have our literal byte.  Save it into dbuf. */</span>
		<span class="n">byteCount</span><span class="p">[</span><span class="n">uc</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dbuf</span><span class="p">[</span><span class="n">dbufCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">uc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* At this point, we&#39;ve read all the Huffman-coded symbols</span>
<span class="cm">	   (and repeated runs) for this block from the input stream,</span>
<span class="cm">	   and decoded them into the intermediate buffer.  There are</span>
<span class="cm">	   dbufCount many decoded bytes in dbuf[].  Now undo the</span>
<span class="cm">	   Burrows-Wheeler transform on dbuf.  See</span>
<span class="cm">	   http://dogma.net/markn/articles/bwt/bwt.htm</span>
<span class="cm">	 */</span>
	<span class="cm">/* Turn byteCount into cumulative occurrence counts of 0 to n-1. */</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="n">byteCount</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">byteCount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Figure out what order dbuf would be in if we sorted it. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dbufCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">dbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">dbuf</span><span class="p">[</span><span class="n">byteCount</span><span class="p">[</span><span class="n">uc</span><span class="p">]]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">byteCount</span><span class="p">[</span><span class="n">uc</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Decode first byte by hand to initialize &quot;previous&quot; byte.</span>
<span class="cm">	   Note that it doesn&#39;t get output, and if the first three</span>
<span class="cm">	   characters are identical it doesn&#39;t qualify as a run (hence</span>
<span class="cm">	   writeRunCountdown = 5). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbufCount</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">origPtr</span> <span class="o">&gt;=</span> <span class="n">dbufCount</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">RETVAL_DATA_ERROR</span><span class="p">;</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writePos</span> <span class="o">=</span> <span class="n">dbuf</span><span class="p">[</span><span class="n">origPtr</span><span class="p">];</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCurrent</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writePos</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">);</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writePos</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeRunCountdown</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCount</span> <span class="o">=</span> <span class="n">dbufCount</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">RETVAL_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Undo burrows-wheeler transform on intermediate buffer to produce output.</span>
<span class="cm">   If start_bunzip was initialized with out_fd =-1, then up to len bytes of</span>
<span class="cm">   data are written to outbuf.  Return value is number of bytes written or</span>
<span class="cm">   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len</span>
<span class="cm">   are ignored, data is written to out_fd and return is RETVAL_OK or error.</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">read_bunzip</span><span class="p">(</span><span class="k">struct</span> <span class="n">bunzip_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">outbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">xcurrent</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">gotcount</span><span class="p">;</span>

	<span class="cm">/* If last read was short due to end of file, return last block now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCount</span><span class="p">;</span>

	<span class="n">gotcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dbuf</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">writePos</span><span class="p">;</span>
	<span class="n">xcurrent</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCurrent</span><span class="p">;</span>

	<span class="cm">/* We will always have pending decoded data to write into the output</span>
<span class="cm">	   buffer unless this is the very first call (in which case we haven&#39;t</span>
<span class="cm">	   Huffman-decoded a block into the intermediate buffer yet). */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCopies</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Inside the loop, writeCopies means extra copies (beyond 1) */</span>
		<span class="o">--</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCopies</span><span class="p">;</span>
		<span class="cm">/* Loop outputting bytes */</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="cm">/* If the output buffer is full, snapshot</span>
<span class="cm">			 * state and return */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gotcount</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writePos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
				<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCurrent</span> <span class="o">=</span> <span class="n">xcurrent</span><span class="p">;</span>
				<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCopies</span><span class="o">++</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Write next byte into output buffer, updating CRC */</span>
			<span class="n">outbuf</span><span class="p">[</span><span class="n">gotcount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcurrent</span><span class="p">;</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCRC</span> <span class="o">=</span> <span class="p">(((</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCRC</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
				<span class="o">^</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">crc32Table</span><span class="p">[((</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCRC</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
				<span class="o">^</span><span class="n">xcurrent</span><span class="p">]);</span>
			<span class="cm">/* Loop now if we&#39;re outputting multiple</span>
<span class="cm">			 * copies of this byte */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCopies</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">--</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCopies</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
<span class="nl">decode_next_byte:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCount</span><span class="o">--</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* Follow sequence vector to undo</span>
<span class="cm">			 * Burrows-Wheeler transform */</span>
			<span class="n">previous</span> <span class="o">=</span> <span class="n">xcurrent</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">dbuf</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
			<span class="n">xcurrent</span> <span class="o">=</span> <span class="n">pos</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="cm">/* After 3 consecutive copies of the same</span>
<span class="cm">			   byte, the 4th is a repeat count.  We count</span>
<span class="cm">			   down from 4 instead *of counting up because</span>
<span class="cm">			   testing for non-zero is faster */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeRunCountdown</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">xcurrent</span> <span class="o">!=</span> <span class="n">previous</span><span class="p">)</span>
					<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeRunCountdown</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* We have a repeated run, this byte</span>
<span class="cm">				 * indicates the count */</span>
				<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCopies</span> <span class="o">=</span> <span class="n">xcurrent</span><span class="p">;</span>
				<span class="n">xcurrent</span> <span class="o">=</span> <span class="n">previous</span><span class="p">;</span>
				<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeRunCountdown</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
				<span class="cm">/* Sometimes there are just 3 bytes</span>
<span class="cm">				 * (run length 0) */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCopies</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">decode_next_byte</span><span class="p">;</span>
				<span class="cm">/* Subtract the 1 copy we&#39;d output</span>
<span class="cm">				 * anyway to get extras */</span>
				<span class="o">--</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCopies</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Decompression of this block completed successfully */</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCRC</span> <span class="o">=</span> <span class="o">~</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCRC</span><span class="p">;</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">totalCRC</span> <span class="o">=</span> <span class="p">((</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">totalCRC</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">totalCRC</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">))</span> <span class="o">^</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCRC</span><span class="p">;</span>
		<span class="cm">/* If this block had a CRC error, force file level CRC error. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCRC</span> <span class="o">!=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">headerCRC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bd</span><span class="o">-&gt;</span><span class="n">totalCRC</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">headerCRC</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">RETVAL_LAST_BLOCK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Refill the intermediate buffer by Huffman-decoding next</span>
<span class="cm">	 * block of input */</span>
	<span class="cm">/* (previous is just a convenient unused temp variable here) */</span>
	<span class="n">previous</span> <span class="o">=</span> <span class="n">get_next_block</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">previous</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCount</span> <span class="o">=</span> <span class="n">previous</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">previous</span> <span class="o">!=</span> <span class="n">RETVAL_LAST_BLOCK</span><span class="p">)</span> <span class="o">?</span> <span class="n">previous</span> <span class="o">:</span> <span class="n">gotcount</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCRC</span> <span class="o">=</span> <span class="mh">0xffffffffUL</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">writePos</span><span class="p">;</span>
	<span class="n">xcurrent</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">writeCurrent</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">decode_next_byte</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">nofill</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate the structure, read file header.  If in_fd ==-1, inbuf must contain</span>
<span class="cm">   a complete bunzip file (len bytes long).  If in_fd!=-1, inbuf and len are</span>
<span class="cm">   ignored, and data is read from file handle into temporary buffer. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">start_bunzip</span><span class="p">(</span><span class="k">struct</span> <span class="n">bunzip_data</span> <span class="o">**</span><span class="n">bdp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bunzip_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">BZh0</span> <span class="o">=</span>
		<span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="sc">&#39;B&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span><span class="o">+</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="sc">&#39;Z&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="o">+</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="sc">&#39;h&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="sc">&#39;0&#39;</span><span class="p">;</span>

	<span class="cm">/* Figure out how much data to allocate */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bunzip_data</span><span class="p">);</span>

	<span class="cm">/* Allocate bunzip_data.  Most fields initialize to zero. */</span>
	<span class="n">bd</span> <span class="o">=</span> <span class="o">*</span><span class="n">bdp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RETVAL_OUT_OF_MEMORY</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bunzip_data</span><span class="p">));</span>
	<span class="cm">/* Setup input buffer */</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbuf</span> <span class="o">=</span> <span class="n">inbuf</span><span class="p">;</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufCount</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fill</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">fill</span> <span class="o">=</span> <span class="n">nofill</span><span class="p">;</span>

	<span class="cm">/* Init the CRC32 table (big endian) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">&amp;</span><span class="mh">0x80000000</span> <span class="o">?</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mh">0x04c11db7</span> <span class="o">:</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bd</span><span class="o">-&gt;</span><span class="n">crc32Table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Ensure that file starts with &quot;BZh[&#39;1&#39;-&#39;9&#39;].&quot; */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">get_bits</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">i</span><span class="o">-</span><span class="n">BZh0</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">9</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RETVAL_NOT_BZIP_DATA</span><span class="p">;</span>

	<span class="cm">/* Fourth byte (ascii &#39;1&#39;-&#39;9&#39;), indicates block size in units of 100k of</span>
<span class="cm">	   uncompressed data.  Allocate intermediate buffer for block. */</span>
	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbufSize</span> <span class="o">=</span> <span class="mi">100000</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">BZh0</span><span class="p">);</span>

	<span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbuf</span> <span class="o">=</span> <span class="n">large_malloc</span><span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbufSize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RETVAL_OUT_OF_MEMORY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">RETVAL_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Example usage: decompress src_fd to dst_fd.  (Stops at end of bzip2 data,</span>
<span class="cm">   not end of file.) */</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">bunzip2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fill</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
			<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">outbuf</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span>
			<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">error</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bunzip_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">)</span>
		<span class="n">outbuf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BZIP2_IOBUF_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">outbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">&quot;Could not allocate output buffer&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">RETVAL_OUT_OF_MEMORY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span>
		<span class="n">inbuf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">inbuf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BZIP2_IOBUF_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">&quot;Could not allocate input buffer&quot;</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">RETVAL_OUT_OF_MEMORY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">start_bunzip</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bd</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">fill</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">read_bunzip</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">outbuf</span><span class="p">,</span> <span class="n">BZIP2_IOBUF_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flush</span><span class="p">)</span>
				<span class="n">outbuf</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">flush</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">i</span> <span class="o">=</span> <span class="n">RETVAL_UNEXPECTED_OUTPUT_EOF</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Check CRC and release memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">RETVAL_LAST_BLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">headerCRC</span> <span class="o">!=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">totalCRC</span><span class="p">)</span>
			<span class="n">error</span><span class="p">(</span><span class="s">&quot;Data integrity error when decompressing.&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">RETVAL_OK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">RETVAL_UNEXPECTED_OUTPUT_EOF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span><span class="p">(</span><span class="s">&quot;Compressed file ends unexpectedly&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">)</span>
		<span class="n">large_free</span><span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">inbufPos</span><span class="p">;</span>
	<span class="n">free</span><span class="p">(</span><span class="n">bd</span><span class="p">);</span>
<span class="nl">exit_1:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="n">free</span><span class="p">(</span><span class="n">inbuf</span><span class="p">);</span>
<span class="nl">exit_0:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">)</span>
		<span class="n">free</span><span class="p">(</span><span class="n">outbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef PREBOOT</span>
<span class="n">STATIC</span> <span class="kt">int</span> <span class="n">INIT</span> <span class="nf">decompress</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">fill</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
			<span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">outbuf</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span>
			<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">error</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bunzip2</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">flush</span><span class="p">,</span> <span class="n">outbuf</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
