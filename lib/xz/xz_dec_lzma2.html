<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › xz › xz_dec_lzma2.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xz_dec_lzma2.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * LZMA2 decoder</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Lasse Collin &lt;lasse.collin@tukaani.org&gt;</span>
<span class="cm"> *          Igor Pavlov &lt;http://7-zip.org/&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file has been put into the public domain.</span>
<span class="cm"> * You can do whatever you want with this file.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;xz_private.h&quot;</span>
<span class="cp">#include &quot;xz_lzma2.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Range decoder initialization eats the first five bytes of each LZMA chunk.</span>
<span class="cm"> */</span>
<span class="cp">#define RC_INIT_BYTES 5</span>

<span class="cm">/*</span>
<span class="cm"> * Minimum number of usable input buffer to safely decode one LZMA symbol.</span>
<span class="cm"> * The worst case is that we decode 22 bits using probabilities and 26</span>
<span class="cm"> * direct bits. This may decode at maximum of 20 bytes of input. However,</span>
<span class="cm"> * lzma_main() does an extra normalization before returning, thus we</span>
<span class="cm"> * need to put 21 here.</span>
<span class="cm"> */</span>
<span class="cp">#define LZMA_IN_REQUIRED 21</span>

<span class="cm">/*</span>
<span class="cm"> * Dictionary (history buffer)</span>
<span class="cm"> *</span>
<span class="cm"> * These are always true:</span>
<span class="cm"> *    start &lt;= pos &lt;= full &lt;= end</span>
<span class="cm"> *    pos &lt;= limit &lt;= end</span>
<span class="cm"> *</span>
<span class="cm"> * In multi-call mode, also these are true:</span>
<span class="cm"> *    end == size</span>
<span class="cm"> *    size &lt;= size_max</span>
<span class="cm"> *    allocated &lt;= size</span>
<span class="cm"> *</span>
<span class="cm"> * Most of these variables are size_t to support single-call mode,</span>
<span class="cm"> * in which the dictionary variables address the actual output</span>
<span class="cm"> * buffer directly.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dictionary</span> <span class="p">{</span>
	<span class="cm">/* Beginning of the history buffer */</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Old position in buf (before decoding more data) */</span>
	<span class="kt">size_t</span> <span class="n">start</span><span class="p">;</span>

	<span class="cm">/* Position in buf */</span>
	<span class="kt">size_t</span> <span class="n">pos</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * How full dictionary is. This is used to detect corrupt input that</span>
<span class="cm">	 * would read beyond the beginning of the uncompressed stream.</span>
<span class="cm">	 */</span>
	<span class="kt">size_t</span> <span class="n">full</span><span class="p">;</span>

	<span class="cm">/* Write limit; we don&#39;t write to buf[limit] or later bytes. */</span>
	<span class="kt">size_t</span> <span class="n">limit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * End of the dictionary buffer. In multi-call mode, this is</span>
<span class="cm">	 * the same as the dictionary size. In single-call mode, this</span>
<span class="cm">	 * indicates the size of the output buffer.</span>
<span class="cm">	 */</span>
	<span class="kt">size_t</span> <span class="n">end</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Size of the dictionary as specified in Block Header. This is used</span>
<span class="cm">	 * together with &quot;full&quot; to detect corrupt input that would make us</span>
<span class="cm">	 * read beyond the beginning of the uncompressed stream.</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum allowed dictionary size in multi-call mode.</span>
<span class="cm">	 * This is ignored in single-call mode.</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">size_max</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Amount of memory currently allocated for the dictionary.</span>
<span class="cm">	 * This is used only with XZ_DYNALLOC. (With XZ_PREALLOC,</span>
<span class="cm">	 * size_max is always the same as the allocated size.)</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">allocated</span><span class="p">;</span>

	<span class="cm">/* Operation mode */</span>
	<span class="k">enum</span> <span class="n">xz_mode</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Range decoder */</span>
<span class="k">struct</span> <span class="n">rc_dec</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">range</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">code</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of initializing bytes remaining to be read</span>
<span class="cm">	 * by rc_read_init().</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">init_bytes_left</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Buffer from which we read our input. It can be either</span>
<span class="cm">	 * temp.buf or the caller-provided input buffer.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">in_pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">in_limit</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Probabilities for a length decoder. */</span>
<span class="k">struct</span> <span class="n">lzma_len_dec</span> <span class="p">{</span>
	<span class="cm">/* Probability of match length being at least 10 */</span>
	<span class="kt">uint16_t</span> <span class="n">choice</span><span class="p">;</span>

	<span class="cm">/* Probability of match length being at least 18 */</span>
	<span class="kt">uint16_t</span> <span class="n">choice2</span><span class="p">;</span>

	<span class="cm">/* Probabilities for match lengths 2-9 */</span>
	<span class="kt">uint16_t</span> <span class="n">low</span><span class="p">[</span><span class="n">POS_STATES_MAX</span><span class="p">][</span><span class="n">LEN_LOW_SYMBOLS</span><span class="p">];</span>

	<span class="cm">/* Probabilities for match lengths 10-17 */</span>
	<span class="kt">uint16_t</span> <span class="n">mid</span><span class="p">[</span><span class="n">POS_STATES_MAX</span><span class="p">][</span><span class="n">LEN_MID_SYMBOLS</span><span class="p">];</span>

	<span class="cm">/* Probabilities for match lengths 18-273 */</span>
	<span class="kt">uint16_t</span> <span class="n">high</span><span class="p">[</span><span class="n">LEN_HIGH_SYMBOLS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lzma_dec</span> <span class="p">{</span>
	<span class="cm">/* Distances of latest four matches */</span>
	<span class="kt">uint32_t</span> <span class="n">rep0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rep1</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rep2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rep3</span><span class="p">;</span>

	<span class="cm">/* Types of the most recently seen LZMA symbols */</span>
	<span class="k">enum</span> <span class="n">lzma_state</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Length of a match. This is updated so that dict_repeat can</span>
<span class="cm">	 * be called again to finish repeating the whole match.</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * LZMA properties or related bit masks (number of literal</span>
<span class="cm">	 * context bits, a mask dervied from the number of literal</span>
<span class="cm">	 * position bits, and a mask dervied from the number</span>
<span class="cm">	 * position bits)</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">lc</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">literal_pos_mask</span><span class="p">;</span> <span class="cm">/* (1 &lt;&lt; lp) - 1 */</span>
	<span class="kt">uint32_t</span> <span class="n">pos_mask</span><span class="p">;</span>         <span class="cm">/* (1 &lt;&lt; pb) - 1 */</span>

	<span class="cm">/* If 1, it&#39;s a match. Otherwise it&#39;s a single 8-bit literal. */</span>
	<span class="kt">uint16_t</span> <span class="n">is_match</span><span class="p">[</span><span class="n">STATES</span><span class="p">][</span><span class="n">POS_STATES_MAX</span><span class="p">];</span>

	<span class="cm">/* If 1, it&#39;s a repeated match. The distance is one of rep0 .. rep3. */</span>
	<span class="kt">uint16_t</span> <span class="n">is_rep</span><span class="p">[</span><span class="n">STATES</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If 0, distance of a repeated match is rep0.</span>
<span class="cm">	 * Otherwise check is_rep1.</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">is_rep0</span><span class="p">[</span><span class="n">STATES</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If 0, distance of a repeated match is rep1.</span>
<span class="cm">	 * Otherwise check is_rep2.</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">is_rep1</span><span class="p">[</span><span class="n">STATES</span><span class="p">];</span>

	<span class="cm">/* If 0, distance of a repeated match is rep2. Otherwise it is rep3. */</span>
	<span class="kt">uint16_t</span> <span class="n">is_rep2</span><span class="p">[</span><span class="n">STATES</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If 1, the repeated match has length of one byte. Otherwise</span>
<span class="cm">	 * the length is decoded from rep_len_decoder.</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">is_rep0_long</span><span class="p">[</span><span class="n">STATES</span><span class="p">][</span><span class="n">POS_STATES_MAX</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Probability tree for the highest two bits of the match</span>
<span class="cm">	 * distance. There is a separate probability tree for match</span>
<span class="cm">	 * lengths of 2 (i.e. MATCH_LEN_MIN), 3, 4, and [5, 273].</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">dist_slot</span><span class="p">[</span><span class="n">DIST_STATES</span><span class="p">][</span><span class="n">DIST_SLOTS</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Probility trees for additional bits for match distance</span>
<span class="cm">	 * when the distance is in the range [4, 127].</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">dist_special</span><span class="p">[</span><span class="n">FULL_DISTANCES</span> <span class="o">-</span> <span class="n">DIST_MODEL_END</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Probability tree for the lowest four bits of a match</span>
<span class="cm">	 * distance that is equal to or greater than 128.</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">dist_align</span><span class="p">[</span><span class="n">ALIGN_SIZE</span><span class="p">];</span>

	<span class="cm">/* Length of a normal match */</span>
	<span class="k">struct</span> <span class="n">lzma_len_dec</span> <span class="n">match_len_dec</span><span class="p">;</span>

	<span class="cm">/* Length of a repeated match */</span>
	<span class="k">struct</span> <span class="n">lzma_len_dec</span> <span class="n">rep_len_dec</span><span class="p">;</span>

	<span class="cm">/* Probabilities of literals */</span>
	<span class="kt">uint16_t</span> <span class="n">literal</span><span class="p">[</span><span class="n">LITERAL_CODERS_MAX</span><span class="p">][</span><span class="n">LITERAL_CODER_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lzma2_dec</span> <span class="p">{</span>
	<span class="cm">/* Position in xz_dec_lzma2_run(). */</span>
	<span class="k">enum</span> <span class="n">lzma2_seq</span> <span class="p">{</span>
		<span class="n">SEQ_CONTROL</span><span class="p">,</span>
		<span class="n">SEQ_UNCOMPRESSED_1</span><span class="p">,</span>
		<span class="n">SEQ_UNCOMPRESSED_2</span><span class="p">,</span>
		<span class="n">SEQ_COMPRESSED_0</span><span class="p">,</span>
		<span class="n">SEQ_COMPRESSED_1</span><span class="p">,</span>
		<span class="n">SEQ_PROPERTIES</span><span class="p">,</span>
		<span class="n">SEQ_LZMA_PREPARE</span><span class="p">,</span>
		<span class="n">SEQ_LZMA_RUN</span><span class="p">,</span>
		<span class="n">SEQ_COPY</span>
	<span class="p">}</span> <span class="n">sequence</span><span class="p">;</span>

	<span class="cm">/* Next position after decoding the compressed size of the chunk. */</span>
	<span class="k">enum</span> <span class="n">lzma2_seq</span> <span class="n">next_sequence</span><span class="p">;</span>

	<span class="cm">/* Uncompressed size of LZMA chunk (2 MiB at maximum) */</span>
	<span class="kt">uint32_t</span> <span class="n">uncompressed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compressed size of LZMA chunk or compressed/uncompressed</span>
<span class="cm">	 * size of uncompressed chunk (64 KiB at maximum)</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">compressed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if dictionary reset is needed. This is false before</span>
<span class="cm">	 * the first chunk (LZMA or uncompressed).</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">need_dict_reset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if new LZMA properties are needed. This is false</span>
<span class="cm">	 * before the first LZMA chunk.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">need_props</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The order below is important on x86 to reduce code size and</span>
<span class="cm">	 * it shouldn&#39;t hurt on other platforms. Everything up to and</span>
<span class="cm">	 * including lzma.pos_mask are in the first 128 bytes on x86-32,</span>
<span class="cm">	 * which allows using smaller instructions to access those</span>
<span class="cm">	 * variables. On x86-64, fewer variables fit into the first 128</span>
<span class="cm">	 * bytes, but this is still the best order without sacrificing</span>
<span class="cm">	 * the readability by splitting the structures.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rc_dec</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dictionary</span> <span class="n">dict</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lzma2_dec</span> <span class="n">lzma2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lzma_dec</span> <span class="n">lzma</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Temporary buffer which holds small number of input bytes between</span>
<span class="cm">	 * decoder calls. See lzma2_lzma() for details.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">LZMA_IN_REQUIRED</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**************</span>
<span class="cm"> * Dictionary *</span>
<span class="cm"> **************/</span>

<span class="cm">/*</span>
<span class="cm"> * Reset the dictionary state. When in single-call mode, set up the beginning</span>
<span class="cm"> * of the dictionary to point to the actual output buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dict_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_SINGLE</span><span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">;</span>
		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dict</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dict</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set dictionary write limit */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dict_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">out_max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">out_max</span><span class="p">)</span>
		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">out_max</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return true if at least one byte can be written into the dictionary. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dict_has_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dictionary</span> <span class="o">*</span><span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a byte from the dictionary at the given distance. The distance is</span>
<span class="cm"> * assumed to valid, or as a special case, zero when the dictionary is</span>
<span class="cm"> * still empty. This special case is needed for single-call decoding to</span>
<span class="cm"> * avoid writing a &#39;\0&#39; to the end of the destination buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">dict_get</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dictionary</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">dist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Put one byte into the dictionary. It is assumed that there is space for it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dict_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dict</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Repeat given number of bytes from the given distance. If the distance is</span>
<span class="cm"> * invalid, false is returned. On success, true is returned and *len is</span>
<span class="cm"> * updated to indicate how many bytes were left to be repeated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">dict_repeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">dist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">back</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">left</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">||</span> <span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">left</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">-</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">-=</span> <span class="n">left</span><span class="p">;</span>

	<span class="n">back</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">back</span> <span class="o">+=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">back</span><span class="o">++</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">back</span> <span class="o">==</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="n">back</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Copy uncompressed data as is from input to dictionary and output buffers. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dict_uncompressed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
			      <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">left</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">copy_size</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span>
			<span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">,</span>
				<span class="n">b</span><span class="o">-&gt;</span><span class="n">out_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_size</span> <span class="o">&gt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
			<span class="n">copy_size</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_size</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">left</span><span class="p">)</span>
			<span class="n">copy_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>

		<span class="o">*</span><span class="n">left</span> <span class="o">-=</span> <span class="n">copy_size</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>
		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">copy_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
			<span class="n">dict</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_MULTI</span><span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
				<span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">out</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">,</span>
					<span class="n">copy_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">dict</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>

		<span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span> <span class="o">+=</span> <span class="n">copy_size</span><span class="p">;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">+=</span> <span class="n">copy_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush pending data from dictionary to b-&gt;out. It is assumed that there is</span>
<span class="cm"> * enough space in b-&gt;out. This is guaranteed because caller uses dict_limit()</span>
<span class="cm"> * before decoding data into the dictionary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">dict_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">copy_size</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_MULTI</span><span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">out</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">,</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				<span class="n">copy_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dict</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span> <span class="o">+=</span> <span class="n">copy_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">copy_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*****************</span>
<span class="cm"> * Range decoder *</span>
<span class="cm"> *****************/</span>

<span class="cm">/* Reset the range decoder. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rc_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rc</span><span class="o">-&gt;</span><span class="n">init_bytes_left</span> <span class="o">=</span> <span class="n">RC_INIT_BYTES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the first five initial bytes into rc-&gt;code if they haven&#39;t been</span>
<span class="cm"> * read already. (Yes, the first byte gets completely ignored.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">rc_read_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">init_bytes_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">];</span>
		<span class="o">--</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">init_bytes_left</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return true if there may not be enough input for the next decoding loop. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rc_limit_exceeded</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">&gt;</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">in_limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if it is possible (from point of view of range decoder) that</span>
<span class="cm"> * we have reached the end of the LZMA chunk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rc_is_finished</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Read the next input byte if needed. */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">rc_normalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">&lt;</span> <span class="n">RC_TOP_VALUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">&lt;&lt;=</span> <span class="n">RC_SHIFT_BITS</span><span class="p">;</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="n">RC_SHIFT_BITS</span><span class="p">)</span> <span class="o">+</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decode one bit. In some versions, this function has been splitted in three</span>
<span class="cm"> * functions so that the compiler is supposed to be able to more easily avoid</span>
<span class="cm"> * an extra branch. In this particular version of the LZMA decoder, this</span>
<span class="cm"> * doesn&#39;t seem to be a good idea (tested with GCC 3.3.6, 3.4.6, and 4.3.3</span>
<span class="cm"> * on x86). Using a non-splitted version results in nicer looking code too.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This must return an int. Do not make it return a bool or the speed</span>
<span class="cm"> * of the code generated by GCC 3.x decreases 10-15 %. (GCC 4.3 doesn&#39;t care,</span>
<span class="cm"> * and it generates 10-20 % faster code than GCC 3.x from this file anyway.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span> <span class="nf">rc_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">prob</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">bound</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="n">rc_normalize</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
	<span class="n">bound</span> <span class="o">=</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">&gt;&gt;</span> <span class="n">RC_BIT_MODEL_TOTAL_BITS</span><span class="p">)</span> <span class="o">*</span> <span class="o">*</span><span class="n">prob</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">=</span> <span class="n">bound</span><span class="p">;</span>
		<span class="o">*</span><span class="n">prob</span> <span class="o">+=</span> <span class="p">(</span><span class="n">RC_BIT_MODEL_TOTAL</span> <span class="o">-</span> <span class="o">*</span><span class="n">prob</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">RC_MOVE_BITS</span><span class="p">;</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">-=</span> <span class="n">bound</span><span class="p">;</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">-=</span> <span class="n">bound</span><span class="p">;</span>
		<span class="o">*</span><span class="n">prob</span> <span class="o">-=</span> <span class="o">*</span><span class="n">prob</span> <span class="o">&gt;&gt;</span> <span class="n">RC_MOVE_BITS</span><span class="p">;</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decode a bittree starting from the most significant bit. */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">uint32_t</span> <span class="nf">rc_bittree</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
					   <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">probs</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">symbol</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc_bit</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">probs</span><span class="p">[</span><span class="n">symbol</span><span class="p">]))</span>
			<span class="n">symbol</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbol</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">symbol</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">symbol</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">symbol</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decode a bittree starting from the least significant bit. */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">rc_bittree_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
					       <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">probs</span><span class="p">,</span>
					       <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">symbol</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc_bit</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">probs</span><span class="p">[</span><span class="n">symbol</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">symbol</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbol</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">dest</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">symbol</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Decode direct bits (fixed fifty-fifty probability) */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rc_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">rc_dec</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">rc_normalize</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">-=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">);</span>
		<span class="n">rc</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">+=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">range</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dest</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/********</span>
<span class="cm"> * LZMA *</span>
<span class="cm"> ********/</span>

<span class="cm">/* Get pointer to literal coder probability array. */</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="nf">lzma_literal_probs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">prev_byte</span> <span class="o">=</span> <span class="n">dict_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">low</span> <span class="o">=</span> <span class="n">prev_byte</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">lc</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">high</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">literal_pos_mask</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">lc</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">literal</span><span class="p">[</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Decode a literal (one 8-bit byte) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lzma_literal</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">probs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">symbol</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">match_byte</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">match_bit</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">probs</span> <span class="o">=</span> <span class="n">lzma_literal_probs</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lzma_state_is_literal</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">symbol</span> <span class="o">=</span> <span class="n">rc_bittree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">symbol</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">match_byte</span> <span class="o">=</span> <span class="n">dict_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">match_bit</span> <span class="o">=</span> <span class="n">match_byte</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">match_byte</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">match_bit</span> <span class="o">+</span> <span class="n">symbol</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">symbol</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbol</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">offset</span> <span class="o">&amp;=</span> <span class="n">match_bit</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">symbol</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">match_bit</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">symbol</span> <span class="o">&lt;</span> <span class="mh">0x100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dict_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">symbol</span><span class="p">);</span>
	<span class="n">lzma_state_literal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Decode the length of the match into s-&gt;lzma.len. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lzma_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lzma_len_dec</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span>
		     <span class="kt">uint32_t</span> <span class="n">pos_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">probs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">choice</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">probs</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">low</span><span class="p">[</span><span class="n">pos_state</span><span class="p">];</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">LEN_LOW_SYMBOLS</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">MATCH_LEN_MIN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">choice2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">probs</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">mid</span><span class="p">[</span><span class="n">pos_state</span><span class="p">];</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">LEN_MID_SYMBOLS</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">MATCH_LEN_MIN</span> <span class="o">+</span> <span class="n">LEN_LOW_SYMBOLS</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">probs</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">high</span><span class="p">;</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">LEN_HIGH_SYMBOLS</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">MATCH_LEN_MIN</span> <span class="o">+</span> <span class="n">LEN_LOW_SYMBOLS</span>
					<span class="o">+</span> <span class="n">LEN_MID_SYMBOLS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span> <span class="o">+=</span> <span class="n">rc_bittree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span> <span class="o">-</span> <span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decode a match. The distance will be stored in s-&gt;lzma.rep0. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lzma_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">pos_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">probs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dist_slot</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">limit</span><span class="p">;</span>

	<span class="n">lzma_state_match</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep3</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep2</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep2</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep1</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep1</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span><span class="p">;</span>

	<span class="n">lzma_len</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">match_len_dec</span><span class="p">,</span> <span class="n">pos_state</span><span class="p">);</span>

	<span class="n">probs</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">dist_slot</span><span class="p">[</span><span class="n">lzma_get_dist_state</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span><span class="p">)];</span>
	<span class="n">dist_slot</span> <span class="o">=</span> <span class="n">rc_bittree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">DIST_SLOTS</span><span class="p">)</span> <span class="o">-</span> <span class="n">DIST_SLOTS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dist_slot</span> <span class="o">&lt;</span> <span class="n">DIST_MODEL_START</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span> <span class="o">=</span> <span class="n">dist_slot</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_slot</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">dist_slot</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dist_slot</span> <span class="o">&lt;</span> <span class="n">DIST_MODEL_END</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span> <span class="o">&lt;&lt;=</span> <span class="n">limit</span><span class="p">;</span>
			<span class="n">probs</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">dist_special</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span>
					<span class="o">-</span> <span class="n">dist_slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">rc_bittree_reverse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rc_direct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span><span class="p">,</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">ALIGN_BITS</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span> <span class="o">&lt;&lt;=</span> <span class="n">ALIGN_BITS</span><span class="p">;</span>
			<span class="n">rc_bittree_reverse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">dist_align</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span><span class="p">,</span> <span class="n">ALIGN_BITS</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decode a repeated match. The distance is one of the four most recently</span>
<span class="cm"> * seen matches. The distance will be stored in s-&gt;lzma.rep0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lzma_rep_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">pos_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">is_rep0</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">]))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">is_rep0_long</span><span class="p">[</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">][</span><span class="n">pos_state</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">lzma_state_short_rep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">is_rep1</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">is_rep2</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep2</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep3</span><span class="p">;</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep3</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep2</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep2</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep1</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lzma_state_long_rep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">);</span>
	<span class="n">lzma_len</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep_len_dec</span><span class="p">,</span> <span class="n">pos_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* LZMA decoder core */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">lzma_main</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">pos_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the dictionary was reached during the previous call, try to</span>
<span class="cm">	 * finish the possibly pending repeat in the dictionary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dict_has_space</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dict_repeat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decode more LZMA symbols. One iteration may consume up to</span>
<span class="cm">	 * LZMA_IN_REQUIRED - 1 bytes.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dict_has_space</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rc_limit_exceeded</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pos_state</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">pos_mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">is_match</span><span class="p">[</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">][</span><span class="n">pos_state</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">lzma_literal</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">is_rep</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span><span class="p">]))</span>
				<span class="n">lzma_rep_match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos_state</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">lzma_match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos_state</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dict_repeat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Having the range decoder always normalized when we are outside</span>
<span class="cm">	 * this function makes it easier to correctly handle end of the chunk.</span>
<span class="cm">	 */</span>
	<span class="n">rc_normalize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reset the LZMA decoder and range decoder state. Dictionary is nore reset</span>
<span class="cm"> * here, because LZMA state may be reset without resetting the dictionary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lzma_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">probs</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_LIT_LIT</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">rep3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * All probabilities are initialized to the same value. This hack</span>
<span class="cm">	 * makes the code smaller by avoiding a separate loop for each</span>
<span class="cm">	 * probability array.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This could be optimized so that only that part of literal</span>
<span class="cm">	 * probabilities that are actually required. In the common case</span>
<span class="cm">	 * we would write 12 KiB less.</span>
<span class="cm">	 */</span>
	<span class="n">probs</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">is_match</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PROBS_TOTAL</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">RC_BIT_MODEL_TOTAL</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">rc_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decode and validate LZMA properties (lc/lp/pb) and calculate the bit masks</span>
<span class="cm"> * from the decoded lp and pb values. On success, the LZMA decoder state is</span>
<span class="cm"> * reset and true is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">lzma_props</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">props</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">props</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">pos_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">props</span> <span class="o">&gt;=</span> <span class="mi">9</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">props</span> <span class="o">-=</span> <span class="mi">9</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>
		<span class="o">++</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">pos_mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">pos_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">pos_mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">literal_pos_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">props</span> <span class="o">&gt;=</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">props</span> <span class="o">-=</span> <span class="mi">9</span><span class="p">;</span>
		<span class="o">++</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">literal_pos_mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">lc</span> <span class="o">=</span> <span class="n">props</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">lc</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">literal_pos_mask</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">literal_pos_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">literal_pos_mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lzma_reset</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*********</span>
<span class="cm"> * LZMA2 *</span>
<span class="cm"> *********/</span>

<span class="cm">/*</span>
<span class="cm"> * The LZMA decoder assumes that if the input limit (s-&gt;rc.in_limit) hasn&#39;t</span>
<span class="cm"> * been exceeded, it is safe to read up to LZMA_IN_REQUIRED bytes. This</span>
<span class="cm"> * wrapper function takes care of making the LZMA decoder&#39;s assumption safe.</span>
<span class="cm"> *</span>
<span class="cm"> * As long as there is plenty of input left to be decoded in the current LZMA</span>
<span class="cm"> * chunk, we decode directly from the caller-supplied input buffer until</span>
<span class="cm"> * there&#39;s LZMA_IN_REQUIRED bytes left. Those remaining bytes are copied into</span>
<span class="cm"> * s-&gt;temp.buf, which (hopefully) gets filled on the next call to this</span>
<span class="cm"> * function. We decode a few bytes from the temporary buffer so that we can</span>
<span class="cm"> * continue decoding from the caller-supplied input buffer again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">lzma2_lzma</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">in_avail</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">in_avail</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">LZMA_IN_REQUIRED</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">in_avail</span><span class="p">)</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">in_avail</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">==</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memzero</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">)</span>
						<span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_limit</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">LZMA_IN_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_limit</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">LZMA_IN_REQUIRED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lzma_main</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">-=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span><span class="p">;</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span><span class="p">,</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">in_avail</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_avail</span> <span class="o">&gt;=</span> <span class="n">LZMA_IN_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_avail</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">+</span> <span class="n">LZMA_IN_REQUIRED</span><span class="p">)</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_limit</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_limit</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span> <span class="o">-</span> <span class="n">LZMA_IN_REQUIRED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lzma_main</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">in_avail</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_avail</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">-=</span> <span class="n">in_avail</span><span class="p">;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">.</span><span class="n">in_pos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">in_avail</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_avail</span> <span class="o">&lt;</span> <span class="n">LZMA_IN_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_avail</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span><span class="p">)</span>
			<span class="n">in_avail</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">,</span> <span class="n">in_avail</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">in_avail</span><span class="p">;</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">+=</span> <span class="n">in_avail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take care of the LZMA2 control layer, and forward the job of actual LZMA</span>
<span class="cm"> * decoding or copying of uncompressed chunks to other functions.</span>
<span class="cm"> */</span>
<span class="n">XZ_EXTERN</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">xz_dec_lzma2_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">==</span> <span class="n">SEQ_LZMA_RUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SEQ_CONTROL</span>:
			<span class="cm">/*</span>
<span class="cm">			 * LZMA2 control byte</span>
<span class="cm">			 *</span>
<span class="cm">			 * Exact values:</span>
<span class="cm">			 *   0x00   End marker</span>
<span class="cm">			 *   0x01   Dictionary reset followed by</span>
<span class="cm">			 *          an uncompressed chunk</span>
<span class="cm">			 *   0x02   Uncompressed chunk (no dictionary reset)</span>
<span class="cm">			 *</span>
<span class="cm">			 * Highest three bits (s-&gt;control &amp; 0xE0):</span>
<span class="cm">			 *   0xE0   Dictionary reset, new properties and state</span>
<span class="cm">			 *          reset, followed by LZMA compressed chunk</span>
<span class="cm">			 *   0xC0   New properties and state reset, followed</span>
<span class="cm">			 *          by LZMA compressed chunk (no dictionary</span>
<span class="cm">			 *          reset)</span>
<span class="cm">			 *   0xA0   State reset using old properties,</span>
<span class="cm">			 *          followed by LZMA compressed chunk (no</span>
<span class="cm">			 *          dictionary reset)</span>
<span class="cm">			 *   0x80   LZMA chunk (no dictionary or state reset)</span>
<span class="cm">			 *</span>
<span class="cm">			 * For LZMA compressed chunks, the lowest five bits</span>
<span class="cm">			 * (s-&gt;control &amp; 1F) are the highest bits of the</span>
<span class="cm">			 * uncompressed size (bits 16-20).</span>
<span class="cm">			 *</span>
<span class="cm">			 * A new LZMA2 stream must begin with a dictionary</span>
<span class="cm">			 * reset. The first LZMA chunk must set new</span>
<span class="cm">			 * properties and reset the LZMA state.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Values that don&#39;t match anything described above</span>
<span class="cm">			 * are invalid and we return XZ_DATA_ERROR.</span>
<span class="cm">			 */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XZ_STREAM_END</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="mh">0xE0</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">need_props</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">need_dict_reset</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">dict_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">need_dict_reset</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_UNCOMPRESSED_1</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * When there are new properties,</span>
<span class="cm">					 * state reset is done at</span>
<span class="cm">					 * SEQ_PROPERTIES.</span>
<span class="cm">					 */</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">need_props</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">next_sequence</span>
							<span class="o">=</span> <span class="n">SEQ_PROPERTIES</span><span class="p">;</span>

				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">need_props</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">next_sequence</span>
							<span class="o">=</span> <span class="n">SEQ_LZMA_PREPARE</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="mh">0xA0</span><span class="p">)</span>
						<span class="n">lzma_reset</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="mh">0x02</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_COMPRESSED_0</span><span class="p">;</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">next_sequence</span> <span class="o">=</span> <span class="n">SEQ_COPY</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_UNCOMPRESSED_1</span>:
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">uncompressed</span>
					<span class="o">+=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_UNCOMPRESSED_2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_UNCOMPRESSED_2</span>:
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">uncompressed</span>
					<span class="o">+=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_COMPRESSED_0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_COMPRESSED_0</span>:
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span>
					<span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_COMPRESSED_1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_COMPRESSED_1</span>:
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span>
					<span class="o">+=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">next_sequence</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_PROPERTIES</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lzma_props</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">]))</span>
				<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_LZMA_PREPARE</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_LZMA_PREPARE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">&lt;</span> <span class="n">RC_INIT_BYTES</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc_read_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">-=</span> <span class="n">RC_INIT_BYTES</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_LZMA_RUN</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_LZMA_RUN</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Set dictionary limit to indicate how much we want</span>
<span class="cm">			 * to be encoded at maximum. Decode new data into the</span>
<span class="cm">			 * dictionary. Flush the new data from dictionary to</span>
<span class="cm">			 * b-&gt;out. Check if we finished decoding this chunk.</span>
<span class="cm">			 * In case the dictionary got full but we didn&#39;t fill</span>
<span class="cm">			 * the output buffer yet, we may run this loop</span>
<span class="cm">			 * multiple times without changing s-&gt;lzma2.sequence.</span>
<span class="cm">			 */</span>
			<span class="n">dict_limit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span>
					<span class="n">b</span><span class="o">-&gt;</span><span class="n">out_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">,</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">uncompressed</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lzma2_lzma</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">-=</span> <span class="n">dict_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span>
						<span class="o">||</span> <span class="o">!</span><span class="n">rc_is_finished</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

				<span class="n">rc_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">rc</span><span class="p">);</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_CONTROL</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_size</span>
					<span class="o">||</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span>
						<span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span>
						<span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_COPY</span>:
			<span class="n">dict_uncompressed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">compressed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_CONTROL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">XZ_EXTERN</span> <span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="nf">xz_dec_lzma2_create</span><span class="p">(</span><span class="k">enum</span> <span class="n">xz_mode</span> <span class="n">mode</span><span class="p">,</span>
						   <span class="kt">uint32_t</span> <span class="n">dict_max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">size_max</span> <span class="o">=</span> <span class="n">dict_max</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_PREALLOC</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">dict_max</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_DYNALLOC</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">XZ_EXTERN</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">xz_dec_lzma2_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">props</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This limits dictionary size to 3 GiB to keep parsing simpler. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">props</span> <span class="o">&gt;</span> <span class="mi">39</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">props</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">props</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">11</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_MULTI</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">size_max</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_MEMLIMIT_ERROR</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_DYNALLOC</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">allocated</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">XZ_MEM_ERROR</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_CONTROL</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">.</span><span class="n">need_dict_reset</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">XZ_EXTERN</span> <span class="kt">void</span> <span class="nf">xz_dec_lzma2_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_MULTI</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
