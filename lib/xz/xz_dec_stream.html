<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › xz › xz_dec_stream.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xz_dec_stream.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * .xz Stream decoder</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Lasse Collin &lt;lasse.collin@tukaani.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file has been put into the public domain.</span>
<span class="cm"> * You can do whatever you want with this file.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;xz_private.h&quot;</span>
<span class="cp">#include &quot;xz_stream.h&quot;</span>

<span class="cm">/* Hash used to validate the Index field */</span>
<span class="k">struct</span> <span class="n">xz_dec_hash</span> <span class="p">{</span>
	<span class="n">vli_type</span> <span class="n">unpadded</span><span class="p">;</span>
	<span class="n">vli_type</span> <span class="n">uncompressed</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc32</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xz_dec</span> <span class="p">{</span>
	<span class="cm">/* Position in dec_main() */</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">SEQ_STREAM_HEADER</span><span class="p">,</span>
		<span class="n">SEQ_BLOCK_START</span><span class="p">,</span>
		<span class="n">SEQ_BLOCK_HEADER</span><span class="p">,</span>
		<span class="n">SEQ_BLOCK_UNCOMPRESS</span><span class="p">,</span>
		<span class="n">SEQ_BLOCK_PADDING</span><span class="p">,</span>
		<span class="n">SEQ_BLOCK_CHECK</span><span class="p">,</span>
		<span class="n">SEQ_INDEX</span><span class="p">,</span>
		<span class="n">SEQ_INDEX_PADDING</span><span class="p">,</span>
		<span class="n">SEQ_INDEX_CRC32</span><span class="p">,</span>
		<span class="n">SEQ_STREAM_FOOTER</span>
	<span class="p">}</span> <span class="n">sequence</span><span class="p">;</span>

	<span class="cm">/* Position in variable-length integers and Check fields */</span>
	<span class="kt">uint32_t</span> <span class="n">pos</span><span class="p">;</span>

	<span class="cm">/* Variable-length integer decoded by dec_vli() */</span>
	<span class="n">vli_type</span> <span class="n">vli</span><span class="p">;</span>

	<span class="cm">/* Saved in_pos and out_pos */</span>
	<span class="kt">size_t</span> <span class="n">in_start</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">out_start</span><span class="p">;</span>

	<span class="cm">/* CRC32 value in Block or Index */</span>
	<span class="kt">uint32_t</span> <span class="n">crc32</span><span class="p">;</span>

	<span class="cm">/* Type of the integrity check calculated from uncompressed data */</span>
	<span class="k">enum</span> <span class="n">xz_check</span> <span class="n">check_type</span><span class="p">;</span>

	<span class="cm">/* Operation mode */</span>
	<span class="k">enum</span> <span class="n">xz_mode</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * True if the next call to xz_dec_run() is allowed to return</span>
<span class="cm">	 * XZ_BUF_ERROR.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">allow_buf_error</span><span class="p">;</span>

	<span class="cm">/* Information stored in Block Header */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Value stored in the Compressed Size field, or</span>
<span class="cm">		 * VLI_UNKNOWN if Compressed Size is not present.</span>
<span class="cm">		 */</span>
		<span class="n">vli_type</span> <span class="n">compressed</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Value stored in the Uncompressed Size field, or</span>
<span class="cm">		 * VLI_UNKNOWN if Uncompressed Size is not present.</span>
<span class="cm">		 */</span>
		<span class="n">vli_type</span> <span class="n">uncompressed</span><span class="p">;</span>

		<span class="cm">/* Size of the Block Header field */</span>
		<span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">block_header</span><span class="p">;</span>

	<span class="cm">/* Information collected when decoding Blocks */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Observed compressed size of the current Block */</span>
		<span class="n">vli_type</span> <span class="n">compressed</span><span class="p">;</span>

		<span class="cm">/* Observed uncompressed size of the current Block */</span>
		<span class="n">vli_type</span> <span class="n">uncompressed</span><span class="p">;</span>

		<span class="cm">/* Number of Blocks decoded so far */</span>
		<span class="n">vli_type</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Hash calculated from the Block sizes. This is used to</span>
<span class="cm">		 * validate the Index field.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">xz_dec_hash</span> <span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">block</span><span class="p">;</span>

	<span class="cm">/* Variables needed when verifying the Index field */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* Position in dec_index() */</span>
		<span class="k">enum</span> <span class="p">{</span>
			<span class="n">SEQ_INDEX_COUNT</span><span class="p">,</span>
			<span class="n">SEQ_INDEX_UNPADDED</span><span class="p">,</span>
			<span class="n">SEQ_INDEX_UNCOMPRESSED</span>
		<span class="p">}</span> <span class="n">sequence</span><span class="p">;</span>

		<span class="cm">/* Size of the Index in bytes */</span>
		<span class="n">vli_type</span> <span class="n">size</span><span class="p">;</span>

		<span class="cm">/* Number of Records (matches block.count in valid files) */</span>
		<span class="n">vli_type</span> <span class="n">count</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Hash calculated from the Records (matches block.hash in</span>
<span class="cm">		 * valid files).</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">xz_dec_hash</span> <span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Temporary buffer needed to hold Stream Header, Block Header,</span>
<span class="cm">	 * and Stream Footer. The Block Header is the biggest (1 KiB)</span>
<span class="cm">	 * so we reserve space according to that. buf[] has to be aligned</span>
<span class="cm">	 * to a multiple of four bytes; the size_t variables before it</span>
<span class="cm">	 * should guarantee this.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">pos</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">temp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xz_dec_lzma2</span> <span class="o">*</span><span class="n">lzma2</span><span class="p">;</span>

<span class="cp">#ifdef XZ_DEC_BCJ</span>
	<span class="k">struct</span> <span class="n">xz_dec_bcj</span> <span class="o">*</span><span class="n">bcj</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bcj_active</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#ifdef XZ_DEC_ANY_CHECK</span>
<span class="cm">/* Sizes of the Check field with different Check IDs */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">check_sizes</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
	<span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
	<span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>
	<span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span>
	<span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Fill s-&gt;temp by copying data starting from b-&gt;in[b-&gt;in_pos]. Caller</span>
<span class="cm"> * must have set s-&gt;temp.pos to indicate how much data we are supposed</span>
<span class="cm"> * to copy into s-&gt;temp.buf. Return true once s-&gt;temp.pos has reached</span>
<span class="cm"> * s-&gt;temp.size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">fill_temp</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">copy_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">+=</span> <span class="n">copy_size</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">copy_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">==</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decode a variable-length integer (little-endian base-128 encoding) */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">dec_vli</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="o">*</span><span class="n">in_pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">in_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">vli</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">in_pos</span> <span class="o">&lt;</span> <span class="n">in_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="o">*</span><span class="n">in_pos</span><span class="p">];</span>
		<span class="o">++*</span><span class="n">in_pos</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">vli</span> <span class="o">|=</span> <span class="p">(</span><span class="n">vli_type</span><span class="p">)(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t allow non-minimal encodings. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">byte</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">XZ_STREAM_END</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">VLI_BYTES_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decode the Compressed Data field from a Block. Update and validate</span>
<span class="cm"> * the observed compressed and uncompressed sizes of the Block so that</span>
<span class="cm"> * they don&#39;t exceed the values possibly stored in the Block Header</span>
<span class="cm"> * (validation assumes that no integer overflow occurs, since vli_type</span>
<span class="cm"> * is normally uint64_t). Update the CRC32 if presence of the CRC32</span>
<span class="cm"> * field was indicated in Stream Header.</span>
<span class="cm"> *</span>
<span class="cm"> * Once the decoding is finished, validate that the observed sizes match</span>
<span class="cm"> * the sizes possibly stored in the Block Header. Update the hash and</span>
<span class="cm"> * Block count, which are later used to validate the Index field.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">dec_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">xz_ret</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">in_start</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">out_start</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">;</span>

<span class="cp">#ifdef XZ_DEC_BCJ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj_active</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xz_dec_bcj_run</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">xz_dec_lzma2_run</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">compressed</span> <span class="o">+=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">in_start</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">+=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">out_start</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no need to separately check for VLI_UNKNOWN, since</span>
<span class="cm">	 * the observed sizes are always smaller than VLI_UNKNOWN.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">compressed</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">compressed</span>
			<span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">uncompressed</span>
				<span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">uncompressed</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span> <span class="o">==</span> <span class="n">XZ_CHECK_CRC32</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">xz_crc32</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">out</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">out_start</span><span class="p">,</span>
				<span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">out_start</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">crc32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">compressed</span> <span class="o">!=</span> <span class="n">VLI_UNKNOWN</span>
				<span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">compressed</span>
					<span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">compressed</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">!=</span> <span class="n">VLI_UNKNOWN</span>
				<span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">uncompressed</span>
					<span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">uncompressed</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">unpadded</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">size</span>
				<span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">compressed</span><span class="p">;</span>

<span class="cp">#ifdef XZ_DEC_ANY_CHECK</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">unpadded</span> <span class="o">+=</span> <span class="n">check_sizes</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span><span class="p">];</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span> <span class="o">==</span> <span class="n">XZ_CHECK_CRC32</span><span class="p">)</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">unpadded</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">uncompressed</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">xz_crc32</span><span class="p">(</span>
				<span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">crc32</span><span class="p">);</span>

		<span class="o">++</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update the Index size and the CRC32 value. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">index_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">in_used</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">in_start</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">in_used</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">xz_crc32</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">in_start</span><span class="p">,</span> <span class="n">in_used</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">crc32</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decode the Number of Records, Unpadded Size, and Uncompressed Size</span>
<span class="cm"> * fields from the Index field. That is, Index Padding and CRC32 are not</span>
<span class="cm"> * decoded by this function.</span>
<span class="cm"> *</span>
<span class="cm"> * This can return XZ_OK (more input needed), XZ_STREAM_END (everything</span>
<span class="cm"> * successfully decoded), or XZ_DATA_ERROR (input is corrupt).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">dec_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">xz_ret</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dec_vli</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">index_update</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SEQ_INDEX_COUNT</span>:
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">vli</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Validate that the Number of Records field</span>
<span class="cm">			 * indicates the same number of Records as</span>
<span class="cm">			 * there were Blocks in the Stream.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">count</span> <span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_INDEX_UNPADDED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_INDEX_UNPADDED</span>:
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">unpadded</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">vli</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_INDEX_UNCOMPRESSED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_INDEX_UNCOMPRESSED</span>:
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">vli</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">crc32</span> <span class="o">=</span> <span class="n">xz_crc32</span><span class="p">(</span>
					<span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">hash</span><span class="p">),</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">hash</span><span class="p">.</span><span class="n">crc32</span><span class="p">);</span>
			<span class="o">--</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_INDEX_UNPADDED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">XZ_STREAM_END</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Validate that the next four input bytes match the value of s-&gt;crc32.</span>
<span class="cm"> * s-&gt;pos must be zero when starting to validate the first byte.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">crc32_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">crc32</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">crc32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">XZ_STREAM_END</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef XZ_DEC_ANY_CHECK</span>
<span class="cm">/*</span>
<span class="cm"> * Skip over the Check field when the Check ID is not supported.</span>
<span class="cm"> * Returns true once the whole Check field has been skipped over.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">check_skip</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">check_sizes</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="o">++</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>
		<span class="o">++</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Decode the Stream Header field (the first 12 bytes of the .xz Stream). */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">dec_stream_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memeq</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">HEADER_MAGIC</span><span class="p">,</span> <span class="n">HEADER_MAGIC_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XZ_FORMAT_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xz_crc32</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">HEADER_MAGIC_SIZE</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">!=</span> <span class="n">get_le32</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">HEADER_MAGIC_SIZE</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">HEADER_MAGIC_SIZE</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Of integrity checks, we support only none (Check ID = 0) and</span>
<span class="cm">	 * CRC32 (Check ID = 1). However, if XZ_DEC_ANY_CHECK is defined,</span>
<span class="cm">	 * we will accept other check types too, but then the check won&#39;t</span>
<span class="cm">	 * be verified and a warning (XZ_UNSUPPORTED_CHECK) will be given.</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">HEADER_MAGIC_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="cp">#ifdef XZ_DEC_ANY_CHECK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span> <span class="o">&gt;</span> <span class="n">XZ_CHECK_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span> <span class="o">&gt;</span> <span class="n">XZ_CHECK_CRC32</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_UNSUPPORTED_CHECK</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span> <span class="o">&gt;</span> <span class="n">XZ_CHECK_CRC32</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decode the Stream Footer field (the last 12 bytes of the .xz Stream) */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">dec_stream_footer</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memeq</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">FOOTER_MAGIC</span><span class="p">,</span> <span class="n">FOOTER_MAGIC_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xz_crc32</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">get_le32</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate Backward Size. Note that we never added the size of the</span>
<span class="cm">	 * Index CRC32 field to s-&gt;index.size, thus we use s-&gt;index.size / 4</span>
<span class="cm">	 * instead of s-&gt;index.size / 4 - 1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">get_le32</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use XZ_STREAM_END instead of XZ_OK to be more convenient</span>
<span class="cm">	 * for the caller.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">XZ_STREAM_END</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decode the Block Header and initialize the filter chain. */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">dec_block_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">xz_ret</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Validate the CRC32. We know that the temp buffer is at least</span>
<span class="cm">	 * eight bytes so this is safe.</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xz_crc32</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">!=</span> <span class="n">get_le32</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Catch unsupported Block Flags. We support only one or two filters</span>
<span class="cm">	 * in the chain, so we catch that with the same test.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef XZ_DEC_BCJ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3E</span><span class="p">)</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">)</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>

	<span class="cm">/* Compressed Size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dec_vli</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
					<span class="o">!=</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">compressed</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">vli</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">compressed</span> <span class="o">=</span> <span class="n">VLI_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Uncompressed Size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dec_vli</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
				<span class="o">!=</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">vli</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">=</span> <span class="n">VLI_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef XZ_DEC_BCJ</span>
	<span class="cm">/* If there are two filters, the first one must be a BCJ filter. */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj_active</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">xz_dec_bcj_reset</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="o">++</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_OK</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t support custom start offset,</span>
<span class="cm">		 * so Size of Properties must be zero.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x00</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Valid Filter Flags always take at least two bytes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="cm">/* Filter ID = LZMA2 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x21</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>

	<span class="cm">/* Size of Properties = 1-byte Filter Properties */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x01</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>

	<span class="cm">/* Filter Properties contains LZMA2 dictionary size. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">xz_dec_lzma2_reset</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* The rest must be Header Padding. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x00</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">XZ_OPTIONS_ERROR</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">compressed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">uncompressed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">dec_main</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">xz_ret</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store the start position for the case when we are in the middle</span>
<span class="cm">	 * of the Index field.</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">in_start</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SEQ_STREAM_HEADER</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Stream Header is copied to s-&gt;temp, and then</span>
<span class="cm">			 * decoded from there. This way if the caller</span>
<span class="cm">			 * gives us only little input at a time, we can</span>
<span class="cm">			 * still keep the Stream Header decoding code</span>
<span class="cm">			 * simple. Similar approach is used in many places</span>
<span class="cm">			 * in this file.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fill_temp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If dec_stream_header() returns</span>
<span class="cm">			 * XZ_UNSUPPORTED_CHECK, it is still possible</span>
<span class="cm">			 * to continue decoding if working in multi-call</span>
<span class="cm">			 * mode. Thus, update s-&gt;sequence before calling</span>
<span class="cm">			 * dec_stream_header().</span>
<span class="cm">			 */</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_BLOCK_START</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">dec_stream_header</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_OK</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_BLOCK_START</span>:
			<span class="cm">/* We need one byte of input to continue. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>

			<span class="cm">/* See if this is the beginning of the Index field. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">in_start</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">;</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_INDEX</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Calculate the size of the Block Header and</span>
<span class="cm">			 * prepare to decode it.</span>
<span class="cm">			 */</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">size</span>
				<span class="o">=</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">block_header</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_BLOCK_HEADER</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_BLOCK_HEADER</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fill_temp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">dec_block_header</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_OK</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_BLOCK_UNCOMPRESS</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_BLOCK_UNCOMPRESS</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dec_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_BLOCK_PADDING</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_BLOCK_PADDING</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Size of Compressed Data + Block Padding</span>
<span class="cm">			 * must be a multiple of four. We don&#39;t need</span>
<span class="cm">			 * s-&gt;block.compressed for anything else</span>
<span class="cm">			 * anymore, so we use it here to test the size</span>
<span class="cm">			 * of the Block Padding field.</span>
<span class="cm">			 */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">compressed</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

				<span class="o">++</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">compressed</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_BLOCK_CHECK</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_BLOCK_CHECK</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">check_type</span> <span class="o">==</span> <span class="n">XZ_CHECK_CRC32</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">crc32_validate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#ifdef XZ_DEC_ANY_CHECK</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_skip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_BLOCK_START</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_INDEX</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dec_index</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_INDEX_PADDING</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_INDEX_PADDING</span>:
			<span class="k">while</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">in_start</span><span class="p">))</span>
					<span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">index_update</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="o">++</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Finish the CRC32 value and Index size. */</span>
			<span class="n">index_update</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

			<span class="cm">/* Compare the hashes to validate the Index field. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memeq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">.</span><span class="n">hash</span><span class="p">)))</span>
				<span class="k">return</span> <span class="n">XZ_DATA_ERROR</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_INDEX_CRC32</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_INDEX_CRC32</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">crc32_validate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">STREAM_HEADER_SIZE</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_STREAM_FOOTER</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SEQ_STREAM_FOOTER</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fill_temp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">XZ_OK</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">dec_stream_footer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Never reached */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * xz_dec_run() is a wrapper for dec_main() to handle some special cases in</span>
<span class="cm"> * multi-call and single-call decoding.</span>
<span class="cm"> *</span>
<span class="cm"> * In multi-call mode, we must return XZ_BUF_ERROR when it seems clear that we</span>
<span class="cm"> * are not going to make any progress anymore. This is to prevent the caller</span>
<span class="cm"> * from calling us infinitely when the input file is truncated or otherwise</span>
<span class="cm"> * corrupt. Since zlib-style API allows that the caller fills the input buffer</span>
<span class="cm"> * only when the decoder doesn&#39;t produce any new output, we have to be careful</span>
<span class="cm"> * to avoid returning XZ_BUF_ERROR too easily: XZ_BUF_ERROR is returned only</span>
<span class="cm"> * after the second consecutive call to xz_dec_run() that makes no progress.</span>
<span class="cm"> *</span>
<span class="cm"> * In single-call mode, if we couldn&#39;t decode everything and no error</span>
<span class="cm"> * occurred, either the input is truncated or the output buffer is too small.</span>
<span class="cm"> * Since we know that the last input byte never produces any output, we know</span>
<span class="cm"> * that if all the input was consumed and decoding wasn&#39;t finished, the file</span>
<span class="cm"> * must be corrupt. Otherwise the output buffer has to be too small or the</span>
<span class="cm"> * file is corrupt in a way that decoding it produces too big output.</span>
<span class="cm"> *</span>
<span class="cm"> * If single-call decoding fails, we reset b-&gt;in_pos and b-&gt;out_pos back to</span>
<span class="cm"> * their original values. This is because with some filter chains there won&#39;t</span>
<span class="cm"> * be any valid uncompressed data in the output buffer unless the decoding</span>
<span class="cm"> * actually succeeds (that&#39;s the price to pay of using the output buffer as</span>
<span class="cm"> * the workspace).</span>
<span class="cm"> */</span>
<span class="n">XZ_EXTERN</span> <span class="k">enum</span> <span class="n">xz_ret</span> <span class="nf">xz_dec_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xz_buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">in_start</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">out_start</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">xz_ret</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_SINGLE</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">xz_dec_reset</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">in_start</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span><span class="p">;</span>
	<span class="n">out_start</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dec_main</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEC_IS_SINGLE</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">XZ_OK</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_size</span>
					<span class="o">?</span> <span class="n">XZ_DATA_ERROR</span> <span class="o">:</span> <span class="n">XZ_BUF_ERROR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">XZ_STREAM_END</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span> <span class="o">=</span> <span class="n">in_start</span><span class="p">;</span>
			<span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span> <span class="o">=</span> <span class="n">out_start</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">XZ_OK</span> <span class="o">&amp;&amp;</span> <span class="n">in_start</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">in_pos</span>
			<span class="o">&amp;&amp;</span> <span class="n">out_start</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">out_pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">allow_buf_error</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">XZ_BUF_ERROR</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">allow_buf_error</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">allow_buf_error</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">XZ_EXTERN</span> <span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="nf">xz_dec_init</span><span class="p">(</span><span class="k">enum</span> <span class="n">xz_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">dict_max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>

<span class="cp">#ifdef XZ_DEC_BCJ</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj</span> <span class="o">=</span> <span class="n">xz_dec_bcj_create</span><span class="p">(</span><span class="n">DEC_IS_SINGLE</span><span class="p">(</span><span class="n">mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_bcj</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span> <span class="o">=</span> <span class="n">xz_dec_lzma2_create</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">dict_max</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_lzma2</span><span class="p">;</span>

	<span class="n">xz_dec_reset</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>

<span class="nl">error_lzma2:</span>
<span class="cp">#ifdef XZ_DEC_BCJ</span>
	<span class="n">xz_dec_bcj_end</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj</span><span class="p">);</span>
<span class="nl">error_bcj:</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">XZ_EXTERN</span> <span class="kt">void</span> <span class="nf">xz_dec_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">SEQ_STREAM_HEADER</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">allow_buf_error</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">crc32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">));</span>
	<span class="n">memzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">temp</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">STREAM_HEADER_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">XZ_EXTERN</span> <span class="kt">void</span> <span class="nf">xz_dec_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">xz_dec</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xz_dec_lzma2_end</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lzma2</span><span class="p">);</span>
<span class="cp">#ifdef XZ_DEC_BCJ</span>
		<span class="n">xz_dec_bcj_end</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bcj</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
