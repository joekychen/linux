<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › xz › xz_lzma2.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>xz_lzma2.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * LZMA2 definitions</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Lasse Collin &lt;lasse.collin@tukaani.org&gt;</span>
<span class="cm"> *          Igor Pavlov &lt;http://7-zip.org/&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file has been put into the public domain.</span>
<span class="cm"> * You can do whatever you want with this file.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef XZ_LZMA2_H</span>
<span class="cp">#define XZ_LZMA2_H</span>

<span class="cm">/* Range coder constants */</span>
<span class="cp">#define RC_SHIFT_BITS 8</span>
<span class="cp">#define RC_TOP_BITS 24</span>
<span class="cp">#define RC_TOP_VALUE (1 &lt;&lt; RC_TOP_BITS)</span>
<span class="cp">#define RC_BIT_MODEL_TOTAL_BITS 11</span>
<span class="cp">#define RC_BIT_MODEL_TOTAL (1 &lt;&lt; RC_BIT_MODEL_TOTAL_BITS)</span>
<span class="cp">#define RC_MOVE_BITS 5</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of position states. A position state is the lowest pb</span>
<span class="cm"> * number of bits of the current uncompressed offset. In some places there</span>
<span class="cm"> * are different sets of probabilities for different position states.</span>
<span class="cm"> */</span>
<span class="cp">#define POS_STATES_MAX (1 &lt;&lt; 4)</span>

<span class="cm">/*</span>
<span class="cm"> * This enum is used to track which LZMA symbols have occurred most recently</span>
<span class="cm"> * and in which order. This information is used to predict the next symbol.</span>
<span class="cm"> *</span>
<span class="cm"> * Symbols:</span>
<span class="cm"> *  - Literal: One 8-bit byte</span>
<span class="cm"> *  - Match: Repeat a chunk of data at some distance</span>
<span class="cm"> *  - Long repeat: Multi-byte match at a recently seen distance</span>
<span class="cm"> *  - Short repeat: One-byte repeat at a recently seen distance</span>
<span class="cm"> *</span>
<span class="cm"> * The symbol names are in from STATE_oldest_older_previous. REP means</span>
<span class="cm"> * either short or long repeated match, and NONLIT means any non-literal.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">lzma_state</span> <span class="p">{</span>
	<span class="n">STATE_LIT_LIT</span><span class="p">,</span>
	<span class="n">STATE_MATCH_LIT_LIT</span><span class="p">,</span>
	<span class="n">STATE_REP_LIT_LIT</span><span class="p">,</span>
	<span class="n">STATE_SHORTREP_LIT_LIT</span><span class="p">,</span>
	<span class="n">STATE_MATCH_LIT</span><span class="p">,</span>
	<span class="n">STATE_REP_LIT</span><span class="p">,</span>
	<span class="n">STATE_SHORTREP_LIT</span><span class="p">,</span>
	<span class="n">STATE_LIT_MATCH</span><span class="p">,</span>
	<span class="n">STATE_LIT_LONGREP</span><span class="p">,</span>
	<span class="n">STATE_LIT_SHORTREP</span><span class="p">,</span>
	<span class="n">STATE_NONLIT_MATCH</span><span class="p">,</span>
	<span class="n">STATE_NONLIT_REP</span>
<span class="p">};</span>

<span class="cm">/* Total number of states */</span>
<span class="cp">#define STATES 12</span>

<span class="cm">/* The lowest 7 states indicate that the previous state was a literal. */</span>
<span class="cp">#define LIT_STATES 7</span>

<span class="cm">/* Indicate that the latest symbol was a literal. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lzma_state_literal</span><span class="p">(</span><span class="k">enum</span> <span class="n">lzma_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">STATE_SHORTREP_LIT_LIT</span><span class="p">)</span>
		<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_LIT_LIT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">state</span> <span class="o">&lt;=</span> <span class="n">STATE_LIT_SHORTREP</span><span class="p">)</span>
		<span class="o">*</span><span class="n">state</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">state</span> <span class="o">-=</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Indicate that the latest symbol was a match. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lzma_state_match</span><span class="p">(</span><span class="k">enum</span> <span class="n">lzma_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="o">*</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">LIT_STATES</span> <span class="o">?</span> <span class="n">STATE_LIT_MATCH</span> <span class="o">:</span> <span class="n">STATE_NONLIT_MATCH</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Indicate that the latest state was a long repeated match. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lzma_state_long_rep</span><span class="p">(</span><span class="k">enum</span> <span class="n">lzma_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="o">*</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">LIT_STATES</span> <span class="o">?</span> <span class="n">STATE_LIT_LONGREP</span> <span class="o">:</span> <span class="n">STATE_NONLIT_REP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Indicate that the latest symbol was a short match. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lzma_state_short_rep</span><span class="p">(</span><span class="k">enum</span> <span class="n">lzma_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="o">*</span><span class="n">state</span> <span class="o">&lt;</span> <span class="n">LIT_STATES</span> <span class="o">?</span> <span class="n">STATE_LIT_SHORTREP</span> <span class="o">:</span> <span class="n">STATE_NONLIT_REP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Test if the previous symbol was a literal. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">lzma_state_is_literal</span><span class="p">(</span><span class="k">enum</span> <span class="n">lzma_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">state</span> <span class="o">&lt;</span> <span class="n">LIT_STATES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Each literal coder is divided in three sections:</span>
<span class="cm"> *   - 0x001-0x0FF: Without match byte</span>
<span class="cm"> *   - 0x101-0x1FF: With match byte; match bit is 0</span>
<span class="cm"> *   - 0x201-0x2FF: With match byte; match bit is 1</span>
<span class="cm"> *</span>
<span class="cm"> * Match byte is used when the previous LZMA symbol was something else than</span>
<span class="cm"> * a literal (that is, it was some kind of match).</span>
<span class="cm"> */</span>
<span class="cp">#define LITERAL_CODER_SIZE 0x300</span>

<span class="cm">/* Maximum number of literal coders */</span>
<span class="cp">#define LITERAL_CODERS_MAX (1 &lt;&lt; 4)</span>

<span class="cm">/* Minimum length of a match is two bytes. */</span>
<span class="cp">#define MATCH_LEN_MIN 2</span>

<span class="cm">/* Match length is encoded with 4, 5, or 10 bits.</span>
<span class="cm"> *</span>
<span class="cm"> * Length   Bits</span>
<span class="cm"> *  2-9      4 = Choice=0 + 3 bits</span>
<span class="cm"> * 10-17     5 = Choice=1 + Choice2=0 + 3 bits</span>
<span class="cm"> * 18-273   10 = Choice=1 + Choice2=1 + 8 bits</span>
<span class="cm"> */</span>
<span class="cp">#define LEN_LOW_BITS 3</span>
<span class="cp">#define LEN_LOW_SYMBOLS (1 &lt;&lt; LEN_LOW_BITS)</span>
<span class="cp">#define LEN_MID_BITS 3</span>
<span class="cp">#define LEN_MID_SYMBOLS (1 &lt;&lt; LEN_MID_BITS)</span>
<span class="cp">#define LEN_HIGH_BITS 8</span>
<span class="cp">#define LEN_HIGH_SYMBOLS (1 &lt;&lt; LEN_HIGH_BITS)</span>
<span class="cp">#define LEN_SYMBOLS (LEN_LOW_SYMBOLS + LEN_MID_SYMBOLS + LEN_HIGH_SYMBOLS)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum length of a match is 273 which is a result of the encoding</span>
<span class="cm"> * described above.</span>
<span class="cm"> */</span>
<span class="cp">#define MATCH_LEN_MAX (MATCH_LEN_MIN + LEN_SYMBOLS - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Different sets of probabilities are used for match distances that have</span>
<span class="cm"> * very short match length: Lengths of 2, 3, and 4 bytes have a separate</span>
<span class="cm"> * set of probabilities for each length. The matches with longer length</span>
<span class="cm"> * use a shared set of probabilities.</span>
<span class="cm"> */</span>
<span class="cp">#define DIST_STATES 4</span>

<span class="cm">/*</span>
<span class="cm"> * Get the index of the appropriate probability array for decoding</span>
<span class="cm"> * the distance slot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">lzma_get_dist_state</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">DIST_STATES</span> <span class="o">+</span> <span class="n">MATCH_LEN_MIN</span>
			<span class="o">?</span> <span class="n">len</span> <span class="o">-</span> <span class="n">MATCH_LEN_MIN</span> <span class="o">:</span> <span class="n">DIST_STATES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The highest two bits of a 32-bit match distance are encoded using six bits.</span>
<span class="cm"> * This six-bit value is called a distance slot. This way encoding a 32-bit</span>
<span class="cm"> * value takes 6-36 bits, larger values taking more bits.</span>
<span class="cm"> */</span>
<span class="cp">#define DIST_SLOT_BITS 6</span>
<span class="cp">#define DIST_SLOTS (1 &lt;&lt; DIST_SLOT_BITS)</span>

<span class="cm">/* Match distances up to 127 are fully encoded using probabilities. Since</span>
<span class="cm"> * the highest two bits (distance slot) are always encoded using six bits,</span>
<span class="cm"> * the distances 0-3 don&#39;t need any additional bits to encode, since the</span>
<span class="cm"> * distance slot itself is the same as the actual distance. DIST_MODEL_START</span>
<span class="cm"> * indicates the first distance slot where at least one additional bit is</span>
<span class="cm"> * needed.</span>
<span class="cm"> */</span>
<span class="cp">#define DIST_MODEL_START 4</span>

<span class="cm">/*</span>
<span class="cm"> * Match distances greater than 127 are encoded in three pieces:</span>
<span class="cm"> *   - distance slot: the highest two bits</span>
<span class="cm"> *   - direct bits: 2-26 bits below the highest two bits</span>
<span class="cm"> *   - alignment bits: four lowest bits</span>
<span class="cm"> *</span>
<span class="cm"> * Direct bits don&#39;t use any probabilities.</span>
<span class="cm"> *</span>
<span class="cm"> * The distance slot value of 14 is for distances 128-191.</span>
<span class="cm"> */</span>
<span class="cp">#define DIST_MODEL_END 14</span>

<span class="cm">/* Distance slots that indicate a distance &lt;= 127. */</span>
<span class="cp">#define FULL_DISTANCES_BITS (DIST_MODEL_END / 2)</span>
<span class="cp">#define FULL_DISTANCES (1 &lt;&lt; FULL_DISTANCES_BITS)</span>

<span class="cm">/*</span>
<span class="cm"> * For match distances greater than 127, only the highest two bits and the</span>
<span class="cm"> * lowest four bits (alignment) is encoded using probabilities.</span>
<span class="cm"> */</span>
<span class="cp">#define ALIGN_BITS 4</span>
<span class="cp">#define ALIGN_SIZE (1 &lt;&lt; ALIGN_BITS)</span>
<span class="cp">#define ALIGN_MASK (ALIGN_SIZE - 1)</span>

<span class="cm">/* Total number of all probability variables */</span>
<span class="cp">#define PROBS_TOTAL (1846 + LITERAL_CODERS_MAX * LITERAL_CODER_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * LZMA remembers the four most recent match distances. Reusing these</span>
<span class="cm"> * distances tends to take less space than re-encoding the actual</span>
<span class="cm"> * distance value.</span>
<span class="cm"> */</span>
<span class="cp">#define REPS 4</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
