<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › klist.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>klist.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * klist.c - Routines for manipulating klists.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 Patrick Mochel</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPL v2.</span>
<span class="cm"> *</span>
<span class="cm"> * This klist interface provides a couple of structures that wrap around</span>
<span class="cm"> * struct list_head to provide explicit list &quot;head&quot; (struct klist) and list</span>
<span class="cm"> * &quot;node&quot; (struct klist_node) objects. For struct klist, a spinlock is</span>
<span class="cm"> * included that protects access to the actual list itself. struct</span>
<span class="cm"> * klist_node provides a pointer to the klist that owns it and a kref</span>
<span class="cm"> * reference count that indicates the number of current users of that node</span>
<span class="cm"> * in the list.</span>
<span class="cm"> *</span>
<span class="cm"> * The entire point is to provide an interface for iterating over a list</span>
<span class="cm"> * that is safe and allows for modification of the list during the</span>
<span class="cm"> * iteration (e.g. insertion and removal), including modification of the</span>
<span class="cm"> * current node on the list.</span>
<span class="cm"> *</span>
<span class="cm"> * It works using a 3rd object type - struct klist_iter - that is declared</span>
<span class="cm"> * and initialized before an iteration. klist_next() is used to acquire the</span>
<span class="cm"> * next element in the list. It returns NULL if there are no more items.</span>
<span class="cm"> * Internally, that routine takes the klist&#39;s lock, decrements the</span>
<span class="cm"> * reference count of the previous klist_node and increments the count of</span>
<span class="cm"> * the next klist_node. It then drops the lock and returns.</span>
<span class="cm"> *</span>
<span class="cm"> * There are primitives for adding and removing nodes to/from a klist.</span>
<span class="cm"> * When deleting, klist_del() will simply decrement the reference count.</span>
<span class="cm"> * Only when the count goes to 0 is the node removed from the list.</span>
<span class="cm"> * klist_remove() will try to delete the node from the list and block until</span>
<span class="cm"> * it is actually removed. This is useful for objects (like devices) that</span>
<span class="cm"> * have been removed from the system and must be freed (but must wait until</span>
<span class="cm"> * all accessors have finished).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/klist.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Use the lowest bit of n_klist to mark deleted nodes and exclude</span>
<span class="cm"> * dead ones from iteration.</span>
<span class="cm"> */</span>
<span class="cp">#define KNODE_DEAD		1LU</span>
<span class="cp">#define KNODE_KLIST_MASK	~KNODE_DEAD</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="nf">knode_klist</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">knode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">knode</span><span class="o">-&gt;</span><span class="n">n_klist</span> <span class="o">&amp;</span> <span class="n">KNODE_KLIST_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">knode_dead</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">knode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">knode</span><span class="o">-&gt;</span><span class="n">n_klist</span> <span class="o">&amp;</span> <span class="n">KNODE_DEAD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">knode_set_klist</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">knode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">klist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">knode</span><span class="o">-&gt;</span><span class="n">n_klist</span> <span class="o">=</span> <span class="n">klist</span><span class="p">;</span>
	<span class="cm">/* no knode deserves to start its life dead */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">knode_dead</span><span class="p">(</span><span class="n">knode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">knode_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">knode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* and no knode should die twice ever either, see we&#39;re very humane */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">knode_dead</span><span class="p">(</span><span class="n">knode</span><span class="p">));</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">knode</span><span class="o">-&gt;</span><span class="n">n_klist</span> <span class="o">|=</span> <span class="n">KNODE_DEAD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * klist_init - Initialize a klist structure.</span>
<span class="cm"> * @k: The klist we&#39;re initializing.</span>
<span class="cm"> * @get: The get function for the embedding object (NULL if none)</span>
<span class="cm"> * @put: The put function for the embedding object (NULL if none)</span>
<span class="cm"> *</span>
<span class="cm"> * Initialises the klist structure.  If the klist_node structures are</span>
<span class="cm"> * going to be embedded in refcounted objects (necessary for safe</span>
<span class="cm"> * deletion) then the get/put arguments are used to initialise</span>
<span class="cm"> * functions that take and release references on the embedding</span>
<span class="cm"> * objects.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get</span><span class="p">)(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="p">),</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put</span><span class="p">)(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">get</span> <span class="o">=</span> <span class="n">get</span><span class="p">;</span>
	<span class="n">k</span><span class="o">-&gt;</span><span class="n">put</span> <span class="o">=</span> <span class="n">put</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">klist_node_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_ref</span><span class="p">);</span>
	<span class="n">knode_set_klist</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">)</span>
		<span class="n">k</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * klist_add_head - Initialize a klist_node and add it to front.</span>
<span class="cm"> * @n: node we&#39;re adding.</span>
<span class="cm"> * @k: klist it&#39;s going on.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_add_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">klist_node_init</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">add_head</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_add_head</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * klist_add_tail - Initialize a klist_node and add it to back.</span>
<span class="cm"> * @n: node we&#39;re adding.</span>
<span class="cm"> * @k: klist it&#39;s going on.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_add_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">klist_node_init</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">add_tail</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_add_tail</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * klist_add_after - Init a klist_node and add it after an existing node</span>
<span class="cm"> * @n: node we&#39;re adding.</span>
<span class="cm"> * @pos: node to put @n after</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_add_after</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="n">knode_klist</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>

	<span class="n">klist_node_init</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_add_after</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * klist_add_before - Init a klist_node and add it before an existing node</span>
<span class="cm"> * @n: node we&#39;re adding.</span>
<span class="cm"> * @pos: node to put @n after</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_add_before</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="n">knode_klist</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>

	<span class="n">klist_node_init</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_add_before</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">klist_waiter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">process</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">woken</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">klist_remove_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">klist_remove_waiters</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">klist_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_waiter</span> <span class="o">*</span><span class="n">waiter</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span><span class="p">,</span> <span class="n">n_ref</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">knode_dead</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist_remove_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">waiter</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">klist_remove_waiters</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">woken</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mb</span><span class="p">();</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist_remove_lock</span><span class="p">);</span>
	<span class="n">knode_set_klist</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">klist_dec_and_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_ref</span><span class="p">,</span> <span class="n">klist_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">klist_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">bool</span> <span class="n">kill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="n">knode_klist</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put</span><span class="p">)(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kill</span><span class="p">)</span>
		<span class="n">knode_kill</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">klist_dec_and_del</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
		<span class="n">put</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put</span><span class="p">)</span>
		<span class="n">put</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * klist_del - Decrement the reference count of node and try to remove.</span>
<span class="cm"> * @n: node we&#39;re deleting.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">klist_put</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_del</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * klist_remove - Decrement the refcount of node and wait for it to go away.</span>
<span class="cm"> * @n: node we&#39;re removing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_waiter</span> <span class="n">waiter</span><span class="p">;</span>

	<span class="n">waiter</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">waiter</span><span class="p">.</span><span class="n">process</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">waiter</span><span class="p">.</span><span class="n">woken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist_remove_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">klist_remove_waiters</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">klist_remove_lock</span><span class="p">);</span>

	<span class="n">klist_del</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="p">.</span><span class="n">woken</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_remove</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * klist_node_attached - Say whether a node is bound to a list or not.</span>
<span class="cm"> * @n: Node that we&#39;re testing.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">klist_node_attached</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_klist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_node_attached</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * klist_iter_init_node - Initialize a klist_iter structure.</span>
<span class="cm"> * @k: klist we&#39;re iterating.</span>
<span class="cm"> * @i: klist_iter we&#39;re filling.</span>
<span class="cm"> * @n: node to start with.</span>
<span class="cm"> *</span>
<span class="cm"> * Similar to klist_iter_init(), but starts the action off with @n,</span>
<span class="cm"> * instead of with the list head.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_iter_init_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">i_klist</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">i_cur</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">n_ref</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_iter_init_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * klist_iter_init - Iniitalize a klist_iter structure.</span>
<span class="cm"> * @k: klist we&#39;re iterating.</span>
<span class="cm"> * @i: klist_iter structure we&#39;re filling.</span>
<span class="cm"> *</span>
<span class="cm"> * Similar to klist_iter_init_node(), but start with the list head.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">klist_iter_init_node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_iter_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * klist_iter_exit - Finish a list iteration.</span>
<span class="cm"> * @i: Iterator structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called when done iterating over list, as it decrements the</span>
<span class="cm"> * refcount of the current node. Necessary in case iteration exited before</span>
<span class="cm"> * the end of the list was reached, and always good form.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">klist_iter_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_cur</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">klist_put</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_cur</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">i_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_iter_exit</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="nf">to_klist_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">klist_node</span><span class="p">,</span> <span class="n">n_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * klist_next - Ante up next node in list.</span>
<span class="cm"> * @i: Iterator structure.</span>
<span class="cm"> *</span>
<span class="cm"> * First grab list lock. Decrement the reference count of the previous</span>
<span class="cm"> * node, if there was one. Grab the next node, increment its reference</span>
<span class="cm"> * count, drop the lock, and return that next node.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="nf">klist_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">klist_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put</span><span class="p">)(</span><span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_klist</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_klist</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">to_klist_node</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">klist_dec_and_del</span><span class="p">(</span><span class="n">last</span><span class="p">))</span>
			<span class="n">put</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">to_klist_node</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_klist</span><span class="o">-&gt;</span><span class="n">k_list</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>

	<span class="n">i</span><span class="o">-&gt;</span><span class="n">i_cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">to_klist_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_klist</span><span class="o">-&gt;</span><span class="n">k_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">knode_dead</span><span class="p">(</span><span class="n">next</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">n_ref</span><span class="p">);</span>
			<span class="n">i</span><span class="o">-&gt;</span><span class="n">i_cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">to_klist_node</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">n_node</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_klist</span><span class="o">-&gt;</span><span class="n">k_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put</span> <span class="o">&amp;&amp;</span> <span class="n">last</span><span class="p">)</span>
		<span class="n">put</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">i_cur</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">klist_next</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
