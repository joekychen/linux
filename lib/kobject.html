<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › kobject.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>kobject.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * kobject.c - library routines for handling generic kernel objects</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002-2003 Patrick Mochel &lt;mochel@osdl.org&gt;</span>
<span class="cm"> * Copyright (c) 2006-2007 Greg Kroah-Hartman &lt;greg@kroah.com&gt;</span>
<span class="cm"> * Copyright (c) 2006-2007 Novell Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Please see the file Documentation/kobject.txt for critical information</span>
<span class="cm"> * about using the kobject interface.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * populate_dir - populate directory with attributes.</span>
<span class="cm"> * @kobj: object we&#39;re working on.</span>
<span class="cm"> *</span>
<span class="cm"> * Most subsystems have a set of default attributes that are associated</span>
<span class="cm"> * with an object that registers with them.  This is a helper called during</span>
<span class="cm"> * object registration that loops through the default attributes of the</span>
<span class="cm"> * subsystem and creates attributes files for them in sysfs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">populate_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobj_type</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">get_ktype</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">default_attrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">attr</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">default_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_file</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">populate_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">sysfs_remove_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_kobj_path_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">kobj</span><span class="p">;</span>

	<span class="cm">/* walk up the ancestors until we hit the one pointing to the</span>
<span class="cm">	 * root.</span>
<span class="cm">	 * Add 1 to strlen for leading &#39;/&#39; of each level.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kobject_name</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">kobject_name</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_kobj_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="o">--</span><span class="n">length</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">parent</span> <span class="o">=</span> <span class="n">kobj</span><span class="p">;</span> <span class="n">parent</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">kobject_name</span><span class="p">(</span><span class="n">parent</span><span class="p">));</span>
		<span class="cm">/* back up enough to print this name with &#39;/&#39; */</span>
		<span class="n">length</span> <span class="o">-=</span> <span class="n">cur</span><span class="p">;</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">length</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span> <span class="n">cur</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="o">--</span><span class="n">length</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39; (%p): %s: path = &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span>
		 <span class="n">kobj</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_get_path - generate and return the path associated with a given kobj and kset pair.</span>
<span class="cm"> *</span>
<span class="cm"> * @kobj:	kobject in question, with which to build the path</span>
<span class="cm"> * @gfp_mask:	the allocation type used to allocate the path</span>
<span class="cm"> *</span>
<span class="cm"> * The result must be freed by the caller with kfree().</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">kobject_get_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">get_kobj_path_length</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fill_kobj_path</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">path</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kobject_get_path</span><span class="p">);</span>

<span class="cm">/* add the kobject to its kset&#39;s list */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kobj_kset_join</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kset_get</span><span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* remove the kobject from its kset&#39;s list */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kobj_kset_leave</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">kset_put</span><span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kobject_init_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_in_sysfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_add_uevent_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_remove_uevent_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">kobject_add_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span> <span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;kobject: (%p): attempted to be registered with empty &quot;</span>
			 <span class="s">&quot;name!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/* join kset if set, use it as parent if we do not already have one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">kobj_kset_join</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39; (%p): %s: parent: &#39;%s&#39;, set: &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		 <span class="n">parent</span> <span class="o">?</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;&lt;NULL&gt;&quot;</span><span class="p">,</span>
		 <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span> <span class="o">?</span> <span class="n">kobject_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;&lt;NULL&gt;&quot;</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">create_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kobj_kset_leave</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* be noisy on error issues */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s failed for %s with &quot;</span>
			     <span class="s">&quot;-EEXIST, don&#39;t try to register things with &quot;</span>
			     <span class="s">&quot;the same name in the same directory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s failed for %s (error: %d parent: %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">error</span><span class="p">,</span>
			     <span class="n">parent</span> <span class="o">?</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;&#39;none&#39;&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_in_sysfs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_set_name_vargs - Set the name of an kobject</span>
<span class="cm"> * @kobj: struct kobject to set the name of</span>
<span class="cm"> * @fmt: format string used to build the name</span>
<span class="cm"> * @vargs: vargs to format the string.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kobject_set_name_vargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span>
				  <span class="kt">va_list</span> <span class="n">vargs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fmt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kvasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">vargs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* ewww... some of these buggers have &#39;/&#39; in the name ... */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)))</span>
		<span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">old_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_set_name - Set the name of a kobject</span>
<span class="cm"> * @kobj: struct kobject to set the name of</span>
<span class="cm"> * @fmt: format string used to build the name</span>
<span class="cm"> *</span>
<span class="cm"> * This sets the name of the kobject.  If you have already added the</span>
<span class="cm"> * kobject to the system, you must call kobject_rename() in order to</span>
<span class="cm"> * change the name of the kobject.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kobject_set_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">vargs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">vargs</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_set_name_vargs</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">vargs</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">vargs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kobject_set_name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_init - initialize a kobject structure</span>
<span class="cm"> * @kobj: pointer to the kobject to initialize</span>
<span class="cm"> * @ktype: pointer to the ktype for this kobject.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will properly initialize a kobject such that it can then</span>
<span class="cm"> * be passed to the kobject_add() call.</span>
<span class="cm"> *</span>
<span class="cm"> * After this function is called, the kobject MUST be cleaned up by a call</span>
<span class="cm"> * to kobject_put(), not by a call to kfree directly to ensure that all of</span>
<span class="cm"> * the memory is cleaned up properly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kobject_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">err_str</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_str</span> <span class="o">=</span> <span class="s">&quot;invalid kobject pointer!&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ktype</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_str</span> <span class="o">=</span> <span class="s">&quot;must have a ktype to be initialized properly!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* do not error out as sometimes we can recover */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kobject (%p): tried to init an initialized &quot;</span>
		       <span class="s">&quot;object, something is seriously wrong.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">kobject_init_internal</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">ktype</span> <span class="o">=</span> <span class="n">ktype</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kobject (%p): %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kobj</span><span class="p">,</span> <span class="n">err_str</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kobject_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kobject_add_varg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">vargs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_set_name_vargs</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">vargs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kobject: can not set name properly!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kobject_add_internal</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_add - the main kobject add function</span>
<span class="cm"> * @kobj: the kobject to add</span>
<span class="cm"> * @parent: pointer to the parent of the kobject.</span>
<span class="cm"> * @fmt: format to name the kobject with.</span>
<span class="cm"> *</span>
<span class="cm"> * The kobject name is set and added to the kobject hierarchy in this</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * If @parent is set, then the parent of the @kobj will be set to it.</span>
<span class="cm"> * If @parent is NULL, then the parent of the @kobj will be set to the</span>
<span class="cm"> * kobject associted with the kset assigned to this kobject.  If no kset</span>
<span class="cm"> * is assigned to the kobject, then the kobject will be located in the</span>
<span class="cm"> * root of the sysfs tree.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function returns an error, kobject_put() must be called to</span>
<span class="cm"> * properly clean up the memory associated with the object.</span>
<span class="cm"> * Under no instance should the kobject that is passed to this function</span>
<span class="cm"> * be directly freed with a call to kfree(), that can leak memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, no &quot;add&quot; uevent will be created with this call, the caller should set</span>
<span class="cm"> * up all of the necessary sysfs files for the object and then call</span>
<span class="cm"> * kobject_uevent() with the UEVENT_ADD parameter to ensure that</span>
<span class="cm"> * userspace is properly notified of this kobject&#39;s creation.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kobject_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;kobject &#39;%s&#39; (%p): tried to add an &quot;</span>
		       <span class="s">&quot;uninitialized object, something is seriously wrong.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_add_varg</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kobject_add</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_init_and_add - initialize a kobject structure and add it to the kobject hierarchy</span>
<span class="cm"> * @kobj: pointer to the kobject to initialize</span>
<span class="cm"> * @ktype: pointer to the ktype for this kobject.</span>
<span class="cm"> * @parent: pointer to the parent of this kobject.</span>
<span class="cm"> * @fmt: the name of the kobject.</span>
<span class="cm"> *</span>
<span class="cm"> * This function combines the call to kobject_init() and</span>
<span class="cm"> * kobject_add().  The same type of error handling after a call to</span>
<span class="cm"> * kobject_add() and kobject lifetime rules are the same here.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kobject_init_and_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="o">*</span><span class="n">ktype</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">kobject_init</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">ktype</span><span class="p">);</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_add_varg</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kobject_init_and_add</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_rename - change the name of an object</span>
<span class="cm"> * @kobj: object in question.</span>
<span class="cm"> * @new_name: object&#39;s new name</span>
<span class="cm"> *</span>
<span class="cm"> * It is the responsibility of the caller to provide mutual</span>
<span class="cm"> * exclusion between two different calls of kobject_rename</span>
<span class="cm"> * on the same kobject and to ensure that new_name is valid and</span>
<span class="cm"> * won&#39;t conflict with other kobjects.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kobject_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">new_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devpath</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dup_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">devpath_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">devpath</span> <span class="o">=</span> <span class="n">kobject_get_path</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpath</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devpath_string</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">devpath</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpath_string</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">devpath_string</span><span class="p">,</span> <span class="s">&quot;DEVPATH_OLD=%s&quot;</span><span class="p">,</span> <span class="n">devpath</span><span class="p">);</span>
	<span class="n">envp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">devpath_string</span><span class="p">;</span>
	<span class="n">envp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">dup_name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_rename_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">new_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Install the new kobject name */</span>
	<span class="n">dup_name</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>

	<span class="cm">/* This function is mostly/only used for network interface.</span>
<span class="cm">	 * Some hotplug package track interfaces by their name and</span>
<span class="cm">	 * therefore want to know when the name is changed by the user. */</span>
	<span class="n">kobject_uevent_env</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_MOVE</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dup_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">devpath_string</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">devpath</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kobject_rename</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_move - move object to another parent</span>
<span class="cm"> * @kobj: object in question.</span>
<span class="cm"> * @new_parent: object&#39;s new parent (can be NULL)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kobject_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">new_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">old_parent</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devpath</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">devpath_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">new_parent</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="n">new_parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">)</span>
			<span class="n">new_parent</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* old object path */</span>
	<span class="n">devpath</span> <span class="o">=</span> <span class="n">kobject_get_path</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpath</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">devpath_string</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">devpath</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devpath_string</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">devpath_string</span><span class="p">,</span> <span class="s">&quot;DEVPATH_OLD=%s&quot;</span><span class="p">,</span> <span class="n">devpath</span><span class="p">);</span>
	<span class="n">envp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">devpath_string</span><span class="p">;</span>
	<span class="n">envp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_move_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">new_parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">old_parent</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">new_parent</span><span class="p">;</span>
	<span class="n">new_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">old_parent</span><span class="p">);</span>
	<span class="n">kobject_uevent_env</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_MOVE</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">new_parent</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">devpath_string</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">devpath</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_del - unlink kobject from hierarchy.</span>
<span class="cm"> * @kobj: object.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kobject_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sysfs_remove_dir</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_in_sysfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kobj_kset_leave</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_get - increment refcount for object.</span>
<span class="cm"> * @kobj: object.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">kobject_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kobject_cleanup - free kobject resources.</span>
<span class="cm"> * @kobj: object to cleanup</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kobject_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobj_type</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">get_ktype</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39; (%p): %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39; (%p): does not have a release() &quot;</span>
			 <span class="s">&quot;function, it is broken and must be fixed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">);</span>

	<span class="cm">/* send &quot;remove&quot; if the caller did not do it but sent &quot;add&quot; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_add_uevent_sent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_remove_uevent_sent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39; (%p): auto cleanup &#39;remove&#39; event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">);</span>
		<span class="n">kobject_uevent</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_REMOVE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* remove from sysfs if the caller did not do it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_in_sysfs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39; (%p): auto cleanup kobject_del</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">);</span>
		<span class="n">kobject_del</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39; (%p): calling ktype release</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* free name if we allocated it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39;: free name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kobject_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kobject_cleanup</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span><span class="p">,</span> <span class="n">kref</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_put - decrement refcount for object.</span>
<span class="cm"> * @kobj: object.</span>
<span class="cm"> *</span>
<span class="cm"> * Decrement the refcount, and if 0, call kobject_cleanup().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kobject_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">state_initialized</span><span class="p">)</span>
			<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_WARNING</span> <span class="s">&quot;kobject: &#39;%s&#39; (%p): is not &quot;</span>
			       <span class="s">&quot;initialized, yet kobject_put() is being &quot;</span>
			       <span class="s">&quot;called.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">);</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">kobject_release</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dynamic_kobj_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: (%p): %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">kobj</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">dynamic_kobj_ktype</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">dynamic_kobj_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sysfs_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">kobj_sysfs_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_create - create a struct kobject dynamically</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a kobject structure dynamically and sets it up</span>
<span class="cm"> * to be a &quot;dynamic&quot; kobject with a default release function set up.</span>
<span class="cm"> *</span>
<span class="cm"> * If the kobject was not able to be created, NULL will be returned.</span>
<span class="cm"> * The kobject structure returned from here must be cleaned up with a</span>
<span class="cm"> * call to kobject_put() and not kfree(), as kobject_init() has</span>
<span class="cm"> * already been called on this structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">kobject_create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>

	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">kobj</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kobject_init</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dynamic_kobj_ktype</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kobject_create_and_add - create a struct kobject dynamically and register it with sysfs</span>
<span class="cm"> *</span>
<span class="cm"> * @name: the name for the kobject</span>
<span class="cm"> * @parent: the parent kobject of this kobject, if any.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a kobject structure dynamically and registers it</span>
<span class="cm"> * with sysfs.  When you are finished with this structure, call</span>
<span class="cm"> * kobject_put() and the structure will be dynamically freed when</span>
<span class="cm"> * it is no longer being used.</span>
<span class="cm"> *</span>
<span class="cm"> * If the kobject was not able to be created, NULL will be returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">kobject_create_and_add</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">kobj</span> <span class="o">=</span> <span class="n">kobject_create</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kobj</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_add</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: kobject_add error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">kobj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kobject_create_and_add</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * kset_init - initialize a kset for use</span>
<span class="cm"> * @k: kset</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kset_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kobject_init_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* default kobject attribute operations */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">kobj_attr_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">kattr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">kattr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kattr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kattr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">kattr</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">kobj_attr_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">kattr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">kattr</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kattr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kattr</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">kattr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">kobj_sysfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">kobj_attr_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span>	<span class="o">=</span> <span class="n">kobj_attr_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * kset_register - initialize and add a kset.</span>
<span class="cm"> * @k: kset.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kset_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">k</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">kset_init</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_add_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kset_unregister - remove a kset.</span>
<span class="cm"> * @k: kset.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kset_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">k</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kset_find_obj - search for object in kset.</span>
<span class="cm"> * @kset: kset we&#39;re looking in.</span>
<span class="cm"> * @name: object&#39;s name.</span>
<span class="cm"> *</span>
<span class="cm"> * Lock kset via @kset-&gt;subsys, and iterate over @kset-&gt;list,</span>
<span class="cm"> * looking for a matching kobject. If matching object is found</span>
<span class="cm"> * take a reference and return the object.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="nf">kset_find_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">kset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">k</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kobject_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">kobject_name</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">kobject_get</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kset_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">kset</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kset</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;kobject: &#39;%s&#39; (%p): %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">kobject_name</span><span class="p">(</span><span class="n">kobj</span><span class="p">),</span> <span class="n">kobj</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">kset_ktype</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sysfs_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">kobj_sysfs_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">kset_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * kset_create - create a struct kset dynamically</span>
<span class="cm"> *</span>
<span class="cm"> * @name: the name for the kset</span>
<span class="cm"> * @uevent_ops: a struct kset_uevent_ops for the kset</span>
<span class="cm"> * @parent_kobj: the parent kobject of this kset, if any.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a kset structure dynamically.  This structure can</span>
<span class="cm"> * then be registered with the system and show up in sysfs with a call to</span>
<span class="cm"> * kset_register().  When you are finished with this structure, if</span>
<span class="cm"> * kset_register() has been called, call kset_unregister() and the</span>
<span class="cm"> * structure will be dynamically freed when it is no longer being used.</span>
<span class="cm"> *</span>
<span class="cm"> * If the kset was not able to be created, NULL will be returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="nf">kset_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">kset_uevent_ops</span> <span class="o">*</span><span class="n">uevent_ops</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent_kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">kset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">kset</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">kset</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kset</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">kobject_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">kset</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kset</span><span class="o">-&gt;</span><span class="n">uevent_ops</span> <span class="o">=</span> <span class="n">uevent_ops</span><span class="p">;</span>
	<span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent_kobj</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The kobject of this kset will have a type of kset_ktype and belong to</span>
<span class="cm">	 * no kset itself.  That way we can properly free it when it is</span>
<span class="cm">	 * finished being used.</span>
<span class="cm">	 */</span>
	<span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">ktype</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kset_ktype</span><span class="p">;</span>
	<span class="n">kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">kset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kset_create_and_add - create a struct kset dynamically and add it to sysfs</span>
<span class="cm"> *</span>
<span class="cm"> * @name: the name for the kset</span>
<span class="cm"> * @uevent_ops: a struct kset_uevent_ops for the kset</span>
<span class="cm"> * @parent_kobj: the parent kobject of this kset, if any.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a kset structure dynamically and registers it</span>
<span class="cm"> * with sysfs.  When you are finished with this structure, call</span>
<span class="cm"> * kset_unregister() and the structure will be dynamically freed when it</span>
<span class="cm"> * is no longer being used.</span>
<span class="cm"> *</span>
<span class="cm"> * If the kset was not able to be created, NULL will be returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="nf">kset_create_and_add</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">kset_uevent_ops</span> <span class="o">*</span><span class="n">uevent_ops</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent_kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">kset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">kset</span> <span class="o">=</span> <span class="n">kset_create</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">uevent_ops</span><span class="p">,</span> <span class="n">parent_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kset</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">kset_register</span><span class="p">(</span><span class="n">kset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">kset</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">kset</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kset_create_and_add</span><span class="p">);</span>


<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kobj_ns_type_operations</span> <span class="o">*</span><span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">KOBJ_NS_TYPES</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">kobj_ns_type_register</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kobj_ns_type_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">kobj_ns_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">KOBJ_NS_TYPES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;=</span> <span class="n">KOBJ_NS_TYPE_NONE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kobj_ns_type_registered</span><span class="p">(</span><span class="k">enum</span> <span class="n">kobj_ns_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">KOBJ_NS_TYPE_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">KOBJ_NS_TYPES</span><span class="p">))</span>
		<span class="n">registered</span> <span class="o">=</span> <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">registered</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">kobj_ns_type_operations</span> <span class="o">*</span><span class="nf">kobj_child_ns_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kobj_ns_type_operations</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">child_ns_type</span><span class="p">)</span>
		<span class="n">ops</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">ktype</span><span class="o">-&gt;</span><span class="n">child_ns_type</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ops</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">kobj_ns_type_operations</span> <span class="o">*</span><span class="nf">kobj_ns_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kobj_child_ns_ops</span><span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="o">*</span><span class="nf">kobj_ns_grab_current</span><span class="p">(</span><span class="k">enum</span> <span class="n">kobj_ns_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">KOBJ_NS_TYPE_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">KOBJ_NS_TYPES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">])</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">grab_current_ns</span><span class="p">();</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kobj_ns_netlink</span><span class="p">(</span><span class="k">enum</span> <span class="n">kobj_ns_type</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">KOBJ_NS_TYPE_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">KOBJ_NS_TYPES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">])</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">netlink_ns</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kobj_ns_initial</span><span class="p">(</span><span class="k">enum</span> <span class="n">kobj_ns_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">KOBJ_NS_TYPE_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">KOBJ_NS_TYPES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">])</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">initial_ns</span><span class="p">();</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kobj_ns_drop</span><span class="p">(</span><span class="k">enum</span> <span class="n">kobj_ns_type</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">KOBJ_NS_TYPE_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">KOBJ_NS_TYPES</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">drop_ns</span><span class="p">)</span>
		<span class="n">kobj_ns_ops_tbl</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">drop_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj_ns_type_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kobject_get</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kobject_put</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kobject_del</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kset_register</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kset_unregister</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
