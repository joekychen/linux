<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › reed_solomon › reed_solomon.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>reed_solomon.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * lib/reed_solomon/reed_solomon.c</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Generic Reed Solomon encoder / decoder library</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)</span>
<span class="cm"> *</span>
<span class="cm"> * Reed Solomon code lifted from reed solomon library written by Phil Karn</span>
<span class="cm"> * Copyright 2002 Phil Karn, KA9Q</span>
<span class="cm"> *</span>
<span class="cm"> * $Id: rslib.c,v 1.7 2005/11/07 11:14:59 gleixner Exp $</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *</span>
<span class="cm"> * The generic Reed Solomon library provides runtime configurable</span>
<span class="cm"> * encoding / decoding of RS codes.</span>
<span class="cm"> * Each user must call init_rs to get a pointer to a rs_control</span>
<span class="cm"> * structure for the given rs parameters. This structure is either</span>
<span class="cm"> * generated or a already available matching control structure is used.</span>
<span class="cm"> * If a structure is generated then the polynomial arrays for</span>
<span class="cm"> * fast encoding / decoding are built. This can take some time so</span>
<span class="cm"> * make sure not to call this function from a time critical path.</span>
<span class="cm"> * Usually a module / driver should initialize the necessary</span>
<span class="cm"> * rs_control structure on module / driver init and release it</span>
<span class="cm"> * on exit.</span>
<span class="cm"> * The encoding puts the calculated syndrome into a given syndrome</span>
<span class="cm"> * buffer.</span>
<span class="cm"> * The decoding is a two step process. The first step calculates</span>
<span class="cm"> * the syndrome over the received (data + syndrome) and calls the</span>
<span class="cm"> * second stage, which does the decoding / error correction itself.</span>
<span class="cm"> * Many hw encoders provide a syndrome calculation over the received</span>
<span class="cm"> * data + syndrome and can call the second stage directly.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/rslib.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cm">/* This list holds all currently allocated rs control structures */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span> <span class="p">(</span><span class="n">rslist</span><span class="p">);</span>
<span class="cm">/* Protection for the list */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">rslistlock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rs_init - Initialize a Reed-Solomon codec</span>
<span class="cm"> * @symsize:	symbol size, bits (1-8)</span>
<span class="cm"> * @gfpoly:	Field generator polynomial coefficients</span>
<span class="cm"> * @gffunc:	Field generator function</span>
<span class="cm"> * @fcr:	first root of RS code generator polynomial, index form</span>
<span class="cm"> * @prim:	primitive element to generate polynomial roots</span>
<span class="cm"> * @nroots:	RS code generator polynomial degree (number of roots)</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a control structure and the polynom arrays for faster</span>
<span class="cm"> * en/decoding. Fill the arrays according to the given parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="nf">rs_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">symsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gfpoly</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">gffunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span>
                                  <span class="kt">int</span> <span class="n">fcr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nroots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="n">rs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">iprim</span><span class="p">;</span>

	<span class="cm">/* Allocate the control structure */</span>
	<span class="n">rs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rs_control</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">symsize</span><span class="p">;</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">symsize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">fcr</span> <span class="o">=</span> <span class="n">fcr</span><span class="p">;</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">prim</span> <span class="o">=</span> <span class="n">prim</span><span class="p">;</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">nroots</span> <span class="o">=</span> <span class="n">nroots</span><span class="p">;</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">gfpoly</span> <span class="o">=</span> <span class="n">gfpoly</span><span class="p">;</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">gffunc</span> <span class="o">=</span> <span class="n">gffunc</span><span class="p">;</span>

	<span class="cm">/* Allocate the arrays */</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errrs</span><span class="p">;</span>

	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">erralp</span><span class="p">;</span>

	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">nroots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">erridx</span><span class="p">;</span>

	<span class="cm">/* Generate Galois field lookup tables */</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span><span class="p">;</span>	<span class="cm">/* log(zero) = -inf */</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">[</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* alpha**-inf = 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gfpoly</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">[</span><span class="n">sr</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sr</span><span class="p">;</span>
			<span class="n">sr</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">symsize</span><span class="p">))</span>
				<span class="n">sr</span> <span class="o">^=</span> <span class="n">gfpoly</span><span class="p">;</span>
			<span class="n">sr</span> <span class="o">&amp;=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sr</span> <span class="o">=</span> <span class="n">gffunc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">[</span><span class="n">sr</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sr</span><span class="p">;</span>
			<span class="n">sr</span> <span class="o">=</span> <span class="n">gffunc</span><span class="p">(</span><span class="n">sr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* If it&#39;s not primitive, exit */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sr</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">errpol</span><span class="p">;</span>

	<span class="cm">/* Find prim-th root of 1, used in decoding */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">iprim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">(</span><span class="n">iprim</span> <span class="o">%</span> <span class="n">prim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iprim</span> <span class="o">+=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">nn</span><span class="p">);</span>
	<span class="cm">/* prim-th root of 1, index form */</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">iprim</span> <span class="o">=</span> <span class="n">iprim</span> <span class="o">/</span> <span class="n">prim</span><span class="p">;</span>

	<span class="cm">/* Form RS code generator polynomial from its roots */</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="n">fcr</span> <span class="o">*</span> <span class="n">prim</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nroots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">root</span> <span class="o">+=</span> <span class="n">prim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Multiply rs-&gt;genpoly[] by  @**(root + x) */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span>
					<span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">[</span><span class="n">rs_modnn</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span>
					<span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">[</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="n">root</span><span class="p">)];</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="cm">/* rs-&gt;genpoly[0] can never be zero */</span>
		<span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">[</span><span class="n">rs_modnn</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span>
				<span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">[</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">root</span><span class="p">)];</span>
	<span class="p">}</span>
	<span class="cm">/* convert rs-&gt;genpoly[] to index form for quicker encoding */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nroots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">[</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
	<span class="k">return</span> <span class="n">rs</span><span class="p">;</span>

	<span class="cm">/* Error exit */</span>
<span class="nl">errpol:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">);</span>
<span class="nl">erridx:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">);</span>
<span class="nl">erralp:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">);</span>
<span class="nl">errrs:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rs</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *  free_rs - Free the rs control structure, if it is no longer used</span>
<span class="cm"> *  @rs:	the control structure which is not longer used by the</span>
<span class="cm"> *		caller</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">free_rs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="n">rs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rslistlock</span><span class="p">);</span>
	<span class="n">rs</span><span class="o">-&gt;</span><span class="n">users</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">genpoly</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rslistlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_rs_internal - Find a matching or allocate a new rs control structure</span>
<span class="cm"> *  @symsize:	the symbol size (number of bits)</span>
<span class="cm"> *  @gfpoly:	the extended Galois field generator polynomial coefficients,</span>
<span class="cm"> *		with the 0th coefficient in the low order bit. The polynomial</span>
<span class="cm"> *		must be primitive;</span>
<span class="cm"> *  @gffunc:	pointer to function to generate the next field element,</span>
<span class="cm"> *		or the multiplicative identity element if given 0.  Used</span>
<span class="cm"> *		instead of gfpoly if gfpoly is 0</span>
<span class="cm"> *  @fcr:  	the first consecutive root of the rs code generator polynomial</span>
<span class="cm"> *		in index form</span>
<span class="cm"> *  @prim:	primitive element to generate polynomial roots</span>
<span class="cm"> *  @nroots:	RS code generator polynomial degree (number of roots)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="nf">init_rs_internal</span><span class="p">(</span><span class="kt">int</span> <span class="n">symsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gfpoly</span><span class="p">,</span>
                                           <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">gffunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span> <span class="kt">int</span> <span class="n">fcr</span><span class="p">,</span>
                                           <span class="kt">int</span> <span class="n">prim</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nroots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rs_control</span>	<span class="o">*</span><span class="n">rs</span><span class="p">;</span>

	<span class="cm">/* Sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">symsize</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">fcr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">symsize</span><span class="p">))</span>
    		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prim</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">prim</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">symsize</span><span class="p">))</span>
    		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nroots</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nroots</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">symsize</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rslistlock</span><span class="p">);</span>

	<span class="cm">/* Walk through the list and look for a matching entry */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rslist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rs</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rs_control</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">symsize</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gfpoly</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">gfpoly</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gffunc</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">gffunc</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcr</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">fcr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prim</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">prim</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nroots</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">nroots</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* We have a matching one already */</span>
		<span class="n">rs</span><span class="o">-&gt;</span><span class="n">users</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create a new one */</span>
	<span class="n">rs</span> <span class="o">=</span> <span class="n">rs_init</span><span class="p">(</span><span class="n">symsize</span><span class="p">,</span> <span class="n">gfpoly</span><span class="p">,</span> <span class="n">gffunc</span><span class="p">,</span> <span class="n">fcr</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">nroots</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rs</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rs</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rslist</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rslistlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_rs - Find a matching or allocate a new rs control structure</span>
<span class="cm"> *  @symsize:	the symbol size (number of bits)</span>
<span class="cm"> *  @gfpoly:	the extended Galois field generator polynomial coefficients,</span>
<span class="cm"> *		with the 0th coefficient in the low order bit. The polynomial</span>
<span class="cm"> *		must be primitive;</span>
<span class="cm"> *  @fcr:  	the first consecutive root of the rs code generator polynomial</span>
<span class="cm"> *		in index form</span>
<span class="cm"> *  @prim:	primitive element to generate polynomial roots</span>
<span class="cm"> *  @nroots:	RS code generator polynomial degree (number of roots)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="nf">init_rs</span><span class="p">(</span><span class="kt">int</span> <span class="n">symsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gfpoly</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fcr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">nroots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">init_rs_internal</span><span class="p">(</span><span class="n">symsize</span><span class="p">,</span> <span class="n">gfpoly</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fcr</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">nroots</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_rs_non_canonical - Find a matching or allocate a new rs control</span>
<span class="cm"> *                         structure, for fields with non-canonical</span>
<span class="cm"> *                         representation</span>
<span class="cm"> *  @symsize:	the symbol size (number of bits)</span>
<span class="cm"> *  @gffunc:	pointer to function to generate the next field element,</span>
<span class="cm"> *		or the multiplicative identity element if given 0.  Used</span>
<span class="cm"> *		instead of gfpoly if gfpoly is 0</span>
<span class="cm"> *  @fcr:  	the first consecutive root of the rs code generator polynomial</span>
<span class="cm"> *		in index form</span>
<span class="cm"> *  @prim:	primitive element to generate polynomial roots</span>
<span class="cm"> *  @nroots:	RS code generator polynomial degree (number of roots)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="nf">init_rs_non_canonical</span><span class="p">(</span><span class="kt">int</span> <span class="n">symsize</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">gffunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span>
                                         <span class="kt">int</span> <span class="n">fcr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prim</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nroots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">init_rs_internal</span><span class="p">(</span><span class="n">symsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gffunc</span><span class="p">,</span> <span class="n">fcr</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">nroots</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_REED_SOLOMON_ENC8</span>
<span class="cm">/**</span>
<span class="cm"> *  encode_rs8 - Calculate the parity for data values (8bit data width)</span>
<span class="cm"> *  @rs:	the rs control structure</span>
<span class="cm"> *  @data:	data field of a given type</span>
<span class="cm"> *  @len:	data length</span>
<span class="cm"> *  @par:	parity data, must be initialized by caller (usually all 0)</span>
<span class="cm"> *  @invmsk:	invert data mask (will be xored on data)</span>
<span class="cm"> *</span>
<span class="cm"> *  The parity uses a uint16_t data type to enable</span>
<span class="cm"> *  symbol size &gt; 8. The calling code must take care of encoding of the</span>
<span class="cm"> *  syndrome result for storage itself.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">encode_rs8</span><span class="p">(</span><span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="n">rs</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
	       <span class="kt">uint16_t</span> <span class="n">invmsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#include &quot;encode_rs.c&quot;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">encode_rs8</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_REED_SOLOMON_DEC8</span>
<span class="cm">/**</span>
<span class="cm"> *  decode_rs8 - Decode codeword (8bit data width)</span>
<span class="cm"> *  @rs:	the rs control structure</span>
<span class="cm"> *  @data:	data field of a given type</span>
<span class="cm"> *  @par:	received parity data field</span>
<span class="cm"> *  @len:	data length</span>
<span class="cm"> *  @s:		syndrome data field (if NULL, syndrome is calculated)</span>
<span class="cm"> *  @no_eras:	number of erasures</span>
<span class="cm"> *  @eras_pos:	position of erasures, can be NULL</span>
<span class="cm"> *  @invmsk:	invert data mask (will be xored on data, not on parity!)</span>
<span class="cm"> *  @corr:	buffer to store correction bitmask on eras_pos</span>
<span class="cm"> *</span>
<span class="cm"> *  The syndrome and parity uses a uint16_t data type to enable</span>
<span class="cm"> *  symbol size &gt; 8. The calling code must take care of decoding of the</span>
<span class="cm"> *  syndrome result and the received parity before calling this code.</span>
<span class="cm"> *  Returns the number of corrected bits or -EBADMSG for uncorrectable errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">decode_rs8</span><span class="p">(</span><span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="n">rs</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
	       <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">no_eras</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eras_pos</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">invmsk</span><span class="p">,</span>
	       <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">corr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#include &quot;decode_rs.c&quot;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">decode_rs8</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_REED_SOLOMON_ENC16</span>
<span class="cm">/**</span>
<span class="cm"> *  encode_rs16 - Calculate the parity for data values (16bit data width)</span>
<span class="cm"> *  @rs:	the rs control structure</span>
<span class="cm"> *  @data:	data field of a given type</span>
<span class="cm"> *  @len:	data length</span>
<span class="cm"> *  @par:	parity data, must be initialized by caller (usually all 0)</span>
<span class="cm"> *  @invmsk:	invert data mask (will be xored on data, not on parity!)</span>
<span class="cm"> *</span>
<span class="cm"> *  Each field in the data array contains up to symbol size bits of valid data.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">encode_rs16</span><span class="p">(</span><span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="n">rs</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
	<span class="kt">uint16_t</span> <span class="n">invmsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#include &quot;encode_rs.c&quot;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">encode_rs16</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_REED_SOLOMON_DEC16</span>
<span class="cm">/**</span>
<span class="cm"> *  decode_rs16 - Decode codeword (16bit data width)</span>
<span class="cm"> *  @rs:	the rs control structure</span>
<span class="cm"> *  @data:	data field of a given type</span>
<span class="cm"> *  @par:	received parity data field</span>
<span class="cm"> *  @len:	data length</span>
<span class="cm"> *  @s:		syndrome data field (if NULL, syndrome is calculated)</span>
<span class="cm"> *  @no_eras:	number of erasures</span>
<span class="cm"> *  @eras_pos:	position of erasures, can be NULL</span>
<span class="cm"> *  @invmsk:	invert data mask (will be xored on data, not on parity!)</span>
<span class="cm"> *  @corr:	buffer to store correction bitmask on eras_pos</span>
<span class="cm"> *</span>
<span class="cm"> *  Each field in the data array contains up to symbol size bits of valid data.</span>
<span class="cm"> *  Returns the number of corrected bits or -EBADMSG for uncorrectable errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">decode_rs16</span><span class="p">(</span><span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="n">rs</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">no_eras</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eras_pos</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">invmsk</span><span class="p">,</span>
		<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">corr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#include &quot;decode_rs.c&quot;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">decode_rs16</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">init_rs</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">init_rs_non_canonical</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">free_rs</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Reed Solomon encoder/decoder&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Phil Karn, Thomas Gleixner&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
