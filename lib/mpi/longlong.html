<!DOCTYPE html>
<html><head><title>joekychen/linux » lib › mpi › longlong.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>longlong.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* longlong.h -- definitions for mixed size 32/64 bit arithmetic.</span>
<span class="cm"> * Note: I added some stuff for use with gnupg</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1991, 1992, 1993, 1994, 1996, 1998,</span>
<span class="cm"> *	2000, 2001, 2002, 2003 Free Software Foundation, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU Library General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public</span>
<span class="cm"> * License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU Library General Public License</span>
<span class="cm"> * along with this file; see the file COPYING.LIB.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</span>
<span class="cm"> * MA 02111-1307, USA. */</span>

<span class="cm">/* You have to define the following before including this file:</span>
<span class="cm"> *</span>
<span class="cm"> * UWtype -- An unsigned type, default type for operations (typically a &quot;word&quot;)</span>
<span class="cm"> * UHWtype -- An unsigned type, at least half the size of UWtype.</span>
<span class="cm"> * UDWtype -- An unsigned type, at least twice as large a UWtype</span>
<span class="cm"> * W_TYPE_SIZE -- size in bits of UWtype</span>
<span class="cm"> *</span>
<span class="cm"> * SItype, USItype -- Signed and unsigned 32 bit types.</span>
<span class="cm"> * DItype, UDItype -- Signed and unsigned 64 bit types.</span>
<span class="cm"> *</span>
<span class="cm"> * On a 32 bit machine UWtype should typically be USItype;</span>
<span class="cm"> * on a 64 bit machine, UWtype should typically be UDItype.</span>
<span class="cm">*/</span>

<span class="cp">#define __BITS4 (W_TYPE_SIZE / 4)</span>
<span class="cp">#define __ll_B ((UWtype) 1 &lt;&lt; (W_TYPE_SIZE / 2))</span>
<span class="cp">#define __ll_lowpart(t) ((UWtype) (t) &amp; (__ll_B - 1))</span>
<span class="cp">#define __ll_highpart(t) ((UWtype) (t) &gt;&gt; (W_TYPE_SIZE / 2))</span>

<span class="cm">/* This is used to make sure no undesirable sharing between different libraries</span>
<span class="cm">	that use this file takes place.  */</span>
<span class="cp">#ifndef __MPN</span>
<span class="cp">#define __MPN(x) __##x</span>
<span class="cp">#endif</span>

<span class="cm">/* Define auxiliary asm macros.</span>
<span class="cm"> *</span>
<span class="cm"> * 1) umul_ppmm(high_prod, low_prod, multipler, multiplicand) multiplies two</span>
<span class="cm"> * UWtype integers MULTIPLER and MULTIPLICAND, and generates a two UWtype</span>
<span class="cm"> * word product in HIGH_PROD and LOW_PROD.</span>
<span class="cm"> *</span>
<span class="cm"> * 2) __umulsidi3(a,b) multiplies two UWtype integers A and B, and returns a</span>
<span class="cm"> * UDWtype product.  This is just a variant of umul_ppmm.</span>

<span class="cm"> * 3) udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,</span>
<span class="cm"> * denominator) divides a UDWtype, composed by the UWtype integers</span>
<span class="cm"> * HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient</span>
<span class="cm"> * in QUOTIENT and the remainder in REMAINDER.	HIGH_NUMERATOR must be less</span>
<span class="cm"> * than DENOMINATOR for correct operation.  If, in addition, the most</span>
<span class="cm"> * significant bit of DENOMINATOR must be 1, then the pre-processor symbol</span>
<span class="cm"> * UDIV_NEEDS_NORMALIZATION is defined to 1.</span>
<span class="cm"> * 4) sdiv_qrnnd(quotient, remainder, high_numerator, low_numerator,</span>
<span class="cm"> * denominator).  Like udiv_qrnnd but the numbers are signed.  The quotient</span>
<span class="cm"> * is rounded towards 0.</span>
<span class="cm"> *</span>
<span class="cm"> * 5) count_leading_zeros(count, x) counts the number of zero-bits from the</span>
<span class="cm"> * msb to the first non-zero bit in the UWtype X.  This is the number of</span>
<span class="cm"> * steps X needs to be shifted left to set the msb.  Undefined for X == 0,</span>
<span class="cm"> * unless the symbol COUNT_LEADING_ZEROS_0 is defined to some value.</span>
<span class="cm"> *</span>
<span class="cm"> * 6) count_trailing_zeros(count, x) like count_leading_zeros, but counts</span>
<span class="cm"> * from the least significant end.</span>
<span class="cm"> *</span>
<span class="cm"> * 7) add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,</span>
<span class="cm"> * high_addend_2, low_addend_2) adds two UWtype integers, composed by</span>
<span class="cm"> * HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2</span>
<span class="cm"> * respectively.  The result is placed in HIGH_SUM and LOW_SUM.  Overflow</span>
<span class="cm"> * (i.e. carry out) is not stored anywhere, and is lost.</span>
<span class="cm"> *</span>
<span class="cm"> * 8) sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,</span>
<span class="cm"> * high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,</span>
<span class="cm"> * composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and</span>
<span class="cm"> * LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE</span>
<span class="cm"> * and LOW_DIFFERENCE.	Overflow (i.e. carry out) is not stored anywhere,</span>
<span class="cm"> * and is lost.</span>
<span class="cm"> *</span>
<span class="cm"> * If any of these macros are left undefined for a particular CPU,</span>
<span class="cm"> * C macros are used.  */</span>

<span class="cm">/* The CPUs come in alphabetical order below.</span>
<span class="cm"> *</span>
<span class="cm"> * Please add support for more CPUs here, or improve the current support</span>
<span class="cm"> * for the CPUs below!	*/</span>

<span class="cp">#if defined(__GNUC__) &amp;&amp; !defined(NO_ASM)</span>

<span class="cm">/* We sometimes need to clobber &quot;cc&quot; with gcc2, but that would not be</span>
<span class="cm">	understood by gcc1.	Use cpp to avoid major code duplication.  */</span>
<span class="cp">#if __GNUC__ &lt; 2</span>
<span class="cp">#define __CLOBBER_CC</span>
<span class="cp">#define __AND_CLOBBER_CC</span>
<span class="cp">#else </span><span class="cm">/* __GNUC__ &gt;= 2 */</span><span class="cp"></span>
<span class="cp">#define __CLOBBER_CC : &quot;cc&quot;</span>
<span class="cp">#define __AND_CLOBBER_CC , &quot;cc&quot;</span>
<span class="cp">#endif </span><span class="cm">/* __GNUC__ &lt; 2 */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  A29K  *****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if (defined(__a29k__) || defined(_AM29K)) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;add %1,%4,%5\n&quot; \</span>
<span class="cp">		&quot;addc %0,%2,%3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;%r&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;sub %1,%4,%5\n&quot; \</span>
<span class="cp">		&quot;subc %0,%2,%3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bl)))</span>
<span class="cp">#define umul_ppmm(xh, xl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">		USItype __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">		__asm__ (&quot;multiplu %0,%1,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(xl)) \</span>
<span class="cp">		: &quot;r&quot; (__m0), \</span>
<span class="cp">			&quot;r&quot; (__m1)); \</span>
<span class="cp">		__asm__ (&quot;multmu %0,%1,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(xh)) \</span>
<span class="cp">		: &quot;r&quot; (__m0), \</span>
<span class="cp">			&quot;r&quot; (__m1)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">	__asm__ (&quot;dividu %0,%3,%4&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(q)), \</span>
<span class="cp">		&quot;=q&quot; ((USItype)(r)) \</span>
<span class="cp">	: &quot;1&quot; ((USItype)(n1)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(n0)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(d)))</span>

<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">	__asm__ (&quot;clz %0,%1&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(count)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(x)))</span>
<span class="cp">#define COUNT_LEADING_ZEROS_0 32</span>
<span class="cp">#endif </span><span class="cm">/* __a29k__ */</span><span class="cp"></span>

<span class="cp">#if defined(__alpha) &amp;&amp; W_TYPE_SIZE == 64</span>
<span class="cp">#define umul_ppmm(ph, pl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">		UDItype __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">		__asm__ (&quot;umulh %r1,%2,%0&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((UDItype) ph) \</span>
<span class="cp">		: &quot;%rJ&quot; (__m0), \</span>
<span class="cp">			&quot;rI&quot; (__m1)); \</span>
<span class="cp">		(pl) = __m0 * __m1; \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define UMUL_TIME 46</span>
<span class="cp">#ifndef LONGLONG_STANDALONE</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">do { UDItype __r; \</span>
<span class="cp">	(q) = __udiv_qrnnd(&amp;__r, (n1), (n0), (d)); \</span>
<span class="cp">	(r) = __r; \</span>
<span class="cp">} while (0)</span>
<span class="k">extern</span> <span class="n">UDItype</span> <span class="n">__udiv_qrnnd</span><span class="p">();</span>
<span class="cp">#define UDIV_TIME 220</span>
<span class="cp">#endif </span><span class="cm">/* LONGLONG_STANDALONE */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __alpha */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  ARM  ******************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__arm__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;adds %1, %4, %5\n&quot; \</span>
<span class="cp">		&quot;adc  %0, %2, %3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;%r&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;subs %1, %4, %5\n&quot; \</span>
<span class="cp">		&quot;sbc  %0, %2, %3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bl)))</span>
<span class="cp">#if defined __ARM_ARCH_2__ || defined __ARM_ARCH_3__</span>
<span class="cp">#define umul_ppmm(xh, xl, a, b) \</span>
<span class="cp">	__asm__ (&quot;%@ Inlined umul_ppmm\n&quot; \</span>
<span class="cp">		&quot;mov	%|r0, %2, lsr #16		@ AAAA\n&quot; \</span>
<span class="cp">		&quot;mov	%|r2, %3, lsr #16		@ BBBB\n&quot; \</span>
<span class="cp">		&quot;bic	%|r1, %2, %|r0, lsl #16		@ aaaa\n&quot; \</span>
<span class="cp">		&quot;bic	%0, %3, %|r2, lsl #16		@ bbbb\n&quot; \</span>
<span class="cp">		&quot;mul	%1, %|r1, %|r2			@ aaaa * BBBB\n&quot; \</span>
<span class="cp">		&quot;mul	%|r2, %|r0, %|r2		@ AAAA * BBBB\n&quot; \</span>
<span class="cp">		&quot;mul	%|r1, %0, %|r1			@ aaaa * bbbb\n&quot; \</span>
<span class="cp">		&quot;mul	%0, %|r0, %0			@ AAAA * bbbb\n&quot; \</span>
<span class="cp">		&quot;adds	%|r0, %1, %0			@ central sum\n&quot; \</span>
<span class="cp">		&quot;addcs	%|r2, %|r2, #65536\n&quot; \</span>
<span class="cp">		&quot;adds	%1, %|r1, %|r0, lsl #16\n&quot; \</span>
<span class="cp">		&quot;adc	%0, %|r2, %|r0, lsr #16&quot; \</span>
<span class="cp">	: &quot;=&amp;r&quot; ((USItype)(xh)), \</span>
<span class="cp">		&quot;=r&quot; ((USItype)(xl)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(a)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(b)) \</span>
<span class="cp">	: &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;)</span>
<span class="cp">#else</span>
<span class="cp">#define umul_ppmm(xh, xl, a, b) \</span>
<span class="cp">	__asm__ (&quot;%@ Inlined umul_ppmm\n&quot; \</span>
<span class="cp">		&quot;umull %r1, %r0, %r2, %r3&quot; \</span>
<span class="cp">	: &quot;=&amp;r&quot; ((USItype)(xh)), \</span>
<span class="cp">			&quot;=r&quot; ((USItype)(xl)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(a)), \</span>
<span class="cp">			&quot;r&quot; ((USItype)(b)) \</span>
<span class="cp">	: &quot;r0&quot;, &quot;r1&quot;)</span>
<span class="cp">#endif</span>
<span class="cp">#define UMUL_TIME 20</span>
<span class="cp">#define UDIV_TIME 100</span>
<span class="cp">#endif </span><span class="cm">/* __arm__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  CLIPPER  **************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__clipper__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	({union {UDItype __ll; \</span>
<span class="cp">		struct {USItype __l, __h; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__asm__ (&quot;mulwux %2,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(u)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(v))); \</span>
<span class="cp">	(w1) = __xx.__i.__h; (w0) = __xx.__i.__l; })</span>
<span class="cp">#define smul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	({union {DItype __ll; \</span>
<span class="cp">		struct {SItype __l, __h; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__asm__ (&quot;mulwx %2,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;%0&quot; ((SItype)(u)), \</span>
<span class="cp">		&quot;r&quot; ((SItype)(v))); \</span>
<span class="cp">	(w1) = __xx.__i.__h; (w0) = __xx.__i.__l; })</span>
<span class="cp">#define __umulsidi3(u, v) \</span>
<span class="cp">	({UDItype __w; \</span>
<span class="cp">	__asm__ (&quot;mulwux %2,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__w) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(u)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(v))); \</span>
<span class="cp">	__w; })</span>
<span class="cp">#endif </span><span class="cm">/* __clipper__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  GMICRO  ***************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__gmicro__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;add.w %5,%1\n&quot; \</span>
<span class="cp">		&quot;addx %3,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;g&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;g&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;%1&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;sub.w %5,%1\n&quot; \</span>
<span class="cp">		&quot;subx %3,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;g&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;g&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;1&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#define umul_ppmm(ph, pl, m0, m1) \</span>
<span class="cp">	__asm__ (&quot;mulx %3,%0,%1&quot; \</span>
<span class="cp">	: &quot;=g&quot; ((USItype)(ph)), \</span>
<span class="cp">		&quot;=r&quot; ((USItype)(pl)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(m0)), \</span>
<span class="cp">		&quot;g&quot; ((USItype)(m1)))</span>
<span class="cp">#define udiv_qrnnd(q, r, nh, nl, d) \</span>
<span class="cp">	__asm__ (&quot;divx %4,%0,%1&quot; \</span>
<span class="cp">	: &quot;=g&quot; ((USItype)(q)), \</span>
<span class="cp">		&quot;=r&quot; ((USItype)(r)) \</span>
<span class="cp">	: &quot;1&quot; ((USItype)(nh)), \</span>
<span class="cp">		&quot;0&quot; ((USItype)(nl)), \</span>
<span class="cp">		&quot;g&quot; ((USItype)(d)))</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">	__asm__ (&quot;bsch/1 %1,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; (count) \</span>
<span class="cp">	: &quot;g&quot; ((USItype)(x)), \</span>
<span class="cp">	     &quot;0&quot; ((USItype)0))</span>
<span class="cp">#endif</span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  HPPA  *****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__hppa) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;add %4,%5,%1\n&quot; \</span>
<span class="cp">		   &quot;addc %2,%3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%rM&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;rM&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;%rM&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;rM&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;sub %4,%5,%1\n&quot; \</span>
<span class="cp">	   &quot;subb %2,%3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;rM&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;rM&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;rM&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;rM&quot; ((USItype)(bl)))</span>
<span class="cp">#if defined(_PA_RISC1_1)</span>
<span class="cp">#define umul_ppmm(wh, wl, u, v) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {UDItype __ll; \</span>
<span class="cp">	struct {USItype __h, __l; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__asm__ (&quot;xmpyu %1,%2,%0&quot; \</span>
<span class="cp">	: &quot;=*f&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;*f&quot; ((USItype)(u)), \</span>
<span class="cp">	       &quot;*f&quot; ((USItype)(v))); \</span>
<span class="cp">	(wh) = __xx.__i.__h; \</span>
<span class="cp">	(wl) = __xx.__i.__l; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define UMUL_TIME 8</span>
<span class="cp">#define UDIV_TIME 60</span>
<span class="cp">#else</span>
<span class="cp">#define UMUL_TIME 40</span>
<span class="cp">#define UDIV_TIME 80</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef LONGLONG_STANDALONE</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">do { USItype __r; \</span>
<span class="cp">	(q) = __udiv_qrnnd(&amp;__r, (n1), (n0), (d)); \</span>
<span class="cp">	(r) = __r; \</span>
<span class="cp">} while (0)</span>
<span class="k">extern</span> <span class="n">USItype</span> <span class="n">__udiv_qrnnd</span><span class="p">();</span>
<span class="cp">#endif </span><span class="cm">/* LONGLONG_STANDALONE */</span><span class="cp"></span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">do { \</span>
<span class="cp">	USItype __tmp; \</span>
<span class="cp">	__asm__ ( \</span>
<span class="cp">	&quot;ldi             1,%0\n&quot; \</span>
<span class="cp">	&quot;extru,=	%1,15,16,%%r0  ; Bits 31..16 zero?\n&quot; \</span>
<span class="cp">	&quot;extru,tr	%1,15,16,%1    ; No.  Shift down, skip add.\n&quot; \</span>
<span class="cp">	&quot;ldo		16(%0),%0      ; Yes.	Perform add.\n&quot; \</span>
<span class="cp">	&quot;extru,=	%1,23,8,%%r0   ; Bits 15..8 zero?\n&quot; \</span>
<span class="cp">	&quot;extru,tr	%1,23,8,%1     ; No.  Shift down, skip add.\n&quot; \</span>
<span class="cp">	&quot;ldo		8(%0),%0       ; Yes.	Perform add.\n&quot; \</span>
<span class="cp">	&quot;extru,=	%1,27,4,%%r0   ; Bits 7..4 zero?\n&quot; \</span>
<span class="cp">	&quot;extru,tr	%1,27,4,%1     ; No.  Shift down, skip add.\n&quot; \</span>
<span class="cp">	&quot;ldo		4(%0),%0       ; Yes.	Perform add.\n&quot; \</span>
<span class="cp">	&quot;extru,=	%1,29,2,%%r0   ; Bits 3..2 zero?\n&quot; \</span>
<span class="cp">	&quot;extru,tr	%1,29,2,%1     ; No.  Shift down, skip add.\n&quot; \</span>
<span class="cp">	&quot;ldo		2(%0),%0       ; Yes.	Perform add.\n&quot; \</span>
<span class="cp">	&quot;extru		%1,30,1,%1     ; Extract bit 1.\n&quot; \</span>
<span class="cp">	&quot;sub		%0,%1,%0       ; Subtract it.              &quot; \</span>
<span class="cp">	: &quot;=r&quot; (count), &quot;=r&quot; (__tmp) : &quot;1&quot; (x)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* hppa */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  I370  *****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if (defined(__i370__) || defined(__mvs__)) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define umul_ppmm(xh, xl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {UDItype __ll; \</span>
<span class="cp">	   struct {USItype __h, __l; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	USItype __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">	__asm__ (&quot;mr %0,%3&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__xx.__i.__h), \</span>
<span class="cp">	       &quot;=r&quot; (__xx.__i.__l) \</span>
<span class="cp">	: &quot;%1&quot; (__m0), \</span>
<span class="cp">	       &quot;r&quot; (__m1)); \</span>
<span class="cp">	(xh) = __xx.__i.__h; (xl) = __xx.__i.__l; \</span>
<span class="cp">	(xh) += ((((SItype) __m0 &gt;&gt; 31) &amp; __m1) \</span>
<span class="cp">	     + (((SItype) __m1 &gt;&gt; 31) &amp; __m0)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define smul_ppmm(xh, xl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {DItype __ll; \</span>
<span class="cp">	   struct {USItype __h, __l; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__asm__ (&quot;mr %0,%3&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__xx.__i.__h), \</span>
<span class="cp">	       &quot;=r&quot; (__xx.__i.__l) \</span>
<span class="cp">	: &quot;%1&quot; (m0), \</span>
<span class="cp">	       &quot;r&quot; (m1)); \</span>
<span class="cp">	(xh) = __xx.__i.__h; (xl) = __xx.__i.__l; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define sdiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {DItype __ll; \</span>
<span class="cp">	   struct {USItype __h, __l; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__xx.__i.__h = n1; __xx.__i.__l = n0; \</span>
<span class="cp">	__asm__ (&quot;dr %0,%2&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;0&quot; (__xx.__ll), &quot;r&quot; (d)); \</span>
<span class="cp">	(q) = __xx.__i.__l; (r) = __xx.__i.__h; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  I386  *****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#undef __i386__</span>
<span class="cp">#if (defined(__i386__) || defined(__i486__)) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;addl %5,%1\n&quot; \</span>
<span class="cp">	   &quot;adcl %3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;g&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;%1&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;subl %5,%1\n&quot; \</span>
<span class="cp">	   &quot;sbbl %3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;g&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;1&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;mull %3&quot; \</span>
<span class="cp">	: &quot;=a&quot; ((USItype)(w0)), \</span>
<span class="cp">	     &quot;=d&quot; ((USItype)(w1)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(u)), \</span>
<span class="cp">	     &quot;rm&quot; ((USItype)(v)))</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">	__asm__ (&quot;divl %4&quot; \</span>
<span class="cp">	: &quot;=a&quot; ((USItype)(q)), \</span>
<span class="cp">	     &quot;=d&quot; ((USItype)(r)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(n0)), \</span>
<span class="cp">	     &quot;1&quot; ((USItype)(n1)), \</span>
<span class="cp">	     &quot;rm&quot; ((USItype)(d)))</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">do { \</span>
<span class="cp">	USItype __cbtmp; \</span>
<span class="cp">	__asm__ (&quot;bsrl %1,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__cbtmp) : &quot;rm&quot; ((USItype)(x))); \</span>
<span class="cp">	(count) = __cbtmp ^ 31; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define count_trailing_zeros(count, x) \</span>
<span class="cp">	__asm__ (&quot;bsfl %1,%0&quot; : &quot;=r&quot; (count) : &quot;rm&quot; ((USItype)(x)))</span>
<span class="cp">#ifndef UMUL_TIME</span>
<span class="cp">#define UMUL_TIME 40</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef UDIV_TIME</span>
<span class="cp">#define UDIV_TIME 40</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* 80x86 */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  I860  *****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__i860__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define rshift_rhlc(r, h, l, c) \</span>
<span class="cp">	__asm__ (&quot;shr %3,r0,r0\n&quot; \</span>
<span class="cp">	&quot;shrd %1,%2,%0&quot; \</span>
<span class="cp">	   &quot;=r&quot; (r) : &quot;r&quot; (h), &quot;r&quot; (l), &quot;rn&quot; (c))</span>
<span class="cp">#endif </span><span class="cm">/* i860 */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  I960  *****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__i960__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;cmpo 1,0\n&quot; \</span>
<span class="cp">	&quot;addc %5,%4,%1\n&quot; \</span>
<span class="cp">	&quot;addc %3,%2,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%dI&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;dI&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;%dI&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;dI&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;cmpo 0,0\n&quot; \</span>
<span class="cp">	&quot;subc %5,%4,%1\n&quot; \</span>
<span class="cp">	&quot;subc %3,%2,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;dI&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;dI&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;dI&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;dI&quot; ((USItype)(bl)))</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	({union {UDItype __ll; \</span>
<span class="cp">	   struct {USItype __l, __h; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__asm__ (&quot;emul        %2,%1,%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;%dI&quot; ((USItype)(u)), \</span>
<span class="cp">	     &quot;dI&quot; ((USItype)(v))); \</span>
<span class="cp">	(w1) = __xx.__i.__h; (w0) = __xx.__i.__l; })</span>
<span class="cp">#define __umulsidi3(u, v) \</span>
<span class="cp">	({UDItype __w; \</span>
<span class="cp">	__asm__ (&quot;emul      %2,%1,%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; (__w) \</span>
<span class="cp">	: &quot;%dI&quot; ((USItype)(u)), \</span>
<span class="cp">	       &quot;dI&quot; ((USItype)(v))); \</span>
<span class="cp">	__w; })</span>
<span class="cp">#define udiv_qrnnd(q, r, nh, nl, d) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {UDItype __ll; \</span>
<span class="cp">	   struct {USItype __l, __h; } __i; \</span>
<span class="cp">	} __nn; \</span>
<span class="cp">	__nn.__i.__h = (nh); __nn.__i.__l = (nl); \</span>
<span class="cp">	__asm__ (&quot;ediv %d,%n,%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; (__rq.__ll) \</span>
<span class="cp">	: &quot;dI&quot; (__nn.__ll), \</span>
<span class="cp">	     &quot;dI&quot; ((USItype)(d))); \</span>
<span class="cp">	(r) = __rq.__i.__l; (q) = __rq.__i.__h; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">do { \</span>
<span class="cp">	USItype __cbtmp; \</span>
<span class="cp">	__asm__ (&quot;scanbit %1,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__cbtmp) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(x))); \</span>
<span class="cp">	(count) = __cbtmp ^ 31; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define COUNT_LEADING_ZEROS_0 (-32)	</span><span class="cm">/* sic */</span><span class="cp"></span>
<span class="cp">#if defined(__i960mx)		</span><span class="cm">/* what is the proper symbol to test??? */</span><span class="cp"></span>
<span class="cp">#define rshift_rhlc(r, h, l, c) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {UDItype __ll; \</span>
<span class="cp">	   struct {USItype __l, __h; } __i; \</span>
<span class="cp">	} __nn; \</span>
<span class="cp">	__nn.__i.__h = (h); __nn.__i.__l = (l); \</span>
<span class="cp">	__asm__ (&quot;shre %2,%1,%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; (r) : &quot;dI&quot; (__nn.__ll), &quot;dI&quot; (c)); \</span>
<span class="cp">}</span>
<span class="cp">#endif </span><span class="cm">/* i960mx */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* i960 */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  68000	****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if (defined(__mc68000__) || defined(__mc68020__) || defined(__NeXT__) || defined(mc68020)) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;add%.l %5,%1\n&quot; \</span>
<span class="cp">	   &quot;addx%.l %3,%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;d&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;d&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;%1&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;sub%.l %5,%1\n&quot; \</span>
<span class="cp">	   &quot;subx%.l %3,%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;d&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;d&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;1&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#if (defined(__mc68020__) || defined(__NeXT__) || defined(mc68020))</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;mulu%.l %3,%1:%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; ((USItype)(w0)), \</span>
<span class="cp">	     &quot;=d&quot; ((USItype)(w1)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(u)), \</span>
<span class="cp">	     &quot;dmi&quot; ((USItype)(v)))</span>
<span class="cp">#define UMUL_TIME 45</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">	__asm__ (&quot;divu%.l %4,%1:%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; ((USItype)(q)), \</span>
<span class="cp">	     &quot;=d&quot; ((USItype)(r)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(n0)), \</span>
<span class="cp">	     &quot;1&quot; ((USItype)(n1)), \</span>
<span class="cp">	     &quot;dmi&quot; ((USItype)(d)))</span>
<span class="cp">#define UDIV_TIME 90</span>
<span class="cp">#define sdiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">	__asm__ (&quot;divs%.l %4,%1:%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; ((USItype)(q)), \</span>
<span class="cp">	     &quot;=d&quot; ((USItype)(r)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(n0)), \</span>
<span class="cp">	     &quot;1&quot; ((USItype)(n1)), \</span>
<span class="cp">	     &quot;dmi&quot; ((USItype)(d)))</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">	__asm__ (&quot;bfffo %1{%b2:%b2},%0&quot; \</span>
<span class="cp">	: &quot;=d&quot; ((USItype)(count)) \</span>
<span class="cp">	: &quot;od&quot; ((USItype)(x)), &quot;n&quot; (0))</span>
<span class="cp">#define COUNT_LEADING_ZEROS_0 32</span>
<span class="cp">#else </span><span class="cm">/* not mc68020 */</span><span class="cp"></span>
<span class="cp">#define umul_ppmm(xh, xl, a, b) \</span>
<span class="cp">do { USItype __umul_tmp1, __umul_tmp2; \</span>
<span class="cp">	__asm__ (&quot;| Inlined umul_ppmm\n&quot; \</span>
<span class="cp">	&quot;move%.l %5,%3\n&quot; \</span>
<span class="cp">	&quot;move%.l %2,%0\n&quot; \</span>
<span class="cp">	&quot;move%.w %3,%1\n&quot; \</span>
<span class="cp">	&quot;swap	%3\n&quot; \</span>
<span class="cp">	&quot;swap	%0\n&quot; \</span>
<span class="cp">	&quot;mulu	%2,%1\n&quot; \</span>
<span class="cp">	&quot;mulu	%3,%0\n&quot; \</span>
<span class="cp">	&quot;mulu	%2,%3\n&quot; \</span>
<span class="cp">	&quot;swap	%2\n&quot; \</span>
<span class="cp">	&quot;mulu	%5,%2\n&quot; \</span>
<span class="cp">	&quot;add%.l	%3,%2\n&quot; \</span>
<span class="cp">	&quot;jcc	1f\n&quot; \</span>
<span class="cp">	&quot;add%.l	%#0x10000,%0\n&quot; \</span>
<span class="cp">	&quot;1:	move%.l %2,%3\n&quot; \</span>
<span class="cp">	&quot;clr%.w	%2\n&quot; \</span>
<span class="cp">	&quot;swap	%2\n&quot; \</span>
<span class="cp">	&quot;swap	%3\n&quot; \</span>
<span class="cp">	&quot;clr%.w	%3\n&quot; \</span>
<span class="cp">	&quot;add%.l	%3,%1\n&quot; \</span>
<span class="cp">	&quot;addx%.l %2,%0\n&quot; \</span>
<span class="cp">	&quot;| End inlined umul_ppmm&quot; \</span>
<span class="cp">	: &quot;=&amp;d&quot; ((USItype)(xh)), &quot;=&amp;d&quot; ((USItype)(xl)), \</span>
<span class="cp">		&quot;=d&quot; (__umul_tmp1), &quot;=&amp;d&quot; (__umul_tmp2) \</span>
<span class="cp">	: &quot;%2&quot; ((USItype)(a)), &quot;d&quot; ((USItype)(b))); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define UMUL_TIME 100</span>
<span class="cp">#define UDIV_TIME 400</span>
<span class="cp">#endif </span><span class="cm">/* not mc68020 */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* mc68000 */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  88000	****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__m88000__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;addu.co %1,%r4,%r5\n&quot; \</span>
<span class="cp">	   &quot;addu.ci %0,%r2,%r3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%rJ&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;rJ&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;%rJ&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;rJ&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;subu.co %1,%r4,%r5\n&quot; \</span>
<span class="cp">	   &quot;subu.ci %0,%r2,%r3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;rJ&quot; ((USItype)(ah)), \</span>
<span class="cp">	     &quot;rJ&quot; ((USItype)(bh)), \</span>
<span class="cp">	     &quot;rJ&quot; ((USItype)(al)), \</span>
<span class="cp">	     &quot;rJ&quot; ((USItype)(bl)))</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">do { \</span>
<span class="cp">	USItype __cbtmp; \</span>
<span class="cp">	__asm__ (&quot;ff1 %0,%1&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__cbtmp) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(x))); \</span>
<span class="cp">	(count) = __cbtmp ^ 31; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define COUNT_LEADING_ZEROS_0 63	</span><span class="cm">/* sic */</span><span class="cp"></span>
<span class="cp">#if defined(__m88110__)</span>
<span class="cp">#define umul_ppmm(wh, wl, u, v) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {UDItype __ll; \</span>
<span class="cp">	   struct {USItype __h, __l; } __i; \</span>
<span class="cp">	} __x; \</span>
<span class="cp">	__asm__ (&quot;mulu.d %0,%1,%2&quot; : &quot;=r&quot; (__x.__ll) : &quot;r&quot; (u), &quot;r&quot; (v)); \</span>
<span class="cp">	(wh) = __x.__i.__h; \</span>
<span class="cp">	(wl) = __x.__i.__l; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">	({union {UDItype __ll; \</span>
<span class="cp">	   struct {USItype __h, __l; } __i; \</span>
<span class="cp">	} __x, __q; \</span>
<span class="cp">	__x.__i.__h = (n1); __x.__i.__l = (n0); \</span>
<span class="cp">	__asm__ (&quot;divu.d %0,%1,%2&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__q.__ll) : &quot;r&quot; (__x.__ll), &quot;r&quot; (d)); \</span>
<span class="cp">	(r) = (n0) - __q.__l * (d); (q) = __q.__l; })</span>
<span class="cp">#define UMUL_TIME 5</span>
<span class="cp">#define UDIV_TIME 25</span>
<span class="cp">#else</span>
<span class="cp">#define UMUL_TIME 17</span>
<span class="cp">#define UDIV_TIME 150</span>
<span class="cp">#endif </span><span class="cm">/* __m88110__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __m88000__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  MIPS  *****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__mips__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#if __GNUC__ &gt; 2 || __GNUC_MINOR__ &gt;= 7</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;multu %2,%3&quot; \</span>
<span class="cp">	: &quot;=l&quot; ((USItype)(w0)), \</span>
<span class="cp">	     &quot;=h&quot; ((USItype)(w1)) \</span>
<span class="cp">	: &quot;d&quot; ((USItype)(u)), \</span>
<span class="cp">	     &quot;d&quot; ((USItype)(v)))</span>
<span class="cp">#else</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;multu %2,%3\n&quot; \</span>
<span class="cp">	   &quot;mflo %0\n&quot; \</span>
<span class="cp">	   &quot;mfhi %1&quot; \</span>
<span class="cp">	: &quot;=d&quot; ((USItype)(w0)), \</span>
<span class="cp">	     &quot;=d&quot; ((USItype)(w1)) \</span>
<span class="cp">	: &quot;d&quot; ((USItype)(u)), \</span>
<span class="cp">	     &quot;d&quot; ((USItype)(v)))</span>
<span class="cp">#endif</span>
<span class="cp">#define UMUL_TIME 10</span>
<span class="cp">#define UDIV_TIME 100</span>
<span class="cp">#endif </span><span class="cm">/* __mips__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  MIPS/64  **************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if (defined(__mips) &amp;&amp; __mips &gt;= 3) &amp;&amp; W_TYPE_SIZE == 64</span>
<span class="cp">#if __GNUC__ &gt; 2 || __GNUC_MINOR__ &gt;= 7</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;dmultu %2,%3&quot; \</span>
<span class="cp">	: &quot;=l&quot; ((UDItype)(w0)), \</span>
<span class="cp">	     &quot;=h&quot; ((UDItype)(w1)) \</span>
<span class="cp">	: &quot;d&quot; ((UDItype)(u)), \</span>
<span class="cp">	     &quot;d&quot; ((UDItype)(v)))</span>
<span class="cp">#else</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;dmultu %2,%3\n&quot; \</span>
<span class="cp">	   &quot;mflo %0\n&quot; \</span>
<span class="cp">	   &quot;mfhi %1&quot; \</span>
<span class="cp">	: &quot;=d&quot; ((UDItype)(w0)), \</span>
<span class="cp">	     &quot;=d&quot; ((UDItype)(w1)) \</span>
<span class="cp">	: &quot;d&quot; ((UDItype)(u)), \</span>
<span class="cp">	     &quot;d&quot; ((UDItype)(v)))</span>
<span class="cp">#endif</span>
<span class="cp">#define UMUL_TIME 20</span>
<span class="cp">#define UDIV_TIME 140</span>
<span class="cp">#endif </span><span class="cm">/* __mips__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  32000	****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__ns32000__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	({union {UDItype __ll; \</span>
<span class="cp">	   struct {USItype __l, __h; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__asm__ (&quot;meid %2,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(u)), \</span>
<span class="cp">	     &quot;g&quot; ((USItype)(v))); \</span>
<span class="cp">	(w1) = __xx.__i.__h; (w0) = __xx.__i.__l; })</span>
<span class="cp">#define __umulsidi3(u, v) \</span>
<span class="cp">	({UDItype __w; \</span>
<span class="cp">	__asm__ (&quot;meid %2,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; (__w) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(u)), \</span>
<span class="cp">	       &quot;g&quot; ((USItype)(v))); \</span>
<span class="cp">	__w; })</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">	({union {UDItype __ll; \</span>
<span class="cp">	   struct {USItype __l, __h; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__xx.__i.__h = (n1); __xx.__i.__l = (n0); \</span>
<span class="cp">	__asm__ (&quot;deid %2,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;0&quot; (__xx.__ll), \</span>
<span class="cp">	     &quot;g&quot; ((USItype)(d))); \</span>
<span class="cp">	(r) = __xx.__i.__l; (q) = __xx.__i.__h; })</span>
<span class="cp">#define count_trailing_zeros(count, x) \</span>
<span class="cp">do { \</span>
<span class="cp">	__asm__(&quot;ffsd      %2,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot;((USItype) (count)) \</span>
<span class="cp">	: &quot;0&quot;((USItype) 0), &quot;r&quot;((USItype) (x))); \</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* __ns32000__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  PPC  ******************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if (defined(_ARCH_PPC) || defined(_IBMR2)) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">do { \</span>
<span class="cp">	if (__builtin_constant_p(bh) &amp;&amp; (bh) == 0) \</span>
<span class="cp">		__asm__ (&quot;{a%I4|add%I4c} %1,%3,%4\n\t{aze|addze} %0,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">		: &quot;%r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;%r&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bl))); \</span>
<span class="cp">	else if (__builtin_constant_p(bh) &amp;&amp; (bh) == ~(USItype) 0) \</span>
<span class="cp">		__asm__ (&quot;{a%I4|add%I4c} %1,%3,%4\n\t{ame|addme} %0,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">		: &quot;%r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;%r&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bl))); \</span>
<span class="cp">	else \</span>
<span class="cp">		__asm__ (&quot;{a%I5|add%I5c} %1,%4,%5\n\t{ae|adde} %0,%2,%3&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">		: &quot;%r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;%r&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(bl))); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">do { \</span>
<span class="cp">	if (__builtin_constant_p(ah) &amp;&amp; (ah) == 0) \</span>
<span class="cp">		__asm__ (&quot;{sf%I3|subf%I3c} %1,%4,%3\n\t{sfze|subfze} %0,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">		: &quot;r&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(bl))); \</span>
<span class="cp">	else if (__builtin_constant_p(ah) &amp;&amp; (ah) == ~(USItype) 0) \</span>
<span class="cp">		__asm__ (&quot;{sf%I3|subf%I3c} %1,%4,%3\n\t{sfme|subfme} %0,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">		: &quot;r&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(bl))); \</span>
<span class="cp">	else if (__builtin_constant_p(bh) &amp;&amp; (bh) == 0) \</span>
<span class="cp">		__asm__ (&quot;{sf%I3|subf%I3c} %1,%4,%3\n\t{ame|addme} %0,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">		: &quot;r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(bl))); \</span>
<span class="cp">	else if (__builtin_constant_p(bh) &amp;&amp; (bh) == ~(USItype) 0) \</span>
<span class="cp">		__asm__ (&quot;{sf%I3|subf%I3c} %1,%4,%3\n\t{aze|addze} %0,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">		: &quot;r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(bl))); \</span>
<span class="cp">	else \</span>
<span class="cp">		__asm__ (&quot;{sf%I4|subf%I4c} %1,%5,%4\n\t{sfe|subfe} %0,%3,%2&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">		&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">		: &quot;r&quot; ((USItype)(ah)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(bh)), \</span>
<span class="cp">		&quot;rI&quot; ((USItype)(al)), \</span>
<span class="cp">		&quot;r&quot; ((USItype)(bl))); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">	__asm__ (&quot;{cntlz|cntlzw} %0,%1&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(count)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(x)))</span>
<span class="cp">#define COUNT_LEADING_ZEROS_0 32</span>
<span class="cp">#if defined(_ARCH_PPC)</span>
<span class="cp">#define umul_ppmm(ph, pl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">	USItype __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">	__asm__ (&quot;mulhwu %0,%1,%2&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype) ph) \</span>
<span class="cp">	: &quot;%r&quot; (__m0), \</span>
<span class="cp">	&quot;r&quot; (__m1)); \</span>
<span class="cp">	(pl) = __m0 * __m1; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define UMUL_TIME 15</span>
<span class="cp">#define smul_ppmm(ph, pl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">	SItype __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">	__asm__ (&quot;mulhw %0,%1,%2&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((SItype) ph) \</span>
<span class="cp">	: &quot;%r&quot; (__m0), \</span>
<span class="cp">	&quot;r&quot; (__m1)); \</span>
<span class="cp">	(pl) = __m0 * __m1; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define SMUL_TIME 14</span>
<span class="cp">#define UDIV_TIME 120</span>
<span class="cp">#else</span>
<span class="cp">#define umul_ppmm(xh, xl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">	USItype __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">	__asm__ (&quot;mul %0,%2,%3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(xh)), \</span>
<span class="cp">	&quot;=q&quot; ((USItype)(xl)) \</span>
<span class="cp">	: &quot;r&quot; (__m0), \</span>
<span class="cp">	&quot;r&quot; (__m1)); \</span>
<span class="cp">	(xh) += ((((SItype) __m0 &gt;&gt; 31) &amp; __m1) \</span>
<span class="cp">	+ (((SItype) __m1 &gt;&gt; 31) &amp; __m0)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define UMUL_TIME 8</span>
<span class="cp">#define smul_ppmm(xh, xl, m0, m1) \</span>
<span class="cp">	__asm__ (&quot;mul %0,%2,%3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((SItype)(xh)), \</span>
<span class="cp">	&quot;=q&quot; ((SItype)(xl)) \</span>
<span class="cp">	: &quot;r&quot; (m0), \</span>
<span class="cp">	&quot;r&quot; (m1))</span>
<span class="cp">#define SMUL_TIME 4</span>
<span class="cp">#define sdiv_qrnnd(q, r, nh, nl, d) \</span>
<span class="cp">	__asm__ (&quot;div %0,%2,%4&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((SItype)(q)), &quot;=q&quot; ((SItype)(r)) \</span>
<span class="cp">	: &quot;r&quot; ((SItype)(nh)), &quot;1&quot; ((SItype)(nl)), &quot;r&quot; ((SItype)(d)))</span>
<span class="cp">#define UDIV_TIME 100</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* Power architecture variants.  */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  PYR  ******************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__pyr__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;addw        %5,%1\n&quot; \</span>
<span class="cp">	&quot;addwc	%3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(ah)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(bh)), \</span>
<span class="cp">	&quot;%1&quot; ((USItype)(al)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;subw        %5,%1\n&quot; \</span>
<span class="cp">	&quot;subwb	%3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(ah)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(bh)), \</span>
<span class="cp">	&quot;1&quot; ((USItype)(al)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(bl)))</span>
	<span class="cm">/* This insn works on Pyramids with AP, XP, or MI CPUs, but not with SP.  */</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	({union {UDItype __ll; \</span>
<span class="cp">	struct {USItype __h, __l; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__asm__ (&quot;movw %1,%R0\n&quot; \</span>
<span class="cp">	&quot;uemul %2,%0&quot; \</span>
<span class="cp">	: &quot;=&amp;r&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;g&quot; ((USItype) (u)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(v))); \</span>
<span class="cp">	(w1) = __xx.__i.__h; (w0) = __xx.__i.__l; })</span>
<span class="cp">#endif </span><span class="cm">/* __pyr__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  RT/ROMP  **************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__ibm032__) </span><span class="cm">/* RT/ROMP */</span><span class="cp">	&amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;a %1,%5\n&quot; \</span>
<span class="cp">	&quot;ae %0,%3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(ah)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(bh)), \</span>
<span class="cp">	&quot;%1&quot; ((USItype)(al)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;s %1,%5\n&quot; \</span>
<span class="cp">	&quot;se %0,%3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(ah)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(bh)), \</span>
<span class="cp">	&quot;1&quot; ((USItype)(al)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(bl)))</span>
<span class="cp">#define umul_ppmm(ph, pl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">	USItype __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">	__asm__ ( \</span>
<span class="cp">	&quot;s       r2,r2\n&quot; \</span>
<span class="cp">	&quot;mts	r10,%2\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;m	r2,%3\n&quot; \</span>
<span class="cp">	&quot;cas	%0,r2,r0\n&quot; \</span>
<span class="cp">	&quot;mfs	r10,%1&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(ph)), \</span>
<span class="cp">	&quot;=r&quot; ((USItype)(pl)) \</span>
<span class="cp">	: &quot;%r&quot; (__m0), \</span>
<span class="cp">	&quot;r&quot; (__m1) \</span>
<span class="cp">	: &quot;r2&quot;); \</span>
<span class="cp">	(ph) += ((((SItype) __m0 &gt;&gt; 31) &amp; __m1) \</span>
<span class="cp">	+ (((SItype) __m1 &gt;&gt; 31) &amp; __m0)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define UMUL_TIME 20</span>
<span class="cp">#define UDIV_TIME 200</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">do { \</span>
<span class="cp">	if ((x) &gt;= 0x10000) \</span>
<span class="cp">		__asm__ (&quot;clz     %0,%1&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(count)) \</span>
<span class="cp">		: &quot;r&quot; ((USItype)(x) &gt;&gt; 16)); \</span>
<span class="cp">	else { \</span>
<span class="cp">		__asm__ (&quot;clz   %0,%1&quot; \</span>
<span class="cp">		: &quot;=r&quot; ((USItype)(count)) \</span>
<span class="cp">		: &quot;r&quot; ((USItype)(x))); \</span>
<span class="cp">		(count) += 16; \</span>
<span class="cp">	} \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* RT/ROMP */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  SH2  ******************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if (defined(__sh2__) || defined(__sh3__) || defined(__SH4__)) \</span>
<span class="cp">	&amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ ( \</span>
<span class="cp">	&quot;dmulu.l %2,%3\n&quot; \</span>
<span class="cp">	&quot;sts	macl,%1\n&quot; \</span>
<span class="cp">	&quot;sts	mach,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(w1)), \</span>
<span class="cp">	&quot;=r&quot; ((USItype)(w0)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(u)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(v)) \</span>
<span class="cp">	: &quot;macl&quot;, &quot;mach&quot;)</span>
<span class="cp">#define UMUL_TIME 5</span>
<span class="cp">#endif</span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  SPARC	****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__sparc__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;addcc %r4,%5,%1\n&quot; \</span>
<span class="cp">	&quot;addx %r2,%3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%rJ&quot; ((USItype)(ah)), \</span>
<span class="cp">	&quot;rI&quot; ((USItype)(bh)), \</span>
<span class="cp">	&quot;%rJ&quot; ((USItype)(al)), \</span>
<span class="cp">	&quot;rI&quot; ((USItype)(bl)) \</span>
<span class="cp">	__CLOBBER_CC)</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;subcc %r4,%5,%1\n&quot; \</span>
<span class="cp">	&quot;subx %r2,%3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(sh)), \</span>
<span class="cp">	&quot;=&amp;r&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;rJ&quot; ((USItype)(ah)), \</span>
<span class="cp">	&quot;rI&quot; ((USItype)(bh)), \</span>
<span class="cp">	&quot;rJ&quot; ((USItype)(al)), \</span>
<span class="cp">	&quot;rI&quot; ((USItype)(bl)) \</span>
<span class="cp">	__CLOBBER_CC)</span>
<span class="cp">#if defined(__sparc_v8__)</span>
<span class="cm">/* Don&#39;t match immediate range because, 1) it is not often useful,</span>
<span class="cm">	2) the &#39;I&#39; flag thinks of the range as a 13 bit signed interval,</span>
<span class="cm">	while we want to match a 13 bit interval, sign extended to 32 bits,</span>
<span class="cm">	but INTERPRETED AS UNSIGNED.  */</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;umul %2,%3,%1;rd %%y,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(w1)), \</span>
<span class="cp">	&quot;=r&quot; ((USItype)(w0)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(u)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(v)))</span>
<span class="cp">#define UMUL_TIME 5</span>
<span class="cp">#ifndef SUPERSPARC		</span><span class="cm">/* SuperSPARC&#39;s udiv only handles 53 bit dividends */</span><span class="cp"></span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">do { \</span>
<span class="cp">	USItype __q; \</span>
<span class="cp">	__asm__ (&quot;mov %1,%%y;nop;nop;nop;udiv %2,%3,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(__q)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(n1)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(n0)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(d))); \</span>
<span class="cp">	(r) = (n0) - __q * (d); \</span>
<span class="cp">	(q) = __q; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define UDIV_TIME 25</span>
<span class="cp">#endif </span><span class="cm">/* SUPERSPARC */</span><span class="cp"></span>
<span class="cp">#else </span><span class="cm">/* ! __sparc_v8__ */</span><span class="cp"></span>
<span class="cp">#if defined(__sparclite__)</span>
<span class="cm">/* This has hardware multiply but not divide.  It also has two additional</span>
<span class="cm">	instructions scan (ffs from high bit) and divscc.  */</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;umul %2,%3,%1;rd %%y,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(w1)), \</span>
<span class="cp">	&quot;=r&quot; ((USItype)(w0)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(u)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(v)))</span>
<span class="cp">#define UMUL_TIME 5</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">	__asm__ (&quot;! Inlined udiv_qrnnd\n&quot; \</span>
<span class="cp">	&quot;wr	%%g0,%2,%%y	! Not a delayed write for sparclite\n&quot; \</span>
<span class="cp">	&quot;tst	%%g0\n&quot; \</span>
<span class="cp">	&quot;divscc	%3,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%%g1\n&quot; \</span>
<span class="cp">	&quot;divscc	%%g1,%4,%0\n&quot; \</span>
<span class="cp">	&quot;rd	%%y,%1\n&quot; \</span>
<span class="cp">	&quot;bl,a 1f\n&quot; \</span>
<span class="cp">	&quot;add	%1,%4,%1\n&quot; \</span>
<span class="cp">	&quot;1:	! End of inline udiv_qrnnd&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(q)), \</span>
<span class="cp">	&quot;=r&quot; ((USItype)(r)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(n1)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(n0)), \</span>
<span class="cp">	&quot;rI&quot; ((USItype)(d)) \</span>
<span class="cp">	: &quot;%g1&quot; __AND_CLOBBER_CC)</span>
<span class="cp">#define UDIV_TIME 37</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">	__asm__ (&quot;scan %1,0,%0&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(x)) \</span>
<span class="cp">	: &quot;r&quot; ((USItype)(count)))</span>
<span class="cm">/* Early sparclites return 63 for an argument of 0, but they warn that future</span>
<span class="cm">	implementations might change this.  Therefore, leave COUNT_LEADING_ZEROS_0</span>
<span class="cm">	undefined.  */</span>
<span class="cp">#endif </span><span class="cm">/* __sparclite__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __sparc_v8__ */</span><span class="cp"></span>
	<span class="cm">/* Default to sparc v7 versions of umul_ppmm and udiv_qrnnd.  */</span>
<span class="cp">#ifndef umul_ppmm</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">	__asm__ (&quot;! Inlined umul_ppmm\n&quot; \</span>
<span class="cp">	&quot;wr	%%g0,%2,%%y	! SPARC has 0-3 delay insn after a wr\n&quot; \</span>
<span class="cp">	&quot;sra	%3,31,%%g2	! Don&#39;t move this insn\n&quot; \</span>
<span class="cp">	&quot;and	%2,%%g2,%%g2	! Don&#39;t move this insn\n&quot; \</span>
<span class="cp">	&quot;andcc	%%g0,0,%%g1	! Don&#39;t move this insn\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,%3,%%g1\n&quot; \</span>
<span class="cp">	&quot;mulscc	%%g1,0,%%g1\n&quot; \</span>
<span class="cp">	&quot;add	%%g1,%%g2,%0\n&quot; \</span>
<span class="cp">	&quot;rd	%%y,%1&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((USItype)(w1)), \</span>
<span class="cp">	&quot;=r&quot; ((USItype)(w0)) \</span>
<span class="cp">	: &quot;%rI&quot; ((USItype)(u)), \</span>
<span class="cp">	&quot;r&quot; ((USItype)(v)) \</span>
<span class="cp">	: &quot;%g1&quot;, &quot;%g2&quot; __AND_CLOBBER_CC)</span>
<span class="cp">#define UMUL_TIME 39		</span><span class="cm">/* 39 instructions */</span><span class="cp"></span>
<span class="cm">/* It&#39;s quite necessary to add this much assembler for the sparc.</span>
<span class="cm">   The default udiv_qrnnd (in C) is more than 10 times slower!  */</span>
<span class="cp">#define udiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">  __asm__ (&quot;! Inlined udiv_qrnnd\n\t&quot;					\</span>
<span class="cp">	   &quot;mov	32,%%g1\n\t&quot;						\</span>
<span class="cp">	   &quot;subcc	%1,%2,%%g0\n\t&quot;					\</span>
<span class="cp">	   &quot;1:	bcs	5f\n\t&quot;						\</span>
<span class="cp">	   &quot;addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n\t&quot;	\</span>
<span class="cp">	   &quot;sub	%1,%2,%1	! this kills msb of n\n\t&quot;		\</span>
<span class="cp">	   &quot;addx	%1,%1,%1	! so this can&#39;t give carry\n\t&quot;	\</span>
<span class="cp">	   &quot;subcc	%%g1,1,%%g1\n\t&quot;				\</span>
<span class="cp">	   &quot;2:	bne	1b\n\t&quot;						\</span>
<span class="cp">	   &quot;subcc	%1,%2,%%g0\n\t&quot;					\</span>
<span class="cp">	   &quot;bcs	3f\n\t&quot;							\</span>
<span class="cp">	   &quot;addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n\t&quot;	\</span>
<span class="cp">	   &quot;b		3f\n\t&quot;						\</span>
<span class="cp">	   &quot;sub	%1,%2,%1	! this kills msb of n\n\t&quot;		\</span>
<span class="cp">	   &quot;4:	sub	%1,%2,%1\n\t&quot;					\</span>
<span class="cp">	   &quot;5:	addxcc	%1,%1,%1\n\t&quot;					\</span>
<span class="cp">	   &quot;bcc	2b\n\t&quot;							\</span>
<span class="cp">	   &quot;subcc	%%g1,1,%%g1\n\t&quot;				\</span>
<span class="cp">	   &quot;! Got carry from n.  Subtract next step to cancel this carry.\n\t&quot; \</span>
<span class="cp">	   &quot;bne	4b\n\t&quot;							\</span>
<span class="cp">	   &quot;addcc	%0,%0,%0	! shift n1n0 and a 0-bit in lsb\n\t&quot; \</span>
<span class="cp">	   &quot;sub	%1,%2,%1\n\t&quot;						\</span>
<span class="cp">	   &quot;3:	xnor	%0,0,%0\n\t&quot;					\</span>
<span class="cp">	   &quot;! End of inline udiv_qrnnd\n&quot;				\</span>
<span class="cp">	   : &quot;=&amp;r&quot; ((USItype)(q)),					\</span>
<span class="cp">	     &quot;=&amp;r&quot; ((USItype)(r))					\</span>
<span class="cp">	   : &quot;r&quot; ((USItype)(d)),					\</span>
<span class="cp">	     &quot;1&quot; ((USItype)(n1)),					\</span>
<span class="cp">	     &quot;0&quot; ((USItype)(n0)) : &quot;%g1&quot;, &quot;cc&quot;)</span>
<span class="cp">#define UDIV_TIME (3+7*32)      </span><span class="cm">/* 7 instructions/iteration. 32 iterations.  */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* __sparc__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  VAX  ******************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__vax__) &amp;&amp; W_TYPE_SIZE == 32</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;addl2 %5,%1\n&quot; \</span>
<span class="cp">	&quot;adwc %3,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; ((USItype)(sh)), \</span>
<span class="cp">	&quot;=&amp;g&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;%0&quot; ((USItype)(ah)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(bh)), \</span>
<span class="cp">	&quot;%1&quot; ((USItype)(al)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;subl2 %5,%1\n&quot; \</span>
<span class="cp">	&quot;sbwc %3,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; ((USItype)(sh)), \</span>
<span class="cp">	&quot;=&amp;g&quot; ((USItype)(sl)) \</span>
<span class="cp">	: &quot;0&quot; ((USItype)(ah)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(bh)), \</span>
<span class="cp">	&quot;1&quot; ((USItype)(al)), \</span>
<span class="cp">	&quot;g&quot; ((USItype)(bl)))</span>
<span class="cp">#define umul_ppmm(xh, xl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {UDItype __ll; \</span>
<span class="cp">	struct {USItype __l, __h; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	USItype __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">	__asm__ (&quot;emul %1,%2,$0,%0&quot; \</span>
<span class="cp">	: &quot;=g&quot; (__xx.__ll) \</span>
<span class="cp">	: &quot;g&quot; (__m0), \</span>
<span class="cp">	&quot;g&quot; (__m1)); \</span>
<span class="cp">	(xh) = __xx.__i.__h; (xl) = __xx.__i.__l; \</span>
<span class="cp">	(xh) += ((((SItype) __m0 &gt;&gt; 31) &amp; __m1) \</span>
<span class="cp">	+ (((SItype) __m1 &gt;&gt; 31) &amp; __m0)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#define sdiv_qrnnd(q, r, n1, n0, d) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {DItype __ll; \</span>
<span class="cp">	struct {SItype __l, __h; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	__xx.__i.__h = n1; __xx.__i.__l = n0; \</span>
<span class="cp">	__asm__ (&quot;ediv %3,%2,%0,%1&quot; \</span>
<span class="cp">	: &quot;=g&quot; (q), &quot;=g&quot; (r) \</span>
<span class="cp">	: &quot;g&quot; (__xx.__ll), &quot;g&quot; (d)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* __vax__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	**************  Z8000	****************</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if defined(__z8000__) &amp;&amp; W_TYPE_SIZE == 16</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;add %H1,%H5\n\tadc  %H0,%H3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((unsigned int)(sh)), \</span>
<span class="cp">	&quot;=&amp;r&quot; ((unsigned int)(sl)) \</span>
<span class="cp">	: &quot;%0&quot; ((unsigned int)(ah)), \</span>
<span class="cp">	&quot;r&quot; ((unsigned int)(bh)), \</span>
<span class="cp">	&quot;%1&quot; ((unsigned int)(al)), \</span>
<span class="cp">	&quot;rQR&quot; ((unsigned int)(bl)))</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">	__asm__ (&quot;sub %H1,%H5\n\tsbc  %H0,%H3&quot; \</span>
<span class="cp">	: &quot;=r&quot; ((unsigned int)(sh)), \</span>
<span class="cp">	&quot;=&amp;r&quot; ((unsigned int)(sl)) \</span>
<span class="cp">	: &quot;0&quot; ((unsigned int)(ah)), \</span>
<span class="cp">	&quot;r&quot; ((unsigned int)(bh)), \</span>
<span class="cp">	&quot;1&quot; ((unsigned int)(al)), \</span>
<span class="cp">	&quot;rQR&quot; ((unsigned int)(bl)))</span>
<span class="cp">#define umul_ppmm(xh, xl, m0, m1) \</span>
<span class="cp">do { \</span>
<span class="cp">	union {long int __ll; \</span>
<span class="cp">	struct {unsigned int __h, __l; } __i; \</span>
<span class="cp">	} __xx; \</span>
<span class="cp">	unsigned int __m0 = (m0), __m1 = (m1); \</span>
<span class="cp">	__asm__ (&quot;mult      %S0,%H3&quot; \</span>
<span class="cp">	: &quot;=r&quot; (__xx.__i.__h), \</span>
<span class="cp">	&quot;=r&quot; (__xx.__i.__l) \</span>
<span class="cp">	: &quot;%1&quot; (__m0), \</span>
<span class="cp">	&quot;rQR&quot; (__m1)); \</span>
<span class="cp">	(xh) = __xx.__i.__h; (xl) = __xx.__i.__l; \</span>
<span class="cp">	(xh) += ((((signed int) __m0 &gt;&gt; 15) &amp; __m1) \</span>
<span class="cp">	+ (((signed int) __m1 &gt;&gt; 15) &amp; __m0)); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif </span><span class="cm">/* __z8000__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __GNUC__ */</span><span class="cp"></span>

<span class="cm">/***************************************</span>
<span class="cm">	***********  Generic Versions	********</span>
<span class="cm">	***************************************/</span>
<span class="cp">#if !defined(umul_ppmm) &amp;&amp; defined(__umulsidi3)</span>
<span class="cp">#define umul_ppmm(ph, pl, m0, m1) \</span>
<span class="cp">{ \</span>
<span class="cp">	UDWtype __ll = __umulsidi3(m0, m1); \</span>
<span class="cp">	ph = (UWtype) (__ll &gt;&gt; W_TYPE_SIZE); \</span>
<span class="cp">	pl = (UWtype) __ll; \</span>
<span class="cp">}</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(__umulsidi3)</span>
<span class="cp">#define __umulsidi3(u, v) \</span>
<span class="cp">	({UWtype __hi, __lo; \</span>
<span class="cp">	umul_ppmm(__hi, __lo, u, v); \</span>
<span class="cp">	((UDWtype) __hi &lt;&lt; W_TYPE_SIZE) | __lo; })</span>
<span class="cp">#endif</span>

	<span class="cm">/* If this machine has no inline assembler, use C macros.  */</span>

<span class="cp">#if !defined(add_ssaaaa)</span>
<span class="cp">#define add_ssaaaa(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">do { \</span>
<span class="cp">	UWtype __x; \</span>
<span class="cp">	__x = (al) + (bl); \</span>
<span class="cp">	(sh) = (ah) + (bh) + (__x &lt; (al)); \</span>
<span class="cp">	(sl) = __x; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(sub_ddmmss)</span>
<span class="cp">#define sub_ddmmss(sh, sl, ah, al, bh, bl) \</span>
<span class="cp">do { \</span>
<span class="cp">	UWtype __x; \</span>
<span class="cp">	__x = (al) - (bl); \</span>
<span class="cp">	(sh) = (ah) - (bh) - (__x &gt; (al)); \</span>
<span class="cp">	(sl) = __x; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(umul_ppmm)</span>
<span class="cp">#define umul_ppmm(w1, w0, u, v) \</span>
<span class="cp">do { \</span>
<span class="cp">	UWtype __x0, __x1, __x2, __x3; \</span>
<span class="cp">	UHWtype __ul, __vl, __uh, __vh; \</span>
<span class="cp">	UWtype __u = (u), __v = (v); \</span>
<span class="cp">	\</span>
<span class="cp">	__ul = __ll_lowpart(__u); \</span>
<span class="cp">	__uh = __ll_highpart(__u); \</span>
<span class="cp">	__vl = __ll_lowpart(__v); \</span>
<span class="cp">	__vh = __ll_highpart(__v); \</span>
<span class="cp">	\</span>
<span class="cp">	__x0 = (UWtype) __ul * __vl; \</span>
<span class="cp">	__x1 = (UWtype) __ul * __vh; \</span>
<span class="cp">	__x2 = (UWtype) __uh * __vl; \</span>
<span class="cp">	__x3 = (UWtype) __uh * __vh; \</span>
<span class="cp">	\</span>
<span class="cp">	__x1 += __ll_highpart(__x0);</span><span class="cm">/* this can&#39;t give carry */</span><span class="cp"> \</span>
<span class="cp">	__x1 += __x2;		</span><span class="cm">/* but this indeed can */</span><span class="cp"> \</span>
<span class="cp">	if (__x1 &lt; __x2)		</span><span class="cm">/* did we get it? */</span><span class="cp"> \</span>
<span class="cp">	__x3 += __ll_B;		</span><span class="cm">/* yes, add it in the proper pos. */</span><span class="cp"> \</span>
<span class="cp">	\</span>
<span class="cp">	(w1) = __x3 + __ll_highpart(__x1); \</span>
<span class="cp">	(w0) = (__ll_lowpart(__x1) &lt;&lt; W_TYPE_SIZE/2) + __ll_lowpart(__x0); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(umul_ppmm)</span>
<span class="cp">#define smul_ppmm(w1, w0, u, v) \</span>
<span class="cp">do { \</span>
<span class="cp">	UWtype __w1; \</span>
<span class="cp">	UWtype __m0 = (u), __m1 = (v); \</span>
<span class="cp">	umul_ppmm(__w1, w0, __m0, __m1); \</span>
<span class="cp">	(w1) = __w1 - (-(__m0 &gt;&gt; (W_TYPE_SIZE - 1)) &amp; __m1) \</span>
<span class="cp">	- (-(__m1 &gt;&gt; (W_TYPE_SIZE - 1)) &amp; __m0); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

	<span class="cm">/* Define this unconditionally, so it can be used for debugging.  */</span>
<span class="cp">#define __udiv_qrnnd_c(q, r, n1, n0, d) \</span>
<span class="cp">do { \</span>
<span class="cp">	UWtype __d1, __d0, __q1, __q0, __r1, __r0, __m; \</span>
<span class="cp">	__d1 = __ll_highpart(d); \</span>
<span class="cp">	__d0 = __ll_lowpart(d); \</span>
<span class="cp">	\</span>
<span class="cp">	__r1 = (n1) % __d1; \</span>
<span class="cp">	__q1 = (n1) / __d1; \</span>
<span class="cp">	__m = (UWtype) __q1 * __d0; \</span>
<span class="cp">	__r1 = __r1 * __ll_B | __ll_highpart(n0); \</span>
<span class="cp">	if (__r1 &lt; __m) { \</span>
<span class="cp">		__q1--, __r1 += (d); \</span>
<span class="cp">		if (__r1 &gt;= (d)) </span><span class="cm">/* i.e. we didn&#39;t get carry when adding to __r1 */</span><span class="cp"> \</span>
<span class="cp">		if (__r1 &lt; __m) \</span>
<span class="cp">			__q1--, __r1 += (d); \</span>
<span class="cp">	} \</span>
<span class="cp">	__r1 -= __m; \</span>
<span class="cp">	\</span>
<span class="cp">	__r0 = __r1 % __d1; \</span>
<span class="cp">	__q0 = __r1 / __d1; \</span>
<span class="cp">	__m = (UWtype) __q0 * __d0; \</span>
<span class="cp">	__r0 = __r0 * __ll_B | __ll_lowpart(n0); \</span>
<span class="cp">	if (__r0 &lt; __m) { \</span>
<span class="cp">		__q0--, __r0 += (d); \</span>
<span class="cp">		if (__r0 &gt;= (d)) \</span>
<span class="cp">			if (__r0 &lt; __m) \</span>
<span class="cp">				__q0--, __r0 += (d); \</span>
<span class="cp">	} \</span>
<span class="cp">	__r0 -= __m; \</span>
<span class="cp">	\</span>
<span class="cp">	(q) = (UWtype) __q1 * __ll_B | __q0; \</span>
<span class="cp">	(r) = __r0; \</span>
<span class="cp">} while (0)</span>

<span class="cm">/* If the processor has no udiv_qrnnd but sdiv_qrnnd, go through</span>
<span class="cm">	__udiv_w_sdiv (defined in libgcc or elsewhere).  */</span>
<span class="cp">#if !defined(udiv_qrnnd) &amp;&amp; defined(sdiv_qrnnd)</span>
<span class="cp">#define udiv_qrnnd(q, r, nh, nl, d) \</span>
<span class="cp">do { \</span>
<span class="cp">	UWtype __r; \</span>
<span class="cp">	(q) = __MPN(udiv_w_sdiv) (&amp;__r, nh, nl, d); \</span>
<span class="cp">	(r) = __r; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

	<span class="cm">/* If udiv_qrnnd was not defined for this processor, use __udiv_qrnnd_c.  */</span>
<span class="cp">#if !defined(udiv_qrnnd)</span>
<span class="cp">#define UDIV_NEEDS_NORMALIZATION 1</span>
<span class="cp">#define udiv_qrnnd __udiv_qrnnd_c</span>
<span class="cp">#endif</span>

<span class="cp">#undef count_leading_zeros</span>
<span class="cp">#if !defined(count_leading_zeros)</span>
	<span class="k">extern</span>
<span class="cp">#ifdef __STDC__</span>
			<span class="k">const</span>
<span class="cp">#endif</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__clz_tab</span><span class="p">[];</span>
<span class="cp">#define count_leading_zeros(count, x) \</span>
<span class="cp">do { \</span>
<span class="cp">	UWtype __xr = (x); \</span>
<span class="cp">	UWtype __a; \</span>
<span class="cp">	\</span>
<span class="cp">	if (W_TYPE_SIZE &lt;= 32) { \</span>
<span class="cp">		__a = __xr &lt; ((UWtype) 1 &lt;&lt; 2*__BITS4) \</span>
<span class="cp">		? (__xr &lt; ((UWtype) 1 &lt;&lt; __BITS4) ? 0 : __BITS4) \</span>
<span class="cp">		: (__xr &lt; ((UWtype) 1 &lt;&lt; 3*__BITS4) ?  2*__BITS4 : 3*__BITS4); \</span>
<span class="cp">	} \</span>
<span class="cp">	else { \</span>
<span class="cp">		for (__a = W_TYPE_SIZE - 8; __a &gt; 0; __a -= 8) \</span>
<span class="cp">			if (((__xr &gt;&gt; __a) &amp; 0xff) != 0) \</span>
<span class="cp">				break; \</span>
<span class="cp">	} \</span>
<span class="cp">	\</span>
<span class="cp">	(count) = W_TYPE_SIZE - (__clz_tab[__xr &gt;&gt; __a] + __a); \</span>
<span class="cp">} while (0)</span>
	<span class="cm">/* This version gives a well-defined value for zero. */</span>
<span class="cp">#define COUNT_LEADING_ZEROS_0 W_TYPE_SIZE</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(count_trailing_zeros)</span>
<span class="cm">/* Define count_trailing_zeros using count_leading_zeros.  The latter might be</span>
<span class="cm">	defined in asm, but if it is not, the C version above is good enough.  */</span>
<span class="cp">#define count_trailing_zeros(count, x) \</span>
<span class="cp">do { \</span>
<span class="cp">	UWtype __ctz_x = (x); \</span>
<span class="cp">	UWtype __ctz_c; \</span>
<span class="cp">	count_leading_zeros(__ctz_c, __ctz_x &amp; -__ctz_x); \</span>
<span class="cp">	(count) = W_TYPE_SIZE - 1 - __ctz_c; \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef UDIV_NEEDS_NORMALIZATION</span>
<span class="cp">#define UDIV_NEEDS_NORMALIZATION 0</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
