f | tracepoint-sample.c | s | 1.2K | 47 | Arnd Bergmann | arnd@arndb.de | 1287150807 |  | llseek: automatically add .llseek fop  All file_operations should get a .llseek operation so we can make nonseekable_open the default for future file operations without a .llseek pointer.  The three cases that we can automatically detect are no_llseek, seq_lseek and default_llseek. For cases where we can we can automatically prove that the file offset is always ignored, we use noop_llseek, which maintains the current behavior of not returning an error from a seek.  New drivers should normally not use noop_llseek but instead use no_llseek and call nonseekable_open at open time.  Existing drivers can be converted to do the same when the maintainer knows for certain that no user code relies on calling seek on the device file.  The generated code is often incorrectly indented and right now contains comments that clarify for each added line why a specific variant was chosen. In the version that gets submitted upstream, the comments will be gone and I will manually fix the indentation, because there does not seem to be a way to do that using coccinelle.  Some amount of new code is currently sitting in linux-next that should get the same modifications, which I will do at the end of the merge window.  Many thanks to Julia Lawall for helping me learn to write a semantic patch that does all this.  ===== begin semantic patch ===== // This adds an llseek= method to all file operations, // as a preparation for making no_llseek the default. // // The rules are // - use no_llseek explicitly if we do nonseekable_open // - use seq_lseek for sequential files // - use default_llseek if we know we access f_pos // - use noop_llseek if we know we don't access f_pos, //   but we still want to allow users to call lseek // @ open1 exists @ identifier nested_open; @@ nested_open(...) { <+... nonseekable_open(...) ...+> }  @ open exists@ identifier open_f; identifier i, f; identifier open1.nested_open; @@ int open_f(struct inode *i, struct file *f) { <+... ( nonseekable_open(...) || nested_open(...) ) ...+> }  @ read disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { <+... (    *off = E ||    *off += E ||    func(..., off, ...) ||    E = *off ) ...+> }  @ read_no_fpos disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { ... when != off }  @ write @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { <+... (   *off = E ||   *off += E ||   func(..., off, ...) ||   E = *off ) ...+> }  @ write_no_fpos @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { ... when != off }  @ fops0 @ identifier fops; @@ struct file_operations fops = {  ... };  @ has_llseek depends on fops0 @ identifier fops0.fops; identifier llseek_f; @@ struct file_operations fops = { ...  .llseek = llseek_f, ... };  @ has_read depends on fops0 @ identifier fops0.fops; identifier read_f; @@ struct file_operations fops = { ...  .read = read_f, ... };  @ has_write depends on fops0 @ identifier fops0.fops; identifier write_f; @@ struct file_operations fops = { ...  .write = write_f, ... };  @ has_open depends on fops0 @ identifier fops0.fops; identifier open_f; @@ struct file_operations fops = { ...  .open = open_f, ... };  // use no_llseek if we call nonseekable_open //////////////////////////////////////////// @ nonseekable1 depends on !has_llseek && has_open @ identifier fops0.fops; identifier nso ~= "nonseekable_open"; @@ struct file_operations fops = { ...  .open = nso, ... +.llseek = no_llseek, /* nonseekable */ };  @ nonseekable2 depends on !has_llseek @ identifier fops0.fops; identifier open.open_f; @@ struct file_operations fops = { ...  .open = open_f, ... +.llseek = no_llseek, /* open uses nonseekable */ };  // use seq_lseek for sequential files ///////////////////////////////////// @ seq depends on !has_llseek @ identifier fops0.fops; identifier sr ~= "seq_read"; @@ struct file_operations fops = { ...  .read = sr, ... +.llseek = seq_lseek, /* we have seq_read */ };  // use default_llseek if there is a readdir /////////////////////////////////////////// @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier readdir_e; @@ // any other fop is used that changes pos struct file_operations fops = { ... .readdir = readdir_e, ... +.llseek = default_llseek, /* readdir is present */ };  // use default_llseek if at least one of read/write touches f_pos ///////////////////////////////////////////////////////////////// @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read.read_f; @@ // read fops use offset struct file_operations fops = { ... .read = read_f, ... +.llseek = default_llseek, /* read accesses f_pos */ };  @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write.write_f; @@ // write fops use offset struct file_operations fops = { ... .write = write_f, ... +	.llseek = default_llseek, /* write accesses f_pos */ };  // Use noop_llseek if neither read nor write accesses f_pos ///////////////////////////////////////////////////////////  @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; identifier write_no_fpos.write_f; @@ // write fops use offset struct file_operations fops = { ...  .write = write_f,  .read = read_f, ... +.llseek = noop_llseek, /* read and write both use no f_pos */ };  @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write_no_fpos.write_f; @@ struct file_operations fops = { ... .write = write_f, ... +.llseek = noop_llseek, /* write uses no f_pos */ };  @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; @@ struct file_operations fops = { ... .read = read_f, ... +.llseek = noop_llseek, /* read uses no f_pos */ };  @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; @@ struct file_operations fops = { ... +.llseek = noop_llseek, /* no read or write fn */ }; ===== End semantic patch =====  Signed-off-by: Arnd Bergmann <arnd@arndb.de> Cc: Julia Lawall <julia@diku.dk> Cc: Christoph Hellwig <hch@infradead.org>
f | tracepoint-probe-sample.c | s | 1.3K | 47 | Steven Rostedt | srostedt@redhat.com | 1273845034 |  | tracing: Let tracepoints have data passed to tracepoint callbacks  This patch adds data to be passed to tracepoint callbacks.  The created functions from DECLARE_TRACE() now need a mandatory data parameter. For example:  DECLARE_TRACE(mytracepoint, int value, value)  Will create the register function:  int register_trace_mytracepoint((void(*)(void *data, int value))probe,                                 void *data);  As the first argument, all callbacks (probes) must take a (void *data) parameter. So a callback for the above tracepoint will look like:  void myprobe(void *data, int value) { }  The callback may choose to ignore the data parameter.  This change allows callbacks to register a private data pointer along with the function probe.  	void mycallback(void *data, int value);  	register_trace_mytracepoint(mycallback, mydata);  Then the mycallback() will receive the "mydata" as the first parameter before the args.  A more detailed example:    DECLARE_TRACE(mytracepoint, TP_PROTO(int status), TP_ARGS(status));    /* In the C file */    DEFINE_TRACE(mytracepoint, TP_PROTO(int status), TP_ARGS(status));    [...]         trace_mytracepoint(status);    /* In a file registering this tracepoint */    int my_callback(void *data, int status)   { 	struct my_struct my_data = data; 	[...]   }    [...] 	my_data = kmalloc(sizeof(*my_data), GFP_KERNEL); 	init_my_data(my_data); 	register_trace_mytracepoint(my_callback, my_data);  The same callback can also be registered to the same tracepoint as long as the data registered is different. Note, the data must also be used to unregister the callback:  	unregister_trace_mytracepoint(my_callback, my_data);  Because of the data parameter, tracepoints declared this way can not have no args. That is:    DECLARE_TRACE(mytracepoint, TP_PROTO(void), TP_ARGS());  will cause an error.  If no arguments are needed, a new macro can be used instead:    DECLARE_TRACE_NOARGS(mytracepoint);  Since there are no arguments, the proto and args fields are left out.  This is part of a series to make the tracepoint footprint smaller:     text	   data	    bss	    dec	    hex	filename 4913961	1088356	 861512	6863829	 68bbd5	vmlinux.orig 4914025	1088868	 861512	6864405	 68be15	vmlinux.class 4918492	1084612	 861512	6864616	 68bee8	vmlinux.tracepoint  Again, this patch also increases the size of the kernel, but lays the ground work for decreasing it.   v5: Fixed net/core/drop_monitor.c to handle these updates.   v4: Moved the DECLARE_TRACE() DECLARE_TRACE_NOARGS out of the      #ifdef CONFIG_TRACE_POINTS, since the two are the same in both      cases. The __DECLARE_TRACE() is what changes.      Thanks to Frederic Weisbecker for pointing this out.   v3: Made all register_* functions require data to be passed and      all callbacks to take a void * parameter as its first argument.      This makes the calling functions comply with C standards.       Also added more comments to the modifications of DECLARE_TRACE().   v2: Made the DECLARE_TRACE() have the ability to pass arguments      and added a new DECLARE_TRACE_NOARGS() for tracepoints that      do not need any arguments.  Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com> Acked-by: Masami Hiramatsu <mhiramat@redhat.com> Acked-by: Frederic Weisbecker <fweisbec@gmail.com> Cc: Neil Horman <nhorman@tuxdriver.com> Cc: David S. Miller <davem@davemloft.net> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | tracepoint-probe-sample2.c | s | 963B | 35 | Steven Rostedt | srostedt@redhat.com | 1273845034 |  | tracing: Let tracepoints have data passed to tracepoint callbacks  This patch adds data to be passed to tracepoint callbacks.  The created functions from DECLARE_TRACE() now need a mandatory data parameter. For example:  DECLARE_TRACE(mytracepoint, int value, value)  Will create the register function:  int register_trace_mytracepoint((void(*)(void *data, int value))probe,                                 void *data);  As the first argument, all callbacks (probes) must take a (void *data) parameter. So a callback for the above tracepoint will look like:  void myprobe(void *data, int value) { }  The callback may choose to ignore the data parameter.  This change allows callbacks to register a private data pointer along with the function probe.  	void mycallback(void *data, int value);  	register_trace_mytracepoint(mycallback, mydata);  Then the mycallback() will receive the "mydata" as the first parameter before the args.  A more detailed example:    DECLARE_TRACE(mytracepoint, TP_PROTO(int status), TP_ARGS(status));    /* In the C file */    DEFINE_TRACE(mytracepoint, TP_PROTO(int status), TP_ARGS(status));    [...]         trace_mytracepoint(status);    /* In a file registering this tracepoint */    int my_callback(void *data, int status)   { 	struct my_struct my_data = data; 	[...]   }    [...] 	my_data = kmalloc(sizeof(*my_data), GFP_KERNEL); 	init_my_data(my_data); 	register_trace_mytracepoint(my_callback, my_data);  The same callback can also be registered to the same tracepoint as long as the data registered is different. Note, the data must also be used to unregister the callback:  	unregister_trace_mytracepoint(my_callback, my_data);  Because of the data parameter, tracepoints declared this way can not have no args. That is:    DECLARE_TRACE(mytracepoint, TP_PROTO(void), TP_ARGS());  will cause an error.  If no arguments are needed, a new macro can be used instead:    DECLARE_TRACE_NOARGS(mytracepoint);  Since there are no arguments, the proto and args fields are left out.  This is part of a series to make the tracepoint footprint smaller:     text	   data	    bss	    dec	    hex	filename 4913961	1088356	 861512	6863829	 68bbd5	vmlinux.orig 4914025	1088868	 861512	6864405	 68be15	vmlinux.class 4918492	1084612	 861512	6864616	 68bee8	vmlinux.tracepoint  Again, this patch also increases the size of the kernel, but lays the ground work for decreasing it.   v5: Fixed net/core/drop_monitor.c to handle these updates.   v4: Moved the DECLARE_TRACE() DECLARE_TRACE_NOARGS out of the      #ifdef CONFIG_TRACE_POINTS, since the two are the same in both      cases. The __DECLARE_TRACE() is what changes.      Thanks to Frederic Weisbecker for pointing this out.   v3: Made all register_* functions require data to be passed and      all callbacks to take a void * parameter as its first argument.      This makes the calling functions comply with C standards.       Also added more comments to the modifications of DECLARE_TRACE().   v2: Made the DECLARE_TRACE() have the ability to pass arguments      and added a new DECLARE_TRACE_NOARGS() for tracepoints that      do not need any arguments.  Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com> Acked-by: Masami Hiramatsu <mhiramat@redhat.com> Acked-by: Frederic Weisbecker <fweisbec@gmail.com> Cc: Neil Horman <nhorman@tuxdriver.com> Cc: David S. Miller <davem@davemloft.net> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
f | Makefile | g | 284B |  | Mathieu Desnoyers | mathieu.desnoyers@polymtl.ca | 1223972945 |  | tracing: tracepoints, samples  Tracepoint example code under samples/.  Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca> Acked-by: 'Peter Zijlstra' <peterz@infradead.org> Signed-off-by: Ingo Molnar <mingo@elte.hu>
f | tp-samples-trace.h | s | 301B | 9 | Steven Rostedt | srostedt@redhat.com | 1273845034 |  | tracing: Let tracepoints have data passed to tracepoint callbacks  This patch adds data to be passed to tracepoint callbacks.  The created functions from DECLARE_TRACE() now need a mandatory data parameter. For example:  DECLARE_TRACE(mytracepoint, int value, value)  Will create the register function:  int register_trace_mytracepoint((void(*)(void *data, int value))probe,                                 void *data);  As the first argument, all callbacks (probes) must take a (void *data) parameter. So a callback for the above tracepoint will look like:  void myprobe(void *data, int value) { }  The callback may choose to ignore the data parameter.  This change allows callbacks to register a private data pointer along with the function probe.  	void mycallback(void *data, int value);  	register_trace_mytracepoint(mycallback, mydata);  Then the mycallback() will receive the "mydata" as the first parameter before the args.  A more detailed example:    DECLARE_TRACE(mytracepoint, TP_PROTO(int status), TP_ARGS(status));    /* In the C file */    DEFINE_TRACE(mytracepoint, TP_PROTO(int status), TP_ARGS(status));    [...]         trace_mytracepoint(status);    /* In a file registering this tracepoint */    int my_callback(void *data, int status)   { 	struct my_struct my_data = data; 	[...]   }    [...] 	my_data = kmalloc(sizeof(*my_data), GFP_KERNEL); 	init_my_data(my_data); 	register_trace_mytracepoint(my_callback, my_data);  The same callback can also be registered to the same tracepoint as long as the data registered is different. Note, the data must also be used to unregister the callback:  	unregister_trace_mytracepoint(my_callback, my_data);  Because of the data parameter, tracepoints declared this way can not have no args. That is:    DECLARE_TRACE(mytracepoint, TP_PROTO(void), TP_ARGS());  will cause an error.  If no arguments are needed, a new macro can be used instead:    DECLARE_TRACE_NOARGS(mytracepoint);  Since there are no arguments, the proto and args fields are left out.  This is part of a series to make the tracepoint footprint smaller:     text	   data	    bss	    dec	    hex	filename 4913961	1088356	 861512	6863829	 68bbd5	vmlinux.orig 4914025	1088868	 861512	6864405	 68be15	vmlinux.class 4918492	1084612	 861512	6864616	 68bee8	vmlinux.tracepoint  Again, this patch also increases the size of the kernel, but lays the ground work for decreasing it.   v5: Fixed net/core/drop_monitor.c to handle these updates.   v4: Moved the DECLARE_TRACE() DECLARE_TRACE_NOARGS out of the      #ifdef CONFIG_TRACE_POINTS, since the two are the same in both      cases. The __DECLARE_TRACE() is what changes.      Thanks to Frederic Weisbecker for pointing this out.   v3: Made all register_* functions require data to be passed and      all callbacks to take a void * parameter as its first argument.      This makes the calling functions comply with C standards.       Also added more comments to the modifications of DECLARE_TRACE().   v2: Made the DECLARE_TRACE() have the ability to pass arguments      and added a new DECLARE_TRACE_NOARGS() for tracepoints that      do not need any arguments.  Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com> Acked-by: Masami Hiramatsu <mhiramat@redhat.com> Acked-by: Frederic Weisbecker <fweisbec@gmail.com> Cc: Neil Horman <nhorman@tuxdriver.com> Cc: David S. Miller <davem@davemloft.net> Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
