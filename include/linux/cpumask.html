<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › cpumask.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cpumask.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_CPUMASK_H</span>
<span class="cp">#define __LINUX_CPUMASK_H</span>

<span class="cm">/*</span>
<span class="cm"> * Cpumasks provide a bitmap suitable for representing the</span>
<span class="cm"> * set of CPU&#39;s in a system, one bit position per CPU number.  In general,</span>
<span class="cm"> * only nr_cpu_ids (&lt;= NR_CPUS) bits are valid.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="p">{</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">NR_CPUS</span><span class="p">);</span> <span class="p">}</span> <span class="n">cpumask_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_bits - get the bits in a cpumask</span>
<span class="cm"> * @maskp: the struct cpumask *</span>
<span class="cm"> *</span>
<span class="cm"> * You should only assume nr_cpu_ids bits of this mask are valid.  This is</span>
<span class="cm"> * a macro so it&#39;s const-correct.</span>
<span class="cm"> */</span>
<span class="cp">#define cpumask_bits(maskp) ((maskp)-&gt;bits)</span>

<span class="cp">#if NR_CPUS == 1</span>
<span class="cp">#define nr_cpu_ids		1</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CPUMASK_OFFSTACK</span>
<span class="cm">/* Assuming NR_CPUS is huge, a runtime limit is more efficient.  Also,</span>
<span class="cm"> * not all bits may be allocated. */</span>
<span class="cp">#define nr_cpumask_bits	nr_cpu_ids</span>
<span class="cp">#else</span>
<span class="cp">#define nr_cpumask_bits	NR_CPUS</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The following particular system cpumasks and operations manage</span>
<span class="cm"> * possible, present, active and online cpus.</span>
<span class="cm"> *</span>
<span class="cm"> *     cpu_possible_mask- has bit &#39;cpu&#39; set iff cpu is populatable</span>
<span class="cm"> *     cpu_present_mask - has bit &#39;cpu&#39; set iff cpu is populated</span>
<span class="cm"> *     cpu_online_mask  - has bit &#39;cpu&#39; set iff cpu available to scheduler</span>
<span class="cm"> *     cpu_active_mask  - has bit &#39;cpu&#39; set iff cpu available to migration</span>
<span class="cm"> *</span>
<span class="cm"> *  If !CONFIG_HOTPLUG_CPU, present == possible, and active == online.</span>
<span class="cm"> *</span>
<span class="cm"> *  The cpu_possible_mask is fixed at boot time, as the set of CPU id&#39;s</span>
<span class="cm"> *  that it is possible might ever be plugged in at anytime during the</span>
<span class="cm"> *  life of that system boot.  The cpu_present_mask is dynamic(*),</span>
<span class="cm"> *  representing which CPUs are currently plugged in.  And</span>
<span class="cm"> *  cpu_online_mask is the dynamic subset of cpu_present_mask,</span>
<span class="cm"> *  indicating those CPUs available for scheduling.</span>
<span class="cm"> *</span>
<span class="cm"> *  If HOTPLUG is enabled, then cpu_possible_mask is forced to have</span>
<span class="cm"> *  all NR_CPUS bits set, otherwise it is just the set of CPUs that</span>
<span class="cm"> *  ACPI reports present at boot.</span>
<span class="cm"> *</span>
<span class="cm"> *  If HOTPLUG is enabled, then cpu_present_mask varies dynamically,</span>
<span class="cm"> *  depending on what ACPI reports as currently plugged in, otherwise</span>
<span class="cm"> *  cpu_present_mask is just a copy of cpu_possible_mask.</span>
<span class="cm"> *</span>
<span class="cm"> *  (*) Well, cpu_present_mask is dynamic in the hotplug case.  If not</span>
<span class="cm"> *      hotplug, it&#39;s a copy of cpu_possible_mask, hence fixed at boot.</span>
<span class="cm"> *</span>
<span class="cm"> * Subtleties:</span>
<span class="cm"> * 1) UP arch&#39;s (NR_CPUS == 1, CONFIG_SMP not defined) hardcode</span>
<span class="cm"> *    assumption that their single CPU is online.  The UP</span>
<span class="cm"> *    cpu_{online,possible,present}_masks are placebos.  Changing them</span>
<span class="cm"> *    will have no useful affect on the following num_*_cpus()</span>
<span class="cm"> *    and cpu_*() macros in the UP case.  This ugliness is a UP</span>
<span class="cm"> *    optimization - don&#39;t waste any instructions or memory references</span>
<span class="cm"> *    asking if you&#39;re online or how many CPUs there are if there is</span>
<span class="cm"> *    only one CPU.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="k">const</span> <span class="n">cpu_possible_mask</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="k">const</span> <span class="n">cpu_online_mask</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="k">const</span> <span class="n">cpu_present_mask</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="k">const</span> <span class="n">cpu_active_mask</span><span class="p">;</span>

<span class="cp">#if NR_CPUS &gt; 1</span>
<span class="cp">#define num_online_cpus()	cpumask_weight(cpu_online_mask)</span>
<span class="cp">#define num_possible_cpus()	cpumask_weight(cpu_possible_mask)</span>
<span class="cp">#define num_present_cpus()	cpumask_weight(cpu_present_mask)</span>
<span class="cp">#define num_active_cpus()	cpumask_weight(cpu_active_mask)</span>
<span class="cp">#define cpu_online(cpu)		cpumask_test_cpu((cpu), cpu_online_mask)</span>
<span class="cp">#define cpu_possible(cpu)	cpumask_test_cpu((cpu), cpu_possible_mask)</span>
<span class="cp">#define cpu_present(cpu)	cpumask_test_cpu((cpu), cpu_present_mask)</span>
<span class="cp">#define cpu_active(cpu)		cpumask_test_cpu((cpu), cpu_active_mask)</span>
<span class="cp">#else</span>
<span class="cp">#define num_online_cpus()	1U</span>
<span class="cp">#define num_possible_cpus()	1U</span>
<span class="cp">#define num_present_cpus()	1U</span>
<span class="cp">#define num_active_cpus()	1U</span>
<span class="cp">#define cpu_online(cpu)		((cpu) == 0)</span>
<span class="cp">#define cpu_possible(cpu)	((cpu) == 0)</span>
<span class="cp">#define cpu_present(cpu)	((cpu) == 0)</span>
<span class="cp">#define cpu_active(cpu)		((cpu) == 0)</span>
<span class="cp">#endif</span>

<span class="cm">/* verify cpu argument to cpumask_* operators */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_check</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_PER_CPU_MAPS</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PER_CPU_MAPS */</span><span class="cp"></span>
	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if NR_CPUS == 1</span>
<span class="cm">/* Uniprocessor.  Assume all masks are &quot;1&quot;. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_first</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Valid inputs for n are -1 and 0. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_next</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_next_zero</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_next_and</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">andp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* cpu must be a valid cpu, ie 0, so there&#39;s no other choice. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_any_but</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define for_each_cpu(cpu, mask)			\</span>
<span class="cp">	for ((cpu) = 0; (cpu) &lt; 1; (cpu)++, (void)mask)</span>
<span class="cp">#define for_each_cpu_not(cpu, mask)		\</span>
<span class="cp">	for ((cpu) = 0; (cpu) &lt; 1; (cpu)++, (void)mask)</span>
<span class="cp">#define for_each_cpu_and(cpu, mask, and)	\</span>
<span class="cp">	for ((cpu) = 0; (cpu) &lt; 1; (cpu)++, (void)mask, (void)and)</span>
<span class="cp">#else</span>
<span class="cm">/**</span>
<span class="cm"> * cpumask_first - get the first cpu in a cpumask</span>
<span class="cm"> * @srcp: the cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &gt;= nr_cpu_ids if no cpus set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_first</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_next - get the next cpu in a cpumask</span>
<span class="cm"> * @n: the cpu prior to the place to search (ie. return will be &gt; @n)</span>
<span class="cm"> * @srcp: the cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &gt;= nr_cpu_ids if no further cpus set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_next</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* -1 is a legal arg here. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cpumask_check</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_next_zero - get the next unset cpu in a cpumask</span>
<span class="cm"> * @n: the cpu prior to the place to search (ie. return will be &gt; @n)</span>
<span class="cm"> * @srcp: the cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &gt;= nr_cpu_ids if no further cpus unset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_next_zero</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* -1 is a legal arg here. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cpumask_check</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">cpumask_next_and</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cpumask_any_but</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * for_each_cpu - iterate over every cpu in a mask</span>
<span class="cm"> * @cpu: the (optionally unsigned) integer iterator</span>
<span class="cm"> * @mask: the cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * After the loop, cpu is &gt;= nr_cpu_ids.</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_cpu(cpu, mask)				\</span>
<span class="cp">	for ((cpu) = -1;				\</span>
<span class="cp">		(cpu) = cpumask_next((cpu), (mask)),	\</span>
<span class="cp">		(cpu) &lt; nr_cpu_ids;)</span>

<span class="cm">/**</span>
<span class="cm"> * for_each_cpu_not - iterate over every cpu in a complemented mask</span>
<span class="cm"> * @cpu: the (optionally unsigned) integer iterator</span>
<span class="cm"> * @mask: the cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * After the loop, cpu is &gt;= nr_cpu_ids.</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_cpu_not(cpu, mask)				\</span>
<span class="cp">	for ((cpu) = -1;					\</span>
<span class="cp">		(cpu) = cpumask_next_zero((cpu), (mask)),	\</span>
<span class="cp">		(cpu) &lt; nr_cpu_ids;)</span>

<span class="cm">/**</span>
<span class="cm"> * for_each_cpu_and - iterate over every cpu in both masks</span>
<span class="cm"> * @cpu: the (optionally unsigned) integer iterator</span>
<span class="cm"> * @mask: the first cpumask pointer</span>
<span class="cm"> * @and: the second cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * This saves a temporary CPU mask in many places.  It is equivalent to:</span>
<span class="cm"> *	struct cpumask tmp;</span>
<span class="cm"> *	cpumask_and(&amp;tmp, &amp;mask, &amp;and);</span>
<span class="cm"> *	for_each_cpu(cpu, &amp;tmp)</span>
<span class="cm"> *		...</span>
<span class="cm"> *</span>
<span class="cm"> * After the loop, cpu is &gt;= nr_cpu_ids.</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_cpu_and(cpu, mask, and)				\</span>
<span class="cp">	for ((cpu) = -1;						\</span>
<span class="cp">		(cpu) = cpumask_next_and((cpu), (mask), (and)),		\</span>
<span class="cp">		(cpu) &lt; nr_cpu_ids;)</span>
<span class="cp">#endif </span><span class="cm">/* SMP */</span><span class="cp"></span>

<span class="cp">#define CPU_BITS_NONE						\</span>
<span class="cp">{								\</span>
<span class="cp">	[0 ... BITS_TO_LONGS(NR_CPUS)-1] = 0UL			\</span>
<span class="cp">}</span>

<span class="cp">#define CPU_BITS_CPU0						\</span>
<span class="cp">{								\</span>
<span class="cp">	[0] =  1UL						\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_set_cpu - set a cpu in a cpumask</span>
<span class="cm"> * @cpu: cpu number (&lt; nr_cpu_ids)</span>
<span class="cm"> * @dstp: the cpumask pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_set_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">cpumask_check</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_clear_cpu - clear a cpu in a cpumask</span>
<span class="cm"> * @cpu: cpu number (&lt; nr_cpu_ids)</span>
<span class="cm"> * @dstp: the cpumask pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_clear_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">cpumask_check</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_test_cpu - test for a cpu in a cpumask</span>
<span class="cm"> * @cpu: cpu number (&lt; nr_cpu_ids)</span>
<span class="cm"> * @cpumask: the cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * No static inline type checking - see Subtlety (1) above.</span>
<span class="cm"> */</span>
<span class="cp">#define cpumask_test_cpu(cpu, cpumask) \</span>
<span class="cp">	test_bit(cpumask_check(cpu), cpumask_bits((cpumask)))</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_test_and_set_cpu - atomically test and set a cpu in a cpumask</span>
<span class="cm"> * @cpu: cpu number (&lt; nr_cpu_ids)</span>
<span class="cm"> * @cpumask: the cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * test_and_set_bit wrapper for cpumasks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpumask_test_and_set_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">cpumask_check</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">cpumask</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_test_and_clear_cpu - atomically test and clear a cpu in a cpumask</span>
<span class="cm"> * @cpu: cpu number (&lt; nr_cpu_ids)</span>
<span class="cm"> * @cpumask: the cpumask pointer</span>
<span class="cm"> *</span>
<span class="cm"> * test_and_clear_bit wrapper for cpumasks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpumask_test_and_clear_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">cpumask_check</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">cpumask</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_setall - set all cpus (&lt; nr_cpu_ids) in a cpumask</span>
<span class="cm"> * @dstp: the cpumask pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_setall</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_fill</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_clear - clear all cpus (&lt; nr_cpu_ids) in a cpumask</span>
<span class="cm"> * @dstp: the cpumask pointer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_and - *dstp = *src1p &amp; *src2p</span>
<span class="cm"> * @dstp: the cpumask result</span>
<span class="cm"> * @src1p: the first input</span>
<span class="cm"> * @src2p: the second input</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpumask_and</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src2p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_and</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src1p</span><span class="p">),</span>
				       <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src2p</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_or - *dstp = *src1p | *src2p</span>
<span class="cm"> * @dstp: the cpumask result</span>
<span class="cm"> * @src1p: the first input</span>
<span class="cm"> * @src2p: the second input</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_or</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src2p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_or</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src1p</span><span class="p">),</span>
				      <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src2p</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_xor - *dstp = *src1p ^ *src2p</span>
<span class="cm"> * @dstp: the cpumask result</span>
<span class="cm"> * @src1p: the first input</span>
<span class="cm"> * @src2p: the second input</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_xor</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src2p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_xor</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src1p</span><span class="p">),</span>
				       <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src2p</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_andnot - *dstp = *src1p &amp; ~*src2p</span>
<span class="cm"> * @dstp: the cpumask result</span>
<span class="cm"> * @src1p: the first input</span>
<span class="cm"> * @src2p: the second input</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpumask_andnot</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src2p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_andnot</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src1p</span><span class="p">),</span>
					  <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src2p</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_complement - *dstp = ~*srcp</span>
<span class="cm"> * @dstp: the cpumask result</span>
<span class="cm"> * @srcp: the input to invert</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_complement</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_complement</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span>
					      <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_equal - *src1p == *src2p</span>
<span class="cm"> * @src1p: the first input</span>
<span class="cm"> * @src2p: the second input</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpumask_equal</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src2p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_equal</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src1p</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src2p</span><span class="p">),</span>
						 <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_intersects - (*src1p &amp; *src2p) != 0</span>
<span class="cm"> * @src1p: the first input</span>
<span class="cm"> * @src2p: the second input</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpumask_intersects</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src2p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_intersects</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src1p</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src2p</span><span class="p">),</span>
						      <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_subset - (*src1p &amp; ~*src2p) == 0</span>
<span class="cm"> * @src1p: the first input</span>
<span class="cm"> * @src2p: the second input</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpumask_subset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src2p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_subset</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src1p</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">src2p</span><span class="p">),</span>
						  <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_empty - *srcp == 0</span>
<span class="cm"> * @srcp: the cpumask to that all cpus &lt; nr_cpu_ids are clear.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpumask_empty</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_empty</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_full - *srcp == 0xFFFFFFFF...</span>
<span class="cm"> * @srcp: the cpumask to that all cpus &lt; nr_cpu_ids are set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpumask_full</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_full</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_weight - Count of bits in *srcp</span>
<span class="cm"> * @srcp: the cpumask to count bits (&lt; nr_cpu_ids) in.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpumask_weight</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_weight</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_shift_right - *dstp = *srcp &gt;&gt; n</span>
<span class="cm"> * @dstp: the cpumask result</span>
<span class="cm"> * @srcp: the input to shift</span>
<span class="cm"> * @n: the number of bits to shift by</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_shift_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_shift_right</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">n</span><span class="p">,</span>
					       <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_shift_left - *dstp = *srcp &lt;&lt; n</span>
<span class="cm"> * @dstp: the cpumask result</span>
<span class="cm"> * @srcp: the input to shift</span>
<span class="cm"> * @n: the number of bits to shift by</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_shift_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_shift_left</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">n</span><span class="p">,</span>
					      <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_copy - *dstp = *srcp</span>
<span class="cm"> * @dstp: the result</span>
<span class="cm"> * @srcp: the input cpumask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpumask_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_copy</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_any - pick a &quot;random&quot; cpu from *srcp</span>
<span class="cm"> * @srcp: the input cpumask</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &gt;= nr_cpu_ids if no cpus set.</span>
<span class="cm"> */</span>
<span class="cp">#define cpumask_any(srcp) cpumask_first(srcp)</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_first_and - return the first cpu from *srcp1 &amp; *srcp2</span>
<span class="cm"> * @src1p: the first input</span>
<span class="cm"> * @src2p: the second input</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &gt;= nr_cpu_ids if no cpus set in both.  See also cpumask_next_and().</span>
<span class="cm"> */</span>
<span class="cp">#define cpumask_first_and(src1p, src2p) cpumask_next_and(-1, (src1p), (src2p))</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_any_and - pick a &quot;random&quot; cpu from *mask1 &amp; *mask2</span>
<span class="cm"> * @mask1: the first input cpumask</span>
<span class="cm"> * @mask2: the second input cpumask</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &gt;= nr_cpu_ids if no cpus set.</span>
<span class="cm"> */</span>
<span class="cp">#define cpumask_any_and(mask1, mask2) cpumask_first_and((mask1), (mask2))</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_of - the cpumask containing just a given cpu</span>
<span class="cm"> * @cpu: the cpu (&lt;= nr_cpu_ids)</span>
<span class="cm"> */</span>
<span class="cp">#define cpumask_of(cpu) (get_cpu_mask(cpu))</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_scnprintf - print a cpumask into a string as comma-separated hex</span>
<span class="cm"> * @buf: the buffer to sprintf into</span>
<span class="cm"> * @len: the length of the buffer</span>
<span class="cm"> * @srcp: the cpumask to print</span>
<span class="cm"> *</span>
<span class="cm"> * If len is zero, returns zero.  Otherwise returns the length of the</span>
<span class="cm"> * (nul-terminated) @buf string.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpumask_scnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_parse_user - extract a cpumask from a user string</span>
<span class="cm"> * @buf: the buffer to extract from</span>
<span class="cm"> * @len: the length of the buffer</span>
<span class="cm"> * @dstp: the cpumask to set.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -errno, or 0 for success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpumask_parse_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_parse_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_parselist_user - extract a cpumask from a user string</span>
<span class="cm"> * @buf: the buffer to extract from</span>
<span class="cm"> * @len: the length of the buffer</span>
<span class="cm"> * @dstp: the cpumask to set.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -errno, or 0 for success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpumask_parselist_user</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_parselist_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span>
							<span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpulist_scnprintf - print a cpumask into a string as comma-separated list</span>
<span class="cm"> * @buf: the buffer to sprintf into</span>
<span class="cm"> * @len: the length of the buffer</span>
<span class="cm"> * @srcp: the cpumask to print</span>
<span class="cm"> *</span>
<span class="cm"> * If len is zero, returns zero.  Otherwise returns the length of the</span>
<span class="cm"> * (nul-terminated) @buf string.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpulist_scnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_scnlistprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">srcp</span><span class="p">),</span>
				    <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpulist_parse_user - extract a cpumask from a user string of ranges</span>
<span class="cm"> * @buf: the buffer to extract from</span>
<span class="cm"> * @len: the length of the buffer</span>
<span class="cm"> * @dstp: the cpumask to set.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -errno, or 0 for success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cpulist_parse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_parselist</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">cpumask_bits</span><span class="p">(</span><span class="n">dstp</span><span class="p">),</span> <span class="n">nr_cpumask_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cpumask_size - size to allocate for a &#39;struct cpumask&#39; in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * This will eventually be a runtime variable, depending on nr_cpu_ids.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">cpumask_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: Once all cpumask assignments are eliminated, this</span>
<span class="cm">	 * can be nr_cpumask_bits */</span>
	<span class="k">return</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">NR_CPUS</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpumask_var_t: struct cpumask for stack usage.</span>
<span class="cm"> *</span>
<span class="cm"> * Oh, the wicked games we play!  In order to make kernel coding a</span>
<span class="cm"> * little more difficult, we typedef cpumask_var_t to an array or a</span>
<span class="cm"> * pointer: doing &amp;mask on an array is a noop, so it still works.</span>
<span class="cm"> *</span>
<span class="cm"> * ie.</span>
<span class="cm"> *	cpumask_var_t tmpmask;</span>
<span class="cm"> *	if (!alloc_cpumask_var(&amp;tmpmask, GFP_KERNEL))</span>
<span class="cm"> *		return -ENOMEM;</span>
<span class="cm"> *</span>
<span class="cm"> *	  ... use &#39;tmpmask&#39; like a normal struct cpumask * ...</span>
<span class="cm"> *</span>
<span class="cm"> *	free_cpumask_var(tmpmask);</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * However, one notable exception is there. alloc_cpumask_var() allocates</span>
<span class="cm"> * only nr_cpumask_bits bits (in the other hand, real cpumask_t always has</span>
<span class="cm"> * NR_CPUS bits). Therefore you don&#39;t have to dereference cpumask_var_t.</span>
<span class="cm"> *</span>
<span class="cm"> *	cpumask_var_t tmpmask;</span>
<span class="cm"> *	if (!alloc_cpumask_var(&amp;tmpmask, GFP_KERNEL))</span>
<span class="cm"> *		return -ENOMEM;</span>
<span class="cm"> *</span>
<span class="cm"> *	var = *tmpmask;</span>
<span class="cm"> *</span>
<span class="cm"> * This code makes NR_CPUS length memcopy and brings to a memory corruption.</span>
<span class="cm"> * cpumask_copy() provide safe copy functionality.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_CPUMASK_OFFSTACK</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask_var_t</span><span class="p">;</span>

<span class="n">bool</span> <span class="n">alloc_cpumask_var_node</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">zalloc_cpumask_var_node</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_bootmem_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="n">cpumask_var_t</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">alloc_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">alloc_cpumask_var_node</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">zalloc_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">zalloc_cpumask_var_node</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">alloc_bootmem_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_bootmem_cpumask_var</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CPUMASK_OFFSTACK */</span><span class="cp"></span>

<span class="cm">/* It&#39;s common to want to use cpu_all_mask in struct member initializers,</span>
<span class="cm"> * so it has to refer to an address rather than a pointer. */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cpu_all_bits</span><span class="p">,</span> <span class="n">NR_CPUS</span><span class="p">);</span>
<span class="cp">#define cpu_all_mask to_cpumask(cpu_all_bits)</span>

<span class="cm">/* First bits of cpu_bit_bitmap are in fact unset. */</span>
<span class="cp">#define cpu_none_mask to_cpumask(cpu_bit_bitmap[0])</span>

<span class="cp">#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)</span>
<span class="cp">#define for_each_online_cpu(cpu)   for_each_cpu((cpu), cpu_online_mask)</span>
<span class="cp">#define for_each_present_cpu(cpu)  for_each_cpu((cpu), cpu_present_mask)</span>

<span class="cm">/* Wrappers for arch boot code to manipulate normally-constant masks */</span>
<span class="kt">void</span> <span class="n">set_cpu_possible</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">possible</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_cpu_present</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">present</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_cpu_online</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">online</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_cpu_active</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">init_cpu_present</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">init_cpu_possible</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">init_cpu_online</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * to_cpumask - convert an NR_CPUS bitmap to a struct cpumask *</span>
<span class="cm"> * @bitmap: the bitmap</span>
<span class="cm"> *</span>
<span class="cm"> * There are a few places where cpumask_var_t isn&#39;t appropriate and</span>
<span class="cm"> * static cpumasks must be used (eg. very early boot), yet we don&#39;t</span>
<span class="cm"> * expose the definition of &#39;struct cpumask&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * This does the conversion, and can be used as a constant initializer.</span>
<span class="cm"> */</span>
<span class="cp">#define to_cpumask(bitmap)						\</span>
<span class="cp">	((struct cpumask *)(1 ? (bitmap)				\</span>
<span class="cp">			    : (void *)sizeof(__check_is_bitmap(bitmap))))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__check_is_bitmap</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Special-case data structure for &quot;single bit set only&quot; constant CPU masks.</span>
<span class="cm"> *</span>
<span class="cm"> * We pre-generate all the 64 (or 32) possible bit positions, with enough</span>
<span class="cm"> * padding to the left and the right, and return the constant pointer</span>
<span class="cm"> * appropriately offset.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span>
	<span class="n">cpu_bit_bitmap</span><span class="p">[</span><span class="n">BITS_PER_LONG</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">NR_CPUS</span><span class="p">)];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">get_cpu_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_bit_bitmap</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cpu</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">];</span>
	<span class="n">p</span> <span class="o">-=</span> <span class="n">cpu</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpu_is_offline(cpu)	unlikely(!cpu_online(cpu))</span>

<span class="cp">#if NR_CPUS &lt;= BITS_PER_LONG</span>
<span class="cp">#define CPU_BITS_ALL						\</span>
<span class="cp">{								\</span>
<span class="cp">	[BITS_TO_LONGS(NR_CPUS)-1] = CPU_MASK_LAST_WORD	\</span>
<span class="cp">}</span>

<span class="cp">#else </span><span class="cm">/* NR_CPUS &gt; BITS_PER_LONG */</span><span class="cp"></span>

<span class="cp">#define CPU_BITS_ALL						\</span>
<span class="cp">{								\</span>
<span class="cp">	[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,		\</span>
<span class="cp">	[BITS_TO_LONGS(NR_CPUS)-1] = CPU_MASK_LAST_WORD		\</span>
<span class="cp">}</span>
<span class="cp">#endif </span><span class="cm">/* NR_CPUS &gt; BITS_PER_LONG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * From here down, all obsolete.  Use cpumask_ variants!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_DISABLE_OBSOLETE_CPUMASK_FUNCTIONS</span>
<span class="cp">#define cpumask_of_cpu(cpu) (*get_cpu_mask(cpu))</span>

<span class="cp">#define CPU_MASK_LAST_WORD BITMAP_LAST_WORD_MASK(NR_CPUS)</span>

<span class="cp">#if NR_CPUS &lt;= BITS_PER_LONG</span>

<span class="cp">#define CPU_MASK_ALL							\</span>
<span class="cp">(cpumask_t) { {								\</span>
<span class="cp">	[BITS_TO_LONGS(NR_CPUS)-1] = CPU_MASK_LAST_WORD			\</span>
<span class="cp">} }</span>

<span class="cp">#else</span>

<span class="cp">#define CPU_MASK_ALL							\</span>
<span class="cp">(cpumask_t) { {								\</span>
<span class="cp">	[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,			\</span>
<span class="cp">	[BITS_TO_LONGS(NR_CPUS)-1] = CPU_MASK_LAST_WORD			\</span>
<span class="cp">} }</span>

<span class="cp">#endif</span>

<span class="cp">#define CPU_MASK_NONE							\</span>
<span class="cp">(cpumask_t) { {								\</span>
<span class="cp">	[0 ... BITS_TO_LONGS(NR_CPUS)-1] =  0UL				\</span>
<span class="cp">} }</span>

<span class="cp">#define CPU_MASK_CPU0							\</span>
<span class="cp">(cpumask_t) { {								\</span>
<span class="cp">	[0] =  1UL							\</span>
<span class="cp">} }</span>

<span class="cp">#if NR_CPUS == 1</span>
<span class="cp">#define first_cpu(src)		({ (void)(src); 0; })</span>
<span class="cp">#define next_cpu(n, src)	({ (void)(src); 1; })</span>
<span class="cp">#define any_online_cpu(mask)	0</span>
<span class="cp">#define for_each_cpu_mask(cpu, mask)	\</span>
<span class="cp">	for ((cpu) = 0; (cpu) &lt; 1; (cpu)++, (void)mask)</span>
<span class="cp">#else </span><span class="cm">/* NR_CPUS &gt; 1 */</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">__first_cpu</span><span class="p">(</span><span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__next_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">);</span>

<span class="cp">#define first_cpu(src)		__first_cpu(&amp;(src))</span>
<span class="cp">#define next_cpu(n, src)	__next_cpu((n), &amp;(src))</span>
<span class="cp">#define any_online_cpu(mask) cpumask_any_and(&amp;mask, cpu_online_mask)</span>
<span class="cp">#define for_each_cpu_mask(cpu, mask)			\</span>
<span class="cp">	for ((cpu) = -1;				\</span>
<span class="cp">		(cpu) = next_cpu((cpu), (mask)),	\</span>
<span class="cp">		(cpu) &lt; NR_CPUS; )</span>
<span class="cp">#endif </span><span class="cm">/* SMP */</span><span class="cp"></span>

<span class="cp">#if NR_CPUS &lt;= 64</span>

<span class="cp">#define for_each_cpu_mask_nr(cpu, mask)	for_each_cpu_mask(cpu, mask)</span>

<span class="cp">#else </span><span class="cm">/* NR_CPUS &gt; 64 */</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">__next_cpu_nr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">);</span>
<span class="cp">#define for_each_cpu_mask_nr(cpu, mask)			\</span>
<span class="cp">	for ((cpu) = -1;				\</span>
<span class="cp">		(cpu) = __next_cpu_nr((cpu), &amp;(mask)),	\</span>
<span class="cp">		(cpu) &lt; nr_cpu_ids; )</span>

<span class="cp">#endif </span><span class="cm">/* NR_CPUS &gt; 64 */</span><span class="cp"></span>

<span class="cp">#define cpus_addr(src) ((src).bits)</span>

<span class="cp">#define cpu_set(cpu, dst) __cpu_set((cpu), &amp;(dst))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cpu_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">volatile</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpu_clear(cpu, dst) __cpu_clear((cpu), &amp;(dst))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cpu_clear</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">volatile</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_setall(dst) __cpus_setall(&amp;(dst), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cpus_setall</span><span class="p">(</span><span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_fill</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_clear(dst) __cpus_clear(&amp;(dst), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cpus_clear</span><span class="p">(</span><span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* No static inline type checking - see Subtlety (1) above. */</span>
<span class="cp">#define cpu_isset(cpu, cpumask) test_bit((cpu), (cpumask).bits)</span>

<span class="cp">#define cpu_test_and_set(cpu, cpumask) __cpu_test_and_set((cpu), &amp;(cpumask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cpu_test_and_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_and(dst, src1, src2) __cpus_and(&amp;(dst), &amp;(src1), &amp;(src2), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cpus_and</span><span class="p">(</span><span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_and</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_or(dst, src1, src2) __cpus_or(&amp;(dst), &amp;(src1), &amp;(src2), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cpus_or</span><span class="p">(</span><span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_or</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_xor(dst, src1, src2) __cpus_xor(&amp;(dst), &amp;(src1), &amp;(src2), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cpus_xor</span><span class="p">(</span><span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_xor</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_andnot(dst, src1, src2) \</span>
<span class="cp">				__cpus_andnot(&amp;(dst), &amp;(src1), &amp;(src2), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cpus_andnot</span><span class="p">(</span><span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_andnot</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_equal(src1, src2) __cpus_equal(&amp;(src1), &amp;(src2), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cpus_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_equal</span><span class="p">(</span><span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_intersects(src1, src2) __cpus_intersects(&amp;(src1), &amp;(src2), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cpus_intersects</span><span class="p">(</span><span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_intersects</span><span class="p">(</span><span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_subset(src1, src2) __cpus_subset(&amp;(src1), &amp;(src2), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cpus_subset</span><span class="p">(</span><span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src1p</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">src2p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_subset</span><span class="p">(</span><span class="n">src1p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">src2p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_empty(src) __cpus_empty(&amp;(src), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cpus_empty</span><span class="p">(</span><span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_empty</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_weight(cpumask) __cpus_weight(&amp;(cpumask), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__cpus_weight</span><span class="p">(</span><span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bitmap_weight</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cpus_shift_left(dst, src, n) \</span>
<span class="cp">			__cpus_shift_left(&amp;(dst), &amp;(src), (n), NR_CPUS)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cpus_shift_left</span><span class="p">(</span><span class="n">cpumask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_shift_left</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbits</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_DISABLE_OBSOLETE_CPUMASK_FUNCTIONS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_CPUMASK_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
