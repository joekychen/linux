<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › dmaengine.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dmaengine.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 2004 - 2006 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> * Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> * Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in the</span>
<span class="cm"> * file called COPYING.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef LINUX_DMAENGINE_H</span>
<span class="cp">#define LINUX_DMAENGINE_H</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * typedef dma_cookie_t - an opaque DMA cookie</span>
<span class="cm"> *</span>
<span class="cm"> * if dma_cookie_t is &gt;0 it&#39;s a DMA request cookie, &lt;0 it&#39;s an error code</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">s32</span> <span class="n">dma_cookie_t</span><span class="p">;</span>
<span class="cp">#define DMA_MIN_COOKIE	1</span>
<span class="cp">#define DMA_MAX_COOKIE	INT_MAX</span>

<span class="cp">#define dma_submit_error(cookie) ((cookie) &lt; 0 ? 1 : 0)</span>

<span class="cm">/**</span>
<span class="cm"> * enum dma_status - DMA transaction status</span>
<span class="cm"> * @DMA_SUCCESS: transaction completed successfully</span>
<span class="cm"> * @DMA_IN_PROGRESS: transaction not yet processed</span>
<span class="cm"> * @DMA_PAUSED: transaction is paused</span>
<span class="cm"> * @DMA_ERROR: transaction failed</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dma_status</span> <span class="p">{</span>
	<span class="n">DMA_SUCCESS</span><span class="p">,</span>
	<span class="n">DMA_IN_PROGRESS</span><span class="p">,</span>
	<span class="n">DMA_PAUSED</span><span class="p">,</span>
	<span class="n">DMA_ERROR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum dma_transaction_type - DMA transaction types/indexes</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The DMA_ASYNC_TX capability is not to be set by drivers.  It is</span>
<span class="cm"> * automatically set as dma devices are registered.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dma_transaction_type</span> <span class="p">{</span>
	<span class="n">DMA_MEMCPY</span><span class="p">,</span>
	<span class="n">DMA_XOR</span><span class="p">,</span>
	<span class="n">DMA_PQ</span><span class="p">,</span>
	<span class="n">DMA_XOR_VAL</span><span class="p">,</span>
	<span class="n">DMA_PQ_VAL</span><span class="p">,</span>
	<span class="n">DMA_MEMSET</span><span class="p">,</span>
	<span class="n">DMA_INTERRUPT</span><span class="p">,</span>
	<span class="n">DMA_SG</span><span class="p">,</span>
	<span class="n">DMA_PRIVATE</span><span class="p">,</span>
	<span class="n">DMA_ASYNC_TX</span><span class="p">,</span>
	<span class="n">DMA_SLAVE</span><span class="p">,</span>
	<span class="n">DMA_CYCLIC</span><span class="p">,</span>
	<span class="n">DMA_INTERLEAVE</span><span class="p">,</span>
<span class="cm">/* last transaction type for creation of the capabilities mask */</span>
	<span class="n">DMA_TX_TYPE_END</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum dma_transfer_direction - dma transfer mode and direction indicator</span>
<span class="cm"> * @DMA_MEM_TO_MEM: Async/Memcpy mode</span>
<span class="cm"> * @DMA_MEM_TO_DEV: Slave mode &amp; From Memory to Device</span>
<span class="cm"> * @DMA_DEV_TO_MEM: Slave mode &amp; From Device to Memory</span>
<span class="cm"> * @DMA_DEV_TO_DEV: Slave mode &amp; From Device to Device</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="p">{</span>
	<span class="n">DMA_MEM_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_MEM_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_DEV_TO_MEM</span><span class="p">,</span>
	<span class="n">DMA_DEV_TO_DEV</span><span class="p">,</span>
	<span class="n">DMA_TRANS_NONE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Interleaved Transfer Request</span>
<span class="cm"> * ----------------------------</span>
<span class="cm"> * A chunk is collection of contiguous bytes to be transfered.</span>
<span class="cm"> * The gap(in bytes) between two chunks is called inter-chunk-gap(ICG).</span>
<span class="cm"> * ICGs may or maynot change between chunks.</span>
<span class="cm"> * A FRAME is the smallest series of contiguous {chunk,icg} pairs,</span>
<span class="cm"> *  that when repeated an integral number of times, specifies the transfer.</span>
<span class="cm"> * A transfer template is specification of a Frame, the number of times</span>
<span class="cm"> *  it is to be repeated and other per-transfer attributes.</span>
<span class="cm"> *</span>
<span class="cm"> * Practically, a client driver would have ready a template for each</span>
<span class="cm"> *  type of transfer it is going to need during its lifetime and</span>
<span class="cm"> *  set only &#39;src_start&#39; and &#39;dst_start&#39; before submitting the requests.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  |      Frame-1        |       Frame-2       | ~ |       Frame-&#39;numf&#39;  |</span>
<span class="cm"> *  |====....==.===...=...|====....==.===...=...| ~ |====....==.===...=...|</span>
<span class="cm"> *</span>
<span class="cm"> *    ==  Chunk size</span>
<span class="cm"> *    ... ICG</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct data_chunk - Element of scatter-gather list that makes a frame.</span>
<span class="cm"> * @size: Number of bytes to read from source.</span>
<span class="cm"> *	  size_dst := fn(op, size_src), so doesn&#39;t mean much for destination.</span>
<span class="cm"> * @icg: Number of bytes to jump after last src/dst address of this</span>
<span class="cm"> *	 chunk and before first src/dst address for next chunk.</span>
<span class="cm"> *	 Ignored for dst(assumed 0), if dst_inc is true and dst_sgl is false.</span>
<span class="cm"> *	 Ignored for src(assumed 0), if src_inc is true and src_sgl is false.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">data_chunk</span> <span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">icg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_interleaved_template - Template to convey DMAC the transfer pattern</span>
<span class="cm"> *	 and attributes.</span>
<span class="cm"> * @src_start: Bus address of source for the first chunk.</span>
<span class="cm"> * @dst_start: Bus address of destination for the first chunk.</span>
<span class="cm"> * @dir: Specifies the type of Source and Destination.</span>
<span class="cm"> * @src_inc: If the source address increments after reading from it.</span>
<span class="cm"> * @dst_inc: If the destination address increments after writing to it.</span>
<span class="cm"> * @src_sgl: If the &#39;icg&#39; of sgl[] applies to Source (scattered read).</span>
<span class="cm"> *		Otherwise, source is read contiguously (icg ignored).</span>
<span class="cm"> *		Ignored if src_inc is false.</span>
<span class="cm"> * @dst_sgl: If the &#39;icg&#39; of sgl[] applies to Destination (scattered write).</span>
<span class="cm"> *		Otherwise, destination is filled contiguously (icg ignored).</span>
<span class="cm"> *		Ignored if dst_inc is false.</span>
<span class="cm"> * @numf: Number of frames in this template.</span>
<span class="cm"> * @frame_size: Number of chunks in a frame i.e, size of sgl[].</span>
<span class="cm"> * @sgl: Array of {chunk,icg} pairs that make up a frame.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_interleaved_template</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">src_start</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dst_start</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">dir</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">src_inc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dst_inc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">src_sgl</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dst_sgl</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">numf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">frame_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">data_chunk</span> <span class="n">sgl</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum dma_ctrl_flags - DMA flags to augment operation preparation,</span>
<span class="cm"> *  control completion, and communicate status.</span>
<span class="cm"> * @DMA_PREP_INTERRUPT - trigger an interrupt (callback) upon completion of</span>
<span class="cm"> *  this transaction</span>
<span class="cm"> * @DMA_CTRL_ACK - if clear, the descriptor cannot be reused until the client</span>
<span class="cm"> *  acknowledges receipt, i.e. has has a chance to establish any dependency</span>
<span class="cm"> *  chains</span>
<span class="cm"> * @DMA_COMPL_SKIP_SRC_UNMAP - set to disable dma-unmapping the source buffer(s)</span>
<span class="cm"> * @DMA_COMPL_SKIP_DEST_UNMAP - set to disable dma-unmapping the destination(s)</span>
<span class="cm"> * @DMA_COMPL_SRC_UNMAP_SINGLE - set to do the source dma-unmapping as single</span>
<span class="cm"> * 	(if not set, do the source dma-unmapping as page)</span>
<span class="cm"> * @DMA_COMPL_DEST_UNMAP_SINGLE - set to do the destination dma-unmapping as single</span>
<span class="cm"> * 	(if not set, do the destination dma-unmapping as page)</span>
<span class="cm"> * @DMA_PREP_PQ_DISABLE_P - prevent generation of P while generating Q</span>
<span class="cm"> * @DMA_PREP_PQ_DISABLE_Q - prevent generation of Q while generating P</span>
<span class="cm"> * @DMA_PREP_CONTINUE - indicate to a driver that it is reusing buffers as</span>
<span class="cm"> *  sources that were the result of a previous operation, in the case of a PQ</span>
<span class="cm"> *  operation it continues the calculation with new sources</span>
<span class="cm"> * @DMA_PREP_FENCE - tell the driver that subsequent operations depend</span>
<span class="cm"> *  on the result of this operation</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dma_ctrl_flags</span> <span class="p">{</span>
	<span class="n">DMA_PREP_INTERRUPT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DMA_CTRL_ACK</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">DMA_COMPL_SKIP_SRC_UNMAP</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">DMA_COMPL_SKIP_DEST_UNMAP</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">DMA_COMPL_SRC_UNMAP_SINGLE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="n">DMA_COMPL_DEST_UNMAP_SINGLE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="n">DMA_PREP_PQ_DISABLE_P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
	<span class="n">DMA_PREP_PQ_DISABLE_Q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
	<span class="n">DMA_PREP_CONTINUE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	<span class="n">DMA_PREP_FENCE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum dma_ctrl_cmd - DMA operations that can optionally be exercised</span>
<span class="cm"> * on a running channel.</span>
<span class="cm"> * @DMA_TERMINATE_ALL: terminate all ongoing transfers</span>
<span class="cm"> * @DMA_PAUSE: pause ongoing transfers</span>
<span class="cm"> * @DMA_RESUME: resume paused transfer</span>
<span class="cm"> * @DMA_SLAVE_CONFIG: this command is only implemented by DMA controllers</span>
<span class="cm"> * that need to runtime reconfigure the slave channels (as opposed to passing</span>
<span class="cm"> * configuration data in statically from the platform). An additional</span>
<span class="cm"> * argument of struct dma_slave_config must be passed in with this</span>
<span class="cm"> * command.</span>
<span class="cm"> * @FSLDMA_EXTERNAL_START: this command will put the Freescale DMA controller</span>
<span class="cm"> * into external start mode.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dma_ctrl_cmd</span> <span class="p">{</span>
	<span class="n">DMA_TERMINATE_ALL</span><span class="p">,</span>
	<span class="n">DMA_PAUSE</span><span class="p">,</span>
	<span class="n">DMA_RESUME</span><span class="p">,</span>
	<span class="n">DMA_SLAVE_CONFIG</span><span class="p">,</span>
	<span class="n">FSLDMA_EXTERNAL_START</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum sum_check_bits - bit position of pq_check_flags</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sum_check_bits</span> <span class="p">{</span>
	<span class="n">SUM_CHECK_P</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SUM_CHECK_Q</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum pq_check_flags - result of async_{xor,pq}_zero_sum operations</span>
<span class="cm"> * @SUM_CHECK_P_RESULT - 1 if xor zero sum error, 0 otherwise</span>
<span class="cm"> * @SUM_CHECK_Q_RESULT - 1 if reed-solomon zero sum error, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">sum_check_flags</span> <span class="p">{</span>
	<span class="n">SUM_CHECK_P_RESULT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SUM_CHECK_P</span><span class="p">),</span>
	<span class="n">SUM_CHECK_Q_RESULT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SUM_CHECK_Q</span><span class="p">),</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * dma_cap_mask_t - capabilities bitmap modeled after cpumask_t.</span>
<span class="cm"> * See linux/cpumask.h</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">DMA_TX_TYPE_END</span><span class="p">);</span> <span class="p">}</span> <span class="n">dma_cap_mask_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_chan_percpu - the per-CPU part of struct dma_chan</span>
<span class="cm"> * @memcpy_count: transaction counter</span>
<span class="cm"> * @bytes_transferred: byte counter</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">dma_chan_percpu</span> <span class="p">{</span>
	<span class="cm">/* stats */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memcpy_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes_transferred</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_chan - devices supply DMA channels, clients use them</span>
<span class="cm"> * @device: ptr to the dma device who supplies this channel, always !%NULL</span>
<span class="cm"> * @cookie: last cookie value returned to client</span>
<span class="cm"> * @completed_cookie: last completed cookie for this channel</span>
<span class="cm"> * @chan_id: channel ID for sysfs</span>
<span class="cm"> * @dev: class device for sysfs</span>
<span class="cm"> * @device_node: used to add this to the device chan list</span>
<span class="cm"> * @local: per-cpu pointer to a struct dma_chan_percpu</span>
<span class="cm"> * @client-count: how many clients are using this channel</span>
<span class="cm"> * @table_count: number of appearances in the mem-to-mem allocation table</span>
<span class="cm"> * @private: private data for certain client-channel associations</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_chan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="n">dma_cookie_t</span> <span class="n">completed_cookie</span><span class="p">;</span>

	<span class="cm">/* sysfs */</span>
	<span class="kt">int</span> <span class="n">chan_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">device_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan_percpu</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">client_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">table_count</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_chan_dev - relate sysfs device node to backing channel device</span>
<span class="cm"> * @chan - driver channel device</span>
<span class="cm"> * @device - sysfs device</span>
<span class="cm"> * @dev_id - parent dma_device dev_id</span>
<span class="cm"> * @idr_ref - reference count to gate release of dma_device dev_id</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_chan_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">idr_ref</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum dma_slave_buswidth - defines bus with of the DMA slave</span>
<span class="cm"> * device, source or target buses</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dma_slave_buswidth</span> <span class="p">{</span>
	<span class="n">DMA_SLAVE_BUSWIDTH_UNDEFINED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DMA_SLAVE_BUSWIDTH_1_BYTE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DMA_SLAVE_BUSWIDTH_2_BYTES</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">DMA_SLAVE_BUSWIDTH_4_BYTES</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">DMA_SLAVE_BUSWIDTH_8_BYTES</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_slave_config - dma slave channel runtime config</span>
<span class="cm"> * @direction: whether the data shall go in or out on this slave</span>
<span class="cm"> * channel, right now. DMA_TO_DEVICE and DMA_FROM_DEVICE are</span>
<span class="cm"> * legal values, DMA_BIDIRECTIONAL is not acceptable since we</span>
<span class="cm"> * need to differentiate source and target addresses.</span>
<span class="cm"> * @src_addr: this is the physical address where DMA slave data</span>
<span class="cm"> * should be read (RX), if the source is memory this argument is</span>
<span class="cm"> * ignored.</span>
<span class="cm"> * @dst_addr: this is the physical address where DMA slave data</span>
<span class="cm"> * should be written (TX), if the source is memory this argument</span>
<span class="cm"> * is ignored.</span>
<span class="cm"> * @src_addr_width: this is the width in bytes of the source (RX)</span>
<span class="cm"> * register where DMA data shall be read. If the source</span>
<span class="cm"> * is memory this may be ignored depending on architecture.</span>
<span class="cm"> * Legal values: 1, 2, 4, 8.</span>
<span class="cm"> * @dst_addr_width: same as src_addr_width but for destination</span>
<span class="cm"> * target (TX) mutatis mutandis.</span>
<span class="cm"> * @src_maxburst: the maximum number of words (note: words, as in</span>
<span class="cm"> * units of the src_addr_width member, not bytes) that can be sent</span>
<span class="cm"> * in one burst to the device. Typically something like half the</span>
<span class="cm"> * FIFO depth on I/O peripherals so you don&#39;t overflow it. This</span>
<span class="cm"> * may or may not be applicable on memory sources.</span>
<span class="cm"> * @dst_maxburst: same as src_maxburst but for destination target</span>
<span class="cm"> * mutatis mutandis.</span>
<span class="cm"> * @device_fc: Flow Controller Settings. Only valid for slave channels. Fill</span>
<span class="cm"> * with &#39;true&#39; if peripheral should be flow controller. Direction will be</span>
<span class="cm"> * selected at Runtime.</span>
<span class="cm"> *</span>
<span class="cm"> * This struct is passed in as configuration data to a DMA engine</span>
<span class="cm"> * in order to set up a certain channel for DMA transport at runtime.</span>
<span class="cm"> * The DMA device/engine has to provide support for an additional</span>
<span class="cm"> * command in the channel config interface, DMA_SLAVE_CONFIG</span>
<span class="cm"> * and this struct will then be passed in as an argument to the</span>
<span class="cm"> * DMA engine device_control() function.</span>
<span class="cm"> *</span>
<span class="cm"> * The rationale for adding configuration information to this struct</span>
<span class="cm"> * is as follows: if it is likely that most DMA slave controllers in</span>
<span class="cm"> * the world will support the configuration option, then make it</span>
<span class="cm"> * generic. If not: if it is fixed so that it be sent in static from</span>
<span class="cm"> * the platform data, then prefer to do that. Else, if it is neither</span>
<span class="cm"> * fixed at runtime, nor generic enough (such as bus mastership on</span>
<span class="cm"> * some CPU family and whatnot) then create a custom slave config</span>
<span class="cm"> * struct and pass that, then make this config a member of that</span>
<span class="cm"> * struct, if applicable.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_slave_config</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">src_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dst_addr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_slave_buswidth</span> <span class="n">src_addr_width</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_slave_buswidth</span> <span class="n">dst_addr_width</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src_maxburst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst_maxburst</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">device_fc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dma_chan_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">dma_chan_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * typedef dma_filter_fn - callback filter for dma_request_channel</span>
<span class="cm"> * @chan: channel to be reviewed</span>
<span class="cm"> * @filter_param: opaque parameter passed through dma_request_channel</span>
<span class="cm"> *</span>
<span class="cm"> * When this optional parameter is specified in a call to dma_request_channel a</span>
<span class="cm"> * suitable channel is passed to this routine for further dispositioning before</span>
<span class="cm"> * being returned.  Where &#39;suitable&#39; indicates a non-busy channel that</span>
<span class="cm"> * satisfies the given capability mask.  It returns &#39;true&#39; to indicate that the</span>
<span class="cm"> * channel is suitable.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_filter_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">filter_param</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dma_async_tx_callback</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dma_async_param</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * struct dma_async_tx_descriptor - async transaction descriptor</span>
<span class="cm"> * ---dma generic offload fields---</span>
<span class="cm"> * @cookie: tracking cookie for this transaction, set to -EBUSY if</span>
<span class="cm"> *	this tx is sitting on a dependency list</span>
<span class="cm"> * @flags: flags to augment operation preparation, control completion, and</span>
<span class="cm"> * 	communicate status</span>
<span class="cm"> * @phys: physical address of the descriptor</span>
<span class="cm"> * @chan: target channel for this operation</span>
<span class="cm"> * @tx_submit: set the prepared descriptor(s) to be executed by the engine</span>
<span class="cm"> * @callback: routine to call after this operation is complete</span>
<span class="cm"> * @callback_param: general parameter to pass to the callback routine</span>
<span class="cm"> * ---async_tx api specific fields---</span>
<span class="cm"> * @next: at completion submit this descriptor</span>
<span class="cm"> * @parent: pointer to the next level up in the dependency chain</span>
<span class="cm"> * @lock: protect the parent and next pointers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="p">{</span>
	<span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_ctrl_flags</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* not a &#39;long&#39; to pack with cookie */</span>
	<span class="n">dma_addr_t</span> <span class="n">phys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>
	<span class="n">dma_cookie_t</span> <span class="p">(</span><span class="o">*</span><span class="n">tx_submit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">);</span>
	<span class="n">dma_async_tx_callback</span> <span class="n">callback</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">callback_param</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#ifndef CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_clear_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_clear_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">txd_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">txd_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">txd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">next</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">txd</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_clear_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">txd</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txd_clear_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">txd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">txd_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">txd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">txd_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">txd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_tx_state - filled in to report the status of</span>
<span class="cm"> * a transfer.</span>
<span class="cm"> * @last: last completed DMA cookie</span>
<span class="cm"> * @used: last issued DMA cookie (i.e. the one in progress)</span>
<span class="cm"> * @residue: the remaining number of bytes left to transmit</span>
<span class="cm"> *	on the selected transfer for states DMA_IN_PROGRESS and</span>
<span class="cm"> *	DMA_PAUSED if this is implemented in the driver, else 0</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_tx_state</span> <span class="p">{</span>
	<span class="n">dma_cookie_t</span> <span class="n">last</span><span class="p">;</span>
	<span class="n">dma_cookie_t</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">residue</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct dma_device - info on the entity supplying DMA services</span>
<span class="cm"> * @chancnt: how many DMA channels are supported</span>
<span class="cm"> * @privatecnt: how many DMA channels are requested by dma_request_channel</span>
<span class="cm"> * @channels: the list of struct dma_chan</span>
<span class="cm"> * @global_node: list_head for global dma_device_list</span>
<span class="cm"> * @cap_mask: one or more dma_capability flags</span>
<span class="cm"> * @max_xor: maximum number of xor sources, 0 if no capability</span>
<span class="cm"> * @max_pq: maximum number of PQ sources and PQ-continue capability</span>
<span class="cm"> * @copy_align: alignment shift for memcpy operations</span>
<span class="cm"> * @xor_align: alignment shift for xor operations</span>
<span class="cm"> * @pq_align: alignment shift for pq operations</span>
<span class="cm"> * @fill_align: alignment shift for memset operations</span>
<span class="cm"> * @dev_id: unique device ID</span>
<span class="cm"> * @dev: struct device reference for dma mapping api</span>
<span class="cm"> * @device_alloc_chan_resources: allocate resources and return the</span>
<span class="cm"> *	number of allocated descriptors</span>
<span class="cm"> * @device_free_chan_resources: release DMA channel&#39;s resources</span>
<span class="cm"> * @device_prep_dma_memcpy: prepares a memcpy operation</span>
<span class="cm"> * @device_prep_dma_xor: prepares a xor operation</span>
<span class="cm"> * @device_prep_dma_xor_val: prepares a xor validation operation</span>
<span class="cm"> * @device_prep_dma_pq: prepares a pq operation</span>
<span class="cm"> * @device_prep_dma_pq_val: prepares a pqzero_sum operation</span>
<span class="cm"> * @device_prep_dma_memset: prepares a memset operation</span>
<span class="cm"> * @device_prep_dma_interrupt: prepares an end of chain interrupt operation</span>
<span class="cm"> * @device_prep_slave_sg: prepares a slave dma operation</span>
<span class="cm"> * @device_prep_dma_cyclic: prepare a cyclic dma operation suitable for audio.</span>
<span class="cm"> *	The function takes a buffer of size buf_len. The callback function will</span>
<span class="cm"> *	be called after period_len bytes have been transferred.</span>
<span class="cm"> * @device_prep_interleaved_dma: Transfer expression in a generic way.</span>
<span class="cm"> * @device_control: manipulate all pending operations on a channel, returns</span>
<span class="cm"> *	zero or error code</span>
<span class="cm"> * @device_tx_status: poll for transaction completion, the optional</span>
<span class="cm"> *	txstate parameter can be supplied with a pointer to get a</span>
<span class="cm"> *	struct with auxiliary transfer status information, otherwise the call</span>
<span class="cm"> *	will just return a simple status code</span>
<span class="cm"> * @device_issue_pending: push pending transactions to hardware</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dma_device</span> <span class="p">{</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chancnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">privatecnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">global_node</span><span class="p">;</span>
	<span class="n">dma_cap_mask_t</span>  <span class="n">cap_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_xor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_pq</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">copy_align</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">xor_align</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pq_align</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fill_align</span><span class="p">;</span>
	<span class="cp">#define DMA_HAS_PQ_CONTINUE (1 &lt;&lt; 15)</span>

	<span class="kt">int</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">device_alloc_chan_resources</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">device_free_chan_resources</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_memcpy</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dest</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">src</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_xor</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dest</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src_cnt</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_xor_val</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src_cnt</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sum_check_flags</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_pq</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src_cnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_pq_val</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src_cnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">sum_check_flags</span> <span class="o">*</span><span class="n">pqres</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_memset</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_interrupt</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_sg</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">dst_sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dst_nents</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">src_sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src_nents</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_slave_sg</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">direction</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_dma_cyclic</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">period_len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">direction</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">device_prep_interleaved_dma</span><span class="p">)(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dma_interleaved_template</span> <span class="o">*</span><span class="n">xt</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">device_control</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_ctrl_cmd</span> <span class="n">cmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">enum</span> <span class="n">dma_status</span> <span class="p">(</span><span class="o">*</span><span class="n">device_tx_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
					    <span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">dma_tx_state</span> <span class="o">*</span><span class="n">txstate</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">device_issue_pending</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dmaengine_device_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
					   <span class="k">enum</span> <span class="n">dma_ctrl_cmd</span> <span class="n">cmd</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device_control</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dmaengine_slave_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dma_slave_config</span> <span class="o">*</span><span class="n">config</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dmaengine_device_control</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">DMA_SLAVE_CONFIG</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">config</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">dmaengine_prep_slave_single</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
	<span class="n">sg_init_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sg_dma_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">)</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">sg_dma_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">)</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device_prep_slave_sg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						  <span class="n">dir</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">dmaengine_prep_slave_sg</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_len</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device_prep_slave_sg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">sg_len</span><span class="p">,</span>
						  <span class="n">dir</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RAPIDIO_DMA_ENGINE</span>
<span class="k">struct</span> <span class="n">rio_dma_ext</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">dmaengine_prep_rio_sg</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sg_len</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">rio_dma_ext</span> <span class="o">*</span><span class="n">rio_ext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device_prep_slave_sg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">sg_len</span><span class="p">,</span>
						  <span class="n">dir</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">rio_ext</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="nf">dmaengine_prep_dma_cyclic</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">buf_addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">period_len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device_prep_dma_cyclic</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span>
						<span class="n">period_len</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dmaengine_terminate_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dmaengine_device_control</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">DMA_TERMINATE_ALL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dmaengine_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dmaengine_device_control</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">DMA_PAUSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dmaengine_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dmaengine_device_control</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">DMA_RESUME</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">dma_cookie_t</span> <span class="nf">dmaengine_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">tx_submit</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dmaengine_check_align</span><span class="p">(</span><span class="n">u8</span> <span class="n">align</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">off1</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">off2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">align</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">align</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">off1</span> <span class="o">|</span> <span class="n">off2</span> <span class="o">|</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_dma_copy_aligned</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">off1</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">off2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dmaengine_check_align</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">copy_align</span><span class="p">,</span> <span class="n">off1</span><span class="p">,</span> <span class="n">off2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_dma_xor_aligned</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">off1</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">off2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dmaengine_check_align</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xor_align</span><span class="p">,</span> <span class="n">off1</span><span class="p">,</span> <span class="n">off2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_dma_pq_aligned</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">off1</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">off2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dmaengine_check_align</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pq_align</span><span class="p">,</span> <span class="n">off1</span><span class="p">,</span> <span class="n">off2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_dma_fill_aligned</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">off1</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">off2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dmaengine_check_align</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fill_align</span><span class="p">,</span> <span class="n">off1</span><span class="p">,</span> <span class="n">off2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">dma_set_maxpq</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxpq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">has_pq_continue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma</span><span class="o">-&gt;</span><span class="n">max_pq</span> <span class="o">=</span> <span class="n">maxpq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_pq_continue</span><span class="p">)</span>
		<span class="n">dma</span><span class="o">-&gt;</span><span class="n">max_pq</span> <span class="o">|=</span> <span class="n">DMA_HAS_PQ_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dmaf_continue</span><span class="p">(</span><span class="k">enum</span> <span class="n">dma_ctrl_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_PREP_CONTINUE</span><span class="p">)</span> <span class="o">==</span> <span class="n">DMA_PREP_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dmaf_p_disabled_continue</span><span class="p">(</span><span class="k">enum</span> <span class="n">dma_ctrl_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dma_ctrl_flags</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">DMA_PREP_CONTINUE</span> <span class="o">|</span> <span class="n">DMA_PREP_PQ_DISABLE_P</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dma_dev_has_pq_continue</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">max_pq</span> <span class="o">&amp;</span> <span class="n">DMA_HAS_PQ_CONTINUE</span><span class="p">)</span> <span class="o">==</span> <span class="n">DMA_HAS_PQ_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">dma_dev_to_maxpq</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">dma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">max_pq</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DMA_HAS_PQ_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* dma_maxpq - reduce maxpq in the face of continued operations</span>
<span class="cm"> * @dma - dma device with PQ capability</span>
<span class="cm"> * @flags - to check if DMA_PREP_CONTINUE and DMA_PREP_PQ_DISABLE_P are set</span>
<span class="cm"> *</span>
<span class="cm"> * When an engine does not support native continuation we need 3 extra</span>
<span class="cm"> * source slots to reuse P and Q with the following coefficients:</span>
<span class="cm"> * 1/ {00} * P : remove P from Q&#39;, but use it as a source for P&#39;</span>
<span class="cm"> * 2/ {01} * Q : use Q to continue Q&#39; calculation</span>
<span class="cm"> * 3/ {00} * Q : subtract Q from P&#39; to cancel (2)</span>
<span class="cm"> *</span>
<span class="cm"> * In the case where P is disabled we only need 1 extra source:</span>
<span class="cm"> * 1/ {01} * Q : use Q to continue Q&#39; calculation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dma_maxpq</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">dma</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_ctrl_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_dev_has_pq_continue</span><span class="p">(</span><span class="n">dma</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">dmaf_continue</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dma_dev_to_maxpq</span><span class="p">(</span><span class="n">dma</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dmaf_p_disabled_continue</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dma_dev_to_maxpq</span><span class="p">(</span><span class="n">dma</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dmaf_continue</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dma_dev_to_maxpq</span><span class="p">(</span><span class="n">dma</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* --- public DMA engine API --- */</span>

<span class="cp">#ifdef CONFIG_DMA_ENGINE</span>
<span class="kt">void</span> <span class="n">dmaengine_get</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dmaengine_put</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dmaengine_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dmaengine_put</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
<span class="cp">#define net_dmaengine_get()	dmaengine_get()</span>
<span class="cp">#define net_dmaengine_put()	dmaengine_put()</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">net_dmaengine_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">net_dmaengine_put</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ASYNC_TX_DMA</span>
<span class="cp">#define async_dmaengine_get()	dmaengine_get()</span>
<span class="cp">#define async_dmaengine_put()	dmaengine_put()</span>
<span class="cp">#ifndef CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH</span>
<span class="cp">#define async_dma_find_channel(type) dma_find_channel(DMA_ASYNC_TX)</span>
<span class="cp">#else</span>
<span class="cp">#define async_dma_find_channel(type) dma_find_channel(type)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">async_dmaengine_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">async_dmaengine_put</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span>
<span class="nf">async_dma_find_channel</span><span class="p">(</span><span class="k">enum</span> <span class="n">dma_transaction_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ASYNC_TX_DMA */</span><span class="cp"></span>

<span class="n">dma_cookie_t</span> <span class="n">dma_async_memcpy_buf_to_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="n">dma_cookie_t</span> <span class="n">dma_async_memcpy_buf_to_pg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">kdata</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="n">dma_cookie_t</span> <span class="n">dma_async_memcpy_pg_to_pg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dest_pg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest_off</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src_pg</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src_off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dma_async_tx_descriptor_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">async_tx_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DMA_CTRL_ACK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">async_tx_clear_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DMA_CTRL_ACK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">async_tx_test_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DMA_CTRL_ACK</span><span class="p">)</span> <span class="o">==</span> <span class="n">DMA_CTRL_ACK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define first_dma_cap(mask) __first_dma_cap(&amp;(mask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__first_dma_cap</span><span class="p">(</span><span class="k">const</span> <span class="n">dma_cap_mask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">DMA_TX_TYPE_END</span><span class="p">,</span>
		<span class="n">find_first_bit</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">DMA_TX_TYPE_END</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define next_dma_cap(n, mask) __next_dma_cap((n), &amp;(mask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__next_dma_cap</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">dma_cap_mask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">DMA_TX_TYPE_END</span><span class="p">,</span>
		<span class="n">find_next_bit</span><span class="p">(</span><span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">DMA_TX_TYPE_END</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define dma_cap_set(tx, mask) __dma_cap_set((tx), &amp;(mask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__dma_cap_set</span><span class="p">(</span><span class="k">enum</span> <span class="n">dma_transaction_type</span> <span class="n">tx_type</span><span class="p">,</span> <span class="n">dma_cap_mask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">tx_type</span><span class="p">,</span> <span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define dma_cap_clear(tx, mask) __dma_cap_clear((tx), &amp;(mask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__dma_cap_clear</span><span class="p">(</span><span class="k">enum</span> <span class="n">dma_transaction_type</span> <span class="n">tx_type</span><span class="p">,</span> <span class="n">dma_cap_mask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">tx_type</span><span class="p">,</span> <span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define dma_cap_zero(mask) __dma_cap_zero(&amp;(mask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__dma_cap_zero</span><span class="p">(</span><span class="n">dma_cap_mask_t</span> <span class="o">*</span><span class="n">dstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">dstp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">DMA_TX_TYPE_END</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define dma_has_cap(tx, mask) __dma_has_cap((tx), &amp;(mask))</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">__dma_has_cap</span><span class="p">(</span><span class="k">enum</span> <span class="n">dma_transaction_type</span> <span class="n">tx_type</span><span class="p">,</span> <span class="n">dma_cap_mask_t</span> <span class="o">*</span><span class="n">srcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">tx_type</span><span class="p">,</span> <span class="n">srcp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define for_each_dma_cap_mask(cap, mask) \</span>
<span class="cp">	for ((cap) = first_dma_cap(mask);	\</span>
<span class="cp">		(cap) &lt; DMA_TX_TYPE_END;	\</span>
<span class="cp">		(cap) = next_dma_cap((cap), (mask)))</span>

<span class="cm">/**</span>
<span class="cm"> * dma_async_issue_pending - flush pending transactions to HW</span>
<span class="cm"> * @chan: target DMA channel</span>
<span class="cm"> *</span>
<span class="cm"> * This allows drivers to push copies to HW in batches,</span>
<span class="cm"> * reducing MMIO writes where possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_async_issue_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device_issue_pending</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define dma_async_memcpy_issue_pending(chan) dma_async_issue_pending(chan)</span>

<span class="cm">/**</span>
<span class="cm"> * dma_async_is_tx_complete - poll for transaction completion</span>
<span class="cm"> * @chan: DMA channel</span>
<span class="cm"> * @cookie: transaction identifier to check status of</span>
<span class="cm"> * @last: returns last completed cookie, can be NULL</span>
<span class="cm"> * @used: returns last issued cookie, can be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * If @last and @used are passed in, upon return they reflect the driver</span>
<span class="cm"> * internal state and can be used with dma_async_is_complete() to check</span>
<span class="cm"> * the status of multiple cookies without re-checking hardware state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">dma_status</span> <span class="nf">dma_async_is_tx_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span>
	<span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">dma_cookie_t</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="n">dma_cookie_t</span> <span class="o">*</span><span class="n">used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_tx_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">device_tx_status</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">cookie</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
		<span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">last</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used</span><span class="p">)</span>
		<span class="o">*</span><span class="n">used</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">used</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define dma_async_memcpy_complete(chan, cookie, last, used)\</span>
<span class="cp">	dma_async_is_tx_complete(chan, cookie, last, used)</span>

<span class="cm">/**</span>
<span class="cm"> * dma_async_is_complete - test a cookie against chan state</span>
<span class="cm"> * @cookie: transaction identifier to test status of</span>
<span class="cm"> * @last_complete: last know completed transaction</span>
<span class="cm"> * @last_used: last cookie value handed out</span>
<span class="cm"> *</span>
<span class="cm"> * dma_async_is_complete() is used in dma_async_memcpy_complete()</span>
<span class="cm"> * the test logic is separated for lightweight testing of multiple cookies</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">dma_status</span> <span class="nf">dma_async_is_complete</span><span class="p">(</span><span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">,</span>
			<span class="n">dma_cookie_t</span> <span class="n">last_complete</span><span class="p">,</span> <span class="n">dma_cookie_t</span> <span class="n">last_used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_complete</span> <span class="o">&lt;=</span> <span class="n">last_used</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cookie</span> <span class="o">&lt;=</span> <span class="n">last_complete</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cookie</span> <span class="o">&gt;</span> <span class="n">last_used</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">DMA_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cookie</span> <span class="o">&lt;=</span> <span class="n">last_complete</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cookie</span> <span class="o">&gt;</span> <span class="n">last_used</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">DMA_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">DMA_IN_PROGRESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">dma_set_tx_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_tx_state</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="n">dma_cookie_t</span> <span class="n">last</span><span class="p">,</span> <span class="n">dma_cookie_t</span> <span class="n">used</span><span class="p">,</span> <span class="n">u32</span> <span class="n">residue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">used</span><span class="p">;</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">residue</span> <span class="o">=</span> <span class="n">residue</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">dma_status</span> <span class="n">dma_sync_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="n">dma_cookie_t</span> <span class="n">cookie</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DMA_ENGINE</span>
<span class="k">enum</span> <span class="n">dma_status</span> <span class="n">dma_wait_for_async_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dma_issue_pending_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">__dma_request_channel</span><span class="p">(</span><span class="n">dma_cap_mask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">dma_filter_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fn_param</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dma_release_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">dma_status</span> <span class="nf">dma_wait_for_async_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">DMA_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_issue_pending_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="nf">__dma_request_channel</span><span class="p">(</span><span class="n">dma_cap_mask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
					      <span class="n">dma_filter_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fn_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dma_release_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* --- DMA device --- */</span>

<span class="kt">int</span> <span class="n">dma_async_device_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dma_async_device_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_device</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dma_run_dependencies</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">tx</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dma_find_channel</span><span class="p">(</span><span class="k">enum</span> <span class="n">dma_transaction_type</span> <span class="n">tx_type</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">net_dma_find_channel</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#define dma_request_channel(mask, x, y) __dma_request_channel(&amp;(mask), x, y)</span>

<span class="cm">/* --- Helper iov-locking functions --- */</span>

<span class="k">struct</span> <span class="n">dma_page_list</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">base_address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dma_pinned_list</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_iovecs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_page_list</span> <span class="n">page_list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dma_pinned_list</span> <span class="o">*</span><span class="n">dma_pin_iovec_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dma_unpin_iovec_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_pinned_list</span><span class="o">*</span> <span class="n">pinned_list</span><span class="p">);</span>

<span class="n">dma_cookie_t</span> <span class="n">dma_memcpy_to_iovec</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dma_pinned_list</span> <span class="o">*</span><span class="n">pinned_list</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kdata</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="n">dma_cookie_t</span> <span class="n">dma_memcpy_pg_to_iovec</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dma_pinned_list</span> <span class="o">*</span><span class="n">pinned_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* DMAENGINE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
