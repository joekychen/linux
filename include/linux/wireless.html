<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › wireless.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>wireless.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file define a set of standard wireless extensions</span>
<span class="cm"> *</span>
<span class="cm"> * Version :	22	16.3.07</span>
<span class="cm"> *</span>
<span class="cm"> * Authors :	Jean Tourrilhes - HPL - &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> * Copyright (c) 1997-2007 Jean Tourrilhes, All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_WIRELESS_H</span>
<span class="cp">#define _LINUX_WIRELESS_H</span>

<span class="cm">/************************** DOCUMENTATION **************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Initial APIs (1996 -&gt; onward) :</span>
<span class="cm"> * -----------------------------</span>
<span class="cm"> * Basically, the wireless extensions are for now a set of standard ioctl</span>
<span class="cm"> * call + /proc/net/wireless</span>
<span class="cm"> *</span>
<span class="cm"> * The entry /proc/net/wireless give statistics and information on the</span>
<span class="cm"> * driver.</span>
<span class="cm"> * This is better than having each driver having its entry because</span>
<span class="cm"> * its centralised and we may remove the driver module safely.</span>
<span class="cm"> *</span>
<span class="cm"> * Ioctl are used to configure the driver and issue commands.  This is</span>
<span class="cm"> * better than command line options of insmod because we may want to</span>
<span class="cm"> * change dynamically (while the driver is running) some parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * The ioctl mechanimsm are copied from standard devices ioctl.</span>
<span class="cm"> * We have the list of command plus a structure descibing the</span>
<span class="cm"> * data exchanged...</span>
<span class="cm"> * Note that to add these ioctl, I was obliged to modify :</span>
<span class="cm"> *	# net/core/dev.c (two place + add include)</span>
<span class="cm"> *	# net/ipv4/af_inet.c (one place + add include)</span>
<span class="cm"> *</span>
<span class="cm"> * /proc/net/wireless is a copy of /proc/net/dev.</span>
<span class="cm"> * We have a structure for data passed from the driver to /proc/net/wireless</span>
<span class="cm"> * Too add this, I&#39;ve modified :</span>
<span class="cm"> *	# net/core/dev.c (two other places)</span>
<span class="cm"> *	# include/linux/netdevice.h (one place)</span>
<span class="cm"> *	# include/linux/proc_fs.h (one place)</span>
<span class="cm"> *</span>
<span class="cm"> * New driver API (2002 -&gt; onward) :</span>
<span class="cm"> * -------------------------------</span>
<span class="cm"> * This file is only concerned with the user space API and common definitions.</span>
<span class="cm"> * The new driver API is defined and documented in :</span>
<span class="cm"> *	# include/net/iw_handler.h</span>
<span class="cm"> *</span>
<span class="cm"> * Note as well that /proc/net/wireless implementation has now moved in :</span>
<span class="cm"> *	# net/core/wireless.c</span>
<span class="cm"> *</span>
<span class="cm"> * Wireless Events (2002 -&gt; onward) :</span>
<span class="cm"> * --------------------------------</span>
<span class="cm"> * Events are defined at the end of this file, and implemented in :</span>
<span class="cm"> *	# net/core/wireless.c</span>
<span class="cm"> *</span>
<span class="cm"> * Other comments :</span>
<span class="cm"> * --------------</span>
<span class="cm"> * Do not add here things that are redundant with other mechanisms</span>
<span class="cm"> * (drivers init, ifconfig, /proc/net/dev, ...) and with are not</span>
<span class="cm"> * wireless specific.</span>
<span class="cm"> *</span>
<span class="cm"> * These wireless extensions are not magic : each driver has to provide</span>
<span class="cm"> * support for them...</span>
<span class="cm"> *</span>
<span class="cm"> * IMPORTANT NOTE : As everything in the kernel, this is very much a</span>
<span class="cm"> * work in progress. Contact me if you have ideas of improvements...</span>
<span class="cm"> */</span>

<span class="cm">/***************************** INCLUDES *****************************/</span>

<span class="cp">#include &lt;linux/types.h&gt;		</span><span class="cm">/* for __u* and __s* typedefs */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/socket.h&gt;		</span><span class="cm">/* for &quot;struct sockaddr&quot; et al	*/</span><span class="cp"></span>
<span class="cp">#include &lt;linux/if.h&gt;			</span><span class="cm">/* for IFNAMSIZ and co... */</span><span class="cp"></span>

<span class="cm">/***************************** VERSION *****************************/</span>
<span class="cm">/*</span>
<span class="cm"> * This constant is used to know the availability of the wireless</span>
<span class="cm"> * extensions and to know which version of wireless extensions it is</span>
<span class="cm"> * (there is some stuff that will be added in the future...)</span>
<span class="cm"> * I just plan to increment with each new version.</span>
<span class="cm"> */</span>
<span class="cp">#define WIRELESS_EXT	22</span>

<span class="cm">/*</span>
<span class="cm"> * Changes :</span>
<span class="cm"> *</span>
<span class="cm"> * V2 to V3</span>
<span class="cm"> * --------</span>
<span class="cm"> *	Alan Cox start some incompatibles changes. I&#39;ve integrated a bit more.</span>
<span class="cm"> *	- Encryption renamed to Encode to avoid US regulation problems</span>
<span class="cm"> *	- Frequency changed from float to struct to avoid problems on old 386</span>
<span class="cm"> *</span>
<span class="cm"> * V3 to V4</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Add sensitivity</span>
<span class="cm"> *</span>
<span class="cm"> * V4 to V5</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Missing encoding definitions in range</span>
<span class="cm"> *	- Access points stuff</span>
<span class="cm"> *</span>
<span class="cm"> * V5 to V6</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- 802.11 support (ESSID ioctls)</span>
<span class="cm"> *</span>
<span class="cm"> * V6 to V7</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP</span>
<span class="cm"> *</span>
<span class="cm"> * V7 to V8</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Changed my e-mail address</span>
<span class="cm"> *	- More 802.11 support (nickname, rate, rts, frag)</span>
<span class="cm"> *	- List index in frequencies</span>
<span class="cm"> *</span>
<span class="cm"> * V8 to V9</span>
<span class="cm"> * --------</span>
<span class="cm"> *	- Support for &#39;mode of operation&#39; (ad-hoc, managed...)</span>
<span class="cm"> *	- Support for unicast and multicast power saving</span>
<span class="cm"> *	- Change encoding to support larger tokens (&gt;64 bits)</span>
<span class="cm"> *	- Updated iw_params (disable, flags) and use it for NWID</span>
<span class="cm"> *	- Extracted iw_point from iwreq for clarity</span>
<span class="cm"> *</span>
<span class="cm"> * V9 to V10</span>
<span class="cm"> * ---------</span>
<span class="cm"> *	- Add PM capability to range structure</span>
<span class="cm"> *	- Add PM modifier : MAX/MIN/RELATIVE</span>
<span class="cm"> *	- Add encoding option : IW_ENCODE_NOKEY</span>
<span class="cm"> *	- Add TxPower ioctls (work like TxRate)</span>
<span class="cm"> *</span>
<span class="cm"> * V10 to V11</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Add WE version in range (help backward/forward compatibility)</span>
<span class="cm"> *	- Add retry ioctls (work like PM)</span>
<span class="cm"> *</span>
<span class="cm"> * V11 to V12</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically</span>
<span class="cm"> *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space</span>
<span class="cm"> *	- Add new statistics (frag, retry, beacon)</span>
<span class="cm"> *	- Add average quality (for user space calibration)</span>
<span class="cm"> *</span>
<span class="cm"> * V12 to V13</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Document creation of new driver API.</span>
<span class="cm"> *	- Extract union iwreq_data from struct iwreq (for new driver API).</span>
<span class="cm"> *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT</span>
<span class="cm"> *</span>
<span class="cm"> * V13 to V14</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Wireless Events support : define struct iw_event</span>
<span class="cm"> *	- Define additional specific event numbers</span>
<span class="cm"> *	- Add &quot;addr&quot; and &quot;param&quot; fields in union iwreq_data</span>
<span class="cm"> *	- AP scanning stuff (SIOCSIWSCAN and friends)</span>
<span class="cm"> *</span>
<span class="cm"> * V14 to V15</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg</span>
<span class="cm"> *	- Make struct iw_freq signed (both m &amp; e), add explicit padding</span>
<span class="cm"> *	- Add IWEVCUSTOM for driver specific event/scanning token</span>
<span class="cm"> *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses</span>
<span class="cm"> *	- Add IW_TXPOW_RANGE for range of Tx Powers</span>
<span class="cm"> *	- Add IWEVREGISTERED &amp; IWEVEXPIRED events for Access Points</span>
<span class="cm"> *	- Add IW_MODE_MONITOR for passive monitor</span>
<span class="cm"> *</span>
<span class="cm"> * V15 to V16</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)</span>
<span class="cm"> *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)</span>
<span class="cm"> *	- Reshuffle struct iw_range for increases, add filler</span>
<span class="cm"> *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses</span>
<span class="cm"> *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support</span>
<span class="cm"> *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and &quot;struct iw_thrspy&quot;</span>
<span class="cm"> *	- Add IW_ENCODE_TEMP and iw_range-&gt;encoding_login_index</span>
<span class="cm"> *</span>
<span class="cm"> * V16 to V17</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Add flags to frequency -&gt; auto/fixed</span>
<span class="cm"> *	- Document (struct iw_quality *)-&gt;updated, add new flags (INVALID)</span>
<span class="cm"> *	- Wireless Event capability in struct iw_range</span>
<span class="cm"> *	- Add support for relative TxPower (yick !)</span>
<span class="cm"> *</span>
<span class="cm"> * V17 to V18 (From Jouni Malinen &lt;j@w1.fi&gt;)</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Add support for WPA/WPA2</span>
<span class="cm"> *	- Add extended encoding configuration (SIOCSIWENCODEEXT and</span>
<span class="cm"> *	  SIOCGIWENCODEEXT)</span>
<span class="cm"> *	- Add SIOCSIWGENIE/SIOCGIWGENIE</span>
<span class="cm"> *	- Add SIOCSIWMLME</span>
<span class="cm"> *	- Add SIOCSIWPMKSA</span>
<span class="cm"> *	- Add struct iw_range bit field for supported encoding capabilities</span>
<span class="cm"> *	- Add optional scan request parameters for SIOCSIWSCAN</span>
<span class="cm"> *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA</span>
<span class="cm"> *	  related parameters (extensible up to 4096 parameter values)</span>
<span class="cm"> *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,</span>
<span class="cm"> *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND</span>
<span class="cm"> *</span>
<span class="cm"> * V18 to V19</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Remove (struct iw_point *)-&gt;pointer from events and streams</span>
<span class="cm"> *	- Remove header includes to help user space</span>
<span class="cm"> *	- Increase IW_ENCODING_TOKEN_MAX from 32 to 64</span>
<span class="cm"> *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros</span>
<span class="cm"> *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM</span>
<span class="cm"> *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros</span>
<span class="cm"> *</span>
<span class="cm"> * V19 to V20</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- RtNetlink requests support (SET/GET)</span>
<span class="cm"> *</span>
<span class="cm"> * V20 to V21</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Remove (struct net_device *)-&gt;get_wireless_stats()</span>
<span class="cm"> *	- Change length in ESSID and NICK to strlen() instead of strlen()+1</span>
<span class="cm"> *	- Add IW_RETRY_SHORT/IW_RETRY_LONG retry modifiers</span>
<span class="cm"> *	- Power/Retry relative values no longer * 100000</span>
<span class="cm"> *	- Add explicit flag to tell stats are in 802.11k RCPI : IW_QUAL_RCPI</span>
<span class="cm"> *</span>
<span class="cm"> * V21 to V22</span>
<span class="cm"> * ----------</span>
<span class="cm"> *	- Prevent leaking of kernel space in stream on 64 bits.</span>
<span class="cm"> */</span>

<span class="cm">/**************************** CONSTANTS ****************************/</span>

<span class="cm">/* -------------------------- IOCTL LIST -------------------------- */</span>

<span class="cm">/* Wireless Identification */</span>
<span class="cp">#define SIOCSIWCOMMIT	0x8B00		</span><span class="cm">/* Commit pending changes to driver */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWNAME	0x8B01		</span><span class="cm">/* get name == wireless protocol */</span><span class="cp"></span>
<span class="cm">/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.</span>
<span class="cm"> * Common values : &quot;IEEE 802.11-DS&quot;, &quot;IEEE 802.11-FH&quot;, &quot;IEEE 802.11b&quot;...</span>
<span class="cm"> * Don&#39;t put the name of your driver there, it&#39;s useless. */</span>

<span class="cm">/* Basic operations */</span>
<span class="cp">#define SIOCSIWNWID	0x8B02		</span><span class="cm">/* set network id (pre-802.11) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWNWID	0x8B03		</span><span class="cm">/* get network id (the cell) */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWFREQ	0x8B04		</span><span class="cm">/* set channel/frequency (Hz) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWFREQ	0x8B05		</span><span class="cm">/* get channel/frequency (Hz) */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWMODE	0x8B06		</span><span class="cm">/* set operation mode */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWMODE	0x8B07		</span><span class="cm">/* get operation mode */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWSENS	0x8B08		</span><span class="cm">/* set sensitivity (dBm) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWSENS	0x8B09		</span><span class="cm">/* get sensitivity (dBm) */</span><span class="cp"></span>

<span class="cm">/* Informative stuff */</span>
<span class="cp">#define SIOCSIWRANGE	0x8B0A		</span><span class="cm">/* Unused */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWRANGE	0x8B0B		</span><span class="cm">/* Get range of parameters */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWPRIV	0x8B0C		</span><span class="cm">/* Unused */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWPRIV	0x8B0D		</span><span class="cm">/* get private ioctl interface info */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWSTATS	0x8B0E		</span><span class="cm">/* Unused */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWSTATS	0x8B0F		</span><span class="cm">/* Get /proc/net/wireless stats */</span><span class="cp"></span>
<span class="cm">/* SIOCGIWSTATS is strictly used between user space and the kernel, and</span>
<span class="cm"> * is never passed to the driver (i.e. the driver will never see it). */</span>

<span class="cm">/* Spy support (statistics per MAC address - used for Mobile IP support) */</span>
<span class="cp">#define SIOCSIWSPY	0x8B10		</span><span class="cm">/* set spy addresses */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWSPY	0x8B11		</span><span class="cm">/* get spy info (quality of link) */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWTHRSPY	0x8B12		</span><span class="cm">/* set spy threshold (spy event) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWTHRSPY	0x8B13		</span><span class="cm">/* get spy threshold */</span><span class="cp"></span>

<span class="cm">/* Access Point manipulation */</span>
<span class="cp">#define SIOCSIWAP	0x8B14		</span><span class="cm">/* set access point MAC addresses */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWAP	0x8B15		</span><span class="cm">/* get access point MAC addresses */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWAPLIST	0x8B17		</span><span class="cm">/* Deprecated in favor of scanning */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWSCAN	0x8B18		</span><span class="cm">/* trigger scanning (list cells) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWSCAN	0x8B19		</span><span class="cm">/* get scanning results */</span><span class="cp"></span>

<span class="cm">/* 802.11 specific support */</span>
<span class="cp">#define SIOCSIWESSID	0x8B1A		</span><span class="cm">/* set ESSID (network name) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWESSID	0x8B1B		</span><span class="cm">/* get ESSID */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWNICKN	0x8B1C		</span><span class="cm">/* set node name/nickname */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWNICKN	0x8B1D		</span><span class="cm">/* get node name/nickname */</span><span class="cp"></span>
<span class="cm">/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn&#39;t fit</span>
<span class="cm"> * within the &#39;iwreq&#39; structure, so we need to use the &#39;data&#39; member to</span>
<span class="cm"> * point to a string in user space, like it is done for RANGE... */</span>

<span class="cm">/* Other parameters useful in 802.11 and some other devices */</span>
<span class="cp">#define SIOCSIWRATE	0x8B20		</span><span class="cm">/* set default bit rate (bps) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWRATE	0x8B21		</span><span class="cm">/* get default bit rate (bps) */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWRTS	0x8B22		</span><span class="cm">/* set RTS/CTS threshold (bytes) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWRTS	0x8B23		</span><span class="cm">/* get RTS/CTS threshold (bytes) */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWFRAG	0x8B24		</span><span class="cm">/* set fragmentation thr (bytes) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWFRAG	0x8B25		</span><span class="cm">/* get fragmentation thr (bytes) */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWTXPOW	0x8B26		</span><span class="cm">/* set transmit power (dBm) */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWTXPOW	0x8B27		</span><span class="cm">/* get transmit power (dBm) */</span><span class="cp"></span>
<span class="cp">#define SIOCSIWRETRY	0x8B28		</span><span class="cm">/* set retry limits and lifetime */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWRETRY	0x8B29		</span><span class="cm">/* get retry limits and lifetime */</span><span class="cp"></span>

<span class="cm">/* Encoding stuff (scrambling, hardware security, WEP...) */</span>
<span class="cp">#define SIOCSIWENCODE	0x8B2A		</span><span class="cm">/* set encoding token &amp; mode */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWENCODE	0x8B2B		</span><span class="cm">/* get encoding token &amp; mode */</span><span class="cp"></span>
<span class="cm">/* Power saving stuff (power management, unicast and multicast) */</span>
<span class="cp">#define SIOCSIWPOWER	0x8B2C		</span><span class="cm">/* set Power Management settings */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWPOWER	0x8B2D		</span><span class="cm">/* get Power Management settings */</span><span class="cp"></span>

<span class="cm">/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).</span>
<span class="cm"> * This ioctl uses struct iw_point and data buffer that includes IE id and len</span>
<span class="cm"> * fields. More than one IE may be included in the request. Setting the generic</span>
<span class="cm"> * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers</span>
<span class="cm"> * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers</span>
<span class="cm"> * are required to report the used IE as a wireless event, e.g., when</span>
<span class="cm"> * associating with an AP. */</span>
<span class="cp">#define SIOCSIWGENIE	0x8B30		</span><span class="cm">/* set generic IE */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWGENIE	0x8B31		</span><span class="cm">/* get generic IE */</span><span class="cp"></span>

<span class="cm">/* WPA : IEEE 802.11 MLME requests */</span>
<span class="cp">#define SIOCSIWMLME	0x8B16		</span><span class="cm">/* request MLME operation; uses</span>
<span class="cm">					 * struct iw_mlme */</span><span class="cp"></span>
<span class="cm">/* WPA : Authentication mode parameters */</span>
<span class="cp">#define SIOCSIWAUTH	0x8B32		</span><span class="cm">/* set authentication mode params */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWAUTH	0x8B33		</span><span class="cm">/* get authentication mode params */</span><span class="cp"></span>

<span class="cm">/* WPA : Extended version of encoding configuration */</span>
<span class="cp">#define SIOCSIWENCODEEXT 0x8B34		</span><span class="cm">/* set encoding token &amp; mode */</span><span class="cp"></span>
<span class="cp">#define SIOCGIWENCODEEXT 0x8B35		</span><span class="cm">/* get encoding token &amp; mode */</span><span class="cp"></span>

<span class="cm">/* WPA2 : PMKSA cache management */</span>
<span class="cp">#define SIOCSIWPMKSA	0x8B36		</span><span class="cm">/* PMKSA cache operation */</span><span class="cp"></span>

<span class="cm">/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */</span>

<span class="cm">/* These 32 ioctl are wireless device private, for 16 commands.</span>
<span class="cm"> * Each driver is free to use them for whatever purpose it chooses,</span>
<span class="cm"> * however the driver *must* export the description of those ioctls</span>
<span class="cm"> * with SIOCGIWPRIV and *must* use arguments as defined below.</span>
<span class="cm"> * If you don&#39;t follow those rules, DaveM is going to hate you (reason :</span>
<span class="cm"> * it make mixed 32/64bit operation impossible).</span>
<span class="cm"> */</span>
<span class="cp">#define SIOCIWFIRSTPRIV	0x8BE0</span>
<span class="cp">#define SIOCIWLASTPRIV	0x8BFF</span>
<span class="cm">/* Previously, we were using SIOCDEVPRIVATE, but we now have our</span>
<span class="cm"> * separate range because of collisions with other tools such as</span>
<span class="cm"> * &#39;mii-tool&#39;.</span>
<span class="cm"> * We now have 32 commands, so a bit more space ;-).</span>
<span class="cm"> * Also, all &#39;even&#39; commands are only usable by root and don&#39;t return the</span>
<span class="cm"> * content of ifr/iwr to user (but you are not obliged to use the set/get</span>
<span class="cm"> * convention, just use every other two command). More details in iwpriv.c.</span>
<span class="cm"> * And I repeat : you are not forced to use them with iwpriv, but you</span>
<span class="cm"> * must be compliant with it.</span>
<span class="cm"> */</span>

<span class="cm">/* ------------------------- IOCTL STUFF ------------------------- */</span>

<span class="cm">/* The first and the last (range) */</span>
<span class="cp">#define SIOCIWFIRST	0x8B00</span>
<span class="cp">#define SIOCIWLAST	SIOCIWLASTPRIV		</span><span class="cm">/* 0x8BFF */</span><span class="cp"></span>
<span class="cp">#define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)</span>
<span class="cp">#define IW_HANDLER(id, func)			\</span>
<span class="cp">	[IW_IOCTL_IDX(id)] = func</span>

<span class="cm">/* Odd : get (world access), even : set (root access) */</span>
<span class="cp">#define IW_IS_SET(cmd)	(!((cmd) &amp; 0x1))</span>
<span class="cp">#define IW_IS_GET(cmd)	((cmd) &amp; 0x1)</span>

<span class="cm">/* ----------------------- WIRELESS EVENTS ----------------------- */</span>
<span class="cm">/* Those are *NOT* ioctls, do not issue request on them !!! */</span>
<span class="cm">/* Most events use the same identifier as ioctl requests */</span>

<span class="cp">#define IWEVTXDROP	0x8C00		</span><span class="cm">/* Packet dropped to excessive retry */</span><span class="cp"></span>
<span class="cp">#define IWEVQUAL	0x8C01		</span><span class="cm">/* Quality part of statistics (scan) */</span><span class="cp"></span>
<span class="cp">#define IWEVCUSTOM	0x8C02		</span><span class="cm">/* Driver specific ascii string */</span><span class="cp"></span>
<span class="cp">#define IWEVREGISTERED	0x8C03		</span><span class="cm">/* Discovered a new node (AP mode) */</span><span class="cp"></span>
<span class="cp">#define IWEVEXPIRED	0x8C04		</span><span class="cm">/* Expired a node (AP mode) */</span><span class="cp"></span>
<span class="cp">#define IWEVGENIE	0x8C05		</span><span class="cm">/* Generic IE (WPA, RSN, WMM, ..)</span>
<span class="cm">					 * (scan results); This includes id and</span>
<span class="cm">					 * length fields. One IWEVGENIE may</span>
<span class="cm">					 * contain more than one IE. Scan</span>
<span class="cm">					 * results may contain one or more</span>
<span class="cm">					 * IWEVGENIE events. */</span><span class="cp"></span>
<span class="cp">#define IWEVMICHAELMICFAILURE 0x8C06	</span><span class="cm">/* Michael MIC failure</span>
<span class="cm">					 * (struct iw_michaelmicfailure)</span>
<span class="cm">					 */</span><span class="cp"></span>
<span class="cp">#define IWEVASSOCREQIE	0x8C07		</span><span class="cm">/* IEs used in (Re)Association Request.</span>
<span class="cm">					 * The data includes id and length</span>
<span class="cm">					 * fields and may contain more than one</span>
<span class="cm">					 * IE. This event is required in</span>
<span class="cm">					 * Managed mode if the driver</span>
<span class="cm">					 * generates its own WPA/RSN IE. This</span>
<span class="cm">					 * should be sent just before</span>
<span class="cm">					 * IWEVREGISTERED event for the</span>
<span class="cm">					 * association. */</span><span class="cp"></span>
<span class="cp">#define IWEVASSOCRESPIE	0x8C08		</span><span class="cm">/* IEs used in (Re)Association</span>
<span class="cm">					 * Response. The data includes id and</span>
<span class="cm">					 * length fields and may contain more</span>
<span class="cm">					 * than one IE. This may be sent</span>
<span class="cm">					 * between IWEVASSOCREQIE and</span>
<span class="cm">					 * IWEVREGISTERED events for the</span>
<span class="cm">					 * association. */</span><span class="cp"></span>
<span class="cp">#define IWEVPMKIDCAND	0x8C09		</span><span class="cm">/* PMKID candidate for RSN</span>
<span class="cm">					 * pre-authentication</span>
<span class="cm">					 * (struct iw_pmkid_cand) */</span><span class="cp"></span>

<span class="cp">#define IWEVFIRST	0x8C00</span>
<span class="cp">#define IW_EVENT_IDX(cmd)	((cmd) - IWEVFIRST)</span>

<span class="cm">/* ------------------------- PRIVATE INFO ------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * The following is used with SIOCGIWPRIV. It allow a driver to define</span>
<span class="cm"> * the interface (name, type of data) for its private ioctl.</span>
<span class="cm"> * Privates ioctl are SIOCIWFIRSTPRIV -&gt; SIOCIWLASTPRIV</span>
<span class="cm"> */</span>

<span class="cp">#define IW_PRIV_TYPE_MASK	0x7000	</span><span class="cm">/* Type of arguments */</span><span class="cp"></span>
<span class="cp">#define IW_PRIV_TYPE_NONE	0x0000</span>
<span class="cp">#define IW_PRIV_TYPE_BYTE	0x1000	</span><span class="cm">/* Char as number */</span><span class="cp"></span>
<span class="cp">#define IW_PRIV_TYPE_CHAR	0x2000	</span><span class="cm">/* Char as character */</span><span class="cp"></span>
<span class="cp">#define IW_PRIV_TYPE_INT	0x4000	</span><span class="cm">/* 32 bits int */</span><span class="cp"></span>
<span class="cp">#define IW_PRIV_TYPE_FLOAT	0x5000	</span><span class="cm">/* struct iw_freq */</span><span class="cp"></span>
<span class="cp">#define IW_PRIV_TYPE_ADDR	0x6000	</span><span class="cm">/* struct sockaddr */</span><span class="cp"></span>

<span class="cp">#define IW_PRIV_SIZE_FIXED	0x0800	</span><span class="cm">/* Variable or fixed number of args */</span><span class="cp"></span>

<span class="cp">#define IW_PRIV_SIZE_MASK	0x07FF	</span><span class="cm">/* Max number of those args */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Note : if the number of args is fixed and the size &lt; 16 octets,</span>
<span class="cm"> * instead of passing a pointer we will put args in the iwreq struct...</span>
<span class="cm"> */</span>

<span class="cm">/* ----------------------- OTHER CONSTANTS ----------------------- */</span>

<span class="cm">/* Maximum frequencies in the range struct */</span>
<span class="cp">#define IW_MAX_FREQUENCIES	32</span>
<span class="cm">/* Note : if you have something like 80 frequencies,</span>
<span class="cm"> * don&#39;t increase this constant and don&#39;t fill the frequency list.</span>
<span class="cm"> * The user will be able to set by channel anyway... */</span>

<span class="cm">/* Maximum bit rates in the range struct */</span>
<span class="cp">#define IW_MAX_BITRATES		32</span>

<span class="cm">/* Maximum tx powers in the range struct */</span>
<span class="cp">#define IW_MAX_TXPOWER		8</span>
<span class="cm">/* Note : if you more than 8 TXPowers, just set the max and min or</span>
<span class="cm"> * a few of them in the struct iw_range. */</span>

<span class="cm">/* Maximum of address that you may set with SPY */</span>
<span class="cp">#define IW_MAX_SPY		8</span>

<span class="cm">/* Maximum of address that you may get in the</span>
<span class="cm">   list of access points in range */</span>
<span class="cp">#define IW_MAX_AP		64</span>

<span class="cm">/* Maximum size of the ESSID and NICKN strings */</span>
<span class="cp">#define IW_ESSID_MAX_SIZE	32</span>

<span class="cm">/* Modes of operation */</span>
<span class="cp">#define IW_MODE_AUTO	0	</span><span class="cm">/* Let the driver decides */</span><span class="cp"></span>
<span class="cp">#define IW_MODE_ADHOC	1	</span><span class="cm">/* Single cell network */</span><span class="cp"></span>
<span class="cp">#define IW_MODE_INFRA	2	</span><span class="cm">/* Multi cell network, roaming, ... */</span><span class="cp"></span>
<span class="cp">#define IW_MODE_MASTER	3	</span><span class="cm">/* Synchronisation master or Access Point */</span><span class="cp"></span>
<span class="cp">#define IW_MODE_REPEAT	4	</span><span class="cm">/* Wireless Repeater (forwarder) */</span><span class="cp"></span>
<span class="cp">#define IW_MODE_SECOND	5	</span><span class="cm">/* Secondary master/repeater (backup) */</span><span class="cp"></span>
<span class="cp">#define IW_MODE_MONITOR	6	</span><span class="cm">/* Passive monitor (listen only) */</span><span class="cp"></span>
<span class="cp">#define IW_MODE_MESH	7	</span><span class="cm">/* Mesh (IEEE 802.11s) network */</span><span class="cp"></span>

<span class="cm">/* Statistics flags (bitmask in updated) */</span>
<span class="cp">#define IW_QUAL_QUAL_UPDATED	0x01	</span><span class="cm">/* Value was updated since last read */</span><span class="cp"></span>
<span class="cp">#define IW_QUAL_LEVEL_UPDATED	0x02</span>
<span class="cp">#define IW_QUAL_NOISE_UPDATED	0x04</span>
<span class="cp">#define IW_QUAL_ALL_UPDATED	0x07</span>
<span class="cp">#define IW_QUAL_DBM		0x08	</span><span class="cm">/* Level + Noise are dBm */</span><span class="cp"></span>
<span class="cp">#define IW_QUAL_QUAL_INVALID	0x10	</span><span class="cm">/* Driver doesn&#39;t provide value */</span><span class="cp"></span>
<span class="cp">#define IW_QUAL_LEVEL_INVALID	0x20</span>
<span class="cp">#define IW_QUAL_NOISE_INVALID	0x40</span>
<span class="cp">#define IW_QUAL_RCPI		0x80	</span><span class="cm">/* Level + Noise are 802.11k RCPI */</span><span class="cp"></span>
<span class="cp">#define IW_QUAL_ALL_INVALID	0x70</span>

<span class="cm">/* Frequency flags */</span>
<span class="cp">#define IW_FREQ_AUTO		0x00	</span><span class="cm">/* Let the driver decides */</span><span class="cp"></span>
<span class="cp">#define IW_FREQ_FIXED		0x01	</span><span class="cm">/* Force a specific value */</span><span class="cp"></span>

<span class="cm">/* Maximum number of size of encoding token available</span>
<span class="cm"> * they are listed in the range structure */</span>
<span class="cp">#define IW_MAX_ENCODING_SIZES	8</span>

<span class="cm">/* Maximum size of the encoding token in bytes */</span>
<span class="cp">#define IW_ENCODING_TOKEN_MAX	64	</span><span class="cm">/* 512 bits (for now) */</span><span class="cp"></span>

<span class="cm">/* Flags for encoding (along with the token) */</span>
<span class="cp">#define IW_ENCODE_INDEX		0x00FF	</span><span class="cm">/* Token index (if needed) */</span><span class="cp"></span>
<span class="cp">#define IW_ENCODE_FLAGS		0xFF00	</span><span class="cm">/* Flags defined below */</span><span class="cp"></span>
<span class="cp">#define IW_ENCODE_MODE		0xF000	</span><span class="cm">/* Modes defined below */</span><span class="cp"></span>
<span class="cp">#define IW_ENCODE_DISABLED	0x8000	</span><span class="cm">/* Encoding disabled */</span><span class="cp"></span>
<span class="cp">#define IW_ENCODE_ENABLED	0x0000	</span><span class="cm">/* Encoding enabled */</span><span class="cp"></span>
<span class="cp">#define IW_ENCODE_RESTRICTED	0x4000	</span><span class="cm">/* Refuse non-encoded packets */</span><span class="cp"></span>
<span class="cp">#define IW_ENCODE_OPEN		0x2000	</span><span class="cm">/* Accept non-encoded packets */</span><span class="cp"></span>
<span class="cp">#define IW_ENCODE_NOKEY		0x0800  </span><span class="cm">/* Key is write only, so not present */</span><span class="cp"></span>
<span class="cp">#define IW_ENCODE_TEMP		0x0400  </span><span class="cm">/* Temporary key */</span><span class="cp"></span>

<span class="cm">/* Power management flags available (along with the value, if any) */</span>
<span class="cp">#define IW_POWER_ON		0x0000	</span><span class="cm">/* No details... */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_TYPE		0xF000	</span><span class="cm">/* Type of parameter */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_PERIOD		0x1000	</span><span class="cm">/* Value is a period/duration of  */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_TIMEOUT	0x2000	</span><span class="cm">/* Value is a timeout (to go asleep) */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_MODE		0x0F00	</span><span class="cm">/* Power Management mode */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_UNICAST_R	0x0100	</span><span class="cm">/* Receive only unicast messages */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_MULTICAST_R	0x0200	</span><span class="cm">/* Receive only multicast messages */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_ALL_R		0x0300	</span><span class="cm">/* Receive all messages though PM */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_FORCE_S	0x0400	</span><span class="cm">/* Force PM procedure for sending unicast */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_REPEATER	0x0800	</span><span class="cm">/* Repeat broadcast messages in PM period */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_MODIFIER	0x000F	</span><span class="cm">/* Modify a parameter */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_MIN		0x0001	</span><span class="cm">/* Value is a minimum  */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_MAX		0x0002	</span><span class="cm">/* Value is a maximum */</span><span class="cp"></span>
<span class="cp">#define IW_POWER_RELATIVE	0x0004	</span><span class="cm">/* Value is not in seconds/ms/us */</span><span class="cp"></span>

<span class="cm">/* Transmit Power flags available */</span>
<span class="cp">#define IW_TXPOW_TYPE		0x00FF	</span><span class="cm">/* Type of value */</span><span class="cp"></span>
<span class="cp">#define IW_TXPOW_DBM		0x0000	</span><span class="cm">/* Value is in dBm */</span><span class="cp"></span>
<span class="cp">#define IW_TXPOW_MWATT		0x0001	</span><span class="cm">/* Value is in mW */</span><span class="cp"></span>
<span class="cp">#define IW_TXPOW_RELATIVE	0x0002	</span><span class="cm">/* Value is in arbitrary units */</span><span class="cp"></span>
<span class="cp">#define IW_TXPOW_RANGE		0x1000	</span><span class="cm">/* Range of value between min/max */</span><span class="cp"></span>

<span class="cm">/* Retry limits and lifetime flags available */</span>
<span class="cp">#define IW_RETRY_ON		0x0000	</span><span class="cm">/* No details... */</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_TYPE		0xF000	</span><span class="cm">/* Type of parameter */</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_LIMIT		0x1000	</span><span class="cm">/* Maximum number of retries*/</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_LIFETIME	0x2000	</span><span class="cm">/* Maximum duration of retries in us */</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_MODIFIER	0x00FF	</span><span class="cm">/* Modify a parameter */</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_MIN		0x0001	</span><span class="cm">/* Value is a minimum  */</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_MAX		0x0002	</span><span class="cm">/* Value is a maximum */</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_RELATIVE	0x0004	</span><span class="cm">/* Value is not in seconds/ms/us */</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_SHORT		0x0010	</span><span class="cm">/* Value is for short packets  */</span><span class="cp"></span>
<span class="cp">#define IW_RETRY_LONG		0x0020	</span><span class="cm">/* Value is for long packets */</span><span class="cp"></span>

<span class="cm">/* Scanning request flags */</span>
<span class="cp">#define IW_SCAN_DEFAULT		0x0000	</span><span class="cm">/* Default scan of the driver */</span><span class="cp"></span>
<span class="cp">#define IW_SCAN_ALL_ESSID	0x0001	</span><span class="cm">/* Scan all ESSIDs */</span><span class="cp"></span>
<span class="cp">#define IW_SCAN_THIS_ESSID	0x0002	</span><span class="cm">/* Scan only this ESSID */</span><span class="cp"></span>
<span class="cp">#define IW_SCAN_ALL_FREQ	0x0004	</span><span class="cm">/* Scan all Frequencies */</span><span class="cp"></span>
<span class="cp">#define IW_SCAN_THIS_FREQ	0x0008	</span><span class="cm">/* Scan only this Frequency */</span><span class="cp"></span>
<span class="cp">#define IW_SCAN_ALL_MODE	0x0010	</span><span class="cm">/* Scan all Modes */</span><span class="cp"></span>
<span class="cp">#define IW_SCAN_THIS_MODE	0x0020	</span><span class="cm">/* Scan only this Mode */</span><span class="cp"></span>
<span class="cp">#define IW_SCAN_ALL_RATE	0x0040	</span><span class="cm">/* Scan all Bit-Rates */</span><span class="cp"></span>
<span class="cp">#define IW_SCAN_THIS_RATE	0x0080	</span><span class="cm">/* Scan only this Bit-Rate */</span><span class="cp"></span>
<span class="cm">/* struct iw_scan_req scan_type */</span>
<span class="cp">#define IW_SCAN_TYPE_ACTIVE 0</span>
<span class="cp">#define IW_SCAN_TYPE_PASSIVE 1</span>
<span class="cm">/* Maximum size of returned data */</span>
<span class="cp">#define IW_SCAN_MAX_DATA	4096	</span><span class="cm">/* In bytes */</span><span class="cp"></span>

<span class="cm">/* Scan capability flags - in (struct iw_range *)-&gt;scan_capa */</span>
<span class="cp">#define IW_SCAN_CAPA_NONE		0x00</span>
<span class="cp">#define IW_SCAN_CAPA_ESSID		0x01</span>
<span class="cp">#define IW_SCAN_CAPA_BSSID		0x02</span>
<span class="cp">#define IW_SCAN_CAPA_CHANNEL	0x04</span>
<span class="cp">#define IW_SCAN_CAPA_MODE		0x08</span>
<span class="cp">#define IW_SCAN_CAPA_RATE		0x10</span>
<span class="cp">#define IW_SCAN_CAPA_TYPE		0x20</span>
<span class="cp">#define IW_SCAN_CAPA_TIME		0x40</span>

<span class="cm">/* Max number of char in custom event - use multiple of them if needed */</span>
<span class="cp">#define IW_CUSTOM_MAX		256	</span><span class="cm">/* In bytes */</span><span class="cp"></span>

<span class="cm">/* Generic information element */</span>
<span class="cp">#define IW_GENERIC_IE_MAX	1024</span>

<span class="cm">/* MLME requests (SIOCSIWMLME / struct iw_mlme) */</span>
<span class="cp">#define IW_MLME_DEAUTH		0</span>
<span class="cp">#define IW_MLME_DISASSOC	1</span>
<span class="cp">#define IW_MLME_AUTH		2</span>
<span class="cp">#define IW_MLME_ASSOC		3</span>

<span class="cm">/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */</span>
<span class="cp">#define IW_AUTH_INDEX		0x0FFF</span>
<span class="cp">#define IW_AUTH_FLAGS		0xF000</span>
<span class="cm">/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)</span>
<span class="cm"> * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the</span>
<span class="cm"> * parameter that is being set/get to; value will be read/written to</span>
<span class="cm"> * struct iw_param value field) */</span>
<span class="cp">#define IW_AUTH_WPA_VERSION		0</span>
<span class="cp">#define IW_AUTH_CIPHER_PAIRWISE		1</span>
<span class="cp">#define IW_AUTH_CIPHER_GROUP		2</span>
<span class="cp">#define IW_AUTH_KEY_MGMT		3</span>
<span class="cp">#define IW_AUTH_TKIP_COUNTERMEASURES	4</span>
<span class="cp">#define IW_AUTH_DROP_UNENCRYPTED	5</span>
<span class="cp">#define IW_AUTH_80211_AUTH_ALG		6</span>
<span class="cp">#define IW_AUTH_WPA_ENABLED		7</span>
<span class="cp">#define IW_AUTH_RX_UNENCRYPTED_EAPOL	8</span>
<span class="cp">#define IW_AUTH_ROAMING_CONTROL		9</span>
<span class="cp">#define IW_AUTH_PRIVACY_INVOKED		10</span>
<span class="cp">#define IW_AUTH_CIPHER_GROUP_MGMT	11</span>
<span class="cp">#define IW_AUTH_MFP			12</span>

<span class="cm">/* IW_AUTH_WPA_VERSION values (bit field) */</span>
<span class="cp">#define IW_AUTH_WPA_VERSION_DISABLED	0x00000001</span>
<span class="cp">#define IW_AUTH_WPA_VERSION_WPA		0x00000002</span>
<span class="cp">#define IW_AUTH_WPA_VERSION_WPA2	0x00000004</span>

<span class="cm">/* IW_AUTH_PAIRWISE_CIPHER, IW_AUTH_GROUP_CIPHER, and IW_AUTH_CIPHER_GROUP_MGMT</span>
<span class="cm"> * values (bit field) */</span>
<span class="cp">#define IW_AUTH_CIPHER_NONE	0x00000001</span>
<span class="cp">#define IW_AUTH_CIPHER_WEP40	0x00000002</span>
<span class="cp">#define IW_AUTH_CIPHER_TKIP	0x00000004</span>
<span class="cp">#define IW_AUTH_CIPHER_CCMP	0x00000008</span>
<span class="cp">#define IW_AUTH_CIPHER_WEP104	0x00000010</span>
<span class="cp">#define IW_AUTH_CIPHER_AES_CMAC	0x00000020</span>

<span class="cm">/* IW_AUTH_KEY_MGMT values (bit field) */</span>
<span class="cp">#define IW_AUTH_KEY_MGMT_802_1X	1</span>
<span class="cp">#define IW_AUTH_KEY_MGMT_PSK	2</span>

<span class="cm">/* IW_AUTH_80211_AUTH_ALG values (bit field) */</span>
<span class="cp">#define IW_AUTH_ALG_OPEN_SYSTEM	0x00000001</span>
<span class="cp">#define IW_AUTH_ALG_SHARED_KEY	0x00000002</span>
<span class="cp">#define IW_AUTH_ALG_LEAP	0x00000004</span>

<span class="cm">/* IW_AUTH_ROAMING_CONTROL values */</span>
<span class="cp">#define IW_AUTH_ROAMING_ENABLE	0	</span><span class="cm">/* driver/firmware based roaming */</span><span class="cp"></span>
<span class="cp">#define IW_AUTH_ROAMING_DISABLE	1	</span><span class="cm">/* user space program used for roaming</span>
<span class="cm">					 * control */</span><span class="cp"></span>

<span class="cm">/* IW_AUTH_MFP (management frame protection) values */</span>
<span class="cp">#define IW_AUTH_MFP_DISABLED	0	</span><span class="cm">/* MFP disabled */</span><span class="cp"></span>
<span class="cp">#define IW_AUTH_MFP_OPTIONAL	1	</span><span class="cm">/* MFP optional */</span><span class="cp"></span>
<span class="cp">#define IW_AUTH_MFP_REQUIRED	2	</span><span class="cm">/* MFP required */</span><span class="cp"></span>

<span class="cm">/* SIOCSIWENCODEEXT definitions */</span>
<span class="cp">#define IW_ENCODE_SEQ_MAX_SIZE	8</span>
<span class="cm">/* struct iw_encode_ext -&gt;alg */</span>
<span class="cp">#define IW_ENCODE_ALG_NONE	0</span>
<span class="cp">#define IW_ENCODE_ALG_WEP	1</span>
<span class="cp">#define IW_ENCODE_ALG_TKIP	2</span>
<span class="cp">#define IW_ENCODE_ALG_CCMP	3</span>
<span class="cp">#define IW_ENCODE_ALG_PMK	4</span>
<span class="cp">#define IW_ENCODE_ALG_AES_CMAC	5</span>
<span class="cm">/* struct iw_encode_ext -&gt;ext_flags */</span>
<span class="cp">#define IW_ENCODE_EXT_TX_SEQ_VALID	0x00000001</span>
<span class="cp">#define IW_ENCODE_EXT_RX_SEQ_VALID	0x00000002</span>
<span class="cp">#define IW_ENCODE_EXT_GROUP_KEY		0x00000004</span>
<span class="cp">#define IW_ENCODE_EXT_SET_TX_KEY	0x00000008</span>

<span class="cm">/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure -&gt;flags */</span>
<span class="cp">#define IW_MICFAILURE_KEY_ID	0x00000003 </span><span class="cm">/* Key ID 0..3 */</span><span class="cp"></span>
<span class="cp">#define IW_MICFAILURE_GROUP	0x00000004</span>
<span class="cp">#define IW_MICFAILURE_PAIRWISE	0x00000008</span>
<span class="cp">#define IW_MICFAILURE_STAKEY	0x00000010</span>
<span class="cp">#define IW_MICFAILURE_COUNT	0x00000060 </span><span class="cm">/* 1 or 2 (0 = count not supported)</span>
<span class="cm">					    */</span><span class="cp"></span>

<span class="cm">/* Bit field values for enc_capa in struct iw_range */</span>
<span class="cp">#define IW_ENC_CAPA_WPA		0x00000001</span>
<span class="cp">#define IW_ENC_CAPA_WPA2	0x00000002</span>
<span class="cp">#define IW_ENC_CAPA_CIPHER_TKIP	0x00000004</span>
<span class="cp">#define IW_ENC_CAPA_CIPHER_CCMP	0x00000008</span>
<span class="cp">#define IW_ENC_CAPA_4WAY_HANDSHAKE	0x00000010</span>

<span class="cm">/* Event capability macros - in (struct iw_range *)-&gt;event_capa</span>
<span class="cm"> * Because we have more than 32 possible events, we use an array of</span>
<span class="cm"> * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */</span>
<span class="cp">#define IW_EVENT_CAPA_BASE(cmd)		((cmd &gt;= SIOCIWFIRSTPRIV) ? \</span>
<span class="cp">					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \</span>
<span class="cp">					 (cmd - SIOCIWFIRST))</span>
<span class="cp">#define IW_EVENT_CAPA_INDEX(cmd)	(IW_EVENT_CAPA_BASE(cmd) &gt;&gt; 5)</span>
<span class="cp">#define IW_EVENT_CAPA_MASK(cmd)		(1 &lt;&lt; (IW_EVENT_CAPA_BASE(cmd) &amp; 0x1F))</span>
<span class="cm">/* Event capability constants - event autogenerated by the kernel</span>
<span class="cm"> * This list is valid for most 802.11 devices, customise as needed... */</span>
<span class="cp">#define IW_EVENT_CAPA_K_0	(IW_EVENT_CAPA_MASK(0x8B04) | \</span>
<span class="cp">				 IW_EVENT_CAPA_MASK(0x8B06) | \</span>
<span class="cp">				 IW_EVENT_CAPA_MASK(0x8B1A))</span>
<span class="cp">#define IW_EVENT_CAPA_K_1	(IW_EVENT_CAPA_MASK(0x8B2A))</span>
<span class="cm">/* &quot;Easy&quot; macro to set events in iw_range (less efficient) */</span>
<span class="cp">#define IW_EVENT_CAPA_SET(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))</span>
<span class="cp">#define IW_EVENT_CAPA_SET_KERNEL(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }</span>


<span class="cm">/****************************** TYPES ******************************/</span>

<span class="cm">/* --------------------------- SUBTYPES --------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> *	Generic format for most parameters that fit in an int</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_param</span>
<span class="p">{</span>
  <span class="n">__s32</span>		<span class="n">value</span><span class="p">;</span>		<span class="cm">/* The value of the parameter itself */</span>
  <span class="n">__u8</span>		<span class="n">fixed</span><span class="p">;</span>		<span class="cm">/* Hardware should not use auto select */</span>
  <span class="n">__u8</span>		<span class="n">disabled</span><span class="p">;</span>	<span class="cm">/* Disable the feature */</span>
  <span class="n">__u16</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Various specifc flags (if any) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	For all data larger than 16 octets, we need to use a</span>
<span class="cm"> *	pointer to memory allocated in user space.</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_point</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="n">__user</span>	<span class="o">*</span><span class="n">pointer</span><span class="p">;</span>	<span class="cm">/* Pointer to the data  (in user space) */</span>
  <span class="n">__u16</span>		<span class="n">length</span><span class="p">;</span>		<span class="cm">/* number of fields or size in bytes */</span>
  <span class="n">__u16</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Optional params */</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>

<span class="cp">#include &lt;linux/compat.h&gt;</span>

<span class="k">struct</span> <span class="n">compat_iw_point</span> <span class="p">{</span>
	<span class="n">compat_caddr_t</span> <span class="n">pointer</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	A frequency</span>
<span class="cm"> *	For numbers lower than 10^9, we encode the number in &#39;m&#39; and</span>
<span class="cm"> *	set &#39;e&#39; to 0</span>
<span class="cm"> *	For number greater than 10^9, we divide it by the lowest power</span>
<span class="cm"> *	of 10 to get &#39;m&#39; lower than 10^9, with &#39;m&#39;= f / (10^&#39;e&#39;)...</span>
<span class="cm"> *	The power of 10 is in &#39;e&#39;, the result of the division is in &#39;m&#39;.</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_freq</span>
<span class="p">{</span>
	<span class="n">__s32</span>		<span class="n">m</span><span class="p">;</span>		<span class="cm">/* Mantissa */</span>
	<span class="n">__s16</span>		<span class="n">e</span><span class="p">;</span>		<span class="cm">/* Exponent */</span>
	<span class="n">__u8</span>		<span class="n">i</span><span class="p">;</span>		<span class="cm">/* List index (when in range struct) */</span>
	<span class="n">__u8</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Flags (fixed/auto) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Quality of the link</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_quality</span>
<span class="p">{</span>
	<span class="n">__u8</span>		<span class="n">qual</span><span class="p">;</span>		<span class="cm">/* link quality (%retries, SNR,</span>
<span class="cm">					   %missed beacons or better...) */</span>
	<span class="n">__u8</span>		<span class="n">level</span><span class="p">;</span>		<span class="cm">/* signal level (dBm) */</span>
	<span class="n">__u8</span>		<span class="n">noise</span><span class="p">;</span>		<span class="cm">/* noise level (dBm) */</span>
	<span class="n">__u8</span>		<span class="n">updated</span><span class="p">;</span>	<span class="cm">/* Flags to know if updated */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Packet discarded in the wireless adapter due to</span>
<span class="cm"> *	&quot;wireless&quot; specific problems...</span>
<span class="cm"> *	Note : the list of counter and statistics in net_device_stats</span>
<span class="cm"> *	is already pretty exhaustive, and you should use that first.</span>
<span class="cm"> *	This is only additional stats...</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_discarded</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">nwid</span><span class="p">;</span>		<span class="cm">/* Rx : Wrong nwid/essid */</span>
	<span class="n">__u32</span>		<span class="n">code</span><span class="p">;</span>		<span class="cm">/* Rx : Unable to code/decode (WEP) */</span>
	<span class="n">__u32</span>		<span class="n">fragment</span><span class="p">;</span>	<span class="cm">/* Rx : Can&#39;t perform MAC reassembly */</span>
	<span class="n">__u32</span>		<span class="n">retries</span><span class="p">;</span>	<span class="cm">/* Tx : Max MAC retries num reached */</span>
	<span class="n">__u32</span>		<span class="n">misc</span><span class="p">;</span>		<span class="cm">/* Others cases */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Packet/Time period missed in the wireless adapter due to</span>
<span class="cm"> *	&quot;wireless&quot; specific problems...</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_missed</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">beacon</span><span class="p">;</span>		<span class="cm">/* Missed beacons/superframe */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Quality range (for spy threshold)</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_thrspy</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>		<span class="n">addr</span><span class="p">;</span>		<span class="cm">/* Source address (hw/mac) */</span>
	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">qual</span><span class="p">;</span>		<span class="cm">/* Quality of the link */</span>
	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">low</span><span class="p">;</span>		<span class="cm">/* Low threshold */</span>
	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">high</span><span class="p">;</span>		<span class="cm">/* High threshold */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Optional data for scan request</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: these optional parameters are controlling parameters for the</span>
<span class="cm"> *	scanning behavior, these do not apply to getting scan results</span>
<span class="cm"> *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and</span>
<span class="cm"> *	provide a merged results with all BSSes even if the previous scan</span>
<span class="cm"> *	request limited scanning to a subset, e.g., by specifying an SSID.</span>
<span class="cm"> *	Especially, scan results are required to include an entry for the</span>
<span class="cm"> *	current BSS if the driver is in Managed mode and associated with an AP.</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_scan_req</span>
<span class="p">{</span>
	<span class="n">__u8</span>		<span class="n">scan_type</span><span class="p">;</span> <span class="cm">/* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */</span>
	<span class="n">__u8</span>		<span class="n">essid_len</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">num_channels</span><span class="p">;</span> <span class="cm">/* num entries in channel_list;</span>
<span class="cm">				       * 0 = scan all allowed channels */</span>
	<span class="n">__u8</span>		<span class="n">flags</span><span class="p">;</span> <span class="cm">/* reserved as padding; use zero, this may</span>
<span class="cm">				* be used in the future for adding flags</span>
<span class="cm">				* to request different scan behavior */</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="n">bssid</span><span class="p">;</span> <span class="cm">/* ff:ff:ff:ff:ff:ff for broadcast BSSID or</span>
<span class="cm">				* individual address of a specific BSS */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using</span>
<span class="cm">	 * the current ESSID. This allows scan requests for specific ESSID</span>
<span class="cm">	 * without having to change the current ESSID and potentially breaking</span>
<span class="cm">	 * the current association.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span>		<span class="n">essid</span><span class="p">[</span><span class="n">IW_ESSID_MAX_SIZE</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optional parameters for changing the default scanning behavior.</span>
<span class="cm">	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.</span>
<span class="cm">	 * TU is 1.024 ms. If these are set to 0, driver is expected to use</span>
<span class="cm">	 * reasonable default values. min_channel_time defines the time that</span>
<span class="cm">	 * will be used to wait for the first reply on each channel. If no</span>
<span class="cm">	 * replies are received, next channel will be scanned after this. If</span>
<span class="cm">	 * replies are received, total time waited on the channel is defined by</span>
<span class="cm">	 * max_channel_time.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span>		<span class="n">min_channel_time</span><span class="p">;</span> <span class="cm">/* in TU */</span>
	<span class="n">__u32</span>		<span class="n">max_channel_time</span><span class="p">;</span> <span class="cm">/* in TU */</span>

	<span class="k">struct</span> <span class="n">iw_freq</span>	<span class="n">channel_list</span><span class="p">[</span><span class="n">IW_MAX_FREQUENCIES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* ------------------------- WPA SUPPORT ------------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> *	Extended data structure for get/set encoding (this is used with</span>
<span class="cm"> *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*</span>
<span class="cm"> *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and</span>
<span class="cm"> *	only the data contents changes (key data -&gt; this structure, including</span>
<span class="cm"> *	key data).</span>
<span class="cm"> *</span>
<span class="cm"> *	If the new key is the first group key, it will be set as the default</span>
<span class="cm"> *	TX key. Otherwise, default TX key index is only changed if</span>
<span class="cm"> *	IW_ENCODE_EXT_SET_TX_KEY flag is set.</span>
<span class="cm"> *</span>
<span class="cm"> *	Key will be changed with SIOCSIWENCODEEXT in all cases except for</span>
<span class="cm"> *	special &quot;change TX key index&quot; operation which is indicated by setting</span>
<span class="cm"> *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.</span>
<span class="cm"> *</span>
<span class="cm"> *	tx_seq/rx_seq are only used when respective</span>
<span class="cm"> *	IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal</span>
<span class="cm"> *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start</span>
<span class="cm"> *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally</span>
<span class="cm"> *	used only by an Authenticator (AP or an IBSS station) to get the</span>
<span class="cm"> *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and</span>
<span class="cm"> *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for</span>
<span class="cm"> *	debugging/testing.</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_encode_ext</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">ext_flags</span><span class="p">;</span> <span class="cm">/* IW_ENCODE_EXT_* */</span>
	<span class="n">__u8</span>		<span class="n">tx_seq</span><span class="p">[</span><span class="n">IW_ENCODE_SEQ_MAX_SIZE</span><span class="p">];</span> <span class="cm">/* LSB first */</span>
	<span class="n">__u8</span>		<span class="n">rx_seq</span><span class="p">[</span><span class="n">IW_ENCODE_SEQ_MAX_SIZE</span><span class="p">];</span> <span class="cm">/* LSB first */</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="n">addr</span><span class="p">;</span> <span class="cm">/* ff:ff:ff:ff:ff:ff for broadcast/multicast</span>
<span class="cm">			       * (group) keys or unicast address for</span>
<span class="cm">			       * individual keys */</span>
	<span class="n">__u16</span>		<span class="n">alg</span><span class="p">;</span> <span class="cm">/* IW_ENCODE_ALG_* */</span>
	<span class="n">__u16</span>		<span class="n">key_len</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* SIOCSIWMLME data */</span>
<span class="k">struct</span>	<span class="n">iw_mlme</span>
<span class="p">{</span>
	<span class="n">__u16</span>		<span class="n">cmd</span><span class="p">;</span> <span class="cm">/* IW_MLME_* */</span>
	<span class="n">__u16</span>		<span class="n">reason_code</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="n">addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* SIOCSIWPMKSA data */</span>
<span class="cp">#define IW_PMKSA_ADD		1</span>
<span class="cp">#define IW_PMKSA_REMOVE		2</span>
<span class="cp">#define IW_PMKSA_FLUSH		3</span>

<span class="cp">#define IW_PMKID_LEN	16</span>

<span class="k">struct</span>	<span class="n">iw_pmksa</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">cmd</span><span class="p">;</span> <span class="cm">/* IW_PMKSA_* */</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="n">bssid</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">pmkid</span><span class="p">[</span><span class="n">IW_PMKID_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* IWEVMICHAELMICFAILURE data */</span>
<span class="k">struct</span>	<span class="n">iw_michaelmicfailure</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="n">src_addr</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">tsc</span><span class="p">[</span><span class="n">IW_ENCODE_SEQ_MAX_SIZE</span><span class="p">];</span> <span class="cm">/* LSB first */</span>
<span class="p">};</span>

<span class="cm">/* IWEVPMKIDCAND data */</span>
<span class="cp">#define IW_PMKID_CAND_PREAUTH	0x00000001 </span><span class="cm">/* RNS pre-authentication enabled */</span><span class="cp"></span>
<span class="k">struct</span>	<span class="n">iw_pmkid_cand</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">flags</span><span class="p">;</span> <span class="cm">/* IW_PMKID_CAND_* */</span>
	<span class="n">__u32</span>		<span class="n">index</span><span class="p">;</span> <span class="cm">/* the smaller the index, the higher the</span>
<span class="cm">				* priority */</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="n">bssid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* ------------------------ WIRELESS STATS ------------------------ */</span>
<span class="cm">/*</span>
<span class="cm"> * Wireless statistics (used for /proc/net/wireless)</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iw_statistics</span>
<span class="p">{</span>
	<span class="n">__u16</span>		<span class="n">status</span><span class="p">;</span>		<span class="cm">/* Status</span>
<span class="cm">					 * - device dependent for now */</span>

	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">qual</span><span class="p">;</span>		<span class="cm">/* Quality of the link</span>
<span class="cm">						 * (instant/mean/max) */</span>
	<span class="k">struct</span> <span class="n">iw_discarded</span>	<span class="n">discard</span><span class="p">;</span>	<span class="cm">/* Packet discarded counts */</span>
	<span class="k">struct</span> <span class="n">iw_missed</span>	<span class="n">miss</span><span class="p">;</span>		<span class="cm">/* Packet missed counts */</span>
<span class="p">};</span>

<span class="cm">/* ------------------------ IOCTL REQUEST ------------------------ */</span>
<span class="cm">/*</span>
<span class="cm"> * This structure defines the payload of an ioctl, and is used </span>
<span class="cm"> * below.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this structure should fit on the memory footprint</span>
<span class="cm"> * of iwreq (which is the same as ifreq), which mean a max size of</span>
<span class="cm"> * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...</span>
<span class="cm"> * You should check this when increasing the structures defined</span>
<span class="cm"> * above in this file...</span>
<span class="cm"> */</span>
<span class="k">union</span>	<span class="n">iwreq_data</span>
<span class="p">{</span>
	<span class="cm">/* Config - generic */</span>
	<span class="kt">char</span>		<span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="cm">/* Name : used to verify the presence of  wireless extensions.</span>
<span class="cm">	 * Name of the protocol/provider... */</span>

	<span class="k">struct</span> <span class="n">iw_point</span>	<span class="n">essid</span><span class="p">;</span>		<span class="cm">/* Extended network name */</span>
	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">nwid</span><span class="p">;</span>		<span class="cm">/* network id (or domain - the cell) */</span>
	<span class="k">struct</span> <span class="n">iw_freq</span>	<span class="n">freq</span><span class="p">;</span>		<span class="cm">/* frequency or channel :</span>
<span class="cm">					 * 0-1000 = channel</span>
<span class="cm">					 * &gt; 1000 = frequency in Hz */</span>

	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">sens</span><span class="p">;</span>		<span class="cm">/* signal level threshold */</span>
	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">bitrate</span><span class="p">;</span>	<span class="cm">/* default bit rate */</span>
	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">txpower</span><span class="p">;</span>	<span class="cm">/* default transmit power */</span>
	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">rts</span><span class="p">;</span>		<span class="cm">/* RTS threshold threshold */</span>
	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">frag</span><span class="p">;</span>		<span class="cm">/* Fragmentation threshold */</span>
	<span class="n">__u32</span>		<span class="n">mode</span><span class="p">;</span>		<span class="cm">/* Operation mode */</span>
	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">retry</span><span class="p">;</span>		<span class="cm">/* Retry limits &amp; lifetime */</span>

	<span class="k">struct</span> <span class="n">iw_point</span>	<span class="n">encoding</span><span class="p">;</span>	<span class="cm">/* Encoding stuff : tokens */</span>
	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">power</span><span class="p">;</span>		<span class="cm">/* PM duration/timeout */</span>
	<span class="k">struct</span> <span class="n">iw_quality</span> <span class="n">qual</span><span class="p">;</span>		<span class="cm">/* Quality part of statistics */</span>

	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="n">ap_addr</span><span class="p">;</span>	<span class="cm">/* Access point address */</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="n">addr</span><span class="p">;</span>		<span class="cm">/* Destination address (hw/mac) */</span>

	<span class="k">struct</span> <span class="n">iw_param</span>	<span class="n">param</span><span class="p">;</span>		<span class="cm">/* Other small parameters */</span>
	<span class="k">struct</span> <span class="n">iw_point</span>	<span class="n">data</span><span class="p">;</span>		<span class="cm">/* Other large parameters */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The structure to exchange data for ioctl.</span>
<span class="cm"> * This structure is the same as &#39;struct ifreq&#39;, but (re)defined for</span>
<span class="cm"> * convenience...</span>
<span class="cm"> * Do I need to remind you about structure size (32 octets) ?</span>
<span class="cm"> */</span>
<span class="k">struct</span>	<span class="n">iwreq</span> 
<span class="p">{</span>
	<span class="k">union</span>
	<span class="p">{</span>
		<span class="kt">char</span>	<span class="n">ifrn_name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>	<span class="cm">/* if name, e.g. &quot;eth0&quot; */</span>
	<span class="p">}</span> <span class="n">ifr_ifrn</span><span class="p">;</span>

	<span class="cm">/* Data part (defined just above) */</span>
	<span class="k">union</span>	<span class="n">iwreq_data</span>	<span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* -------------------------- IOCTL DATA -------------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> *	For those ioctl which want to exchange mode data that what could</span>
<span class="cm"> *	fit in the above structure...</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Range of parameters</span>
<span class="cm"> */</span>

<span class="k">struct</span>	<span class="n">iw_range</span>
<span class="p">{</span>
	<span class="cm">/* Informative stuff (to choose between different interface) */</span>
	<span class="n">__u32</span>		<span class="n">throughput</span><span class="p">;</span>	<span class="cm">/* To give an idea... */</span>
	<span class="cm">/* In theory this value should be the maximum benchmarked</span>
<span class="cm">	 * TCP/IP throughput, because with most of these devices the</span>
<span class="cm">	 * bit rate is meaningless (overhead an co) to estimate how</span>
<span class="cm">	 * fast the connection will go and pick the fastest one.</span>
<span class="cm">	 * I suggest people to play with Netperf or any benchmark...</span>
<span class="cm">	 */</span>

	<span class="cm">/* NWID (or domain id) */</span>
	<span class="n">__u32</span>		<span class="n">min_nwid</span><span class="p">;</span>	<span class="cm">/* Minimal NWID we are able to set */</span>
	<span class="n">__u32</span>		<span class="n">max_nwid</span><span class="p">;</span>	<span class="cm">/* Maximal NWID we are able to set */</span>

	<span class="cm">/* Old Frequency (backward compat - moved lower ) */</span>
	<span class="n">__u16</span>		<span class="n">old_num_channels</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">old_num_frequency</span><span class="p">;</span>

	<span class="cm">/* Scan capabilities */</span>
	<span class="n">__u8</span>		<span class="n">scan_capa</span><span class="p">;</span> 	<span class="cm">/* IW_SCAN_CAPA_* bit field */</span>

	<span class="cm">/* Wireless event capability bitmasks */</span>
	<span class="n">__u32</span>		<span class="n">event_capa</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="cm">/* signal level threshold range */</span>
	<span class="n">__s32</span>		<span class="n">sensitivity</span><span class="p">;</span>

	<span class="cm">/* Quality of link &amp; SNR stuff */</span>
	<span class="cm">/* Quality range (link, level, noise)</span>
<span class="cm">	 * If the quality is absolute, it will be in the range [0 ; max_qual],</span>
<span class="cm">	 * if the quality is dBm, it will be in the range [max_qual ; 0].</span>
<span class="cm">	 * Don&#39;t forget that we use 8 bit arithmetics... */</span>
	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">max_qual</span><span class="p">;</span>	<span class="cm">/* Quality of the link */</span>
	<span class="cm">/* This should contain the average/typical values of the quality</span>
<span class="cm">	 * indicator. This should be the threshold between a &quot;good&quot; and</span>
<span class="cm">	 * a &quot;bad&quot; link (example : monitor going from green to orange).</span>
<span class="cm">	 * Currently, user space apps like quality monitors don&#39;t have any</span>
<span class="cm">	 * way to calibrate the measurement. With this, they can split</span>
<span class="cm">	 * the range between 0 and max_qual in different quality level</span>
<span class="cm">	 * (using a geometric subdivision centered on the average).</span>
<span class="cm">	 * I expect that people doing the user space apps will feedback</span>
<span class="cm">	 * us on which value we need to put in each driver... */</span>
	<span class="k">struct</span> <span class="n">iw_quality</span>	<span class="n">avg_qual</span><span class="p">;</span>	<span class="cm">/* Quality of the link */</span>

	<span class="cm">/* Rates */</span>
	<span class="n">__u8</span>		<span class="n">num_bitrates</span><span class="p">;</span>	<span class="cm">/* Number of entries in the list */</span>
	<span class="n">__s32</span>		<span class="n">bitrate</span><span class="p">[</span><span class="n">IW_MAX_BITRATES</span><span class="p">];</span>	<span class="cm">/* list, in bps */</span>

	<span class="cm">/* RTS threshold */</span>
	<span class="n">__s32</span>		<span class="n">min_rts</span><span class="p">;</span>	<span class="cm">/* Minimal RTS threshold */</span>
	<span class="n">__s32</span>		<span class="n">max_rts</span><span class="p">;</span>	<span class="cm">/* Maximal RTS threshold */</span>

	<span class="cm">/* Frag threshold */</span>
	<span class="n">__s32</span>		<span class="n">min_frag</span><span class="p">;</span>	<span class="cm">/* Minimal frag threshold */</span>
	<span class="n">__s32</span>		<span class="n">max_frag</span><span class="p">;</span>	<span class="cm">/* Maximal frag threshold */</span>

	<span class="cm">/* Power Management duration &amp; timeout */</span>
	<span class="n">__s32</span>		<span class="n">min_pmp</span><span class="p">;</span>	<span class="cm">/* Minimal PM period */</span>
	<span class="n">__s32</span>		<span class="n">max_pmp</span><span class="p">;</span>	<span class="cm">/* Maximal PM period */</span>
	<span class="n">__s32</span>		<span class="n">min_pmt</span><span class="p">;</span>	<span class="cm">/* Minimal PM timeout */</span>
	<span class="n">__s32</span>		<span class="n">max_pmt</span><span class="p">;</span>	<span class="cm">/* Maximal PM timeout */</span>
	<span class="n">__u16</span>		<span class="n">pmp_flags</span><span class="p">;</span>	<span class="cm">/* How to decode max/min PM period */</span>
	<span class="n">__u16</span>		<span class="n">pmt_flags</span><span class="p">;</span>	<span class="cm">/* How to decode max/min PM timeout */</span>
	<span class="n">__u16</span>		<span class="n">pm_capa</span><span class="p">;</span>	<span class="cm">/* What PM options are supported */</span>

	<span class="cm">/* Encoder stuff */</span>
	<span class="n">__u16</span>	<span class="n">encoding_size</span><span class="p">[</span><span class="n">IW_MAX_ENCODING_SIZES</span><span class="p">];</span>	<span class="cm">/* Different token sizes */</span>
	<span class="n">__u8</span>	<span class="n">num_encoding_sizes</span><span class="p">;</span>	<span class="cm">/* Number of entry in the list */</span>
	<span class="n">__u8</span>	<span class="n">max_encoding_tokens</span><span class="p">;</span>	<span class="cm">/* Max number of tokens */</span>
	<span class="cm">/* For drivers that need a &quot;login/passwd&quot; form */</span>
	<span class="n">__u8</span>	<span class="n">encoding_login_index</span><span class="p">;</span>	<span class="cm">/* token index for login token */</span>

	<span class="cm">/* Transmit power */</span>
	<span class="n">__u16</span>		<span class="n">txpower_capa</span><span class="p">;</span>	<span class="cm">/* What options are supported */</span>
	<span class="n">__u8</span>		<span class="n">num_txpower</span><span class="p">;</span>	<span class="cm">/* Number of entries in the list */</span>
	<span class="n">__s32</span>		<span class="n">txpower</span><span class="p">[</span><span class="n">IW_MAX_TXPOWER</span><span class="p">];</span>	<span class="cm">/* list, in bps */</span>

	<span class="cm">/* Wireless Extension version info */</span>
	<span class="n">__u8</span>		<span class="n">we_version_compiled</span><span class="p">;</span>	<span class="cm">/* Must be WIRELESS_EXT */</span>
	<span class="n">__u8</span>		<span class="n">we_version_source</span><span class="p">;</span>	<span class="cm">/* Last update of source */</span>

	<span class="cm">/* Retry limits and lifetime */</span>
	<span class="n">__u16</span>		<span class="n">retry_capa</span><span class="p">;</span>	<span class="cm">/* What retry options are supported */</span>
	<span class="n">__u16</span>		<span class="n">retry_flags</span><span class="p">;</span>	<span class="cm">/* How to decode max/min retry limit */</span>
	<span class="n">__u16</span>		<span class="n">r_time_flags</span><span class="p">;</span>	<span class="cm">/* How to decode max/min retry life */</span>
	<span class="n">__s32</span>		<span class="n">min_retry</span><span class="p">;</span>	<span class="cm">/* Minimal number of retries */</span>
	<span class="n">__s32</span>		<span class="n">max_retry</span><span class="p">;</span>	<span class="cm">/* Maximal number of retries */</span>
	<span class="n">__s32</span>		<span class="n">min_r_time</span><span class="p">;</span>	<span class="cm">/* Minimal retry lifetime */</span>
	<span class="n">__s32</span>		<span class="n">max_r_time</span><span class="p">;</span>	<span class="cm">/* Maximal retry lifetime */</span>

	<span class="cm">/* Frequency */</span>
	<span class="n">__u16</span>		<span class="n">num_channels</span><span class="p">;</span>	<span class="cm">/* Number of channels [0; num - 1] */</span>
	<span class="n">__u8</span>		<span class="n">num_frequency</span><span class="p">;</span>	<span class="cm">/* Number of entry in the list */</span>
	<span class="k">struct</span> <span class="n">iw_freq</span>	<span class="n">freq</span><span class="p">[</span><span class="n">IW_MAX_FREQUENCIES</span><span class="p">];</span>	<span class="cm">/* list */</span>
	<span class="cm">/* Note : this frequency list doesn&#39;t need to fit channel numbers,</span>
<span class="cm">	 * because each entry contain its channel index */</span>

	<span class="n">__u32</span>		<span class="n">enc_capa</span><span class="p">;</span>	<span class="cm">/* IW_ENC_CAPA_* bit field */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Private ioctl interface information</span>
<span class="cm"> */</span>
 
<span class="k">struct</span>	<span class="n">iw_priv_args</span>
<span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* Number of the ioctl to issue */</span>
	<span class="n">__u16</span>		<span class="n">set_args</span><span class="p">;</span>	<span class="cm">/* Type and number of args */</span>
	<span class="n">__u16</span>		<span class="n">get_args</span><span class="p">;</span>	<span class="cm">/* Type and number of args */</span>
	<span class="kt">char</span>		<span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>	<span class="cm">/* Name of the extension */</span>
<span class="p">};</span>

<span class="cm">/* ----------------------- WIRELESS EVENTS ----------------------- */</span>
<span class="cm">/*</span>
<span class="cm"> * Wireless events are carried through the rtnetlink socket to user</span>
<span class="cm"> * space. They are encapsulated in the IFLA_WIRELESS field of</span>
<span class="cm"> * a RTM_NEWLINK message.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * A Wireless Event. Contains basically the same data as the ioctl...</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iw_event</span>
<span class="p">{</span>
	<span class="n">__u16</span>		<span class="n">len</span><span class="p">;</span>			<span class="cm">/* Real length of this stuff */</span>
	<span class="n">__u16</span>		<span class="n">cmd</span><span class="p">;</span>			<span class="cm">/* Wireless IOCTL */</span>
	<span class="k">union</span> <span class="n">iwreq_data</span>	<span class="n">u</span><span class="p">;</span>		<span class="cm">/* IOCTL fixed payload */</span>
<span class="p">};</span>

<span class="cm">/* Size of the Event prefix (including padding and alignement junk) */</span>
<span class="cp">#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))</span>
<span class="cm">/* Size of the various events */</span>
<span class="cp">#define IW_EV_CHAR_LEN	(IW_EV_LCP_LEN + IFNAMSIZ)</span>
<span class="cp">#define IW_EV_UINT_LEN	(IW_EV_LCP_LEN + sizeof(__u32))</span>
<span class="cp">#define IW_EV_FREQ_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_freq))</span>
<span class="cp">#define IW_EV_PARAM_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_param))</span>
<span class="cp">#define IW_EV_ADDR_LEN	(IW_EV_LCP_LEN + sizeof(struct sockaddr))</span>
<span class="cp">#define IW_EV_QUAL_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_quality))</span>

<span class="cm">/* iw_point events are special. First, the payload (extra data) come at</span>
<span class="cm"> * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,</span>
<span class="cm"> * we omit the pointer, so start at an offset. */</span>
<span class="cp">#define IW_EV_POINT_OFF (((char *) &amp;(((struct iw_point *) NULL)-&gt;length)) - \</span>
<span class="cp">			  (char *) NULL)</span>
<span class="cp">#define IW_EV_POINT_LEN	(IW_EV_LCP_LEN + sizeof(struct iw_point) - \</span>
<span class="cp">			 IW_EV_POINT_OFF)</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">struct</span> <span class="n">__compat_iw_event</span> <span class="p">{</span>
	<span class="n">__u16</span>		<span class="n">len</span><span class="p">;</span>			<span class="cm">/* Real length of this stuff */</span>
	<span class="n">__u16</span>		<span class="n">cmd</span><span class="p">;</span>			<span class="cm">/* Wireless IOCTL */</span>
	<span class="n">compat_caddr_t</span>	<span class="n">pointer</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define IW_EV_COMPAT_LCP_LEN offsetof(struct __compat_iw_event, pointer)</span>
<span class="cp">#define IW_EV_COMPAT_POINT_OFF offsetof(struct compat_iw_point, length)</span>

<span class="cm">/* Size of the various events for compat */</span>
<span class="cp">#define IW_EV_COMPAT_CHAR_LEN	(IW_EV_COMPAT_LCP_LEN + IFNAMSIZ)</span>
<span class="cp">#define IW_EV_COMPAT_UINT_LEN	(IW_EV_COMPAT_LCP_LEN + sizeof(__u32))</span>
<span class="cp">#define IW_EV_COMPAT_FREQ_LEN	(IW_EV_COMPAT_LCP_LEN + sizeof(struct iw_freq))</span>
<span class="cp">#define IW_EV_COMPAT_PARAM_LEN	(IW_EV_COMPAT_LCP_LEN + sizeof(struct iw_param))</span>
<span class="cp">#define IW_EV_COMPAT_ADDR_LEN	(IW_EV_COMPAT_LCP_LEN + sizeof(struct sockaddr))</span>
<span class="cp">#define IW_EV_COMPAT_QUAL_LEN	(IW_EV_COMPAT_LCP_LEN + sizeof(struct iw_quality))</span>
<span class="cp">#define IW_EV_COMPAT_POINT_LEN	\</span>
<span class="cp">	(IW_EV_COMPAT_LCP_LEN + sizeof(struct compat_iw_point) - \</span>
<span class="cp">	 IW_EV_COMPAT_POINT_OFF)</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/* Size of the Event prefix when packed in stream */</span>
<span class="cp">#define IW_EV_LCP_PK_LEN	(4)</span>
<span class="cm">/* Size of the various events when packed in stream */</span>
<span class="cp">#define IW_EV_CHAR_PK_LEN	(IW_EV_LCP_PK_LEN + IFNAMSIZ)</span>
<span class="cp">#define IW_EV_UINT_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(__u32))</span>
<span class="cp">#define IW_EV_FREQ_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_freq))</span>
<span class="cp">#define IW_EV_PARAM_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_param))</span>
<span class="cp">#define IW_EV_ADDR_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct sockaddr))</span>
<span class="cp">#define IW_EV_QUAL_PK_LEN	(IW_EV_LCP_PK_LEN + sizeof(struct iw_quality))</span>
<span class="cp">#define IW_EV_POINT_PK_LEN	(IW_EV_LCP_PK_LEN + 4)</span>

<span class="cp">#endif	</span><span class="cm">/* _LINUX_WIRELESS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
