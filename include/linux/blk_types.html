<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › blk_types.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>blk_types.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Block data types and constants.  Directly include this file only to</span>
<span class="cm"> * break include dependency loop.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LINUX_BLK_TYPES_H</span>
<span class="cp">#define __LINUX_BLK_TYPES_H</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="k">struct</span> <span class="n">bio_set</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">bio</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">bio_integrity_payload</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">page</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">block_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">io_context</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cgroup_subsys_state</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">bio_end_io_t</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">bio_destructor_t</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * was unsigned short, but we might as well be ready for &gt; 64kB I/O pages</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_vec</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">bv_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">bv_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">bv_offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * main unit of I/O for the block layer and lower layers (ie drivers and</span>
<span class="cm"> * stacking drivers)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="p">{</span>
	<span class="n">sector_t</span>		<span class="n">bi_sector</span><span class="p">;</span>	<span class="cm">/* device address in 512 byte</span>
<span class="cm">						   sectors */</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bi_next</span><span class="p">;</span>	<span class="cm">/* request queue link */</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">bi_bdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bi_flags</span><span class="p">;</span>	<span class="cm">/* status, command, etc */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bi_rw</span><span class="p">;</span>		<span class="cm">/* bottom bits READ/WRITE,</span>
<span class="cm">						 * top bits priority</span>
<span class="cm">						 */</span>

	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">bi_vcnt</span><span class="p">;</span>	<span class="cm">/* how many bio_vec&#39;s */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">bi_idx</span><span class="p">;</span>		<span class="cm">/* current index into bvl_vec */</span>

	<span class="cm">/* Number of segments in this BIO after</span>
<span class="cm">	 * physical address coalescing is performed.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bi_phys_segments</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bi_size</span><span class="p">;</span>	<span class="cm">/* residual I/O count */</span>

	<span class="cm">/*</span>
<span class="cm">	 * To keep track of the max segment size, we account for the</span>
<span class="cm">	 * sizes of the first and last mergeable segments in this bio.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bi_seg_front_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bi_seg_back_size</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bi_max_vecs</span><span class="p">;</span>	<span class="cm">/* max bvl_vecs we can hold */</span>

	<span class="n">atomic_t</span>		<span class="n">bi_cnt</span><span class="p">;</span>		<span class="cm">/* pin count */</span>

	<span class="k">struct</span> <span class="n">bio_vec</span>		<span class="o">*</span><span class="n">bi_io_vec</span><span class="p">;</span>	<span class="cm">/* the actual vec list */</span>

	<span class="n">bio_end_io_t</span>		<span class="o">*</span><span class="n">bi_end_io</span><span class="p">;</span>

	<span class="kt">void</span>			<span class="o">*</span><span class="n">bi_private</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
	<span class="cm">/*</span>
<span class="cm">	 * Optional ioc and css associated with this bio.  Put on bio</span>
<span class="cm">	 * release.  Read comment on top of bio_associate_current().</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">io_context</span>	<span class="o">*</span><span class="n">bi_ioc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">bi_css</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_BLK_DEV_INTEGRITY)</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bi_integrity</span><span class="p">;</span>  <span class="cm">/* data integrity */</span>
<span class="cp">#endif</span>

	<span class="n">bio_destructor_t</span>	<span class="o">*</span><span class="n">bi_destructor</span><span class="p">;</span>	<span class="cm">/* destructor */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can inline a number of vecs at the end of the bio, to avoid</span>
<span class="cm">	 * double allocations for a small number of bio_vecs. This member</span>
<span class="cm">	 * MUST obviously be kept at the very end of the bio.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">bio_vec</span>		<span class="n">bi_inline_vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * bio flags</span>
<span class="cm"> */</span>
<span class="cp">#define BIO_UPTODATE	0	</span><span class="cm">/* ok after I/O completion */</span><span class="cp"></span>
<span class="cp">#define BIO_RW_BLOCK	1	</span><span class="cm">/* RW_AHEAD set, and read/write would block */</span><span class="cp"></span>
<span class="cp">#define BIO_EOF		2	</span><span class="cm">/* out-out-bounds error */</span><span class="cp"></span>
<span class="cp">#define BIO_SEG_VALID	3	</span><span class="cm">/* bi_phys_segments valid */</span><span class="cp"></span>
<span class="cp">#define BIO_CLONED	4	</span><span class="cm">/* doesn&#39;t own data */</span><span class="cp"></span>
<span class="cp">#define BIO_BOUNCED	5	</span><span class="cm">/* bio is a bounce bio */</span><span class="cp"></span>
<span class="cp">#define BIO_USER_MAPPED 6	</span><span class="cm">/* contains user pages */</span><span class="cp"></span>
<span class="cp">#define BIO_EOPNOTSUPP	7	</span><span class="cm">/* not supported */</span><span class="cp"></span>
<span class="cp">#define BIO_NULL_MAPPED 8	</span><span class="cm">/* contains invalid user pages */</span><span class="cp"></span>
<span class="cp">#define BIO_FS_INTEGRITY 9	</span><span class="cm">/* fs owns integrity data, not block layer */</span><span class="cp"></span>
<span class="cp">#define BIO_QUIET	10	</span><span class="cm">/* Make BIO Quiet */</span><span class="cp"></span>
<span class="cp">#define BIO_MAPPED_INTEGRITY 11</span><span class="cm">/* integrity metadata has been remapped */</span><span class="cp"></span>
<span class="cp">#define bio_flagged(bio, flag)	((bio)-&gt;bi_flags &amp; (1 &lt;&lt; (flag)))</span>

<span class="cm">/*</span>
<span class="cm"> * top 4 bits of bio flags indicate the pool this bio came from</span>
<span class="cm"> */</span>
<span class="cp">#define BIO_POOL_BITS		(4)</span>
<span class="cp">#define BIO_POOL_NONE		((1UL &lt;&lt; BIO_POOL_BITS) - 1)</span>
<span class="cp">#define BIO_POOL_OFFSET		(BITS_PER_LONG - BIO_POOL_BITS)</span>
<span class="cp">#define BIO_POOL_MASK		(1UL &lt;&lt; BIO_POOL_OFFSET)</span>
<span class="cp">#define BIO_POOL_IDX(bio)	((bio)-&gt;bi_flags &gt;&gt; BIO_POOL_OFFSET)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLOCK */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Request flags.  For use in the cmd_flags field of struct request, and in</span>
<span class="cm"> * bi_rw of struct bio.  Note that some flags are only valid in either one.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rq_flag_bits</span> <span class="p">{</span>
	<span class="cm">/* common flags */</span>
	<span class="n">__REQ_WRITE</span><span class="p">,</span>		<span class="cm">/* not set, read. set, write */</span>
	<span class="n">__REQ_FAILFAST_DEV</span><span class="p">,</span>	<span class="cm">/* no driver retries of device errors */</span>
	<span class="n">__REQ_FAILFAST_TRANSPORT</span><span class="p">,</span> <span class="cm">/* no driver retries of transport errors */</span>
	<span class="n">__REQ_FAILFAST_DRIVER</span><span class="p">,</span>	<span class="cm">/* no driver retries of driver errors */</span>

	<span class="n">__REQ_SYNC</span><span class="p">,</span>		<span class="cm">/* request is sync (sync write or read) */</span>
	<span class="n">__REQ_META</span><span class="p">,</span>		<span class="cm">/* metadata io request */</span>
	<span class="n">__REQ_PRIO</span><span class="p">,</span>		<span class="cm">/* boost priority in cfq */</span>
	<span class="n">__REQ_DISCARD</span><span class="p">,</span>		<span class="cm">/* request to discard sectors */</span>
	<span class="n">__REQ_SECURE</span><span class="p">,</span>		<span class="cm">/* secure discard (used with __REQ_DISCARD) */</span>

	<span class="n">__REQ_NOIDLE</span><span class="p">,</span>		<span class="cm">/* don&#39;t anticipate more IO after this one */</span>
	<span class="n">__REQ_FUA</span><span class="p">,</span>		<span class="cm">/* forced unit access */</span>
	<span class="n">__REQ_FLUSH</span><span class="p">,</span>		<span class="cm">/* request for cache flush */</span>

	<span class="cm">/* bio only flags */</span>
	<span class="n">__REQ_RAHEAD</span><span class="p">,</span>		<span class="cm">/* read ahead, can fail anytime */</span>
	<span class="n">__REQ_THROTTLED</span><span class="p">,</span>	<span class="cm">/* This bio has already been subjected to</span>
<span class="cm">				 * throttling rules. Don&#39;t do it again. */</span>

	<span class="cm">/* request only flags */</span>
	<span class="n">__REQ_SORTED</span><span class="p">,</span>		<span class="cm">/* elevator knows about this request */</span>
	<span class="n">__REQ_SOFTBARRIER</span><span class="p">,</span>	<span class="cm">/* may not be passed by ioscheduler */</span>
	<span class="n">__REQ_NOMERGE</span><span class="p">,</span>		<span class="cm">/* don&#39;t touch this for merging */</span>
	<span class="n">__REQ_STARTED</span><span class="p">,</span>		<span class="cm">/* drive already may have started this one */</span>
	<span class="n">__REQ_DONTPREP</span><span class="p">,</span>		<span class="cm">/* don&#39;t call prep for this one */</span>
	<span class="n">__REQ_QUEUED</span><span class="p">,</span>		<span class="cm">/* uses queueing */</span>
	<span class="n">__REQ_ELVPRIV</span><span class="p">,</span>		<span class="cm">/* elevator private data attached */</span>
	<span class="n">__REQ_FAILED</span><span class="p">,</span>		<span class="cm">/* set if the request failed */</span>
	<span class="n">__REQ_QUIET</span><span class="p">,</span>		<span class="cm">/* don&#39;t worry about errors */</span>
	<span class="n">__REQ_PREEMPT</span><span class="p">,</span>		<span class="cm">/* set for &quot;ide_preempt&quot; requests */</span>
	<span class="n">__REQ_ALLOCED</span><span class="p">,</span>		<span class="cm">/* request came from our alloc pool */</span>
	<span class="n">__REQ_COPY_USER</span><span class="p">,</span>	<span class="cm">/* contains copies of user pages */</span>
	<span class="n">__REQ_FLUSH_SEQ</span><span class="p">,</span>	<span class="cm">/* request for flush sequence */</span>
	<span class="n">__REQ_IO_STAT</span><span class="p">,</span>		<span class="cm">/* account I/O stat */</span>
	<span class="n">__REQ_MIXED_MERGE</span><span class="p">,</span>	<span class="cm">/* merge of different types, fail separately */</span>
	<span class="n">__REQ_NR_BITS</span><span class="p">,</span>		<span class="cm">/* stops here */</span>
<span class="p">};</span>

<span class="cp">#define REQ_WRITE		(1 &lt;&lt; __REQ_WRITE)</span>
<span class="cp">#define REQ_FAILFAST_DEV	(1 &lt;&lt; __REQ_FAILFAST_DEV)</span>
<span class="cp">#define REQ_FAILFAST_TRANSPORT	(1 &lt;&lt; __REQ_FAILFAST_TRANSPORT)</span>
<span class="cp">#define REQ_FAILFAST_DRIVER	(1 &lt;&lt; __REQ_FAILFAST_DRIVER)</span>
<span class="cp">#define REQ_SYNC		(1 &lt;&lt; __REQ_SYNC)</span>
<span class="cp">#define REQ_META		(1 &lt;&lt; __REQ_META)</span>
<span class="cp">#define REQ_PRIO		(1 &lt;&lt; __REQ_PRIO)</span>
<span class="cp">#define REQ_DISCARD		(1 &lt;&lt; __REQ_DISCARD)</span>
<span class="cp">#define REQ_NOIDLE		(1 &lt;&lt; __REQ_NOIDLE)</span>

<span class="cp">#define REQ_FAILFAST_MASK \</span>
<span class="cp">	(REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER)</span>
<span class="cp">#define REQ_COMMON_MASK \</span>
<span class="cp">	(REQ_WRITE | REQ_FAILFAST_MASK | REQ_SYNC | REQ_META | REQ_PRIO | \</span>
<span class="cp">	 REQ_DISCARD | REQ_NOIDLE | REQ_FLUSH | REQ_FUA | REQ_SECURE)</span>
<span class="cp">#define REQ_CLONE_MASK		REQ_COMMON_MASK</span>

<span class="cp">#define REQ_RAHEAD		(1 &lt;&lt; __REQ_RAHEAD)</span>
<span class="cp">#define REQ_THROTTLED		(1 &lt;&lt; __REQ_THROTTLED)</span>

<span class="cp">#define REQ_SORTED		(1 &lt;&lt; __REQ_SORTED)</span>
<span class="cp">#define REQ_SOFTBARRIER		(1 &lt;&lt; __REQ_SOFTBARRIER)</span>
<span class="cp">#define REQ_FUA			(1 &lt;&lt; __REQ_FUA)</span>
<span class="cp">#define REQ_NOMERGE		(1 &lt;&lt; __REQ_NOMERGE)</span>
<span class="cp">#define REQ_STARTED		(1 &lt;&lt; __REQ_STARTED)</span>
<span class="cp">#define REQ_DONTPREP		(1 &lt;&lt; __REQ_DONTPREP)</span>
<span class="cp">#define REQ_QUEUED		(1 &lt;&lt; __REQ_QUEUED)</span>
<span class="cp">#define REQ_ELVPRIV		(1 &lt;&lt; __REQ_ELVPRIV)</span>
<span class="cp">#define REQ_FAILED		(1 &lt;&lt; __REQ_FAILED)</span>
<span class="cp">#define REQ_QUIET		(1 &lt;&lt; __REQ_QUIET)</span>
<span class="cp">#define REQ_PREEMPT		(1 &lt;&lt; __REQ_PREEMPT)</span>
<span class="cp">#define REQ_ALLOCED		(1 &lt;&lt; __REQ_ALLOCED)</span>
<span class="cp">#define REQ_COPY_USER		(1 &lt;&lt; __REQ_COPY_USER)</span>
<span class="cp">#define REQ_FLUSH		(1 &lt;&lt; __REQ_FLUSH)</span>
<span class="cp">#define REQ_FLUSH_SEQ		(1 &lt;&lt; __REQ_FLUSH_SEQ)</span>
<span class="cp">#define REQ_IO_STAT		(1 &lt;&lt; __REQ_IO_STAT)</span>
<span class="cp">#define REQ_MIXED_MERGE		(1 &lt;&lt; __REQ_MIXED_MERGE)</span>
<span class="cp">#define REQ_SECURE		(1 &lt;&lt; __REQ_SECURE)</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_BLK_TYPES_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
