<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › spinlock.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>spinlock.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_SPINLOCK_H</span>
<span class="cp">#define __LINUX_SPINLOCK_H</span>

<span class="cm">/*</span>
<span class="cm"> * include/linux/spinlock.h - generic spinlock/rwlock declarations</span>
<span class="cm"> *</span>
<span class="cm"> * here&#39;s the role of the various spinlock/rwlock related include files:</span>
<span class="cm"> *</span>
<span class="cm"> * on SMP builds:</span>
<span class="cm"> *</span>
<span class="cm"> *  asm/spinlock_types.h: contains the arch_spinlock_t/arch_rwlock_t and the</span>
<span class="cm"> *                        initializers</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/spinlock_types.h:</span>
<span class="cm"> *                        defines the generic type and initializers</span>
<span class="cm"> *</span>
<span class="cm"> *  asm/spinlock.h:       contains the arch_spin_*()/etc. lowlevel</span>
<span class="cm"> *                        implementations, mostly inline assembly code</span>
<span class="cm"> *</span>
<span class="cm"> *   (also included on UP-debug builds:)</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/spinlock_api_smp.h:</span>
<span class="cm"> *                        contains the prototypes for the _spin_*() APIs.</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/spinlock.h:     builds the final spin_*() APIs.</span>
<span class="cm"> *</span>
<span class="cm"> * on UP builds:</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/spinlock_type_up.h:</span>
<span class="cm"> *                        contains the generic, simplified UP spinlock type.</span>
<span class="cm"> *                        (which is an empty structure on non-debug builds)</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/spinlock_types.h:</span>
<span class="cm"> *                        defines the generic type and initializers</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/spinlock_up.h:</span>
<span class="cm"> *                        contains the arch_spin_*()/etc. version of UP</span>
<span class="cm"> *                        builds. (which are NOPs on non-debug, non-preempt</span>
<span class="cm"> *                        builds)</span>
<span class="cm"> *</span>
<span class="cm"> *   (included on UP-non-debug builds:)</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/spinlock_api_up.h:</span>
<span class="cm"> *                        builds the _spin_*() APIs.</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/spinlock.h:     builds the final spin_*() APIs.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/typecheck.h&gt;</span>
<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/irqflags.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;linux/bottom_half.h&gt;</span>
<span class="cp">#include &lt;asm/barrier.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * Must define these before including other files, inline functions need them</span>
<span class="cm"> */</span>
<span class="cp">#define LOCK_SECTION_NAME &quot;.text..lock.&quot;KBUILD_BASENAME</span>

<span class="cp">#define LOCK_SECTION_START(extra)               \</span>
<span class="cp">        &quot;.subsection 1\n\t&quot;                     \</span>
<span class="cp">        extra                                   \</span>
<span class="cp">        &quot;.ifndef &quot; LOCK_SECTION_NAME &quot;\n\t&quot;     \</span>
<span class="cp">        LOCK_SECTION_NAME &quot;:\n\t&quot;               \</span>
<span class="cp">        &quot;.endif\n&quot;</span>

<span class="cp">#define LOCK_SECTION_END                        \</span>
<span class="cp">        &quot;.previous\n\t&quot;</span>

<span class="cp">#define __lockfunc __attribute__((section(&quot;.spinlock.text&quot;)))</span>

<span class="cm">/*</span>
<span class="cm"> * Pull the arch_spinlock_t and arch_rwlock_t definitions:</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/spinlock_types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Pull the arch_spin*() functions/declarations (UP-nondebug doesn&#39;t need them):</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp"># include &lt;asm/spinlock.h&gt;</span>
<span class="cp">#else</span>
<span class="cp"># include &lt;linux/spinlock_up.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_SPINLOCK</span>
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">__raw_spin_lock_init</span><span class="p">(</span><span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="cp"># define raw_spin_lock_init(lock)				\</span>
<span class="cp">do {								\</span>
<span class="cp">	static struct lock_class_key __key;			\</span>
<span class="cp">								\</span>
<span class="cp">	__raw_spin_lock_init((lock), #lock, &amp;__key);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#else</span>
<span class="cp"># define raw_spin_lock_init(lock)				\</span>
<span class="cp">	do { *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define raw_spin_is_locked(lock)	arch_spin_is_locked(&amp;(lock)-&gt;raw_lock)</span>

<span class="cp">#ifdef CONFIG_GENERIC_LOCKBREAK</span>
<span class="cp">#define raw_spin_is_contended(lock) ((lock)-&gt;break_lock)</span>
<span class="cp">#else</span>

<span class="cp">#ifdef arch_spin_is_contended</span>
<span class="cp">#define raw_spin_is_contended(lock)	arch_spin_is_contended(&amp;(lock)-&gt;raw_lock)</span>
<span class="cp">#else</span>
<span class="cp">#define raw_spin_is_contended(lock)	(((void)(lock), 0))</span>
<span class="cp">#endif </span><span class="cm">/*arch_spin_is_contended*/</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/* The lock does not imply full memory barrier. */</span>
<span class="cp">#ifndef ARCH_HAS_SMP_MB_AFTER_LOCK</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">smp_mb__after_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">smp_mb</span><span class="p">();</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * raw_spin_unlock_wait - wait until the spinlock gets unlocked</span>
<span class="cm"> * @lock: the spinlock in question.</span>
<span class="cm"> */</span>
<span class="cp">#define raw_spin_unlock_wait(lock)	arch_spin_unlock_wait(&amp;(lock)-&gt;raw_lock)</span>

<span class="cp">#ifdef CONFIG_DEBUG_SPINLOCK</span>
 <span class="k">extern</span> <span class="kt">void</span> <span class="n">do_raw_spin_lock</span><span class="p">(</span><span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#define do_raw_spin_lock_flags(lock, flags) do_raw_spin_lock(lock)</span>
 <span class="k">extern</span> <span class="kt">int</span> <span class="n">do_raw_spin_trylock</span><span class="p">(</span><span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
 <span class="k">extern</span> <span class="kt">void</span> <span class="n">do_raw_spin_unlock</span><span class="p">(</span><span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">do_raw_spin_lock</span><span class="p">(</span><span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__acquire</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">arch_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">raw_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">do_raw_spin_lock_flags</span><span class="p">(</span><span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__acquire</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">arch_spin_lock_flags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">raw_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_raw_spin_trylock</span><span class="p">(</span><span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">arch_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">raw_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">do_raw_spin_unlock</span><span class="p">(</span><span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">raw_lock</span><span class="p">);</span>
	<span class="n">__release</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Define the various spin_lock methods.  Note we define these</span>
<span class="cm"> * regardless of whether CONFIG_SMP or CONFIG_PREEMPT are set. The</span>
<span class="cm"> * various methods are defined as nops in the case they are not</span>
<span class="cm"> * required.</span>
<span class="cm"> */</span>
<span class="cp">#define raw_spin_trylock(lock)	__cond_lock(lock, _raw_spin_trylock(lock))</span>

<span class="cp">#define raw_spin_lock(lock)	_raw_spin_lock(lock)</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="cp"># define raw_spin_lock_nested(lock, subclass) \</span>
<span class="cp">	_raw_spin_lock_nested(lock, subclass)</span>

<span class="cp"># define raw_spin_lock_nest_lock(lock, nest_lock)			\</span>
<span class="cp">	 do {								\</span>
<span class="cp">		 typecheck(struct lockdep_map *, &amp;(nest_lock)-&gt;dep_map);\</span>
<span class="cp">		 _raw_spin_lock_nest_lock(lock, &amp;(nest_lock)-&gt;dep_map);	\</span>
<span class="cp">	 } while (0)</span>
<span class="cp">#else</span>
<span class="cp"># define raw_spin_lock_nested(lock, subclass)		_raw_spin_lock(lock)</span>
<span class="cp"># define raw_spin_lock_nest_lock(lock, nest_lock)	_raw_spin_lock(lock)</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)</span>

<span class="cp">#define raw_spin_lock_irqsave(lock, flags)			\</span>
<span class="cp">	do {						\</span>
<span class="cp">		typecheck(unsigned long, flags);	\</span>
<span class="cp">		flags = _raw_spin_lock_irqsave(lock);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="cp">#define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\</span>
<span class="cp">	do {								\</span>
<span class="cp">		typecheck(unsigned long, flags);			\</span>
<span class="cp">		flags = _raw_spin_lock_irqsave_nested(lock, subclass);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define raw_spin_lock_irqsave_nested(lock, flags, subclass)		\</span>
<span class="cp">	do {								\</span>
<span class="cp">		typecheck(unsigned long, flags);			\</span>
<span class="cp">		flags = _raw_spin_lock_irqsave(lock);			\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#else</span>

<span class="cp">#define raw_spin_lock_irqsave(lock, flags)		\</span>
<span class="cp">	do {						\</span>
<span class="cp">		typecheck(unsigned long, flags);	\</span>
<span class="cp">		_raw_spin_lock_irqsave(lock, flags);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define raw_spin_lock_irqsave_nested(lock, flags, subclass)	\</span>
<span class="cp">	raw_spin_lock_irqsave(lock, flags)</span>

<span class="cp">#endif</span>

<span class="cp">#define raw_spin_lock_irq(lock)		_raw_spin_lock_irq(lock)</span>
<span class="cp">#define raw_spin_lock_bh(lock)		_raw_spin_lock_bh(lock)</span>
<span class="cp">#define raw_spin_unlock(lock)		_raw_spin_unlock(lock)</span>
<span class="cp">#define raw_spin_unlock_irq(lock)	_raw_spin_unlock_irq(lock)</span>

<span class="cp">#define raw_spin_unlock_irqrestore(lock, flags)		\</span>
<span class="cp">	do {							\</span>
<span class="cp">		typecheck(unsigned long, flags);		\</span>
<span class="cp">		_raw_spin_unlock_irqrestore(lock, flags);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define raw_spin_unlock_bh(lock)	_raw_spin_unlock_bh(lock)</span>

<span class="cp">#define raw_spin_trylock_bh(lock) \</span>
<span class="cp">	__cond_lock(lock, _raw_spin_trylock_bh(lock))</span>

<span class="cp">#define raw_spin_trylock_irq(lock) \</span>
<span class="cp">({ \</span>
<span class="cp">	local_irq_disable(); \</span>
<span class="cp">	raw_spin_trylock(lock) ? \</span>
<span class="cp">	1 : ({ local_irq_enable(); 0;  }); \</span>
<span class="cp">})</span>

<span class="cp">#define raw_spin_trylock_irqsave(lock, flags) \</span>
<span class="cp">({ \</span>
<span class="cp">	local_irq_save(flags); \</span>
<span class="cp">	raw_spin_trylock(lock) ? \</span>
<span class="cp">	1 : ({ local_irq_restore(flags); 0; }); \</span>
<span class="cp">})</span>

<span class="cm">/**</span>
<span class="cm"> * raw_spin_can_lock - would raw_spin_trylock() succeed?</span>
<span class="cm"> * @lock: the spinlock in question.</span>
<span class="cm"> */</span>
<span class="cp">#define raw_spin_can_lock(lock)	(!raw_spin_is_locked(lock))</span>

<span class="cm">/* Include rwlock functions */</span>
<span class="cp">#include &lt;linux/rwlock.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Pull the _spin_*()/_read_*()/_write_*() functions/declarations:</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)</span>
<span class="cp"># include &lt;linux/spinlock_api_smp.h&gt;</span>
<span class="cp">#else</span>
<span class="cp"># include &lt;linux/spinlock_api_up.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Map the spin_lock functions to the raw variants for PREEMPT_RT=n</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">raw_spinlock_t</span> <span class="o">*</span><span class="nf">spinlock_check</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define spin_lock_init(_lock)				\</span>
<span class="cp">do {							\</span>
<span class="cp">	spinlock_check(_lock);				\</span>
<span class="cp">	raw_spin_lock_init(&amp;(_lock)-&gt;rlock);		\</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_lock_bh</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spin_trylock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define spin_lock_nested(lock, subclass)			\</span>
<span class="cp">do {								\</span>
<span class="cp">	raw_spin_lock_nested(spinlock_check(lock), subclass);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define spin_lock_nest_lock(lock, nest_lock)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	raw_spin_lock_nest_lock(spinlock_check(lock), nest_lock);	\</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_lock_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define spin_lock_irqsave(lock, flags)				\</span>
<span class="cp">do {								\</span>
<span class="cp">	raw_spin_lock_irqsave(spinlock_check(lock), flags);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define spin_lock_irqsave_nested(lock, flags, subclass)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_unlock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_unlock_bh</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_unlock_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spin_trylock_bh</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_spin_trylock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spin_trylock_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_spin_trylock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define spin_trylock_irqsave(lock, flags)			\</span>
<span class="cp">({								\</span>
<span class="cp">	raw_spin_trylock_irqsave(spinlock_check(lock), flags); \</span>
<span class="cp">})</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spin_unlock_wait</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spin_is_locked</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_spin_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spin_is_contended</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_spin_is_contended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spin_can_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_spin_can_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define assert_spin_locked(lock)	assert_raw_spin_locked(&amp;(lock)-&gt;rlock)</span>

<span class="cm">/*</span>
<span class="cm"> * Pull the atomic_t declaration:</span>
<span class="cm"> * (asm-mips/atomic.h needs above definitions)</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cm">/**</span>
<span class="cm"> * atomic_dec_and_lock - lock on reaching reference count zero</span>
<span class="cm"> * @atomic: the atomic counter</span>
<span class="cm"> * @lock: the spinlock in question</span>
<span class="cm"> *</span>
<span class="cm"> * Decrements @atomic by 1.  If the result is 0, returns true and locks</span>
<span class="cm"> * @lock.  Returns false for all other cases.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">_atomic_dec_and_lock</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">atomic</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#define atomic_dec_and_lock(atomic, lock) \</span>
<span class="cp">		__cond_lock(lock, _atomic_dec_and_lock(atomic, lock))</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_SPINLOCK_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
