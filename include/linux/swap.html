<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › swap.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>swap.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_SWAP_H</span>
<span class="cp">#define _LINUX_SWAP_H</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/node.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="k">struct</span> <span class="n">notifier_block</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">bio</span><span class="p">;</span>

<span class="cp">#define SWAP_FLAG_PREFER	0x8000	</span><span class="cm">/* set if swap priority specified */</span><span class="cp"></span>
<span class="cp">#define SWAP_FLAG_PRIO_MASK	0x7fff</span>
<span class="cp">#define SWAP_FLAG_PRIO_SHIFT	0</span>
<span class="cp">#define SWAP_FLAG_DISCARD	0x10000 </span><span class="cm">/* discard swap cluster after use */</span><span class="cp"></span>

<span class="cp">#define SWAP_FLAGS_VALID	(SWAP_FLAG_PRIO_MASK | SWAP_FLAG_PREFER | \</span>
<span class="cp">				 SWAP_FLAG_DISCARD)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">current_is_kswapd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KSWAPD</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * MAX_SWAPFILES defines the maximum number of swaptypes: things which can</span>
<span class="cm"> * be swapped to.  The swap type and the offset into that swap type are</span>
<span class="cm"> * encoded into pte&#39;s and into pgoff_t&#39;s in the swapcache.  Using five bits</span>
<span class="cm"> * for the type means that the maximum number of swapcache pages is 27 bits</span>
<span class="cm"> * on 32-bit-pgoff_t architectures.  And that assumes that the architecture packs</span>
<span class="cm"> * the type/offset into the pte as 5/27 as well.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_SWAPFILES_SHIFT	5</span>

<span class="cm">/*</span>
<span class="cm"> * Use some of the swap files numbers for other purposes. This</span>
<span class="cm"> * is a convenient way to hook into the VM to trigger special</span>
<span class="cm"> * actions on faults.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * NUMA node memory migration support</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_MIGRATION</span>
<span class="cp">#define SWP_MIGRATION_NUM 2</span>
<span class="cp">#define SWP_MIGRATION_READ	(MAX_SWAPFILES + SWP_HWPOISON_NUM)</span>
<span class="cp">#define SWP_MIGRATION_WRITE	(MAX_SWAPFILES + SWP_HWPOISON_NUM + 1)</span>
<span class="cp">#else</span>
<span class="cp">#define SWP_MIGRATION_NUM 0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Handling of hardware poisoned pages with memory corruption.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_MEMORY_FAILURE</span>
<span class="cp">#define SWP_HWPOISON_NUM 1</span>
<span class="cp">#define SWP_HWPOISON		MAX_SWAPFILES</span>
<span class="cp">#else</span>
<span class="cp">#define SWP_HWPOISON_NUM 0</span>
<span class="cp">#endif</span>

<span class="cp">#define MAX_SWAPFILES \</span>
<span class="cp">	((1 &lt;&lt; MAX_SWAPFILES_SHIFT) - SWP_MIGRATION_NUM - SWP_HWPOISON_NUM)</span>

<span class="cm">/*</span>
<span class="cm"> * Magic header for a swap area. The first part of the union is</span>
<span class="cm"> * what the swap magic looks like for the old (limited to 128MB)</span>
<span class="cm"> * swap area format, the second part of the union adds - in the</span>
<span class="cm"> * old reserved area - some extra information. Note that the first</span>
<span class="cm"> * kilobyte is reserved for boot loader or disk label stuff...</span>
<span class="cm"> *</span>
<span class="cm"> * Having the magic at the end of the PAGE_SIZE makes detecting swap</span>
<span class="cm"> * areas somewhat tricky on machines that support multiple page sizes.</span>
<span class="cm"> * For 2.5 we&#39;ll probably want to move the magic to just beyond the</span>
<span class="cm"> * bootbits...</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">swap_header</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">reserved</span><span class="p">[</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">10</span><span class="p">];</span>
		<span class="kt">char</span> <span class="n">magic</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>			<span class="cm">/* SWAP-SPACE or SWAPSPACE2 */</span>
	<span class="p">}</span> <span class="n">magic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">char</span>		<span class="n">bootbits</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>	<span class="cm">/* Space for disklabel etc. */</span>
		<span class="n">__u32</span>		<span class="n">version</span><span class="p">;</span>
		<span class="n">__u32</span>		<span class="n">last_page</span><span class="p">;</span>
		<span class="n">__u32</span>		<span class="n">nr_badpages</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">sws_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">sws_volume</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
		<span class="n">__u32</span>		<span class="n">padding</span><span class="p">[</span><span class="mi">117</span><span class="p">];</span>
		<span class="n">__u32</span>		<span class="n">badpages</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">info</span><span class="p">;</span>
<span class="p">};</span>

 <span class="cm">/* A swap entry has to fit into a &quot;unsigned long&quot;, as</span>
<span class="cm">  * the entry is hidden in the &quot;index&quot; field of the</span>
<span class="cm">  * swapper address space.</span>
<span class="cm">  */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span> <span class="n">swp_entry_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * current-&gt;reclaim_state points to one of these when a task is running</span>
<span class="cm"> * memory reclaim</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">reclaim_state</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reclaimed_slab</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="k">struct</span> <span class="n">address_space</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sysinfo</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">writeback_control</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">zone</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * A swap extent maps a range of a swapfile&#39;s PAGE_SIZE pages onto a range of</span>
<span class="cm"> * disk blocks.  A list of swap extents maps the entire swapfile.  (Where the</span>
<span class="cm"> * term `swapfile&#39; refers to either a blockdevice or an IS_REG file.  Apart</span>
<span class="cm"> * from setup, they&#39;re handled identically.</span>
<span class="cm"> *</span>
<span class="cm"> * We always assume that blocks are of size PAGE_SIZE.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">swap_extent</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">start_page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">start_block</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Max bad pages in the new format..</span>
<span class="cm"> */</span>
<span class="cp">#define __swapoffset(x) ((unsigned long)&amp;((union swap_header *)0)-&gt;x)</span>
<span class="cp">#define MAX_SWAP_BADPAGES \</span>
<span class="cp">	((__swapoffset(magic.magic) - __swapoffset(info.badpages)) / sizeof(int))</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SWP_USED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* is slot in swap_info[] used? */</span>
	<span class="n">SWP_WRITEOK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* ok to write to this swap?	*/</span>
	<span class="n">SWP_DISCARDABLE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* swapon+blkdev support discard */</span>
	<span class="n">SWP_DISCARDING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>	<span class="cm">/* now discarding a free cluster */</span>
	<span class="n">SWP_SOLIDSTATE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* blkdev seeks are cheap */</span>
	<span class="n">SWP_CONTINUED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>	<span class="cm">/* swap_map has count continuation */</span>
	<span class="n">SWP_BLKDEV</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>	<span class="cm">/* its a block device */</span>
					<span class="cm">/* add others here before... */</span>
	<span class="n">SWP_SCANNING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* refcount in scan_swap_map */</span>
<span class="p">};</span>

<span class="cp">#define SWAP_CLUSTER_MAX 32</span>
<span class="cp">#define COMPACT_CLUSTER_MAX SWAP_CLUSTER_MAX</span>

<span class="cm">/*</span>
<span class="cm"> * Ratio between the present memory in the zone and the &quot;gap&quot; that</span>
<span class="cm"> * we&#39;re allowing kswapd to shrink in addition to the per-zone high</span>
<span class="cm"> * wmark, even for zones that already have the high wmark satisfied,</span>
<span class="cm"> * in order to provide better per-zone lru behavior. We are ok to</span>
<span class="cm"> * spend not more than 1% of the memory for this zone balancing &quot;gap&quot;.</span>
<span class="cm"> */</span>
<span class="cp">#define KSWAPD_ZONE_BALANCE_GAP_RATIO 100</span>

<span class="cp">#define SWAP_MAP_MAX	0x3e	</span><span class="cm">/* Max duplication count, in first swap_map */</span><span class="cp"></span>
<span class="cp">#define SWAP_MAP_BAD	0x3f	</span><span class="cm">/* Note pageblock is bad, in first swap_map */</span><span class="cp"></span>
<span class="cp">#define SWAP_HAS_CACHE	0x40	</span><span class="cm">/* Flag page is cached, in first swap_map */</span><span class="cp"></span>
<span class="cp">#define SWAP_CONT_MAX	0x7f	</span><span class="cm">/* Max count, in each swap_map continuation */</span><span class="cp"></span>
<span class="cp">#define COUNT_CONTINUED	0x80	</span><span class="cm">/* See swap_map continuation for full count */</span><span class="cp"></span>
<span class="cp">#define SWAP_MAP_SHMEM	0xbf	</span><span class="cm">/* Owned by shmem/tmpfs, in first swap_map */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The in-memory structure used to track swap areas.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* SWP_USED etc: see above */</span>
	<span class="kt">signed</span> <span class="kt">short</span>	<span class="n">prio</span><span class="p">;</span>		<span class="cm">/* swap priority of this type */</span>
	<span class="kt">signed</span> <span class="kt">char</span>	<span class="n">type</span><span class="p">;</span>		<span class="cm">/* strange name for an index */</span>
	<span class="kt">signed</span> <span class="kt">char</span>	<span class="n">next</span><span class="p">;</span>		<span class="cm">/* next type on the swap list */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">max</span><span class="p">;</span>		<span class="cm">/* extent of the swap_map */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">swap_map</span><span class="p">;</span>	<span class="cm">/* vmalloc&#39;ed array of usage counts */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lowest_bit</span><span class="p">;</span>	<span class="cm">/* index of first free in swap_map */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">highest_bit</span><span class="p">;</span>	<span class="cm">/* index of last free in swap_map */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>		<span class="cm">/* total of usable pages of swap */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inuse_pages</span><span class="p">;</span>	<span class="cm">/* number of those currently in use */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cluster_next</span><span class="p">;</span>	<span class="cm">/* likely index for next allocation */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cluster_nr</span><span class="p">;</span>	<span class="cm">/* countdown to next cluster search */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lowest_alloc</span><span class="p">;</span>	<span class="cm">/* while preparing discard cluster */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">highest_alloc</span><span class="p">;</span>	<span class="cm">/* while preparing discard cluster */</span>
	<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">curr_swap_extent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">swap_extent</span> <span class="n">first_swap_extent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>	<span class="cm">/* swap device or bdev of swap file */</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">swap_file</span><span class="p">;</span>		<span class="cm">/* seldom referenced */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_block_size</span><span class="p">;</span>	<span class="cm">/* seldom referenced */</span>
<span class="cp">#ifdef CONFIG_FRONTSWAP</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">frontswap_map</span><span class="p">;</span>	<span class="cm">/* frontswap in-use, one bit per page */</span>
	<span class="n">atomic_t</span> <span class="n">frontswap_pages</span><span class="p">;</span>	<span class="cm">/* frontswap pages in-use counter */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">swap_list_t</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">head</span><span class="p">;</span>	<span class="cm">/* head of priority-ordered swapfile list */</span>
	<span class="kt">int</span> <span class="n">next</span><span class="p">;</span>	<span class="cm">/* swapfile to be used next */</span>
<span class="p">};</span>

<span class="cm">/* Swap 50% full? Release swapcache more aggressively.. */</span>
<span class="cp">#define vm_swap_full() (nr_swap_pages*2 &lt; total_swap_pages)</span>

<span class="cm">/* linux/mm/page_alloc.c */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">totalram_pages</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">totalreserve_pages</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_balance_reserve</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_free_buffer_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_free_pagecache_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Definition of global_page_state not available yet */</span>
<span class="cp">#define nr_free_pages() global_page_state(NR_FREE_PAGES)</span>


<span class="cm">/* linux/mm/swap.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__lru_cache_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lru_cache_add_lru</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lru_add_page_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page_tail</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">activate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mark_page_accessed</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lru_add_drain</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lru_add_drain_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lru_add_drain_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rotate_reclaimable_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">deactivate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swap_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">add_page_to_unevictable_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lru_cache_add: add a page to the page lists</span>
<span class="cm"> * @page: the page to add</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lru_cache_add_anon</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__lru_cache_add</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">LRU_INACTIVE_ANON</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lru_cache_add_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__lru_cache_add</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">LRU_INACTIVE_FILE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* linux/mm/vmscan.c */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">try_to_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__isolate_lru_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">isolate_mode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">try_to_free_mem_cgroup_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
						  <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noswap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem_cgroup_shrink_node_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span>
						<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noswap</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_scanned</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shrink_all_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vm_swappiness</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">remove_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">vm_total_pages</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">zone_reclaim_mode</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_min_unmapped_ratio</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_min_slab_ratio</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">zone_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define zone_reclaim_mode 0</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zone_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">z</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">page_evictable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">check_move_unevictable_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan_unevictable_pages</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scan_unevictable_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
					<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">scan_unevictable_register_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scan_unevictable_unregister_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scan_unevictable_register_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">scan_unevictable_unregister_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">kswapd_run</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kswapd_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mem_cgroup_swappiness</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">mem</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mem_cgroup_swappiness</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vm_swappiness</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mem_cgroup_uncharge_swap</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mem_cgroup_uncharge_swap</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SWAP</span>
<span class="cm">/* linux/mm/page_io.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swap_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swap_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">end_swap_bio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>

<span class="cm">/* linux/mm/swap_state.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="n">swapper_space</span><span class="p">;</span>
<span class="cp">#define total_swapcache_pages  swapper_space.nrpages</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">show_swap_cache_info</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">add_to_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">add_to_swap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="n">swp_entry_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__delete_from_swap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">delete_from_swap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_page_and_swap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_pages_and_swap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">lookup_swap_cache</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">read_swap_cache_async</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">swapin_readahead</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/* linux/mm/swapfile.c */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">nr_swap_pages</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">total_swap_pages</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">si_swapinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysinfo</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">swp_entry_t</span> <span class="n">get_swap_page</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">swp_entry_t</span> <span class="n">get_swap_page_of_type</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">add_swap_count_continuation</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swap_shmem_alloc</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swap_duplicate</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swapcache_prepare</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swap_free</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swapcache_free</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">free_swap_and_cache</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swap_type_of</span><span class="p">(</span><span class="n">dev_t</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count_swap_pages</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">sector_t</span> <span class="n">map_swap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">sector_t</span> <span class="n">swapdev_block</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">pgoff_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">page_swapcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">reuse_swap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">try_to_free_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">backing_dev_info</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR</span>
<span class="k">extern</span> <span class="kt">void</span>
<span class="n">mem_cgroup_uncharge_swapcache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">,</span> <span class="n">bool</span> <span class="n">swapout</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mem_cgroup_uncharge_swapcache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">,</span> <span class="n">bool</span> <span class="n">swapout</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_SWAP */</span><span class="cp"></span>

<span class="cp">#define nr_swap_pages				0L</span>
<span class="cp">#define total_swap_pages			0L</span>
<span class="cp">#define total_swapcache_pages			0UL</span>

<span class="cp">#define si_swapinfo(val) \</span>
<span class="cp">	do { (val)-&gt;freeswap = (val)-&gt;totalswap = 0; } while (0)</span>
<span class="cm">/* only sparc can not include linux/pagemap.h in this file</span>
<span class="cm"> * so leave page_cache_release and release_pages undeclared... */</span>
<span class="cp">#define free_page_and_swap_cache(page) \</span>
<span class="cp">	page_cache_release(page)</span>
<span class="cp">#define free_pages_and_swap_cache(pages, nr) \</span>
<span class="cp">	release_pages((pages), (nr), 0);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">show_swap_cache_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#define free_swap_and_cache(swp)	is_migration_entry(swp)</span>
<span class="cp">#define swapcache_prepare(swp)		is_migration_entry(swp)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_swap_count_continuation</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap_shmem_alloc</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">swap_duplicate</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap_free</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swapcache_free</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">swapin_readahead</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">swap_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">lookup_swap_cache</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_to_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_to_swap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span>
							<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__delete_from_swap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">delete_from_swap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_swapcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define reuse_swap_page(page)	(page_mapcount(page) == 1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">try_to_free_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">swp_entry_t</span> <span class="nf">get_swap_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mem_cgroup_uncharge_swapcache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SWAP */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__*/</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_SWAP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
