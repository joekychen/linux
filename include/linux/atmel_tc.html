<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › atmel_tc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>atmel_tc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Timer/Counter Unit (TC) registers.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef ATMEL_TC_H</span>
<span class="cp">#define ATMEL_TC_H</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Many 32-bit Atmel SOCs include one or more TC blocks, each of which holds</span>
<span class="cm"> * three general-purpose 16-bit timers.  These timers share one register bank.</span>
<span class="cm"> * Depending on the SOC, each timer may have its own clock and IRQ, or those</span>
<span class="cm"> * may be shared by the whole TC block.</span>
<span class="cm"> *</span>
<span class="cm"> * These TC blocks may have up to nine external pins:  TCLK0..2 signals for</span>
<span class="cm"> * clocks or clock gates, and per-timer TIOA and TIOB signals used for PWM</span>
<span class="cm"> * or triggering.  Those pins need to be set up for use with the TC block,</span>
<span class="cm"> * else they will be used as GPIOs or for a different controller.</span>
<span class="cm"> *</span>
<span class="cm"> * Although we expect each TC block to have a platform_device node, those</span>
<span class="cm"> * nodes are not what drivers bind to.  Instead, they ask for a specific</span>
<span class="cm"> * TC block, by number ... which is a common approach on systems with many</span>
<span class="cm"> * timers.  Then they use clk_get() and platform_get_irq() to get clock and</span>
<span class="cm"> * IRQ resources.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">clk</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct atmel_tcb_config - SoC data for a Timer/Counter Block</span>
<span class="cm"> * @counter_width: size in bits of a timer counter register</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">atmel_tcb_config</span> <span class="p">{</span>
	<span class="kt">size_t</span>	<span class="n">counter_width</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct atmel_tc - information about a Timer/Counter Block</span>
<span class="cm"> * @pdev: physical device</span>
<span class="cm"> * @iomem: resource associated with the I/O register</span>
<span class="cm"> * @regs: mapping through which the I/O registers can be accessed</span>
<span class="cm"> * @tcb_config: configuration data from SoC</span>
<span class="cm"> * @irq: irq for each of the three channels</span>
<span class="cm"> * @clk: internal clock source for each of the three channels</span>
<span class="cm"> * @node: list node, for tclib internal use</span>
<span class="cm"> *</span>
<span class="cm"> * On some platforms, each TC channel has its own clocks and IRQs,</span>
<span class="cm"> * while on others, all TC channels share the same clock and IRQ.</span>
<span class="cm"> * Drivers should clk_enable() all the clocks they need even though</span>
<span class="cm"> * all the entries in @clk may point to the same physical clock.</span>
<span class="cm"> * Likewise, drivers should request irqs independently for each</span>
<span class="cm"> * channel, but they must use IRQF_SHARED in case some of the entries</span>
<span class="cm"> * in @irq are actually the same IRQ.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">atmel_tc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span>		<span class="o">*</span><span class="n">iomem</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atmel_tcb_config</span>	<span class="o">*</span><span class="n">tcb_config</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">irq</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">atmel_tc</span> <span class="o">*</span><span class="n">atmel_tc_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">block</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">atmel_tc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmel_tc</span> <span class="o">*</span><span class="n">tc</span><span class="p">);</span>

<span class="cm">/* platform-specific ATMEL_TC_TIMER_CLOCKx divisors (0 means 32KiHz) */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">atmel_tc_divisors</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>


<span class="cm">/*</span>
<span class="cm"> * Two registers have block-wide controls.  These are: configuring the three</span>
<span class="cm"> * &quot;external&quot; clocks (or event sources) used by the timer channels; and</span>
<span class="cm"> * synchronizing the timers by resetting them all at once.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;External&quot; can mean &quot;external to chip&quot; using the TCLK0, TCLK1, or TCLK2</span>
<span class="cm"> * signals.  Or, it can mean &quot;external to timer&quot;, using the TIOA output from</span>
<span class="cm"> * one of the other two timers that&#39;s being run in waveform mode.</span>
<span class="cm"> */</span>

<span class="cp">#define ATMEL_TC_BCR	0xc0		</span><span class="cm">/* TC Block Control Register */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_SYNC	(1 &lt;&lt; 0)	</span><span class="cm">/* synchronize timers */</span><span class="cp"></span>

<span class="cp">#define ATMEL_TC_BMR	0xc4		</span><span class="cm">/* TC Block Mode Register */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_TC0XC0S	(3 &lt;&lt; 0)	</span><span class="cm">/* external clock 0 source */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_TC0XC0S_TCLK0	(0 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_TC0XC0S_NONE	(1 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_TC0XC0S_TIOA1	(2 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_TC0XC0S_TIOA2	(3 &lt;&lt; 0)</span>
<span class="cp">#define     ATMEL_TC_TC1XC1S	(3 &lt;&lt; 2)	</span><span class="cm">/* external clock 1 source */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_TC1XC1S_TCLK1	(0 &lt;&lt; 2)</span>
<span class="cp">#define        ATMEL_TC_TC1XC1S_NONE	(1 &lt;&lt; 2)</span>
<span class="cp">#define        ATMEL_TC_TC1XC1S_TIOA0	(2 &lt;&lt; 2)</span>
<span class="cp">#define        ATMEL_TC_TC1XC1S_TIOA2	(3 &lt;&lt; 2)</span>
<span class="cp">#define     ATMEL_TC_TC2XC2S	(3 &lt;&lt; 4)	</span><span class="cm">/* external clock 2 source */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_TC2XC2S_TCLK2	(0 &lt;&lt; 4)</span>
<span class="cp">#define        ATMEL_TC_TC2XC2S_NONE	(1 &lt;&lt; 4)</span>
<span class="cp">#define        ATMEL_TC_TC2XC2S_TIOA0	(2 &lt;&lt; 4)</span>
<span class="cp">#define        ATMEL_TC_TC2XC2S_TIOA1	(3 &lt;&lt; 4)</span>


<span class="cm">/*</span>
<span class="cm"> * Each TC block has three &quot;channels&quot;, each with one counter and controls.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the semantics of ATMEL_TC_TIMER_CLOCKx (input clock selection</span>
<span class="cm"> * when it&#39;s not &quot;external&quot;) is silicon-specific.  AT91 platforms use one</span>
<span class="cm"> * set of definitions; AVR32 platforms use a different set.  Don&#39;t hard-wire</span>
<span class="cm"> * such knowledge into your code, use the global &quot;atmel_tc_divisors&quot; ...</span>
<span class="cm"> * where index N is the divisor for clock N+1, else zero to indicate it uses</span>
<span class="cm"> * the 32 KiHz clock.</span>
<span class="cm"> *</span>
<span class="cm"> * The timers can be chained in various ways, and operated in &quot;waveform&quot;</span>
<span class="cm"> * generation mode (including PWM) or &quot;capture&quot; mode (to time events).  In</span>
<span class="cm"> * both modes, behavior can be configured in many ways.</span>
<span class="cm"> *</span>
<span class="cm"> * Each timer has two I/O pins, TIOA and TIOB.  Waveform mode uses TIOA as a</span>
<span class="cm"> * PWM output, and TIOB as either another PWM or as a trigger.  Capture mode</span>
<span class="cm"> * uses them only as inputs.</span>
<span class="cm"> */</span>
<span class="cp">#define ATMEL_TC_CHAN(idx)	((idx)*0x40)</span>
<span class="cp">#define ATMEL_TC_REG(idx, reg)	(ATMEL_TC_CHAN(idx) + ATMEL_TC_ ## reg)</span>

<span class="cp">#define ATMEL_TC_CCR	0x00		</span><span class="cm">/* Channel Control Register */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_CLKEN	(1 &lt;&lt; 0)	</span><span class="cm">/* clock enable */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_CLKDIS	(1 &lt;&lt; 1)	</span><span class="cm">/* clock disable */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_SWTRG	(1 &lt;&lt; 2)	</span><span class="cm">/* software trigger */</span><span class="cp"></span>

<span class="cp">#define ATMEL_TC_CMR	0x04		</span><span class="cm">/* Channel Mode Register */</span><span class="cp"></span>

<span class="cm">/* Both modes share some CMR bits */</span>
<span class="cp">#define     ATMEL_TC_TCCLKS	(7 &lt;&lt; 0)	</span><span class="cm">/* clock source */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_TIMER_CLOCK1	(0 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_TIMER_CLOCK2	(1 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_TIMER_CLOCK3	(2 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_TIMER_CLOCK4	(3 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_TIMER_CLOCK5	(4 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_XC0		(5 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_XC1		(6 &lt;&lt; 0)</span>
<span class="cp">#define        ATMEL_TC_XC2		(7 &lt;&lt; 0)</span>
<span class="cp">#define     ATMEL_TC_CLKI	(1 &lt;&lt; 3)	</span><span class="cm">/* clock invert */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_BURST	(3 &lt;&lt; 4)	</span><span class="cm">/* clock gating */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_GATE_NONE	(0 &lt;&lt; 4)</span>
<span class="cp">#define        ATMEL_TC_GATE_XC0	(1 &lt;&lt; 4)</span>
<span class="cp">#define        ATMEL_TC_GATE_XC1	(2 &lt;&lt; 4)</span>
<span class="cp">#define        ATMEL_TC_GATE_XC2	(3 &lt;&lt; 4)</span>
<span class="cp">#define     ATMEL_TC_WAVE	(1 &lt;&lt; 15)	</span><span class="cm">/* true = Waveform mode */</span><span class="cp"></span>

<span class="cm">/* CAPTURE mode CMR bits */</span>
<span class="cp">#define     ATMEL_TC_LDBSTOP	(1 &lt;&lt; 6)	</span><span class="cm">/* counter stops on RB load */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_LDBDIS	(1 &lt;&lt; 7)	</span><span class="cm">/* counter disable on RB load */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_ETRGEDG	(3 &lt;&lt; 8)	</span><span class="cm">/* external trigger edge */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_ETRGEDG_NONE	(0 &lt;&lt; 8)</span>
<span class="cp">#define        ATMEL_TC_ETRGEDG_RISING	(1 &lt;&lt; 8)</span>
<span class="cp">#define        ATMEL_TC_ETRGEDG_FALLING	(2 &lt;&lt; 8)</span>
<span class="cp">#define        ATMEL_TC_ETRGEDG_BOTH	(3 &lt;&lt; 8)</span>
<span class="cp">#define     ATMEL_TC_ABETRG	(1 &lt;&lt; 10)	</span><span class="cm">/* external trigger is TIOA? */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_CPCTRG	(1 &lt;&lt; 14)	</span><span class="cm">/* RC compare trigger enable */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_LDRA	(3 &lt;&lt; 16)	</span><span class="cm">/* RA loading edge (of TIOA) */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_LDRA_NONE	(0 &lt;&lt; 16)</span>
<span class="cp">#define        ATMEL_TC_LDRA_RISING	(1 &lt;&lt; 16)</span>
<span class="cp">#define        ATMEL_TC_LDRA_FALLING	(2 &lt;&lt; 16)</span>
<span class="cp">#define        ATMEL_TC_LDRA_BOTH	(3 &lt;&lt; 16)</span>
<span class="cp">#define     ATMEL_TC_LDRB	(3 &lt;&lt; 18)	</span><span class="cm">/* RB loading edge (of TIOA) */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_LDRB_NONE	(0 &lt;&lt; 18)</span>
<span class="cp">#define        ATMEL_TC_LDRB_RISING	(1 &lt;&lt; 18)</span>
<span class="cp">#define        ATMEL_TC_LDRB_FALLING	(2 &lt;&lt; 18)</span>
<span class="cp">#define        ATMEL_TC_LDRB_BOTH	(3 &lt;&lt; 18)</span>

<span class="cm">/* WAVEFORM mode CMR bits */</span>
<span class="cp">#define     ATMEL_TC_CPCSTOP	(1 &lt;&lt;  6)	</span><span class="cm">/* RC compare stops counter */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_CPCDIS	(1 &lt;&lt;  7)	</span><span class="cm">/* RC compare disables counter */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_EEVTEDG	(3 &lt;&lt;  8)	</span><span class="cm">/* external event edge */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_EEVTEDG_NONE	(0 &lt;&lt; 8)</span>
<span class="cp">#define        ATMEL_TC_EEVTEDG_RISING	(1 &lt;&lt; 8)</span>
<span class="cp">#define        ATMEL_TC_EEVTEDG_FALLING	(2 &lt;&lt; 8)</span>
<span class="cp">#define        ATMEL_TC_EEVTEDG_BOTH	(3 &lt;&lt; 8)</span>
<span class="cp">#define     ATMEL_TC_EEVT	(3 &lt;&lt; 10)	</span><span class="cm">/* external event source */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_EEVT_TIOB	(0 &lt;&lt; 10)</span>
<span class="cp">#define        ATMEL_TC_EEVT_XC0	(1 &lt;&lt; 10)</span>
<span class="cp">#define        ATMEL_TC_EEVT_XC1	(2 &lt;&lt; 10)</span>
<span class="cp">#define        ATMEL_TC_EEVT_XC2	(3 &lt;&lt; 10)</span>
<span class="cp">#define     ATMEL_TC_ENETRG	(1 &lt;&lt; 12)	</span><span class="cm">/* external event is trigger */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_WAVESEL	(3 &lt;&lt; 13)	</span><span class="cm">/* waveform type */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_WAVESEL_UP	(0 &lt;&lt; 13)</span>
<span class="cp">#define        ATMEL_TC_WAVESEL_UPDOWN	(1 &lt;&lt; 13)</span>
<span class="cp">#define        ATMEL_TC_WAVESEL_UP_AUTO	(2 &lt;&lt; 13)</span>
<span class="cp">#define        ATMEL_TC_WAVESEL_UPDOWN_AUTO (3 &lt;&lt; 13)</span>
<span class="cp">#define     ATMEL_TC_ACPA	(3 &lt;&lt; 16)	</span><span class="cm">/* RA compare changes TIOA */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_ACPA_NONE	(0 &lt;&lt; 16)</span>
<span class="cp">#define        ATMEL_TC_ACPA_SET	(1 &lt;&lt; 16)</span>
<span class="cp">#define        ATMEL_TC_ACPA_CLEAR	(2 &lt;&lt; 16)</span>
<span class="cp">#define        ATMEL_TC_ACPA_TOGGLE	(3 &lt;&lt; 16)</span>
<span class="cp">#define     ATMEL_TC_ACPC	(3 &lt;&lt; 18)	</span><span class="cm">/* RC compare changes TIOA */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_ACPC_NONE	(0 &lt;&lt; 18)</span>
<span class="cp">#define        ATMEL_TC_ACPC_SET	(1 &lt;&lt; 18)</span>
<span class="cp">#define        ATMEL_TC_ACPC_CLEAR	(2 &lt;&lt; 18)</span>
<span class="cp">#define        ATMEL_TC_ACPC_TOGGLE	(3 &lt;&lt; 18)</span>
<span class="cp">#define     ATMEL_TC_AEEVT	(3 &lt;&lt; 20)	</span><span class="cm">/* external event changes TIOA */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_AEEVT_NONE	(0 &lt;&lt; 20)</span>
<span class="cp">#define        ATMEL_TC_AEEVT_SET	(1 &lt;&lt; 20)</span>
<span class="cp">#define        ATMEL_TC_AEEVT_CLEAR	(2 &lt;&lt; 20)</span>
<span class="cp">#define        ATMEL_TC_AEEVT_TOGGLE	(3 &lt;&lt; 20)</span>
<span class="cp">#define     ATMEL_TC_ASWTRG	(3 &lt;&lt; 22)	</span><span class="cm">/* software trigger changes TIOA */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_ASWTRG_NONE	(0 &lt;&lt; 22)</span>
<span class="cp">#define        ATMEL_TC_ASWTRG_SET	(1 &lt;&lt; 22)</span>
<span class="cp">#define        ATMEL_TC_ASWTRG_CLEAR	(2 &lt;&lt; 22)</span>
<span class="cp">#define        ATMEL_TC_ASWTRG_TOGGLE	(3 &lt;&lt; 22)</span>
<span class="cp">#define     ATMEL_TC_BCPB	(3 &lt;&lt; 24)	</span><span class="cm">/* RB compare changes TIOB */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_BCPB_NONE	(0 &lt;&lt; 24)</span>
<span class="cp">#define        ATMEL_TC_BCPB_SET	(1 &lt;&lt; 24)</span>
<span class="cp">#define        ATMEL_TC_BCPB_CLEAR	(2 &lt;&lt; 24)</span>
<span class="cp">#define        ATMEL_TC_BCPB_TOGGLE	(3 &lt;&lt; 24)</span>
<span class="cp">#define     ATMEL_TC_BCPC	(3 &lt;&lt; 26)	</span><span class="cm">/* RC compare changes TIOB */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_BCPC_NONE	(0 &lt;&lt; 26)</span>
<span class="cp">#define        ATMEL_TC_BCPC_SET	(1 &lt;&lt; 26)</span>
<span class="cp">#define        ATMEL_TC_BCPC_CLEAR	(2 &lt;&lt; 26)</span>
<span class="cp">#define        ATMEL_TC_BCPC_TOGGLE	(3 &lt;&lt; 26)</span>
<span class="cp">#define     ATMEL_TC_BEEVT	(3 &lt;&lt; 28)	</span><span class="cm">/* external event changes TIOB */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_BEEVT_NONE	(0 &lt;&lt; 28)</span>
<span class="cp">#define        ATMEL_TC_BEEVT_SET	(1 &lt;&lt; 28)</span>
<span class="cp">#define        ATMEL_TC_BEEVT_CLEAR	(2 &lt;&lt; 28)</span>
<span class="cp">#define        ATMEL_TC_BEEVT_TOGGLE	(3 &lt;&lt; 28)</span>
<span class="cp">#define     ATMEL_TC_BSWTRG	(3 &lt;&lt; 30)	</span><span class="cm">/* software trigger changes TIOB */</span><span class="cp"></span>
<span class="cp">#define        ATMEL_TC_BSWTRG_NONE	(0 &lt;&lt; 30)</span>
<span class="cp">#define        ATMEL_TC_BSWTRG_SET	(1 &lt;&lt; 30)</span>
<span class="cp">#define        ATMEL_TC_BSWTRG_CLEAR	(2 &lt;&lt; 30)</span>
<span class="cp">#define        ATMEL_TC_BSWTRG_TOGGLE	(3 &lt;&lt; 30)</span>

<span class="cp">#define ATMEL_TC_CV	0x10		</span><span class="cm">/* counter Value */</span><span class="cp"></span>
<span class="cp">#define ATMEL_TC_RA	0x14		</span><span class="cm">/* register A */</span><span class="cp"></span>
<span class="cp">#define ATMEL_TC_RB	0x18		</span><span class="cm">/* register B */</span><span class="cp"></span>
<span class="cp">#define ATMEL_TC_RC	0x1c		</span><span class="cm">/* register C */</span><span class="cp"></span>

<span class="cp">#define ATMEL_TC_SR	0x20		</span><span class="cm">/* status (read-only) */</span><span class="cp"></span>
<span class="cm">/* Status-only flags */</span>
<span class="cp">#define     ATMEL_TC_CLKSTA	(1 &lt;&lt; 16)	</span><span class="cm">/* clock enabled */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_MTIOA	(1 &lt;&lt; 17)	</span><span class="cm">/* TIOA mirror */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_MTIOB	(1 &lt;&lt; 18)	</span><span class="cm">/* TIOB mirror */</span><span class="cp"></span>

<span class="cp">#define ATMEL_TC_IER	0x24		</span><span class="cm">/* interrupt enable (write-only) */</span><span class="cp"></span>
<span class="cp">#define ATMEL_TC_IDR	0x28		</span><span class="cm">/* interrupt disable (write-only) */</span><span class="cp"></span>
<span class="cp">#define ATMEL_TC_IMR	0x2c		</span><span class="cm">/* interrupt mask (read-only) */</span><span class="cp"></span>

<span class="cm">/* Status and IRQ flags */</span>
<span class="cp">#define     ATMEL_TC_COVFS	(1 &lt;&lt;  0)	</span><span class="cm">/* counter overflow */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_LOVRS	(1 &lt;&lt;  1)	</span><span class="cm">/* load overrun */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_CPAS	(1 &lt;&lt;  2)	</span><span class="cm">/* RA compare */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_CPBS	(1 &lt;&lt;  3)	</span><span class="cm">/* RB compare */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_CPCS	(1 &lt;&lt;  4)	</span><span class="cm">/* RC compare */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_LDRAS	(1 &lt;&lt;  5)	</span><span class="cm">/* RA loading */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_LDRBS	(1 &lt;&lt;  6)	</span><span class="cm">/* RB loading */</span><span class="cp"></span>
<span class="cp">#define     ATMEL_TC_ETRGS	(1 &lt;&lt;  7)	</span><span class="cm">/* external trigger */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
