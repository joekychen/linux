<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › netdevice.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>netdevice.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Definitions for the Interfaces handler.</span>
<span class="cm"> *</span>
<span class="cm"> * Version:	@(#)dev.h	1.0.10	08/12/93</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *		Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;</span>
<span class="cm"> *		Donald J. Becker, &lt;becker@cesdis.gsfc.nasa.gov&gt;</span>
<span class="cm"> *		Alan Cox, &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *		Bjorn Ekwall. &lt;bj0rn@blox.se&gt;</span>
<span class="cm"> *              Pekka Riikonen &lt;priikone@poseidon.pspt.fi&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *		Moved to /usr/include/linux for NET3</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_NETDEVICE_H</span>
<span class="cp">#define _LINUX_NETDEVICE_H</span>

<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/if_packet.h&gt;</span>
<span class="cp">#include &lt;linux/if_link.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/pm_qos.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/cache.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/dmaengine.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/dynamic_queue_limits.h&gt;</span>

<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/dsa.h&gt;</span>
<span class="cp">#ifdef CONFIG_DCB</span>
<span class="cp">#include &lt;net/dcbnl.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;net/netprio_cgroup.h&gt;</span>

<span class="cp">#include &lt;linux/netdev_features.h&gt;</span>
<span class="cp">#include &lt;linux/neighbour.h&gt;</span>

<span class="k">struct</span> <span class="n">netpoll_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">phy_device</span><span class="p">;</span>
<span class="cm">/* 802.11 specific */</span>
<span class="k">struct</span> <span class="n">wireless_dev</span><span class="p">;</span>
					<span class="cm">/* source back-compat hooks */</span>
<span class="cp">#define SET_ETHTOOL_OPS(netdev,ops) \</span>
<span class="cp">	( (netdev)-&gt;ethtool_ops = (ops) )</span>

<span class="cm">/* hardware address assignment types */</span>
<span class="cp">#define NET_ADDR_PERM		0	</span><span class="cm">/* address is permanent (default) */</span><span class="cp"></span>
<span class="cp">#define NET_ADDR_RANDOM		1	</span><span class="cm">/* address is generated randomly */</span><span class="cp"></span>
<span class="cp">#define NET_ADDR_STOLEN		2	</span><span class="cm">/* address is stolen from other device */</span><span class="cp"></span>

<span class="cm">/* Backlog congestion levels */</span>
<span class="cp">#define NET_RX_SUCCESS		0	</span><span class="cm">/* keep &#39;em coming, baby */</span><span class="cp"></span>
<span class="cp">#define NET_RX_DROP		1	</span><span class="cm">/* packet dropped */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Transmit return codes: transmit return codes originate from three different</span>
<span class="cm"> * namespaces:</span>
<span class="cm"> *</span>
<span class="cm"> * - qdisc return codes</span>
<span class="cm"> * - driver transmit return codes</span>
<span class="cm"> * - errno values</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers are allowed to return any one of those in their hard_start_xmit()</span>
<span class="cm"> * function. Real network devices commonly used with qdiscs should only return</span>
<span class="cm"> * the driver transmit return codes though - when qdiscs are used, the actual</span>
<span class="cm"> * transmission happens asynchronously, so the value is not propagated to</span>
<span class="cm"> * higher layers. Virtual network devices transmit synchronously, in this case</span>
<span class="cm"> * the driver transmit return codes are consumed by dev_queue_xmit(), all</span>
<span class="cm"> * others are propagated to higher layers.</span>
<span class="cm"> */</span>

<span class="cm">/* qdisc -&gt;enqueue() return codes. */</span>
<span class="cp">#define NET_XMIT_SUCCESS	0x00</span>
<span class="cp">#define NET_XMIT_DROP		0x01	</span><span class="cm">/* skb dropped			*/</span><span class="cp"></span>
<span class="cp">#define NET_XMIT_CN		0x02	</span><span class="cm">/* congestion notification	*/</span><span class="cp"></span>
<span class="cp">#define NET_XMIT_POLICED	0x03	</span><span class="cm">/* skb is shot by police	*/</span><span class="cp"></span>
<span class="cp">#define NET_XMIT_MASK		0x0f	</span><span class="cm">/* qdisc flags in net/sch_generic.h */</span><span class="cp"></span>

<span class="cm">/* NET_XMIT_CN is special. It does not guarantee that this packet is lost. It</span>
<span class="cm"> * indicates that the device will soon be dropping packets, or already drops</span>
<span class="cm"> * some packets of the same priority; prompting us to send less aggressively. */</span>
<span class="cp">#define net_xmit_eval(e)	((e) == NET_XMIT_CN ? 0 : (e))</span>
<span class="cp">#define net_xmit_errno(e)	((e) != NET_XMIT_CN ? -ENOBUFS : 0)</span>

<span class="cm">/* Driver transmit return codes */</span>
<span class="cp">#define NETDEV_TX_MASK		0xf0</span>

<span class="k">enum</span> <span class="n">netdev_tx</span> <span class="p">{</span>
	<span class="n">__NETDEV_TX_MIN</span>	 <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">,</span>	<span class="cm">/* make sure enum is signed */</span>
	<span class="n">NETDEV_TX_OK</span>	 <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>	<span class="cm">/* driver took care of packet */</span>
	<span class="n">NETDEV_TX_BUSY</span>	 <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>	<span class="cm">/* driver tx path was busy*/</span>
	<span class="n">NETDEV_TX_LOCKED</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>	<span class="cm">/* driver tx lock was already taken */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">netdev_tx</span> <span class="n">netdev_tx_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Current order: NETDEV_TX_MASK &gt; NET_XMIT_MASK &gt;= 0 is significant;</span>
<span class="cm"> * hard_start_xmit() return &lt; NET_XMIT_MASK means skb was consumed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dev_xmit_complete</span><span class="p">(</span><span class="kt">int</span> <span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Positive cases with an skb consumed by a driver:</span>
<span class="cm">	 * - successful transmission (rc == NETDEV_TX_OK)</span>
<span class="cm">	 * - error while transmitting (rc &lt; 0)</span>
<span class="cm">	 * - error while queueing to a different device (rc &amp; NET_XMIT_MASK)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="n">NET_XMIT_MASK</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#define MAX_ADDR_LEN	32		</span><span class="cm">/* Largest hardware address length */</span><span class="cp"></span>

<span class="cm">/* Initial net device group. All devices belong to group 0 by default. */</span>
<span class="cp">#define INIT_NETDEV_GROUP	0</span>

<span class="cp">#ifdef  __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> *	Compute the worst case header length according to the protocols</span>
<span class="cm"> *	used.</span>
<span class="cm"> */</span>

<span class="cp">#if defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)</span>
<span class="cp"># if defined(CONFIG_MAC80211_MESH)</span>
<span class="cp">#  define LL_MAX_HEADER 128</span>
<span class="cp"># else</span>
<span class="cp">#  define LL_MAX_HEADER 96</span>
<span class="cp"># endif</span>
<span class="cp">#elif IS_ENABLED(CONFIG_TR)</span>
<span class="cp"># define LL_MAX_HEADER 48</span>
<span class="cp">#else</span>
<span class="cp"># define LL_MAX_HEADER 32</span>
<span class="cp">#endif</span>

<span class="cp">#if !IS_ENABLED(CONFIG_NET_IPIP) &amp;&amp; !IS_ENABLED(CONFIG_NET_IPGRE) &amp;&amp; \</span>
<span class="cp">    !IS_ENABLED(CONFIG_IPV6_SIT) &amp;&amp; !IS_ENABLED(CONFIG_IPV6_TUNNEL)</span>
<span class="cp">#define MAX_HEADER LL_MAX_HEADER</span>
<span class="cp">#else</span>
<span class="cp">#define MAX_HEADER (LL_MAX_HEADER + 48)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	Old network device statistics. Fields are native words</span>
<span class="cm"> *	(unsigned long) so they can be read and written atomically.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_packets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_dropped</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_dropped</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">multicast</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">collisions</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_length_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_over_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_crc_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_frame_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_fifo_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_missed_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_aborted_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_carrier_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_fifo_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_heartbeat_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_window_errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">rx_compressed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">tx_compressed</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif  </span><span class="cm">/*  __KERNEL__  */</span><span class="cp"></span>


<span class="cm">/* Media selection options. */</span>
<span class="k">enum</span> <span class="p">{</span>
        <span class="n">IF_PORT_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">IF_PORT_10BASE2</span><span class="p">,</span>
        <span class="n">IF_PORT_10BASET</span><span class="p">,</span>
        <span class="n">IF_PORT_AUI</span><span class="p">,</span>
        <span class="n">IF_PORT_100BASET</span><span class="p">,</span>
        <span class="n">IF_PORT_100BASETX</span><span class="p">,</span>
        <span class="n">IF_PORT_100BASEFX</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>

<span class="cp">#ifdef CONFIG_RPS</span>
<span class="cp">#include &lt;linux/static_key.h&gt;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">static_key</span> <span class="n">rps_needed</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">neighbour</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">neigh_parms</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sk_buff</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">addr</span><span class="p">[</span><span class="n">MAX_ADDR_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">type</span><span class="p">;</span>
<span class="cp">#define NETDEV_HW_ADDR_T_LAN		1</span>
<span class="cp">#define NETDEV_HW_ADDR_T_SAN		2</span>
<span class="cp">#define NETDEV_HW_ADDR_T_SLAVE		3</span>
<span class="cp">#define NETDEV_HW_ADDR_T_UNICAST	4</span>
<span class="cp">#define NETDEV_HW_ADDR_T_MULTICAST	5</span>
	<span class="n">bool</span>			<span class="n">synced</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">global_use</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">refcount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">rcu_head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define netdev_hw_addr_list_count(l) ((l)-&gt;count)</span>
<span class="cp">#define netdev_hw_addr_list_empty(l) (netdev_hw_addr_list_count(l) == 0)</span>
<span class="cp">#define netdev_hw_addr_list_for_each(ha, l) \</span>
<span class="cp">	list_for_each_entry(ha, &amp;(l)-&gt;list, list)</span>

<span class="cp">#define netdev_uc_count(dev) netdev_hw_addr_list_count(&amp;(dev)-&gt;uc)</span>
<span class="cp">#define netdev_uc_empty(dev) netdev_hw_addr_list_empty(&amp;(dev)-&gt;uc)</span>
<span class="cp">#define netdev_for_each_uc_addr(ha, dev) \</span>
<span class="cp">	netdev_hw_addr_list_for_each(ha, &amp;(dev)-&gt;uc)</span>

<span class="cp">#define netdev_mc_count(dev) netdev_hw_addr_list_count(&amp;(dev)-&gt;mc)</span>
<span class="cp">#define netdev_mc_empty(dev) netdev_hw_addr_list_empty(&amp;(dev)-&gt;mc)</span>
<span class="cp">#define netdev_for_each_mc_addr(ha, dev) \</span>
<span class="cp">	netdev_hw_addr_list_for_each(ha, &amp;(dev)-&gt;mc)</span>

<span class="k">struct</span> <span class="n">hh_cache</span> <span class="p">{</span>
	<span class="n">u16</span>		<span class="n">hh_len</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">__pad</span><span class="p">;</span>
	<span class="n">seqlock_t</span>	<span class="n">hh_lock</span><span class="p">;</span>

	<span class="cm">/* cached hardware header; allow for machine alignment needs.        */</span>
<span class="cp">#define HH_DATA_MOD	16</span>
<span class="cp">#define HH_DATA_OFF(__len) \</span>
<span class="cp">	(HH_DATA_MOD - (((__len - 1) &amp; (HH_DATA_MOD - 1)) + 1))</span>
<span class="cp">#define HH_DATA_ALIGN(__len) \</span>
<span class="cp">	(((__len)+(HH_DATA_MOD-1))&amp;~(HH_DATA_MOD - 1))</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">hh_data</span><span class="p">[</span><span class="n">HH_DATA_ALIGN</span><span class="p">(</span><span class="n">LL_MAX_HEADER</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)];</span>
<span class="p">};</span>

<span class="cm">/* Reserve HH_DATA_MOD byte aligned hard_header_len, but at least that much.</span>
<span class="cm"> * Alternative is:</span>
<span class="cm"> *   dev-&gt;hard_header_len ? (dev-&gt;hard_header_len +</span>
<span class="cm"> *                           (HH_DATA_MOD - 1)) &amp; ~(HH_DATA_MOD - 1) : 0</span>
<span class="cm"> *</span>
<span class="cm"> * We could use other alignment values, but we must maintain the</span>
<span class="cm"> * relationship HH alignment &lt;= LL alignment.</span>
<span class="cm"> */</span>
<span class="cp">#define LL_RESERVED_SPACE(dev) \</span>
<span class="cp">	((((dev)-&gt;hard_header_len+(dev)-&gt;needed_headroom)&amp;~(HH_DATA_MOD - 1)) + HH_DATA_MOD)</span>
<span class="cp">#define LL_RESERVED_SPACE_EXTRA(dev,extra) \</span>
<span class="cp">	((((dev)-&gt;hard_header_len+(dev)-&gt;needed_headroom+(extra))&amp;~(HH_DATA_MOD - 1)) + HH_DATA_MOD)</span>

<span class="k">struct</span> <span class="n">header_ops</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">parse</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">haddr</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">rebuild</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hh_cache</span> <span class="o">*</span><span class="n">hh</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">cache_update</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hh_cache</span> <span class="o">*</span><span class="n">hh</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">haddr</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* These flag bits are private to the generic network queueing</span>
<span class="cm"> * layer, they may not be explicitly referenced by any other</span>
<span class="cm"> * code.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">netdev_state_t</span> <span class="p">{</span>
	<span class="n">__LINK_STATE_START</span><span class="p">,</span>
	<span class="n">__LINK_STATE_PRESENT</span><span class="p">,</span>
	<span class="n">__LINK_STATE_NOCARRIER</span><span class="p">,</span>
	<span class="n">__LINK_STATE_LINKWATCH_PENDING</span><span class="p">,</span>
	<span class="n">__LINK_STATE_DORMANT</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * This structure holds at boot time configured netdevice settings. They</span>
<span class="cm"> * are then used in the device probing.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">netdev_boot_setup</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ifmap</span> <span class="n">map</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define NETDEV_BOOT_SETUP_MAX 8</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">netdev_boot_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Structure for NAPI scheduling similar to tasklet but with weighting</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">napi_struct</span> <span class="p">{</span>
	<span class="cm">/* The poll_list must only be managed by the entity which</span>
<span class="cm">	 * changes the state of the NAPI_STATE_SCHED bit.  This means</span>
<span class="cm">	 * whoever atomically sets that bit can add this napi_struct</span>
<span class="cm">	 * to the per-cpu poll_list, and whoever clears that bit</span>
<span class="cm">	 * can remove from the list right before clearing the bit.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">poll_list</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">weight</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NETPOLL</span>
	<span class="n">spinlock_t</span>		<span class="n">poll_lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">poll_owner</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gro_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dev_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">gro_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NAPI_STATE_SCHED</span><span class="p">,</span>	<span class="cm">/* Poll is scheduled */</span>
	<span class="n">NAPI_STATE_DISABLE</span><span class="p">,</span>	<span class="cm">/* Disable pending */</span>
	<span class="n">NAPI_STATE_NPSVC</span><span class="p">,</span>	<span class="cm">/* Netpoll - don&#39;t dequeue from poll_list */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">gro_result</span> <span class="p">{</span>
	<span class="n">GRO_MERGED</span><span class="p">,</span>
	<span class="n">GRO_MERGED_FREE</span><span class="p">,</span>
	<span class="n">GRO_HELD</span><span class="p">,</span>
	<span class="n">GRO_NORMAL</span><span class="p">,</span>
	<span class="n">GRO_DROP</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">gro_result</span> <span class="n">gro_result_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * enum rx_handler_result - Possible return values for rx_handlers.</span>
<span class="cm"> * @RX_HANDLER_CONSUMED: skb was consumed by rx_handler, do not process it</span>
<span class="cm"> * further.</span>
<span class="cm"> * @RX_HANDLER_ANOTHER: Do another round in receive path. This is indicated in</span>
<span class="cm"> * case skb-&gt;dev was changed by rx_handler.</span>
<span class="cm"> * @RX_HANDLER_EXACT: Force exact delivery, no wildcard.</span>
<span class="cm"> * @RX_HANDLER_PASS: Do nothing, passe the skb as if no rx_handler was called.</span>
<span class="cm"> *</span>
<span class="cm"> * rx_handlers are functions called from inside __netif_receive_skb(), to do</span>
<span class="cm"> * special processing of the skb, prior to delivery to protocol handlers.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently, a net_device can only have a single rx_handler registered. Trying</span>
<span class="cm"> * to register a second rx_handler will return -EBUSY.</span>
<span class="cm"> *</span>
<span class="cm"> * To register a rx_handler on a net_device, use netdev_rx_handler_register().</span>
<span class="cm"> * To unregister a rx_handler on a net_device, use</span>
<span class="cm"> * netdev_rx_handler_unregister().</span>
<span class="cm"> *</span>
<span class="cm"> * Upon return, rx_handler is expected to tell __netif_receive_skb() what to</span>
<span class="cm"> * do with the skb.</span>
<span class="cm"> *</span>
<span class="cm"> * If the rx_handler consumed to skb in some way, it should return</span>
<span class="cm"> * RX_HANDLER_CONSUMED. This is appropriate when the rx_handler arranged for</span>
<span class="cm"> * the skb to be delivered in some other ways.</span>
<span class="cm"> *</span>
<span class="cm"> * If the rx_handler changed skb-&gt;dev, to divert the skb to another</span>
<span class="cm"> * net_device, it should return RX_HANDLER_ANOTHER. The rx_handler for the</span>
<span class="cm"> * new device will be called if it exists.</span>
<span class="cm"> *</span>
<span class="cm"> * If the rx_handler consider the skb should be ignored, it should return</span>
<span class="cm"> * RX_HANDLER_EXACT. The skb will only be delivered to protocol handlers that</span>
<span class="cm"> * are registred on exact device (ptype-&gt;dev == skb-&gt;dev).</span>
<span class="cm"> *</span>
<span class="cm"> * If the rx_handler didn&#39;t changed skb-&gt;dev, but want the skb to be normally</span>
<span class="cm"> * delivered, it should return RX_HANDLER_PASS.</span>
<span class="cm"> *</span>
<span class="cm"> * A device without a registered rx_handler will behave as if rx_handler</span>
<span class="cm"> * returned RX_HANDLER_PASS.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">rx_handler_result</span> <span class="p">{</span>
	<span class="n">RX_HANDLER_CONSUMED</span><span class="p">,</span>
	<span class="n">RX_HANDLER_ANOTHER</span><span class="p">,</span>
	<span class="n">RX_HANDLER_EXACT</span><span class="p">,</span>
	<span class="n">RX_HANDLER_PASS</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">rx_handler_result</span> <span class="n">rx_handler_result_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">rx_handler_result_t</span> <span class="n">rx_handler_func_t</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">pskb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__napi_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">napi_disable_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">NAPI_STATE_DISABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	napi_schedule_prep - check if napi can be scheduled</span>
<span class="cm"> *	@n: napi context</span>
<span class="cm"> *</span>
<span class="cm"> * Test if NAPI routine is already running, and if not mark</span>
<span class="cm"> * it as running.  This is used as a condition variable</span>
<span class="cm"> * insure only one NAPI poll instance runs.  We also make</span>
<span class="cm"> * sure there is no pending NAPI disable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">napi_schedule_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">napi_disable_pending</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	napi_schedule - schedule NAPI poll</span>
<span class="cm"> *	@n: napi context</span>
<span class="cm"> *</span>
<span class="cm"> * Schedule NAPI poll routine to be called if it is not already</span>
<span class="cm"> * running.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">napi_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Try to reschedule poll. Called by dev-&gt;poll() after napi_complete().  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">napi_reschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	napi_complete - NAPI processing complete</span>
<span class="cm"> *	@n: napi context</span>
<span class="cm"> *</span>
<span class="cm"> * Mark NAPI processing as complete.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__napi_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">napi_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	napi_disable - prevent NAPI from scheduling</span>
<span class="cm"> *	@n: napi context</span>
<span class="cm"> *</span>
<span class="cm"> * Stop NAPI from being scheduled on this context.</span>
<span class="cm"> * Waits till any outstanding processing completes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">napi_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NAPI_STATE_DISABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">NAPI_STATE_DISABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	napi_enable - enable NAPI scheduling</span>
<span class="cm"> *	@n: napi context</span>
<span class="cm"> *</span>
<span class="cm"> * Resume NAPI from being scheduled on this context.</span>
<span class="cm"> * Must be paired with napi_disable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">napi_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
	<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/**</span>
<span class="cm"> *	napi_synchronize - wait until NAPI is not running</span>
<span class="cm"> *	@n: napi context</span>
<span class="cm"> *</span>
<span class="cm"> * Wait until NAPI is done being scheduled on this context.</span>
<span class="cm"> * Waits till any outstanding processing completes but</span>
<span class="cm"> * does not disable future activations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">napi_synchronize</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp"># define napi_synchronize(n)	barrier()</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="n">netdev_queue_state_t</span> <span class="p">{</span>
	<span class="n">__QUEUE_STATE_DRV_XOFF</span><span class="p">,</span>
	<span class="n">__QUEUE_STATE_STACK_XOFF</span><span class="p">,</span>
	<span class="n">__QUEUE_STATE_FROZEN</span><span class="p">,</span>
<span class="cp">#define QUEUE_STATE_ANY_XOFF ((1 &lt;&lt; __QUEUE_STATE_DRV_XOFF)		| \</span>
<span class="cp">			      (1 &lt;&lt; __QUEUE_STATE_STACK_XOFF))</span>
<span class="cp">#define QUEUE_STATE_ANY_XOFF_OR_FROZEN (QUEUE_STATE_ANY_XOFF		| \</span>
<span class="cp">					(1 &lt;&lt; __QUEUE_STATE_FROZEN))</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * __QUEUE_STATE_DRV_XOFF is used by drivers to stop the transmit queue.  The</span>
<span class="cm"> * netif_tx_* functions below are used to manipulate this flag.  The</span>
<span class="cm"> * __QUEUE_STATE_STACK_XOFF flag is used by the stack to stop the transmit</span>
<span class="cm"> * queue independently.  The netif_xmit_*stopped functions below are called</span>
<span class="cm"> * to check if the queue has been stopped by the driver or stack (either</span>
<span class="cm"> * of the XOFF bits are set in the state).  Drivers should not need to call</span>
<span class="cm"> * netif_xmit*stopped functions, they should only be using netif_tx_*.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> * read mostly part</span>
<span class="cm"> */</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Qdisc</span>		<span class="o">*</span><span class="n">qdisc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Qdisc</span>		<span class="o">*</span><span class="n">qdisc_sleeping</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SYSFS</span>
	<span class="k">struct</span> <span class="n">kobject</span>		<span class="n">kobj</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CONFIG_XPS) &amp;&amp; defined(CONFIG_NUMA)</span>
	<span class="kt">int</span>			<span class="n">numa_node</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> * write mostly part</span>
<span class="cm"> */</span>
	<span class="n">spinlock_t</span>		<span class="n">_xmit_lock</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">xmit_lock_owner</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * please use this field instead of dev-&gt;trans_start</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">trans_start</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of TX timeouts for this queue</span>
<span class="cm">	 * (/sys/class/net/DEV/Q/trans_timeout)</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">trans_timeout</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">state</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_BQL</span>
	<span class="k">struct</span> <span class="n">dql</span>		<span class="n">dql</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netdev_queue_numa_node_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_XPS) &amp;&amp; defined(CONFIG_NUMA)</span>
	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">numa_node</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_queue_numa_node_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_XPS) &amp;&amp; defined(CONFIG_NUMA)</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">numa_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RPS</span>
<span class="cm">/*</span>
<span class="cm"> * This structure holds an RPS map which can be of variable length.  The</span>
<span class="cm"> * map is an array of CPUs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rps_map</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cpus</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define RPS_MAP_SIZE(_num) (sizeof(struct rps_map) + ((_num) * sizeof(u16)))</span>

<span class="cm">/*</span>
<span class="cm"> * The rps_dev_flow structure contains the mapping of a flow to a CPU, the</span>
<span class="cm"> * tail pointer for that CPU&#39;s input queue at the time of last enqueue, and</span>
<span class="cm"> * a hardware filter index.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">filter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_qtail</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define RPS_NO_FILTER 0xffff</span>

<span class="cm">/*</span>
<span class="cm"> * The rps_dev_flow_table structure contains a table of flow mappings.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rps_dev_flow_table</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">free_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="n">flows</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define RPS_DEV_FLOW_TABLE_SIZE(_num) (sizeof(struct rps_dev_flow_table) + \</span>
<span class="cp">    ((_num) * sizeof(struct rps_dev_flow)))</span>

<span class="cm">/*</span>
<span class="cm"> * The rps_sock_flow_table contains mappings of flows to the last CPU</span>
<span class="cm"> * on which they were processed by the application (set in recvmsg).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rps_sock_flow_table</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define	RPS_SOCK_FLOW_TABLE_SIZE(_num) (sizeof(struct rps_sock_flow_table) + \</span>
<span class="cp">    ((_num) * sizeof(u16)))</span>

<span class="cp">#define RPS_NO_CPU 0xffff</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rps_record_sock_flow</span><span class="p">(</span><span class="k">struct</span> <span class="n">rps_sock_flow_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">&amp;&amp;</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>

		<span class="cm">/* We only give a hint, preemption can change cpu under us */</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">raw_smp_processor_id</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span>
			<span class="n">table</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rps_reset_sock_flow</span><span class="p">(</span><span class="k">struct</span> <span class="n">rps_sock_flow_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table</span> <span class="o">&amp;&amp;</span> <span class="n">hash</span><span class="p">)</span>
		<span class="n">table</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">RPS_NO_CPU</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">rps_sock_flow_table</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">rps_sock_flow_table</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">rps_may_expire_flow</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rxq_index</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">flow_id</span><span class="p">,</span> <span class="n">u16</span> <span class="n">filter_id</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* This structure contains an instance of an RX queue. */</span>
<span class="k">struct</span> <span class="n">netdev_rx_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rps_map</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">rps_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rps_dev_flow_table</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">rps_flow_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span>			<span class="n">kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RPS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_XPS</span>
<span class="cm">/*</span>
<span class="cm"> * This structure holds an XPS map which can be of variable length.  The</span>
<span class="cm"> * map is an array of queues.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xps_map</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">queues</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define XPS_MAP_SIZE(_num) (sizeof(struct xps_map) + ((_num) * sizeof(u16)))</span>
<span class="cp">#define XPS_MIN_MAP_ALLOC ((L1_CACHE_BYTES - sizeof(struct xps_map))	\</span>
<span class="cp">    / sizeof(u16))</span>

<span class="cm">/*</span>
<span class="cm"> * This structure holds all XPS maps for device.  Maps are indexed by CPU.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xps_dev_maps</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xps_map</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define XPS_DEV_MAPS_SIZE (sizeof(struct xps_dev_maps) +		\</span>
<span class="cp">    (nr_cpu_ids * sizeof(struct xps_map *)))</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_XPS */</span><span class="cp"></span>

<span class="cp">#define TC_MAX_QUEUE	16</span>
<span class="cp">#define TC_BITMASK	15</span>
<span class="cm">/* HW offloaded queuing disciplines txq count and offset maps */</span>
<span class="k">struct</span> <span class="n">netdev_tc_txq</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)</span>
<span class="cm">/*</span>
<span class="cm"> * This structure is to hold information about the device</span>
<span class="cm"> * configured to run FCoE protocol stack.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">netdev_fcoe_hbainfo</span> <span class="p">{</span>
	<span class="kt">char</span>	<span class="n">manufacturer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">serial_number</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">hardware_version</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">driver_version</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">optionrom_version</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">firmware_version</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">model</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">model_description</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This structure defines the management hooks for network devices.</span>
<span class="cm"> * The following hooks can be defined; unless noted otherwise, they are</span>
<span class="cm"> * optional and can be filled with a null pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_init)(struct net_device *dev);</span>
<span class="cm"> *     This function is called once when network device is registered.</span>
<span class="cm"> *     The network device can use this to any late stage initializaton</span>
<span class="cm"> *     or semantic validattion. It can fail with an error code which will</span>
<span class="cm"> *     be propogated back to register_netdev</span>
<span class="cm"> *</span>
<span class="cm"> * void (*ndo_uninit)(struct net_device *dev);</span>
<span class="cm"> *     This function is called when device is unregistered or when registration</span>
<span class="cm"> *     fails. It is not called if init fails.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_open)(struct net_device *dev);</span>
<span class="cm"> *     This function is called when network device transistions to the up</span>
<span class="cm"> *     state.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_stop)(struct net_device *dev);</span>
<span class="cm"> *     This function is called when network device transistions to the down</span>
<span class="cm"> *     state.</span>
<span class="cm"> *</span>
<span class="cm"> * netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb,</span>
<span class="cm"> *                               struct net_device *dev);</span>
<span class="cm"> *	Called when a packet needs to be transmitted.</span>
<span class="cm"> *	Must return NETDEV_TX_OK , NETDEV_TX_BUSY.</span>
<span class="cm"> *        (can also return NETDEV_TX_LOCKED iff NETIF_F_LLTX)</span>
<span class="cm"> *	Required can not be NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * u16 (*ndo_select_queue)(struct net_device *dev, struct sk_buff *skb);</span>
<span class="cm"> *	Called to decide which queue to when device supports multiple</span>
<span class="cm"> *	transmit queues.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*ndo_change_rx_flags)(struct net_device *dev, int flags);</span>
<span class="cm"> *	This function is called to allow device receiver to make</span>
<span class="cm"> *	changes to configuration when multicast or promiscious is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*ndo_set_rx_mode)(struct net_device *dev);</span>
<span class="cm"> *	This function is called device changes address list filtering.</span>
<span class="cm"> *	If driver handles unicast address filtering, it should set</span>
<span class="cm"> *	IFF_UNICAST_FLT to its priv_flags.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_set_mac_address)(struct net_device *dev, void *addr);</span>
<span class="cm"> *	This function  is called when the Media Access Control address</span>
<span class="cm"> *	needs to be changed. If this interface is not defined, the</span>
<span class="cm"> *	mac address can not be changed.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_validate_addr)(struct net_device *dev);</span>
<span class="cm"> *	Test if Media Access Control address is valid for the device.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd);</span>
<span class="cm"> *	Called when a user request an ioctl which can&#39;t be handled by</span>
<span class="cm"> *	the generic interface code. If not defined ioctl&#39;s return</span>
<span class="cm"> *	not supported error code.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_set_config)(struct net_device *dev, struct ifmap *map);</span>
<span class="cm"> *	Used to set network devices bus interface parameters. This interface</span>
<span class="cm"> *	is retained for legacy reason, new devices should use the bus</span>
<span class="cm"> *	interface (PCI) for low level management.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_change_mtu)(struct net_device *dev, int new_mtu);</span>
<span class="cm"> *	Called when a user wants to change the Maximum Transfer Unit</span>
<span class="cm"> *	of a device. If not defined, any request to change MTU will</span>
<span class="cm"> *	will return an error.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*ndo_tx_timeout)(struct net_device *dev);</span>
<span class="cm"> *	Callback uses when the transmitter has not made any progress</span>
<span class="cm"> *	for dev-&gt;watchdog ticks.</span>
<span class="cm"> *</span>
<span class="cm"> * struct rtnl_link_stats64* (*ndo_get_stats64)(struct net_device *dev,</span>
<span class="cm"> *                      struct rtnl_link_stats64 *storage);</span>
<span class="cm"> * struct net_device_stats* (*ndo_get_stats)(struct net_device *dev);</span>
<span class="cm"> *	Called when a user wants to get the network device usage</span>
<span class="cm"> *	statistics. Drivers must do one of the following:</span>
<span class="cm"> *	1. Define @ndo_get_stats64 to fill in a zero-initialised</span>
<span class="cm"> *	   rtnl_link_stats64 structure passed by the caller.</span>
<span class="cm"> *	2. Define @ndo_get_stats to update a net_device_stats structure</span>
<span class="cm"> *	   (which should normally be dev-&gt;stats) and return a pointer to</span>
<span class="cm"> *	   it. The structure may be changed asynchronously only if each</span>
<span class="cm"> *	   field is written atomically.</span>
<span class="cm"> *	3. Update dev-&gt;stats asynchronously and atomically, and define</span>
<span class="cm"> *	   neither operation.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_vlan_rx_add_vid)(struct net_device *dev, unsigned short vid);</span>
<span class="cm"> *	If device support VLAN filtering (dev-&gt;features &amp; NETIF_F_HW_VLAN_FILTER)</span>
<span class="cm"> *	this function is called when a VLAN id is registered.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_vlan_rx_kill_vid)(struct net_device *dev, unsigned short vid);</span>
<span class="cm"> *	If device support VLAN filtering (dev-&gt;features &amp; NETIF_F_HW_VLAN_FILTER)</span>
<span class="cm"> *	this function is called when a VLAN id is unregistered.</span>
<span class="cm"> *</span>
<span class="cm"> * void (*ndo_poll_controller)(struct net_device *dev);</span>
<span class="cm"> *</span>
<span class="cm"> *	SR-IOV management functions.</span>
<span class="cm"> * int (*ndo_set_vf_mac)(struct net_device *dev, int vf, u8* mac);</span>
<span class="cm"> * int (*ndo_set_vf_vlan)(struct net_device *dev, int vf, u16 vlan, u8 qos);</span>
<span class="cm"> * int (*ndo_set_vf_tx_rate)(struct net_device *dev, int vf, int rate);</span>
<span class="cm"> * int (*ndo_set_vf_spoofchk)(struct net_device *dev, int vf, bool setting);</span>
<span class="cm"> * int (*ndo_get_vf_config)(struct net_device *dev,</span>
<span class="cm"> *			    int vf, struct ifla_vf_info *ivf);</span>
<span class="cm"> * int (*ndo_set_vf_port)(struct net_device *dev, int vf,</span>
<span class="cm"> *			  struct nlattr *port[]);</span>
<span class="cm"> * int (*ndo_get_vf_port)(struct net_device *dev, int vf, struct sk_buff *skb);</span>
<span class="cm"> * int (*ndo_setup_tc)(struct net_device *dev, u8 tc)</span>
<span class="cm"> * 	Called to setup &#39;tc&#39; number of traffic classes in the net device. This</span>
<span class="cm"> * 	is always called from the stack with the rtnl lock held and netif tx</span>
<span class="cm"> * 	queues stopped. This allows the netdevice to perform queue management</span>
<span class="cm"> * 	safely.</span>
<span class="cm"> *</span>
<span class="cm"> *	Fiber Channel over Ethernet (FCoE) offload functions.</span>
<span class="cm"> * int (*ndo_fcoe_enable)(struct net_device *dev);</span>
<span class="cm"> *	Called when the FCoE protocol stack wants to start using LLD for FCoE</span>
<span class="cm"> *	so the underlying device can perform whatever needed configuration or</span>
<span class="cm"> *	initialization to support acceleration of FCoE traffic.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_fcoe_disable)(struct net_device *dev);</span>
<span class="cm"> *	Called when the FCoE protocol stack wants to stop using LLD for FCoE</span>
<span class="cm"> *	so the underlying device can perform whatever needed clean-ups to</span>
<span class="cm"> *	stop supporting acceleration of FCoE traffic.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_fcoe_ddp_setup)(struct net_device *dev, u16 xid,</span>
<span class="cm"> *			     struct scatterlist *sgl, unsigned int sgc);</span>
<span class="cm"> *	Called when the FCoE Initiator wants to initialize an I/O that</span>
<span class="cm"> *	is a possible candidate for Direct Data Placement (DDP). The LLD can</span>
<span class="cm"> *	perform necessary setup and returns 1 to indicate the device is set up</span>
<span class="cm"> *	successfully to perform DDP on this I/O, otherwise this returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_fcoe_ddp_done)(struct net_device *dev,  u16 xid);</span>
<span class="cm"> *	Called when the FCoE Initiator/Target is done with the DDPed I/O as</span>
<span class="cm"> *	indicated by the FC exchange id &#39;xid&#39;, so the underlying device can</span>
<span class="cm"> *	clean up and reuse resources for later DDP requests.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_fcoe_ddp_target)(struct net_device *dev, u16 xid,</span>
<span class="cm"> *			      struct scatterlist *sgl, unsigned int sgc);</span>
<span class="cm"> *	Called when the FCoE Target wants to initialize an I/O that</span>
<span class="cm"> *	is a possible candidate for Direct Data Placement (DDP). The LLD can</span>
<span class="cm"> *	perform necessary setup and returns 1 to indicate the device is set up</span>
<span class="cm"> *	successfully to perform DDP on this I/O, otherwise this returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_fcoe_get_hbainfo)(struct net_device *dev,</span>
<span class="cm"> *			       struct netdev_fcoe_hbainfo *hbainfo);</span>
<span class="cm"> *	Called when the FCoE Protocol stack wants information on the underlying</span>
<span class="cm"> *	device. This information is utilized by the FCoE protocol stack to</span>
<span class="cm"> *	register attributes with Fiber Channel management service as per the</span>
<span class="cm"> *	FC-GS Fabric Device Management Information(FDMI) specification.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_fcoe_get_wwn)(struct net_device *dev, u64 *wwn, int type);</span>
<span class="cm"> *	Called when the underlying device wants to override default World Wide</span>
<span class="cm"> *	Name (WWN) generation mechanism in FCoE protocol stack to pass its own</span>
<span class="cm"> *	World Wide Port Name (WWPN) or World Wide Node Name (WWNN) to the FCoE</span>
<span class="cm"> *	protocol stack to use.</span>
<span class="cm"> *</span>
<span class="cm"> *	RFS acceleration.</span>
<span class="cm"> * int (*ndo_rx_flow_steer)(struct net_device *dev, const struct sk_buff *skb,</span>
<span class="cm"> *			    u16 rxq_index, u32 flow_id);</span>
<span class="cm"> *	Set hardware filter for RFS.  rxq_index is the target queue index;</span>
<span class="cm"> *	flow_id is a flow ID to be passed to rps_may_expire_flow() later.</span>
<span class="cm"> *	Return the filter ID on success, or a negative error code.</span>
<span class="cm"> *</span>
<span class="cm"> *	Slave management functions (for bridge, bonding, etc). User should</span>
<span class="cm"> *	call netdev_set_master() to set dev-&gt;master properly.</span>
<span class="cm"> * int (*ndo_add_slave)(struct net_device *dev, struct net_device *slave_dev);</span>
<span class="cm"> *	Called to make another netdev an underling.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_del_slave)(struct net_device *dev, struct net_device *slave_dev);</span>
<span class="cm"> *	Called to release previously enslaved netdev.</span>
<span class="cm"> *</span>
<span class="cm"> *      Feature/offload setting functions.</span>
<span class="cm"> * netdev_features_t (*ndo_fix_features)(struct net_device *dev,</span>
<span class="cm"> *		netdev_features_t features);</span>
<span class="cm"> *	Adjusts the requested feature flags according to device-specific</span>
<span class="cm"> *	constraints, and returns the resulting flags. Must not modify</span>
<span class="cm"> *	the device state.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_set_features)(struct net_device *dev, netdev_features_t features);</span>
<span class="cm"> *	Called to update device configuration to new features. Passed</span>
<span class="cm"> *	feature set might be less than what was returned by ndo_fix_features()).</span>
<span class="cm"> *	Must return &gt;0 or -errno if it changed dev-&gt;features itself.</span>
<span class="cm"> *</span>
<span class="cm"> * int (*ndo_fdb_add)(struct ndmsg *ndm, struct net_device *dev,</span>
<span class="cm"> *		      unsigned char *addr, u16 flags)</span>
<span class="cm"> *	Adds an FDB entry to dev for addr.</span>
<span class="cm"> * int (*ndo_fdb_del)(struct ndmsg *ndm, struct net_device *dev,</span>
<span class="cm"> *		      unsigned char *addr)</span>
<span class="cm"> *	Deletes the FDB entry from dev coresponding to addr.</span>
<span class="cm"> * int (*ndo_fdb_dump)(struct sk_buff *skb, struct netlink_callback *cb,</span>
<span class="cm"> *		       struct net_device *dev, int idx)</span>
<span class="cm"> *	Used to add FDB entries to dump requests. Implementers should add</span>
<span class="cm"> *	entries to skb and update idx with the number of entries.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">net_device_ops</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_uninit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netdev_tx_t</span>		<span class="p">(</span><span class="o">*</span><span class="n">ndo_start_xmit</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u16</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_select_queue</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_change_rx_flags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						       <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_rx_mode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_mac_address</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						       <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_validate_addr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_do_ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					        <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					          <span class="k">struct</span> <span class="n">ifmap</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_change_mtu</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_neigh_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">neigh_parms</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_tx_timeout</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">rtnl_link_stats64</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">ndo_get_stats64</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">storage</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">ndo_get_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_vlan_rx_add_vid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						       <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vid</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_vlan_rx_kill_vid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						        <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vid</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">ndo_poll_controller</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_netpoll_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">netpoll_info</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_netpoll_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_vf_mac</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_vf_vlan</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">queue</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vlan</span><span class="p">,</span> <span class="n">u8</span> <span class="n">qos</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_vf_tx_rate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						      <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_vf_spoofchk</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						       <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="n">bool</span> <span class="n">setting</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_get_vf_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						     <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">ifla_vf_info</span> <span class="o">*</span><span class="n">ivf</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_vf_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">port</span><span class="p">[]);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_get_vf_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">vf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_setup_tc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tc</span><span class="p">);</span>
<span class="cp">#if IS_ENABLED(CONFIG_FCOE)</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fcoe_enable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fcoe_disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fcoe_ddp_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						      <span class="n">u16</span> <span class="n">xid</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sgc</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fcoe_ddp_done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						     <span class="n">u16</span> <span class="n">xid</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fcoe_ddp_target</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						       <span class="n">u16</span> <span class="n">xid</span><span class="p">,</span>
						       <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
						       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sgc</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fcoe_get_hbainfo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">netdev_fcoe_hbainfo</span> <span class="o">*</span><span class="n">hbainfo</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if IS_ENABLED(CONFIG_LIBFCOE)</span>
<span class="cp">#define NETDEV_FCOE_WWNN 0</span>
<span class="cp">#define NETDEV_FCOE_WWPN 1</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fcoe_get_wwn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						    <span class="n">u64</span> <span class="o">*</span><span class="n">wwn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_rx_flow_steer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						     <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						     <span class="n">u16</span> <span class="n">rxq_index</span><span class="p">,</span>
						     <span class="n">u32</span> <span class="n">flow_id</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_add_slave</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_del_slave</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">);</span>
	<span class="n">netdev_features_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">ndo_fix_features</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						    <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_set_features</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						    <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_neigh_construct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_neigh_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>

	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fdb_add</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ndmsg</span> <span class="o">*</span><span class="n">ndm</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
					       <span class="n">u16</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fdb_del</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ndmsg</span> <span class="o">*</span><span class="n">ndm</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">ndo_fdb_dump</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	The DEVICE structure.</span>
<span class="cm"> *	Actually, this whole structure is a big mistake.  It mixes I/O</span>
<span class="cm"> *	data with strictly &quot;high-level&quot; data, and it has to know about</span>
<span class="cm"> *	almost every data structure used in the INET module.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: cleanup struct net_device such that network protocol info</span>
<span class="cm"> *	moves out.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the first field of the &quot;visible&quot; part of this structure</span>
<span class="cm">	 * (i.e. as seen by users in the &quot;Space.c&quot; file).  It is the name</span>
<span class="cm">	 * of the interface.</span>
<span class="cm">	 */</span>
	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">pm_qos_request</span>	<span class="n">pm_qos_req</span><span class="p">;</span>

	<span class="cm">/* device name hash chain */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">name_hlist</span><span class="p">;</span>
	<span class="cm">/* snmp alias */</span>
	<span class="kt">char</span> 			<span class="o">*</span><span class="n">ifalias</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	I/O specific fields</span>
<span class="cm">	 *	FIXME: Merge these and struct ifmap into one</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mem_end</span><span class="p">;</span>	<span class="cm">/* shared mem end	*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mem_start</span><span class="p">;</span>	<span class="cm">/* shared mem start	*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">base_addr</span><span class="p">;</span>	<span class="cm">/* device I/O address	*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>		<span class="cm">/* device IRQ number	*/</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Some hardware also needs these fields, but they are not</span>
<span class="cm">	 *	part of the usual set specified in Space.c.</span>
<span class="cm">	 */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dev_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">napi_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">unreg_list</span><span class="p">;</span>

	<span class="cm">/* currently active device features */</span>
	<span class="n">netdev_features_t</span>	<span class="n">features</span><span class="p">;</span>
	<span class="cm">/* user-changeable features */</span>
	<span class="n">netdev_features_t</span>	<span class="n">hw_features</span><span class="p">;</span>
	<span class="cm">/* user-requested features */</span>
	<span class="n">netdev_features_t</span>	<span class="n">wanted_features</span><span class="p">;</span>
	<span class="cm">/* mask of features inheritable by VLAN devices */</span>
	<span class="n">netdev_features_t</span>	<span class="n">vlan_features</span><span class="p">;</span>

	<span class="cm">/* Interface index. Unique device identifier	*/</span>
	<span class="kt">int</span>			<span class="n">ifindex</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">iflink</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">net_device_stats</span>	<span class="n">stats</span><span class="p">;</span>
	<span class="n">atomic_long_t</span>		<span class="n">rx_dropped</span><span class="p">;</span> <span class="cm">/* dropped packets by core network</span>
<span class="cm">					     * Do not use this in drivers.</span>
<span class="cm">					     */</span>

<span class="cp">#ifdef CONFIG_WIRELESS_EXT</span>
	<span class="cm">/* List of functions to handle Wireless Extensions (instead of ioctl).</span>
<span class="cm">	 * See &lt;net/iw_handler.h&gt; for details. Jean II */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iw_handler_def</span> <span class="o">*</span>	<span class="n">wireless_handlers</span><span class="p">;</span>
	<span class="cm">/* Instance data managed by the core of Wireless Extensions. */</span>
	<span class="k">struct</span> <span class="n">iw_public_data</span> <span class="o">*</span>	<span class="n">wireless_data</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* Management operations */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="o">*</span><span class="n">ethtool_ops</span><span class="p">;</span>

	<span class="cm">/* Hardware header description */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">header_ops</span> <span class="o">*</span><span class="n">header_ops</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>	<span class="cm">/* interface flags (a la BSD)	*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">priv_flags</span><span class="p">;</span> <span class="cm">/* Like &#39;flags&#39; but invisible to userspace.</span>
<span class="cm">					     * See if.h for definitions. */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">gflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">padded</span><span class="p">;</span>	<span class="cm">/* How much padding added by alloc_netdev() */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">operstate</span><span class="p">;</span> <span class="cm">/* RFC2863 operstate */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">link_mode</span><span class="p">;</span> <span class="cm">/* mapping policy to operstate */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">if_port</span><span class="p">;</span>	<span class="cm">/* Selectable AUI, TP,..*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">dma</span><span class="p">;</span>		<span class="cm">/* DMA channel		*/</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">mtu</span><span class="p">;</span>	<span class="cm">/* interface MTU value		*/</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">type</span><span class="p">;</span>	<span class="cm">/* interface hardware type	*/</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">hard_header_len</span><span class="p">;</span>	<span class="cm">/* hardware hdr length	*/</span>

	<span class="cm">/* extra head- and tailroom the hardware may need, but not in all cases</span>
<span class="cm">	 * can this be guaranteed, especially tailroom. Some cases also use</span>
<span class="cm">	 * LL_MAX_HEADER instead to allocate the skb.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">needed_headroom</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">needed_tailroom</span><span class="p">;</span>

	<span class="cm">/* Interface address info. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">perm_addr</span><span class="p">[</span><span class="n">MAX_ADDR_LEN</span><span class="p">];</span> <span class="cm">/* permanent hw address */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">addr_assign_type</span><span class="p">;</span> <span class="cm">/* hw address assignment type */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">addr_len</span><span class="p">;</span>	<span class="cm">/* hardware address length	*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">neigh_priv_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>          <span class="n">dev_id</span><span class="p">;</span>		<span class="cm">/* for shared network cards */</span>

	<span class="n">spinlock_t</span>		<span class="n">addr_list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr_list</span>	<span class="n">uc</span><span class="p">;</span>	<span class="cm">/* Unicast mac addresses */</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr_list</span>	<span class="n">mc</span><span class="p">;</span>	<span class="cm">/* Multicast mac addresses */</span>
	<span class="n">bool</span>			<span class="n">uc_promisc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">promiscuity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">allmulti</span><span class="p">;</span>


	<span class="cm">/* Protocol specific pointers */</span>

<span class="cp">#if IS_ENABLED(CONFIG_VLAN_8021Q)</span>
	<span class="k">struct</span> <span class="n">vlan_info</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">vlan_info</span><span class="p">;</span>	<span class="cm">/* VLAN info */</span>
<span class="cp">#endif</span>
<span class="cp">#if IS_ENABLED(CONFIG_NET_DSA)</span>
	<span class="k">struct</span> <span class="n">dsa_switch_tree</span>	<span class="o">*</span><span class="n">dsa_ptr</span><span class="p">;</span>	<span class="cm">/* dsa specific data */</span>
<span class="cp">#endif</span>
	<span class="kt">void</span> 			<span class="o">*</span><span class="n">atalk_ptr</span><span class="p">;</span>	<span class="cm">/* AppleTalk link 	*/</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">ip_ptr</span><span class="p">;</span>	<span class="cm">/* IPv4 specific data	*/</span>
	<span class="k">struct</span> <span class="n">dn_dev</span> <span class="n">__rcu</span>     <span class="o">*</span><span class="n">dn_ptr</span><span class="p">;</span>        <span class="cm">/* DECnet specific data */</span>
	<span class="k">struct</span> <span class="n">inet6_dev</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">ip6_ptr</span><span class="p">;</span>       <span class="cm">/* IPv6 specific data */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">ax25_ptr</span><span class="p">;</span>	<span class="cm">/* AX.25 specific data */</span>
	<span class="k">struct</span> <span class="n">wireless_dev</span>	<span class="o">*</span><span class="n">ieee80211_ptr</span><span class="p">;</span>	<span class="cm">/* IEEE 802.11 specific data,</span>
<span class="cm">						   assign before registering */</span>

<span class="cm">/*</span>
<span class="cm"> * Cache lines mostly used on receive path (including eth_type_trans())</span>
<span class="cm"> */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_rx</span><span class="p">;</span>	<span class="cm">/* Time of last Rx</span>
<span class="cm">						 * This should not be set in</span>
<span class="cm">						 * drivers, unless really needed,</span>
<span class="cm">						 * because network stack (bonding)</span>
<span class="cm">						 * use it if/when necessary, to</span>
<span class="cm">						 * avoid dirtying this cache line.</span>
<span class="cm">						 */</span>

	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">master</span><span class="p">;</span> <span class="cm">/* Pointer to master device of a group,</span>
<span class="cm">					  * which this device is member of.</span>
<span class="cm">					  */</span>

	<span class="cm">/* Interface address info used in eth_type_trans() */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">dev_addr</span><span class="p">;</span>	<span class="cm">/* hw address, (before bcast</span>
<span class="cm">						   because most packets are</span>
<span class="cm">						   unicast) */</span>

	<span class="k">struct</span> <span class="n">netdev_hw_addr_list</span>	<span class="n">dev_addrs</span><span class="p">;</span> <span class="cm">/* list of device</span>
<span class="cm">						      hw addresses */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">broadcast</span><span class="p">[</span><span class="n">MAX_ADDR_LEN</span><span class="p">];</span>	<span class="cm">/* hw bcast add	*/</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
	<span class="k">struct</span> <span class="n">kset</span>		<span class="o">*</span><span class="n">queues_kset</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">struct</span> <span class="n">netdev_rx_queue</span>	<span class="o">*</span><span class="n">_rx</span><span class="p">;</span>

	<span class="cm">/* Number of RX queues allocated at register_netdev() time */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">num_rx_queues</span><span class="p">;</span>

	<span class="cm">/* Number of RX queues currently active in device */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">real_num_rx_queues</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
	<span class="cm">/* CPU reverse-mapping for RX completion interrupts, indexed</span>
<span class="cm">	 * by RX queue number.  Assigned by driver.  This must only be</span>
<span class="cm">	 * set if the ndo_rx_flow_steer operation is defined. */</span>
	<span class="k">struct</span> <span class="n">cpu_rmap</span>		<span class="o">*</span><span class="n">rx_cpu_rmap</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="n">rx_handler_func_t</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">rx_handler</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">rx_handler_data</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">ingress_queue</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Cache lines mostly used on transmit path</span>
<span class="cm"> */</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span>	<span class="o">*</span><span class="n">_tx</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

	<span class="cm">/* Number of TX queues allocated at alloc_netdev_mq() time  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">num_tx_queues</span><span class="p">;</span>

	<span class="cm">/* Number of TX queues currently active in device  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">real_num_tx_queues</span><span class="p">;</span>

	<span class="cm">/* root qdisc from userspace point of view */</span>
	<span class="k">struct</span> <span class="n">Qdisc</span>		<span class="o">*</span><span class="n">qdisc</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tx_queue_len</span><span class="p">;</span>	<span class="cm">/* Max frames per queue allowed */</span>
	<span class="n">spinlock_t</span>		<span class="n">tx_global_lock</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_XPS</span>
	<span class="k">struct</span> <span class="n">xps_dev_maps</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">xps_maps</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* These may be needed for future network-power-down code. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * trans_start here is expensive for high speed devices on SMP,</span>
<span class="cm">	 * please use netdev_queue-&gt;trans_start instead.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">trans_start</span><span class="p">;</span>	<span class="cm">/* Time (in jiffies) of last Tx	*/</span>

	<span class="kt">int</span>			<span class="n">watchdog_timeo</span><span class="p">;</span> <span class="cm">/* used by dev_watchdog() */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">watchdog_timer</span><span class="p">;</span>

	<span class="cm">/* Number of references to this device */</span>
	<span class="kt">int</span> <span class="n">__percpu</span>		<span class="o">*</span><span class="n">pcpu_refcnt</span><span class="p">;</span>

	<span class="cm">/* delayed register/unregister */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">todo_list</span><span class="p">;</span>
	<span class="cm">/* device index hash chain */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">index_hlist</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link_watch_list</span><span class="p">;</span>

	<span class="cm">/* register/unregister state machine */</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">NETREG_UNINITIALIZED</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
	       <span class="n">NETREG_REGISTERED</span><span class="p">,</span>	<span class="cm">/* completed register_netdevice */</span>
	       <span class="n">NETREG_UNREGISTERING</span><span class="p">,</span>	<span class="cm">/* called unregister_netdevice */</span>
	       <span class="n">NETREG_UNREGISTERED</span><span class="p">,</span>	<span class="cm">/* completed unregister todo */</span>
	       <span class="n">NETREG_RELEASED</span><span class="p">,</span>		<span class="cm">/* called free_netdev */</span>
	       <span class="n">NETREG_DUMMY</span><span class="p">,</span>		<span class="cm">/* dummy device for NAPI poll */</span>
	<span class="p">}</span> <span class="n">reg_state</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">dismantle</span><span class="p">;</span> <span class="cm">/* device is going do be freed */</span>

	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">RTNL_LINK_INITIALIZED</span><span class="p">,</span>
		<span class="n">RTNL_LINK_INITIALIZING</span><span class="p">,</span>
	<span class="p">}</span> <span class="n">rtnl_link_state</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* Called from unregister, can be used to call free_netdev */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NETPOLL</span>
	<span class="k">struct</span> <span class="n">netpoll_info</span>	<span class="o">*</span><span class="n">npinfo</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="cm">/* Network namespace this network device is inside */</span>
	<span class="k">struct</span> <span class="n">net</span>		<span class="o">*</span><span class="n">nd_net</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* mid-layer private */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">void</span>				<span class="o">*</span><span class="n">ml_priv</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pcpu_lstats</span> <span class="n">__percpu</span>	<span class="o">*</span><span class="n">lstats</span><span class="p">;</span> <span class="cm">/* loopback stats */</span>
		<span class="k">struct</span> <span class="n">pcpu_tstats</span> <span class="n">__percpu</span>	<span class="o">*</span><span class="n">tstats</span><span class="p">;</span> <span class="cm">/* tunnel stats */</span>
		<span class="k">struct</span> <span class="n">pcpu_dstats</span> <span class="n">__percpu</span>	<span class="o">*</span><span class="n">dstats</span><span class="p">;</span> <span class="cm">/* dummy stats */</span>
	<span class="p">};</span>
	<span class="cm">/* GARP */</span>
	<span class="k">struct</span> <span class="n">garp_port</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">garp_port</span><span class="p">;</span>

	<span class="cm">/* class/net/name entry */</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">dev</span><span class="p">;</span>
	<span class="cm">/* space for optional device, statistics, and wireless sysfs groups */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">sysfs_groups</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/* rtnetlink link ops */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rtnl_link_ops</span> <span class="o">*</span><span class="n">rtnl_link_ops</span><span class="p">;</span>

	<span class="cm">/* for setting kernel sock attribute on TCP connection setup */</span>
<span class="cp">#define GSO_MAX_SIZE		65536</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gso_max_size</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DCB</span>
	<span class="cm">/* Data Center Bridging netlink ops */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dcbnl_rtnl_ops</span> <span class="o">*</span><span class="n">dcbnl_ops</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">u8</span> <span class="n">num_tc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_tc_txq</span> <span class="n">tc_to_txq</span><span class="p">[</span><span class="n">TC_MAX_QUEUE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">prio_tc_map</span><span class="p">[</span><span class="n">TC_BITMASK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="cp">#if IS_ENABLED(CONFIG_FCOE)</span>
	<span class="cm">/* max exchange id for FCoE LRO by ddp */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">fcoe_ddp_xid</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if IS_ENABLED(CONFIG_NETPRIO_CGROUP)</span>
	<span class="k">struct</span> <span class="n">netprio_map</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">priomap</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* phy device may attach itself for hardware timestamping */</span>
	<span class="k">struct</span> <span class="n">phy_device</span> <span class="o">*</span><span class="n">phydev</span><span class="p">;</span>

	<span class="cm">/* group the device belongs to */</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_net_dev(d) container_of(d, struct net_device, dev)</span>

<span class="cp">#define	NETDEV_ALIGN		32</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">netdev_get_prio_tc_map</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">prio_tc_map</span><span class="p">[</span><span class="n">prio</span> <span class="o">&amp;</span> <span class="n">TC_BITMASK</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">netdev_set_prio_tc_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">prio</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">prio_tc_map</span><span class="p">[</span><span class="n">prio</span> <span class="o">&amp;</span> <span class="n">TC_BITMASK</span><span class="p">]</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">&amp;</span> <span class="n">TC_BITMASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">netdev_reset_tc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">prio_tc_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">prio_tc_map</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">netdev_set_tc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tc</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">netdev_set_num_tc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">num_tc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_tc</span> <span class="o">&gt;</span> <span class="n">TC_MAX_QUEUE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span> <span class="o">=</span> <span class="n">num_tc</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">netdev_get_num_tc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="nf">netdev_get_tx_queue</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_tx</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_for_each_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="p">,</span>
						      <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
					    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">f</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_tx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Net namespace inlines</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">dev_net</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_pnet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">nd_net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">dev_net_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="n">release_net</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">nd_net</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">nd_net</span> <span class="o">=</span> <span class="n">hold_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netdev_uses_dsa_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_DSA_TAG_DSA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dsa_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dsa_uses_dsa_tags</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dsa_ptr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netdev_uses_trailer_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_DSA_TAG_TRAILER</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dsa_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dsa_uses_trailer_tags</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dsa_ptr</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_priv - access network device private data</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Get network device private data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">netdev_priv</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="p">),</span> <span class="n">NETDEV_ALIGN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set the sysfs physical device reference for the network logical device</span>
<span class="cm"> * if set prior to registration will cause a symlink during initialization.</span>
<span class="cm"> */</span>
<span class="cp">#define SET_NETDEV_DEV(net, pdev)	((net)-&gt;dev.parent = (pdev))</span>

<span class="cm">/* Set the sysfs device type for the network logical device to allow</span>
<span class="cm"> * fin grained indentification of different network device types. For</span>
<span class="cm"> * example Ethernet, Wirelss LAN, Bluetooth, WiMAX etc.</span>
<span class="cm"> */</span>
<span class="cp">#define SET_NETDEV_DEVTYPE(net, devtype)	((net)-&gt;dev.type = (devtype))</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_napi_add - initialize a napi context</span>
<span class="cm"> *	@dev:  network device</span>
<span class="cm"> *	@napi: napi context</span>
<span class="cm"> *	@poll: polling function</span>
<span class="cm"> *	@weight: default weight</span>
<span class="cm"> *</span>
<span class="cm"> * netif_napi_add() must be used to initialize a napi context prior to calling</span>
<span class="cm"> * *any* of the other napi related functions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">netif_napi_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  netif_napi_del - remove a napi context</span>
<span class="cm"> *  @napi: napi context</span>
<span class="cm"> *</span>
<span class="cm"> *  netif_napi_del() removes a napi context from the network device napi list</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">netif_napi_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">napi_gro_cb</span> <span class="p">{</span>
	<span class="cm">/* Virtual address of skb_shinfo(skb)-&gt;frags[0].page + offset. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">frag0</span><span class="p">;</span>

	<span class="cm">/* Length of frag0. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag0_len</span><span class="p">;</span>

	<span class="cm">/* This indicates where we are processing relative to skb-&gt;data. */</span>
	<span class="kt">int</span> <span class="n">data_offset</span><span class="p">;</span>

	<span class="cm">/* This is non-zero if the packet may be of the same flow. */</span>
	<span class="kt">int</span> <span class="n">same_flow</span><span class="p">;</span>

	<span class="cm">/* This is non-zero if the packet cannot be merged with the new skb. */</span>
	<span class="kt">int</span> <span class="n">flush</span><span class="p">;</span>

	<span class="cm">/* Number of segments aggregated. */</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* Free the skb? */</span>
	<span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
<span class="cp">#define NAPI_GRO_FREE		  1</span>
<span class="cp">#define NAPI_GRO_FREE_STOLEN_HEAD 2</span>
<span class="p">};</span>

<span class="cp">#define NAPI_GRO_CB(skb) ((struct napi_gro_cb *)(skb)-&gt;cb)</span>

<span class="k">struct</span> <span class="n">packet_type</span> <span class="p">{</span>
	<span class="n">__be16</span>			<span class="n">type</span><span class="p">;</span>	<span class="cm">/* This is really htons(ether_type). */</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>	<span class="cm">/* NULL is wildcarded here	     */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">gso_segment</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">gso_send_check</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">**</span><span class="p">(</span><span class="o">*</span><span class="n">gro_receive</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">gro_complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">af_packet_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include &lt;linux/notifier.h&gt;</span>

<span class="cm">/* netdevice notifier chain. Please remember to update the rtnetlink</span>
<span class="cm"> * notification exclusion list in rtnetlink_event() when adding new</span>
<span class="cm"> * types.</span>
<span class="cm"> */</span>
<span class="cp">#define NETDEV_UP	0x0001	</span><span class="cm">/* For now you can&#39;t veto a device up/down */</span><span class="cp"></span>
<span class="cp">#define NETDEV_DOWN	0x0002</span>
<span class="cp">#define NETDEV_REBOOT	0x0003	</span><span class="cm">/* Tell a protocol stack a network interface</span>
<span class="cm">				   detected a hardware crash and restarted</span>
<span class="cm">				   - we can use this eg to kick tcp sessions</span>
<span class="cm">				   once done */</span><span class="cp"></span>
<span class="cp">#define NETDEV_CHANGE	0x0004	</span><span class="cm">/* Notify device state change */</span><span class="cp"></span>
<span class="cp">#define NETDEV_REGISTER 0x0005</span>
<span class="cp">#define NETDEV_UNREGISTER	0x0006</span>
<span class="cp">#define NETDEV_CHANGEMTU	0x0007</span>
<span class="cp">#define NETDEV_CHANGEADDR	0x0008</span>
<span class="cp">#define NETDEV_GOING_DOWN	0x0009</span>
<span class="cp">#define NETDEV_CHANGENAME	0x000A</span>
<span class="cp">#define NETDEV_FEAT_CHANGE	0x000B</span>
<span class="cp">#define NETDEV_BONDING_FAILOVER 0x000C</span>
<span class="cp">#define NETDEV_PRE_UP		0x000D</span>
<span class="cp">#define NETDEV_PRE_TYPE_CHANGE	0x000E</span>
<span class="cp">#define NETDEV_POST_TYPE_CHANGE	0x000F</span>
<span class="cp">#define NETDEV_POST_INIT	0x0010</span>
<span class="cp">#define NETDEV_UNREGISTER_BATCH 0x0011</span>
<span class="cp">#define NETDEV_RELEASE		0x0012</span>
<span class="cp">#define NETDEV_NOTIFY_PEERS	0x0013</span>
<span class="cp">#define NETDEV_JOIN		0x0014</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


<span class="k">extern</span> <span class="n">rwlock_t</span>				<span class="n">dev_base_lock</span><span class="p">;</span>		<span class="cm">/* Device list lock */</span>


<span class="cp">#define for_each_netdev(net, d)		\</span>
<span class="cp">		list_for_each_entry(d, &amp;(net)-&gt;dev_base_head, dev_list)</span>
<span class="cp">#define for_each_netdev_reverse(net, d)	\</span>
<span class="cp">		list_for_each_entry_reverse(d, &amp;(net)-&gt;dev_base_head, dev_list)</span>
<span class="cp">#define for_each_netdev_rcu(net, d)		\</span>
<span class="cp">		list_for_each_entry_rcu(d, &amp;(net)-&gt;dev_base_head, dev_list)</span>
<span class="cp">#define for_each_netdev_safe(net, d, n)	\</span>
<span class="cp">		list_for_each_entry_safe(d, n, &amp;(net)-&gt;dev_base_head, dev_list)</span>
<span class="cp">#define for_each_netdev_continue(net, d)		\</span>
<span class="cp">		list_for_each_entry_continue(d, &amp;(net)-&gt;dev_base_head, dev_list)</span>
<span class="cp">#define for_each_netdev_continue_rcu(net, d)		\</span>
<span class="cp">	list_for_each_entry_continue_rcu(d, &amp;(net)-&gt;dev_base_head, dev_list)</span>
<span class="cp">#define net_device_entry(lh)	list_entry(lh, struct net_device, dev_list)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">next_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">lh</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lh</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_head</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">net_device_entry</span><span class="p">(</span><span class="n">lh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">next_net_device_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">lh</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">list_next_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">lh</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_head</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">net_device_entry</span><span class="p">(</span><span class="n">lh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">first_net_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_head</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span>
		<span class="n">net_device_entry</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_head</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">first_net_device_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">list_next_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_head</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">lh</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_head</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">net_device_entry</span><span class="p">(</span><span class="n">lh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> 			<span class="n">netdev_boot_setup_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">netdev_boot_base</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unit</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_getbyhwaddr_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hwaddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_getfirstbyhwtype</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">__dev_getfirstbyhwtype</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">dev_add_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">dev_remove_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">__dev_remove_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev_get_by_flags_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev_get_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev_get_by_name_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">__dev_get_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_alloc_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">dev_disable_lro</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">register_netdevice</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">unregister_netdevice_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">unregister_netdevice_many</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unregister_netdevice</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_netdevice_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> 		<span class="n">netdev_refcnt_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">free_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">synchronize_net</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">init_dummy_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">netdev_resync_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev_get_by_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">__dev_get_by_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev_get_by_index_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NETPOLL_TRAP</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netpoll_trap</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	       <span class="n">skb_gro_reset_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_gro_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_gro_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_gro_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">skb_gro_header_fast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_gro_header_hard</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0_len</span> <span class="o">&lt;</span> <span class="n">hlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">skb_gro_header_slow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hlen</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">skb_gro_mac_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0</span> <span class="o">?:</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">skb_gro_network_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0</span> <span class="o">?:</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span>
	       <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dev_hard_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dev_parse_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">haddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="o">-&gt;</span><span class="n">parse</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="o">-&gt;</span><span class="n">parse</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">haddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">gifconf_func_t</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">bufptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">register_gifconf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gifconf_func_t</span> <span class="o">*</span> <span class="n">gifconf</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unregister_gifconf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_gifconf</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Incoming packets are placed on per-cpu queues</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">softnet_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Qdisc</span>		<span class="o">*</span><span class="n">output_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Qdisc</span>		<span class="o">**</span><span class="n">output_queue_tailp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">poll_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">completion_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">process_queue</span><span class="p">;</span>

	<span class="cm">/* stats */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">processed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">time_squeeze</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cpu_collision</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">received_rps</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">struct</span> <span class="n">softnet_data</span>	<span class="o">*</span><span class="n">rps_ipi_list</span><span class="p">;</span>

	<span class="cm">/* Elements below can be accessed between CPUs for RPS */</span>
	<span class="k">struct</span> <span class="n">call_single_data</span>	<span class="n">csd</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">softnet_data</span>	<span class="o">*</span><span class="n">rps_ipi_next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cpu</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">input_queue_head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">input_queue_tail</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">dropped</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span>	<span class="n">input_pkt_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">napi_struct</span>	<span class="n">backlog</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_queue_head_incr</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_queue_head</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">input_queue_tail_incr_save</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">qtail</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="o">*</span><span class="n">qtail</span> <span class="o">=</span> <span class="o">++</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_queue_tail</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">DECLARE_PER_CPU_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span><span class="p">,</span> <span class="n">softnet_data</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__netif_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_schedule_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">QUEUE_STATE_ANY_XOFF</span><span class="p">))</span>
		<span class="n">__netif_schedule</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_schedule_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">netif_schedule_queue</span><span class="p">(</span><span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_DRV_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_start_queue - allow transmit</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> *	Allow upper layers to call the device hard_start_xmit routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_tx_start_queue</span><span class="p">(</span><span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_start_all_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">netif_tx_start_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_wake_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NETPOLL_TRAP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netpoll_trap</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">netif_tx_start_queue</span><span class="p">(</span><span class="n">dev_queue</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_DRV_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">__netif_schedule</span><span class="p">(</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_wake_queue - restart transmit</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> *	Allow upper layers to call the device hard_start_xmit routine.</span>
<span class="cm"> *	Used for flow control when transmit resources are available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_wake_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_tx_wake_queue</span><span class="p">(</span><span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_wake_all_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">netif_tx_wake_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;netif_stop_queue() cannot be called before register_netdev()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_DRV_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_stop_queue - stop transmitted packets</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> *	Stop upper layers calling the device hard_start_xmit routine.</span>
<span class="cm"> *	Used for flow control when transmit resources are unavailable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_stop_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_stop_all_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_tx_queue_stopped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_DRV_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_queue_stopped - test if transmit queue is flowblocked</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> *	Test if transmit queue on device is currently unable to send.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_queue_stopped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netif_tx_queue_stopped</span><span class="p">(</span><span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_xmit_stopped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">QUEUE_STATE_ANY_XOFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_xmit_frozen_or_stopped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">QUEUE_STATE_ANY_XOFF_OR_FROZEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_tx_sent_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BQL</span>
	<span class="n">dql_queued</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">dql</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dql_avail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">dql</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_STACK_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The XOFF flag must be set before checking the dql_avail below,</span>
<span class="cm">	 * because in netdev_tx_completed_queue we update the dql_completed</span>
<span class="cm">	 * before checking the XOFF flag.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* check again in case another CPU has just made room avail */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dql_avail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">dql</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_STACK_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_sent_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netdev_tx_sent_queue</span><span class="p">(</span><span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_tx_completed_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkts</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BQL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dql_completed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">dql</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Without the memory barrier there is a small possiblity that</span>
<span class="cm">	 * netdev_tx_sent_queue will miss the update and cause the queue to</span>
<span class="cm">	 * be stopped forever</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dql_avail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">dql</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_STACK_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_queue</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">netif_schedule_queue</span><span class="p">(</span><span class="n">dev_queue</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_completed_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkts</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netdev_tx_completed_queue</span><span class="p">(</span><span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">pkts</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_tx_reset_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_BQL</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_STACK_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">dql_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dql</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_reset_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netdev_tx_reset_queue</span><span class="p">(</span><span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev_queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_running - test if up</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> *	Test if the device has been brought up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_running</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">__LINK_STATE_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Routines to manage the subqueues on a device.  We only need start</span>
<span class="cm"> * stop, and a check if it&#39;s stopped.  All other device management is</span>
<span class="cm"> * done at the overall netdevice level.</span>
<span class="cm"> * Also test the device if we&#39;re multiqueue.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_start_subqueue - allow sending packets on subqueue</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *	@queue_index: sub queue index</span>
<span class="cm"> *</span>
<span class="cm"> * Start individual transmit queue of a device with multiple transmit queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_start_subqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">queue_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>

	<span class="n">netif_tx_start_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_stop_subqueue - stop sending packets on subqueue</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *	@queue_index: sub queue index</span>
<span class="cm"> *</span>
<span class="cm"> * Stop individual transmit queue of a device with multiple transmit queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_stop_subqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">queue_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NETPOLL_TRAP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netpoll_trap</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_subqueue_stopped - test status of subqueue</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *	@queue_index: sub queue index</span>
<span class="cm"> *</span>
<span class="cm"> * Check individual transmit queue of a device with multiple transmit queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__netif_subqueue_stopped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="n">u16</span> <span class="n">queue_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">netif_tx_queue_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_subqueue_stopped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__netif_subqueue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb_get_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_wake_subqueue - allow sending packets on subqueue</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *	@queue_index: sub queue index</span>
<span class="cm"> *</span>
<span class="cm"> * Resume individual transmit queue of a device with multiple transmit queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_wake_subqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">queue_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NETPOLL_TRAP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netpoll_trap</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_DRV_XOFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">__netif_schedule</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns a Tx hash for the given packet when dev-&gt;real_num_tx_queues is used</span>
<span class="cm"> * as a distribution range limit for the returned value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">skb_tx_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__skb_tx_hash</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_is_multiqueue - test if device has multiple transmit queues</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Check if device has multiple transmit queues</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_is_multiqueue</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txq</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RPS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxq</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">netif_copy_real_num_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">to_dev</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">from_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">to_dev</span><span class="p">,</span> <span class="n">from_dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">return</span> <span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">to_dev</span><span class="p">,</span>
					    <span class="n">from_dev</span><span class="o">-&gt;</span><span class="n">real_num_rx_queues</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Use this variant when it is known for sure that it</span>
<span class="cm"> * is executing from hardware interrupt context or with hardware interrupts</span>
<span class="cm"> * disabled.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/* Use this variant in places where it could be invoked</span>
<span class="cm"> * from either hardware interrupt or other context, with hardware interrupts</span>
<span class="cm"> * either disabled or enabled.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netif_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netif_rx_ni</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netif_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">gro_result_t</span>	<span class="n">dev_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">gro_result_t</span>	<span class="n">napi_skb_finish</span><span class="p">(</span><span class="n">gro_result_t</span> <span class="n">ret</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">gro_result_t</span>	<span class="n">napi_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">napi_gro_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span>	<span class="n">napi_get_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">gro_result_t</span>	<span class="n">napi_frags_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					  <span class="n">gro_result_t</span> <span class="n">ret</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">gro_result_t</span>	<span class="n">napi_gro_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">napi_free_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">netdev_rx_handler_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="n">rx_handler_func_t</span> <span class="o">*</span><span class="n">rx_handler</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">rx_handler_data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netdev_rx_handler_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span>		<span class="n">dev_valid_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_ethtool</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">dev_get_flags</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">__dev_change_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_change_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">__dev_notify_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_change_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_set_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_change_net_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_set_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">dev_set_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_hard_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_forward_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netdev_budget</span><span class="p">;</span>

<span class="cm">/* Called by rtnetlink.c:rtnl_unlock() */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netdev_run_todo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_put - release reference to device</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Release reference to device to allow it to be freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dev_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">this_cpu_dec</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcpu_refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_hold - get reference to device</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Hold reference to device to keep it from being freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dev_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">this_cpu_inc</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcpu_refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Carrier loss detection, dial on demand. The functions netif_carrier_on</span>
<span class="cm"> * and _off may be called from IRQ context, but it is caller</span>
<span class="cm"> * who is responsible for serialization of these calls.</span>
<span class="cm"> *</span>
<span class="cm"> * The name carrier is inappropriate, these functions should really be</span>
<span class="cm"> * called netif_lowerlayer_*() because they represent the state of any</span>
<span class="cm"> * kind of lower layer not just hardware media.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">linkwatch_fire_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">linkwatch_forget_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_carrier_ok - test if carrier present</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Check if carrier is present on device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_carrier_ok</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__LINK_STATE_NOCARRIER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_trans_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__netdev_watchdog_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">netif_carrier_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">netif_carrier_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">netif_notify_peers</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_dormant_on - mark device as dormant.</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Mark device as dormant (as per RFC2863).</span>
<span class="cm"> *</span>
<span class="cm"> * The dormant state indicates that the relevant interface is not</span>
<span class="cm"> * actually in a condition to pass packets (i.e., it is not &#39;up&#39;) but is</span>
<span class="cm"> * in a &quot;pending&quot; state, waiting for some external event.  For &quot;on-</span>
<span class="cm"> * demand&quot; interfaces, this new state identifies the situation where the</span>
<span class="cm"> * interface is waiting for events to place it in the up state.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_dormant_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__LINK_STATE_DORMANT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">linkwatch_fire_event</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_dormant_off - set device as not dormant.</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Device is not in dormant state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_dormant_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">__LINK_STATE_DORMANT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">linkwatch_fire_event</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_dormant - test if carrier present</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Check if carrier is present on device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_dormant</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">__LINK_STATE_DORMANT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	netif_oper_up - test if device is operational</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Check if carrier is operational</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_oper_up</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">operstate</span> <span class="o">==</span> <span class="n">IF_OPER_UP</span> <span class="o">||</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">operstate</span> <span class="o">==</span> <span class="n">IF_OPER_UNKNOWN</span> <span class="cm">/* backward compat */</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_device_present - is device available or removed</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Check if device has not been removed from system.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_device_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">__LINK_STATE_PRESENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">netif_device_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">netif_device_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Network interface message level settings</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NETIF_MSG_DRV</span>		<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">NETIF_MSG_PROBE</span>		<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">NETIF_MSG_LINK</span>		<span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">NETIF_MSG_TIMER</span>		<span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">NETIF_MSG_IFDOWN</span>	<span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="n">NETIF_MSG_IFUP</span>		<span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="n">NETIF_MSG_RX_ERR</span>	<span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>
	<span class="n">NETIF_MSG_TX_ERR</span>	<span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>
	<span class="n">NETIF_MSG_TX_QUEUED</span>	<span class="o">=</span> <span class="mh">0x0100</span><span class="p">,</span>
	<span class="n">NETIF_MSG_INTR</span>		<span class="o">=</span> <span class="mh">0x0200</span><span class="p">,</span>
	<span class="n">NETIF_MSG_TX_DONE</span>	<span class="o">=</span> <span class="mh">0x0400</span><span class="p">,</span>
	<span class="n">NETIF_MSG_RX_STATUS</span>	<span class="o">=</span> <span class="mh">0x0800</span><span class="p">,</span>
	<span class="n">NETIF_MSG_PKTDATA</span>	<span class="o">=</span> <span class="mh">0x1000</span><span class="p">,</span>
	<span class="n">NETIF_MSG_HW</span>		<span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>
	<span class="n">NETIF_MSG_WOL</span>		<span class="o">=</span> <span class="mh">0x4000</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define netif_msg_drv(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_DRV)</span>
<span class="cp">#define netif_msg_probe(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_PROBE)</span>
<span class="cp">#define netif_msg_link(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_LINK)</span>
<span class="cp">#define netif_msg_timer(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_TIMER)</span>
<span class="cp">#define netif_msg_ifdown(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_IFDOWN)</span>
<span class="cp">#define netif_msg_ifup(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_IFUP)</span>
<span class="cp">#define netif_msg_rx_err(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_RX_ERR)</span>
<span class="cp">#define netif_msg_tx_err(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_TX_ERR)</span>
<span class="cp">#define netif_msg_tx_queued(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_TX_QUEUED)</span>
<span class="cp">#define netif_msg_intr(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_INTR)</span>
<span class="cp">#define netif_msg_tx_done(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_TX_DONE)</span>
<span class="cp">#define netif_msg_rx_status(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_RX_STATUS)</span>
<span class="cp">#define netif_msg_pktdata(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_PKTDATA)</span>
<span class="cp">#define netif_msg_hw(p)		((p)-&gt;msg_enable &amp; NETIF_MSG_HW)</span>
<span class="cp">#define netif_msg_wol(p)	((p)-&gt;msg_enable &amp; NETIF_MSG_WOL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">netif_msg_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">debug_value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">default_msg_enable_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* use default */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">debug_value</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">default_msg_enable_bits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* no output */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* set low N bits */</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">debug_value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__netif_tx_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">_xmit_lock</span><span class="p">);</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__netif_tx_lock_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">_xmit_lock</span><span class="p">);</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__netif_tx_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">_xmit_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ok</span><span class="p">))</span>
		<span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ok</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__netif_tx_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">_xmit_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__netif_tx_unlock_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">_xmit_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">txq_trans_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">txq</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_tx_lock - grab network device transmit lock</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Get network device transmit lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_global_lock</span><span class="p">);</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* We are the only thread of execution doing a</span>
<span class="cm">		 * freeze, but we have to grab the _xmit_lock in</span>
<span class="cm">		 * order to synchronize with threads which are in</span>
<span class="cm">		 * the -&gt;hard_start_xmit() handler and already</span>
<span class="cm">		 * checked the frozen bit.</span>
<span class="cm">		 */</span>
		<span class="n">__netif_tx_lock</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_FROZEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">__netif_tx_unlock</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_lock_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">netif_tx_lock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* No need to grab the _xmit_lock here.  If the</span>
<span class="cm">		 * queue is not stopped for another reason, we</span>
<span class="cm">		 * force a schedule.</span>
<span class="cm">		 */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">__QUEUE_STATE_FROZEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">netif_schedule_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_global_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_unlock_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_tx_unlock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#define HARD_TX_LOCK(dev, txq, cpu) {			\</span>
<span class="cp">	if ((dev-&gt;features &amp; NETIF_F_LLTX) == 0) {	\</span>
<span class="cp">		__netif_tx_lock(txq, cpu);		\</span>
<span class="cp">	}						\</span>
<span class="cp">}</span>

<span class="cp">#define HARD_TX_UNLOCK(dev, txq) {			\</span>
<span class="cp">	if ((dev-&gt;features &amp; NETIF_F_LLTX) == 0) {	\</span>
<span class="cp">		__netif_tx_unlock(txq);			\</span>
<span class="cp">	}						\</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_tx_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">__netif_tx_lock</span><span class="p">(</span><span class="n">txq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="n">netif_tx_stop_queue</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
		<span class="n">__netif_tx_unlock</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_addr_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_addr_lock_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_list_lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_addr_lock_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_addr_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_addr_unlock_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dev_addrs walker. Should be used only for read access. Call with</span>
<span class="cm"> * rcu_read_lock held.</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_dev_addr(dev, ha) \</span>
<span class="cp">		list_for_each_entry_rcu(ha, &amp;dev-&gt;dev_addrs.list, list)</span>

<span class="cm">/* These functions live elsewhere (drivers/net/net_init.c, but related) */</span>

<span class="k">extern</span> <span class="kt">void</span>		<span class="n">ether_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* Support for loadable net-drivers */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">alloc_netdev_mqs</span><span class="p">(</span><span class="kt">int</span> <span class="n">sizeof_priv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">),</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txqs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxqs</span><span class="p">);</span>
<span class="cp">#define alloc_netdev(sizeof_priv, name, setup) \</span>
<span class="cp">	alloc_netdev_mqs(sizeof_priv, name, setup, 1, 1)</span>

<span class="cp">#define alloc_netdev_mq(sizeof_priv, name, setup, count) \</span>
<span class="cp">	alloc_netdev_mqs(sizeof_priv, name, setup, count, count)</span>

<span class="k">extern</span> <span class="kt">int</span>		<span class="n">register_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">unregister_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* General hardware address lists handling functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__hw_addr_add_multiple</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">to_list</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">from_list</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">addr_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__hw_addr_del_multiple</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">to_list</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">from_list</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">addr_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__hw_addr_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">to_list</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">from_list</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">addr_len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__hw_addr_unsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">to_list</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">from_list</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">addr_len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__hw_addr_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__hw_addr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>

<span class="cm">/* Functions used for device addresses handling */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_addr_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_addr_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_addr_add_multiple</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">to_dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">from_dev</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_addr_del_multiple</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">to_dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">from_dev</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">addr_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_addr_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_addr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* Functions used for unicast addresses handling */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_uc_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_uc_add_excl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_uc_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_uc_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_uc_unsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_uc_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_uc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* Functions used for multicast addresses handling */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_mc_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_mc_add_global</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_mc_add_excl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_mc_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_mc_del_global</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_mc_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_mc_unsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_mc_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_mc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* Functions used for secondary unicast and multicast support */</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">dev_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">__dev_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">dev_set_allmulti</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">netdev_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netdev_bonding_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">netdev_features_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cm">/* Load a device via the kmod */</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">dev_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">dev_mcast_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">dev_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">storage</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netdev_stats_to_stats64</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats64</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">netdev_stats</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netdev_max_backlog</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netdev_tstamp_prequeue</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">weight_p</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">bpf_jit_enable</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span>		<span class="n">netdev_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netdev_set_bond_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">skb_checksum_help</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_gso_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_BUG</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netdev_rx_csum_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_rx_csum_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cm">/* rx skb timestamps */</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">net_enable_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">net_disable_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dev_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">netdev_class_create_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">class_attr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netdev_class_remove_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">class_attr</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kobj_ns_type_operations</span> <span class="n">net_ns_type_operations</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">netdev_drivername</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">linkwatch_run_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">netdev_features_t</span> <span class="nf">netdev_get_wanted_features</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span><span class="p">)</span> <span class="o">|</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">wanted_features</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">netdev_features_t</span> <span class="n">netdev_increment_features</span><span class="p">(</span><span class="n">netdev_features_t</span> <span class="n">all</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">one</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__netdev_update_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">netdev_update_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">netdev_change_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">netif_stacked_transfer_operstate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">rootdev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="n">netdev_features_t</span> <span class="n">netif_skb_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">net_gso_ok</span><span class="p">(</span><span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gso_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netdev_features_t</span> <span class="n">feature</span> <span class="o">=</span> <span class="n">gso_type</span> <span class="o">&lt;&lt;</span> <span class="n">NETIF_F_GSO_SHIFT</span><span class="p">;</span>

	<span class="cm">/* check flags correspondence */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SKB_GSO_TCPV4</span>   <span class="o">!=</span> <span class="p">(</span><span class="n">NETIF_F_TSO</span> <span class="o">&gt;&gt;</span> <span class="n">NETIF_F_GSO_SHIFT</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SKB_GSO_UDP</span>     <span class="o">!=</span> <span class="p">(</span><span class="n">NETIF_F_UFO</span> <span class="o">&gt;&gt;</span> <span class="n">NETIF_F_GSO_SHIFT</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SKB_GSO_DODGY</span>   <span class="o">!=</span> <span class="p">(</span><span class="n">NETIF_F_GSO_ROBUST</span> <span class="o">&gt;&gt;</span> <span class="n">NETIF_F_GSO_SHIFT</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SKB_GSO_TCP_ECN</span> <span class="o">!=</span> <span class="p">(</span><span class="n">NETIF_F_TSO_ECN</span> <span class="o">&gt;&gt;</span> <span class="n">NETIF_F_GSO_SHIFT</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SKB_GSO_TCPV6</span>   <span class="o">!=</span> <span class="p">(</span><span class="n">NETIF_F_TSO6</span> <span class="o">&gt;&gt;</span> <span class="n">NETIF_F_GSO_SHIFT</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SKB_GSO_FCOE</span>    <span class="o">!=</span> <span class="p">(</span><span class="n">NETIF_F_FSO</span> <span class="o">&gt;&gt;</span> <span class="n">NETIF_F_GSO_SHIFT</span><span class="p">));</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">feature</span><span class="p">)</span> <span class="o">==</span> <span class="n">feature</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_gso_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">net_gso_ok</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="o">!</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_FRAGLIST</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_needs_gso</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_gso_ok</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">unlikely</span><span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netif_set_gso_max_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gso_max_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_is_bond_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_SLAVE</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_BONDING</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">netif_supports_nofcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_SUPP_NOFCS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">__net_initdata</span> <span class="n">loopback_net_ops</span><span class="p">;</span>

<span class="cm">/* Logging, debugging and troubleshooting/diagnostic helpers. */</span>

<span class="cm">/* netdev_printk helpers, similar to dev_printk */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">netdev_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">!=</span> <span class="n">NETREG_REGISTERED</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;(unregistered net_device)&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__netdev_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">va_format</span> <span class="o">*</span><span class="n">vaf</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">netdev_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">netdev_emerg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">netdev_alert</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">netdev_crit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">netdev_err</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">netdev_warn</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">netdev_notice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">netdev_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="cp">#define MODULE_ALIAS_NETDEV(device) \</span>
<span class="cp">	MODULE_ALIAS(&quot;netdev-&quot; device)</span>

<span class="cp">#if defined(CONFIG_DYNAMIC_DEBUG)</span>
<span class="cp">#define netdev_dbg(__dev, format, args...)			\</span>
<span class="cp">do {								\</span>
<span class="cp">	dynamic_netdev_dbg(__dev, format, ##args);		\</span>
<span class="cp">} while (0)</span>
<span class="cp">#elif defined(DEBUG)</span>
<span class="cp">#define netdev_dbg(__dev, format, args...)			\</span>
<span class="cp">	netdev_printk(KERN_DEBUG, __dev, format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define netdev_dbg(__dev, format, args...)			\</span>
<span class="cp">({								\</span>
<span class="cp">	if (0)							\</span>
<span class="cp">		netdev_printk(KERN_DEBUG, __dev, format, ##args); \</span>
<span class="cp">	0;							\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(VERBOSE_DEBUG)</span>
<span class="cp">#define netdev_vdbg	netdev_dbg</span>
<span class="cp">#else</span>

<span class="cp">#define netdev_vdbg(dev, format, args...)			\</span>
<span class="cp">({								\</span>
<span class="cp">	if (0)							\</span>
<span class="cp">		netdev_printk(KERN_DEBUG, dev, format, ##args);	\</span>
<span class="cp">	0;							\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * netdev_WARN() acts like dev_printk(), but with the key difference</span>
<span class="cm"> * of using a WARN/WARN_ON to get the message out, including the</span>
<span class="cm"> * file/line information and a backtrace.</span>
<span class="cm"> */</span>
<span class="cp">#define netdev_WARN(dev, format, args...)			\</span>
<span class="cp">	WARN(1, &quot;netdevice: %s\n&quot; format, netdev_name(dev), ##args);</span>

<span class="cm">/* netif printk helpers, similar to netdev_printk */</span>

<span class="cp">#define netif_printk(priv, type, level, dev, fmt, args...)	\</span>
<span class="cp">do {					  			\</span>
<span class="cp">	if (netif_msg_##type(priv))				\</span>
<span class="cp">		netdev_printk(level, (dev), fmt, ##args);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define netif_level(level, priv, type, dev, fmt, args...)	\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (netif_msg_##type(priv))				\</span>
<span class="cp">		netdev_##level(dev, fmt, ##args);		\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define netif_emerg(priv, type, dev, fmt, args...)		\</span>
<span class="cp">	netif_level(emerg, priv, type, dev, fmt, ##args)</span>
<span class="cp">#define netif_alert(priv, type, dev, fmt, args...)		\</span>
<span class="cp">	netif_level(alert, priv, type, dev, fmt, ##args)</span>
<span class="cp">#define netif_crit(priv, type, dev, fmt, args...)		\</span>
<span class="cp">	netif_level(crit, priv, type, dev, fmt, ##args)</span>
<span class="cp">#define netif_err(priv, type, dev, fmt, args...)		\</span>
<span class="cp">	netif_level(err, priv, type, dev, fmt, ##args)</span>
<span class="cp">#define netif_warn(priv, type, dev, fmt, args...)		\</span>
<span class="cp">	netif_level(warn, priv, type, dev, fmt, ##args)</span>
<span class="cp">#define netif_notice(priv, type, dev, fmt, args...)		\</span>
<span class="cp">	netif_level(notice, priv, type, dev, fmt, ##args)</span>
<span class="cp">#define netif_info(priv, type, dev, fmt, args...)		\</span>
<span class="cp">	netif_level(info, priv, type, dev, fmt, ##args)</span>

<span class="cp">#if defined(CONFIG_DYNAMIC_DEBUG)</span>
<span class="cp">#define netif_dbg(priv, type, netdev, format, args...)		\</span>
<span class="cp">do {								\</span>
<span class="cp">	if (netif_msg_##type(priv))				\</span>
<span class="cp">		dynamic_netdev_dbg(netdev, format, ##args);	\</span>
<span class="cp">} while (0)</span>
<span class="cp">#elif defined(DEBUG)</span>
<span class="cp">#define netif_dbg(priv, type, dev, format, args...)		\</span>
<span class="cp">	netif_printk(priv, type, KERN_DEBUG, dev, format, ##args)</span>
<span class="cp">#else</span>
<span class="cp">#define netif_dbg(priv, type, dev, format, args...)			\</span>
<span class="cp">({									\</span>
<span class="cp">	if (0)								\</span>
<span class="cp">		netif_printk(priv, type, KERN_DEBUG, dev, format, ##args); \</span>
<span class="cp">	0;								\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(VERBOSE_DEBUG)</span>
<span class="cp">#define netif_vdbg	netif_dbg</span>
<span class="cp">#else</span>
<span class="cp">#define netif_vdbg(priv, type, dev, format, args...)		\</span>
<span class="cp">({								\</span>
<span class="cp">	if (0)							\</span>
<span class="cp">		netif_printk(priv, type, KERN_DEBUG, dev, format, ##args); \</span>
<span class="cp">	0;							\</span>
<span class="cp">})</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* _LINUX_NETDEVICE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
