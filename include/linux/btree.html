<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › btree.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>btree.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef BTREE_H</span>
<span class="cp">#define BTREE_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * DOC: B+Tree basics</span>
<span class="cm"> *</span>
<span class="cm"> * A B+Tree is a data structure for looking up arbitrary (currently allowing</span>
<span class="cm"> * unsigned long, u32, u64 and 2 * u64) keys into pointers. The data structure</span>
<span class="cm"> * is described at http://en.wikipedia.org/wiki/B-tree, we currently do not</span>
<span class="cm"> * use binary search to find the key on lookups.</span>
<span class="cm"> *</span>
<span class="cm"> * Each B+Tree consists of a head, that contains bookkeeping information and</span>
<span class="cm"> * a variable number (starting with zero) nodes. Each node contains the keys</span>
<span class="cm"> * and pointers to sub-nodes, or, for leaf nodes, the keys and values for the</span>
<span class="cm"> * tree entries.</span>
<span class="cm"> *</span>
<span class="cm"> * Each node in this implementation has the following layout:</span>
<span class="cm"> * [key1, key2, ..., keyN] [val1, val2, ..., valN]</span>
<span class="cm"> *</span>
<span class="cm"> * Each key here is an array of unsigned longs, geo-&gt;no_longs in total. The</span>
<span class="cm"> * number of keys and values (N) is geo-&gt;no_pairs.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct btree_head - btree head</span>
<span class="cm"> *</span>
<span class="cm"> * @node: the first node in the tree</span>
<span class="cm"> * @mempool: mempool used for node allocations</span>
<span class="cm"> * @height: current of the tree</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">btree_head</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">mempool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* btree geometry */</span>
<span class="k">struct</span> <span class="n">btree_geo</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * btree_alloc - allocate function for the mempool</span>
<span class="cm"> * @gfp_mask: gfp mask for the allocation</span>
<span class="cm"> * @pool_data: unused</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">btree_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pool_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_free - free function for the mempool</span>
<span class="cm"> * @element: the element to free</span>
<span class="cm"> * @pool_data: unused</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">btree_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pool_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_init_mempool - initialise a btree with given mempool</span>
<span class="cm"> *</span>
<span class="cm"> * @head: the btree head to initialise</span>
<span class="cm"> * @mempool: the mempool to use</span>
<span class="cm"> *</span>
<span class="cm"> * When this function is used, there is no need to destroy</span>
<span class="cm"> * the mempool.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">btree_init_mempool</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">mempool</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_init - initialise a btree</span>
<span class="cm"> *</span>
<span class="cm"> * @head: the btree head to initialise</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates the memory pool that the</span>
<span class="cm"> * btree needs. Returns zero or a negative error code</span>
<span class="cm"> * (-%ENOMEM) when memory allocation fails.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">btree_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_destroy - destroy mempool</span>
<span class="cm"> *</span>
<span class="cm"> * @head: the btree head to destroy</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys the internal memory pool, use only</span>
<span class="cm"> * when using btree_init(), not with btree_init_mempool().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">btree_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_lookup - look up a key in the btree</span>
<span class="cm"> *</span>
<span class="cm"> * @head: the btree to look in</span>
<span class="cm"> * @geo: the btree geometry</span>
<span class="cm"> * @key: the key to look up</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the value for the given key, or %NULL.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">btree_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_insert - insert an entry into the btree</span>
<span class="cm"> *</span>
<span class="cm"> * @head: the btree to add to</span>
<span class="cm"> * @geo: the btree geometry</span>
<span class="cm"> * @key: the key to add (must not already be present)</span>
<span class="cm"> * @val: the value to add (must not be %NULL)</span>
<span class="cm"> * @gfp: allocation flags for node allocations</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if the item could be added, or an</span>
<span class="cm"> * error code if it failed (may fail due to memory pressure).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">btree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * btree_update - update an entry in the btree</span>
<span class="cm"> *</span>
<span class="cm"> * @head: the btree to update</span>
<span class="cm"> * @geo: the btree geometry</span>
<span class="cm"> * @key: the key to update</span>
<span class="cm"> * @val: the value to change it to (must not be %NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if the update was successful, or</span>
<span class="cm"> * -%ENOENT if the key could not be found.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">btree_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * btree_remove - remove an entry from the btree</span>
<span class="cm"> *</span>
<span class="cm"> * @head: the btree to update</span>
<span class="cm"> * @geo: the btree geometry</span>
<span class="cm"> * @key: the key to remove</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the removed entry, or %NULL if the key</span>
<span class="cm"> * could not be found.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">btree_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_merge - merge two btrees</span>
<span class="cm"> *</span>
<span class="cm"> * @target: the tree that gets all the entries</span>
<span class="cm"> * @victim: the tree that gets merged into @target</span>
<span class="cm"> * @geo: the btree geometry</span>
<span class="cm"> * @gfp: allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> * The two trees @target and @victim may not contain the same keys,</span>
<span class="cm"> * that is a bug and triggers a BUG(). This function returns zero</span>
<span class="cm"> * if the trees were merged successfully, and may return a failure</span>
<span class="cm"> * when memory allocation fails, in which case both trees might have</span>
<span class="cm"> * been partially merged, i.e. some entries have been moved from</span>
<span class="cm"> * @victim to @target.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">btree_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">victim</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_last - get last entry in btree</span>
<span class="cm"> *</span>
<span class="cm"> * @head: btree head</span>
<span class="cm"> * @geo: btree geometry</span>
<span class="cm"> * @key: last key</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the last entry in the btree, and sets @key to the key</span>
<span class="cm"> * of that entry; returns NULL if the tree is empty, in that case</span>
<span class="cm"> * key is not changed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">btree_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * btree_get_prev - get previous entry</span>
<span class="cm"> *</span>
<span class="cm"> * @head: btree head</span>
<span class="cm"> * @geo: btree geometry</span>
<span class="cm"> * @key: pointer to key</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns the next item right before the value pointed to by</span>
<span class="cm"> * @key, and updates @key with its key, or returns %NULL when there is no</span>
<span class="cm"> * entry with a key smaller than the given key.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">btree_get_prev</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>


<span class="cm">/* internal use, use btree_visitor{l,32,64,128} */</span>
<span class="kt">size_t</span> <span class="n">btree_visitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">elem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">func2</span><span class="p">),</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">func2</span><span class="p">);</span>

<span class="cm">/* internal use, use btree_grim_visitor{l,32,64,128} */</span>
<span class="kt">size_t</span> <span class="n">btree_grim_visitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">btree_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">elem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">func2</span><span class="p">),</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">func2</span><span class="p">);</span>


<span class="cp">#include &lt;linux/btree-128.h&gt;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="n">btree_geo32</span><span class="p">;</span>
<span class="cp">#define BTREE_TYPE_SUFFIX l</span>
<span class="cp">#define BTREE_TYPE_BITS BITS_PER_LONG</span>
<span class="cp">#define BTREE_TYPE_GEO &amp;btree_geo32</span>
<span class="cp">#define BTREE_KEYTYPE unsigned long</span>
<span class="cp">#include &lt;linux/btree-type.h&gt;</span>

<span class="cp">#define btree_for_each_safel(head, key, val)	\</span>
<span class="cp">	for (val = btree_lastl(head, &amp;key);	\</span>
<span class="cp">	     val;				\</span>
<span class="cp">	     val = btree_get_prevl(head, &amp;key))</span>

<span class="cp">#define BTREE_TYPE_SUFFIX 32</span>
<span class="cp">#define BTREE_TYPE_BITS 32</span>
<span class="cp">#define BTREE_TYPE_GEO &amp;btree_geo32</span>
<span class="cp">#define BTREE_KEYTYPE u32</span>
<span class="cp">#include &lt;linux/btree-type.h&gt;</span>

<span class="cp">#define btree_for_each_safe32(head, key, val)	\</span>
<span class="cp">	for (val = btree_last32(head, &amp;key);	\</span>
<span class="cp">	     val;				\</span>
<span class="cp">	     val = btree_get_prev32(head, &amp;key))</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">btree_geo</span> <span class="n">btree_geo64</span><span class="p">;</span>
<span class="cp">#define BTREE_TYPE_SUFFIX 64</span>
<span class="cp">#define BTREE_TYPE_BITS 64</span>
<span class="cp">#define BTREE_TYPE_GEO &amp;btree_geo64</span>
<span class="cp">#define BTREE_KEYTYPE u64</span>
<span class="cp">#include &lt;linux/btree-type.h&gt;</span>

<span class="cp">#define btree_for_each_safe64(head, key, val)	\</span>
<span class="cp">	for (val = btree_last64(head, &amp;key);	\</span>
<span class="cp">	     val;				\</span>
<span class="cp">	     val = btree_get_prev64(head, &amp;key))</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
