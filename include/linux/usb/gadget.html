<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › usb › gadget.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>gadget.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * &lt;linux/usb/gadget.h&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * We call the USB code inside a Linux-based peripheral device a &quot;gadget&quot;</span>
<span class="cm"> * driver, except for the hardware-specific bus glue.  One USB host can</span>
<span class="cm"> * master many USB gadgets, but the gadgets are only slaved to one host.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2002-2004 by David Brownell</span>
<span class="cm"> * All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is licensed under the GNU GPL version 2.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_USB_GADGET_H</span>
<span class="cp">#define __LINUX_USB_GADGET_H</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>

<span class="k">struct</span> <span class="n">usb_ep</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_request - describes one i/o request</span>
<span class="cm"> * @buf: Buffer used for data.  Always provide this; some controllers</span>
<span class="cm"> *	only use PIO, or don&#39;t use DMA for some endpoints.</span>
<span class="cm"> * @dma: DMA address corresponding to &#39;buf&#39;.  If you don&#39;t set this</span>
<span class="cm"> *	field, and the usb controller needs one, it is responsible</span>
<span class="cm"> *	for mapping and unmapping the buffer.</span>
<span class="cm"> * @sg: a scatterlist for SG-capable controllers.</span>
<span class="cm"> * @num_sgs: number of SG entries</span>
<span class="cm"> * @num_mapped_sgs: number of SG entries mapped to DMA (internal)</span>
<span class="cm"> * @length: Length of that data</span>
<span class="cm"> * @stream_id: The stream id, when USB3.0 bulk streams are being used</span>
<span class="cm"> * @no_interrupt: If true, hints that no completion irq is needed.</span>
<span class="cm"> *	Helpful sometimes with deep request queues that are handled</span>
<span class="cm"> *	directly by DMA controllers.</span>
<span class="cm"> * @zero: If true, when writing data, makes the last packet be &quot;short&quot;</span>
<span class="cm"> *     by adding a zero length packet as needed;</span>
<span class="cm"> * @short_not_ok: When reading data, makes short packets be</span>
<span class="cm"> *     treated as errors (queue stops advancing till cleanup).</span>
<span class="cm"> * @complete: Function called when request completes, so this request and</span>
<span class="cm"> *	its buffer may be re-used.  The function will always be called with</span>
<span class="cm"> *	interrupts disabled, and it must not sleep.</span>
<span class="cm"> *	Reads terminate with a short packet, or when the buffer fills,</span>
<span class="cm"> *	whichever comes first.  When writes terminate, some data bytes</span>
<span class="cm"> *	will usually still be in flight (often in a hardware fifo).</span>
<span class="cm"> *	Errors (for reads or writes) stop the queue from advancing</span>
<span class="cm"> *	until the completion function returns, so that any transfers</span>
<span class="cm"> *	invalidated by the error may first be dequeued.</span>
<span class="cm"> * @context: For use by the completion callback</span>
<span class="cm"> * @list: For use by the gadget driver.</span>
<span class="cm"> * @status: Reports completion code, zero or a negative errno.</span>
<span class="cm"> *	Normally, faults block the transfer queue from advancing until</span>
<span class="cm"> *	the completion callback returns.</span>
<span class="cm"> *	Code &quot;-ESHUTDOWN&quot; indicates completion caused by device disconnect,</span>
<span class="cm"> *	or when the driver disabled the endpoint.</span>
<span class="cm"> * @actual: Reports bytes transferred to/from the buffer.  For reads (OUT</span>
<span class="cm"> *	transfers) this may be less than the requested length.  If the</span>
<span class="cm"> *	short_not_ok flag is set, short reads are treated as errors</span>
<span class="cm"> *	even when status otherwise indicates successful completion.</span>
<span class="cm"> *	Note that for writes (IN transfers) some data bytes may still</span>
<span class="cm"> *	reside in a device-side FIFO when the request is reported as</span>
<span class="cm"> *	complete.</span>
<span class="cm"> *</span>
<span class="cm"> * These are allocated/freed through the endpoint they&#39;re used with.  The</span>
<span class="cm"> * hardware&#39;s driver can add extra per-request data to the memory it returns,</span>
<span class="cm"> * which often avoids separate memory allocations (potential failures),</span>
<span class="cm"> * later when the request is queued.</span>
<span class="cm"> *</span>
<span class="cm"> * Request flags affect request handling, such as whether a zero length</span>
<span class="cm"> * packet is written (the &quot;zero&quot; flag), whether a short read should be</span>
<span class="cm"> * treated as an error (blocking request queue advance, the &quot;short_not_ok&quot;</span>
<span class="cm"> * flag), or hinting that an interrupt is not required (the &quot;no_interrupt&quot;</span>
<span class="cm"> * flag, for use with deep request queues).</span>
<span class="cm"> *</span>
<span class="cm"> * Bulk endpoints can use any size buffers, and can also be used for interrupt</span>
<span class="cm"> * transfers. interrupt-only endpoints can be much less functional.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  this is analogous to &#39;struct urb&#39; on the host side, except that</span>
<span class="cm"> * it&#39;s thinner and promotes more pre-allocation.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">usb_request</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">length</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">dma</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">num_sgs</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">num_mapped_sgs</span><span class="p">;</span>

	<span class="kt">unsigned</span>		<span class="n">stream_id</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">no_interrupt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">zero</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">short_not_ok</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">actual</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* endpoint-specific parts of the api to the usb controller hardware.</span>
<span class="cm"> * unlike the urb model, (de)multiplexing layers are not required.</span>
<span class="cm"> * (so this api could slash overhead if used on the host side...)</span>
<span class="cm"> *</span>
<span class="cm"> * note that device side usb controllers commonly differ in how many</span>
<span class="cm"> * endpoints they support, as well as their capabilities.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_ep_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">disable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_request</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_request</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dequeue</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_halt</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_wedge</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fifo_status</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fifo_flush</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_ep - device side representation of USB endpoint</span>
<span class="cm"> * @name:identifier for the endpoint, such as &quot;ep-a&quot; or &quot;ep9in-bulk&quot;</span>
<span class="cm"> * @ops: Function pointers used to access hardware-specific operations.</span>
<span class="cm"> * @ep_list:the gadget&#39;s ep_list holds all of its endpoints</span>
<span class="cm"> * @maxpacket:The maximum packet size used on this endpoint.  The initial</span>
<span class="cm"> *	value can sometimes be reduced (hardware allowing), according to</span>
<span class="cm"> *      the endpoint descriptor used to configure the endpoint.</span>
<span class="cm"> * @max_streams: The maximum number of streams supported</span>
<span class="cm"> *	by this EP (0 - 16, actual number is 2^n)</span>
<span class="cm"> * @mult: multiplier, &#39;mult&#39; value for SS Isoc EPs</span>
<span class="cm"> * @maxburst: the maximum number of bursts supported by this EP (for usb3)</span>
<span class="cm"> * @driver_data:for use by the gadget driver.</span>
<span class="cm"> * @address: used to identify the endpoint when finding descriptor that</span>
<span class="cm"> *	matches connection speed</span>
<span class="cm"> * @desc: endpoint descriptor.  This pointer is set before the endpoint is</span>
<span class="cm"> *	enabled and remains valid until the endpoint is disabled.</span>
<span class="cm"> * @comp_desc: In case of SuperSpeed support, this is the endpoint companion</span>
<span class="cm"> *	descriptor that is used to configure the endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * the bus controller driver lists all the general purpose endpoints in</span>
<span class="cm"> * gadget-&gt;ep_list.  the control endpoint (gadget-&gt;ep0) is not in that list,</span>
<span class="cm"> * and is accessed only in response to a driver setup() callback.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_ep</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ep_ops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ep_list</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">maxpacket</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">max_streams</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">mult</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">maxburst</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">address</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ss_ep_comp_descriptor</span>	<span class="o">*</span><span class="n">comp_desc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_enable - configure endpoint, making it usable</span>
<span class="cm"> * @ep:the endpoint being configured.  may not be the endpoint named &quot;ep0&quot;.</span>
<span class="cm"> *	drivers discover endpoints through the ep_list of a usb_gadget.</span>
<span class="cm"> *</span>
<span class="cm"> * When configurations are set, or when interface settings change, the driver</span>
<span class="cm"> * will enable or disable the relevant endpoints.  while it is enabled, an</span>
<span class="cm"> * endpoint may be used for i/o until the driver receives a disconnect() from</span>
<span class="cm"> * the host or until the endpoint is disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * the ep0 implementation (which calls this routine) must ensure that the</span>
<span class="cm"> * hardware capabilities of each endpoint match the descriptor provided</span>
<span class="cm"> * for it.  for example, an endpoint named &quot;ep2in-bulk&quot; would be usable</span>
<span class="cm"> * for interrupt transfers as well as bulk, but it likely couldn&#39;t be used</span>
<span class="cm"> * for iso transfers or for endpoint 14.  some endpoints are fully</span>
<span class="cm"> * configurable, with more generic names like &quot;ep-a&quot;.  (remember that for</span>
<span class="cm"> * USB, &quot;in&quot; means &quot;towards the USB master&quot;.)</span>
<span class="cm"> *</span>
<span class="cm"> * returns zero, or a negative error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_ep_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_disable - endpoint is no longer usable</span>
<span class="cm"> * @ep:the endpoint being unconfigured.  may not be the endpoint named &quot;ep0&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * no other task may be using this endpoint when this is called.</span>
<span class="cm"> * any pending and uncompleted requests will complete with status</span>
<span class="cm"> * indicating disconnect (-ESHUTDOWN) before this call returns.</span>
<span class="cm"> * gadget drivers must call usb_ep_enable() again before queueing</span>
<span class="cm"> * requests to the endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * returns zero, or a negative error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_ep_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disable</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_alloc_request - allocate a request object to use with this endpoint</span>
<span class="cm"> * @ep:the endpoint to be used with with the request</span>
<span class="cm"> * @gfp_flags:GFP_* flags to use</span>
<span class="cm"> *</span>
<span class="cm"> * Request objects must be allocated with this call, since they normally</span>
<span class="cm"> * need controller-specific setup and may even need endpoint-specific</span>
<span class="cm"> * resources such as allocation of DMA descriptors.</span>
<span class="cm"> * Requests may be submitted with usb_ep_queue(), and receive a single</span>
<span class="cm"> * completion callback.  Free requests with usb_ep_free_request(), when</span>
<span class="cm"> * they are no longer needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the request, or null if one could not be allocated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="nf">usb_ep_alloc_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
						       <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">alloc_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_free_request - frees a request object</span>
<span class="cm"> * @ep:the endpoint associated with the request</span>
<span class="cm"> * @req:the request being freed</span>
<span class="cm"> *</span>
<span class="cm"> * Reverses the effect of usb_ep_alloc_request().</span>
<span class="cm"> * Caller guarantees the request is not queued, and that it will</span>
<span class="cm"> * no longer be requeued (or otherwise used).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_ep_free_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">free_request</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_queue - queues (submits) an I/O request to an endpoint.</span>
<span class="cm"> * @ep:the endpoint associated with the request</span>
<span class="cm"> * @req:the request being submitted</span>
<span class="cm"> * @gfp_flags: GFP_* flags to use in case the lower level driver couldn&#39;t</span>
<span class="cm"> *	pre-allocate all necessary memory with the request.</span>
<span class="cm"> *</span>
<span class="cm"> * This tells the device controller to perform the specified request through</span>
<span class="cm"> * that endpoint (reading or writing a buffer).  When the request completes,</span>
<span class="cm"> * including being canceled by usb_ep_dequeue(), the request&#39;s completion</span>
<span class="cm"> * routine is called to return the request to the driver.  Any endpoint</span>
<span class="cm"> * (except control endpoints like ep0) may have more than one transfer</span>
<span class="cm"> * request queued; they complete in FIFO order.  Once a gadget driver</span>
<span class="cm"> * submits a request, that request may not be examined or modified until it</span>
<span class="cm"> * is given back to that driver through the completion callback.</span>
<span class="cm"> *</span>
<span class="cm"> * Each request is turned into one or more packets.  The controller driver</span>
<span class="cm"> * never merges adjacent requests into the same packet.  OUT transfers</span>
<span class="cm"> * will sometimes use data that&#39;s already buffered in the hardware.</span>
<span class="cm"> * Drivers can rely on the fact that the first byte of the request&#39;s buffer</span>
<span class="cm"> * always corresponds to the first byte of some USB packet, for both</span>
<span class="cm"> * IN and OUT transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * Bulk endpoints can queue any amount of data; the transfer is packetized</span>
<span class="cm"> * automatically.  The last packet will be short if the request doesn&#39;t fill it</span>
<span class="cm"> * out completely.  Zero length packets (ZLPs) should be avoided in portable</span>
<span class="cm"> * protocols since not all usb hardware can successfully handle zero length</span>
<span class="cm"> * packets.  (ZLPs may be explicitly written, and may be implicitly written if</span>
<span class="cm"> * the request &#39;zero&#39; flag is set.)  Bulk endpoints may also be used</span>
<span class="cm"> * for interrupt transfers; but the reverse is not true, and some endpoints</span>
<span class="cm"> * won&#39;t support every interrupt transfer.  (Such as 768 byte packets.)</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt-only endpoints are less functional than bulk endpoints, for</span>
<span class="cm"> * example by not supporting queueing or not handling buffers that are</span>
<span class="cm"> * larger than the endpoint&#39;s maxpacket size.  They may also treat data</span>
<span class="cm"> * toggle differently.</span>
<span class="cm"> *</span>
<span class="cm"> * Control endpoints ... after getting a setup() callback, the driver queues</span>
<span class="cm"> * one response (even if it would be zero length).  That enables the</span>
<span class="cm"> * status ack, after transferring data as specified in the response.  Setup</span>
<span class="cm"> * functions may return negative error codes to generate protocol stalls.</span>
<span class="cm"> * (Note that some USB device controllers disallow protocol stall responses</span>
<span class="cm"> * in some cases.)  When control responses are deferred (the response is</span>
<span class="cm"> * written after the setup callback returns), then usb_ep_set_halt() may be</span>
<span class="cm"> * used on ep0 to trigger protocol stalls.  Depending on the controller,</span>
<span class="cm"> * it may not be possible to trigger a status-stage protocol stall when the</span>
<span class="cm"> * data stage is over, that is, from within the response&#39;s completion</span>
<span class="cm"> * routine.</span>
<span class="cm"> *</span>
<span class="cm"> * For periodic endpoints, like interrupt or isochronous ones, the usb host</span>
<span class="cm"> * arranges to poll once per interval, and the gadget driver usually will</span>
<span class="cm"> * have queued some data to transfer at that time.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero, or a negative error code.  Endpoints that are not enabled</span>
<span class="cm"> * report errors; errors will also be</span>
<span class="cm"> * reported when the usb peripheral is disconnected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_ep_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_dequeue - dequeues (cancels, unlinks) an I/O request from an endpoint</span>
<span class="cm"> * @ep:the endpoint associated with the request</span>
<span class="cm"> * @req:the request being canceled</span>
<span class="cm"> *</span>
<span class="cm"> * if the request is still active on the endpoint, it is dequeued and its</span>
<span class="cm"> * completion routine is called (with status -ECONNRESET); else a negative</span>
<span class="cm"> * error code is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * note that some hardware can&#39;t clear out write fifos (to unlink the request</span>
<span class="cm"> * at the head of the queue) except as part of disconnecting from usb.  such</span>
<span class="cm"> * restrictions prevent drivers from supporting configuration changes,</span>
<span class="cm"> * even to configuration zero (a &quot;chapter 9&quot; requirement).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_ep_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_set_halt - sets the endpoint halt feature.</span>
<span class="cm"> * @ep: the non-isochronous endpoint being stalled</span>
<span class="cm"> *</span>
<span class="cm"> * Use this to stall an endpoint, perhaps as an error report.</span>
<span class="cm"> * Except for control endpoints,</span>
<span class="cm"> * the endpoint stays halted (will not stream any data) until the host</span>
<span class="cm"> * clears this feature; drivers may need to empty the endpoint&#39;s request</span>
<span class="cm"> * queue first, to make sure no inappropriate transfers happen.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that while an endpoint CLEAR_FEATURE will be invisible to the</span>
<span class="cm"> * gadget driver, a SET_INTERFACE will not be.  To reset endpoints for the</span>
<span class="cm"> * current altsetting, see usb_ep_clear_halt().  When switching altsettings,</span>
<span class="cm"> * it&#39;s simplest to use usb_ep_enable() or usb_ep_disable() for the endpoints.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero, or a negative error code.  On success, this call sets</span>
<span class="cm"> * underlying hardware state that blocks data transfers.</span>
<span class="cm"> * Attempts to halt IN endpoints will fail (returning -EAGAIN) if any</span>
<span class="cm"> * transfer requests are still queued, or if the controller hardware</span>
<span class="cm"> * (usually a FIFO) still holds bytes that the host hasn&#39;t collected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_ep_set_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_halt</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_clear_halt - clears endpoint halt, and resets toggle</span>
<span class="cm"> * @ep:the bulk or interrupt endpoint being reset</span>
<span class="cm"> *</span>
<span class="cm"> * Use this when responding to the standard usb &quot;set interface&quot; request,</span>
<span class="cm"> * for endpoints that aren&#39;t reconfigured, after clearing any other state</span>
<span class="cm"> * in the endpoint&#39;s i/o queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero, or a negative error code.  On success, this call clears</span>
<span class="cm"> * the underlying hardware state reflecting endpoint halt and data toggle.</span>
<span class="cm"> * Note that some hardware can&#39;t support this request (like pxa2xx_udc),</span>
<span class="cm"> * and accordingly can&#39;t correctly implement interface altsettings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_ep_clear_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_halt</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_set_wedge - sets the halt feature and ignores clear requests</span>
<span class="cm"> * @ep: the endpoint being wedged</span>
<span class="cm"> *</span>
<span class="cm"> * Use this to stall an endpoint and ignore CLEAR_FEATURE(HALT_ENDPOINT)</span>
<span class="cm"> * requests. If the gadget driver clears the halt status, it will</span>
<span class="cm"> * automatically unwedge the endpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">usb_ep_set_wedge</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_wedge</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_wedge</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_halt</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_fifo_status - returns number of bytes in fifo, or error</span>
<span class="cm"> * @ep: the endpoint whose fifo status is being checked.</span>
<span class="cm"> *</span>
<span class="cm"> * FIFO endpoints may have &quot;unclaimed data&quot; in them in certain cases,</span>
<span class="cm"> * such as after aborted transfers.  Hosts may not have collected all</span>
<span class="cm"> * the IN data written by the gadget driver (and reported by a request</span>
<span class="cm"> * completion).  The gadget driver may not have collected all the data</span>
<span class="cm"> * written OUT to it by the host.  Drivers that need precise handling for</span>
<span class="cm"> * fault reporting or recovery may need to use this call.</span>
<span class="cm"> *</span>
<span class="cm"> * This returns the number of such bytes in the fifo, or a negative</span>
<span class="cm"> * errno if the endpoint doesn&#39;t use a FIFO or doesn&#39;t support such</span>
<span class="cm"> * precise handling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_ep_fifo_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">fifo_status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">fifo_status</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_ep_fifo_flush - flushes contents of a fifo</span>
<span class="cm"> * @ep: the endpoint whose fifo is being flushed.</span>
<span class="cm"> *</span>
<span class="cm"> * This call may be used to flush the &quot;unclaimed data&quot; that may exist in</span>
<span class="cm"> * an endpoint fifo after abnormal transaction terminations.  The call</span>
<span class="cm"> * must never be used except when endpoint is not being used for any</span>
<span class="cm"> * protocol translation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_ep_fifo_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">fifo_flush</span><span class="p">)</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">fifo_flush</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">struct</span> <span class="n">usb_dcd_config_params</span> <span class="p">{</span>
	<span class="n">__u8</span>  <span class="n">bU1devExitLat</span><span class="p">;</span>	<span class="cm">/* U1 Device exit Latency */</span>
<span class="cp">#define USB_DEFAULT_U1_DEV_EXIT_LAT	0x01	</span><span class="cm">/* Less then 1 microsec */</span><span class="cp"></span>
	<span class="n">__le16</span> <span class="n">bU2DevExitLat</span><span class="p">;</span>	<span class="cm">/* U2 Device exit Latency */</span>
<span class="cp">#define USB_DEFAULT_U2_DEV_EXIT_LAT	0x1F4	</span><span class="cm">/* Less then 500 microsec */</span><span class="cp"></span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">usb_gadget</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">usb_gadget_driver</span><span class="p">;</span>

<span class="cm">/* the rest of the api to the controller hardware: device operations,</span>
<span class="cm"> * which don&#39;t involve endpoints (or i/o).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_gadget_ops</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_frame</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">wakeup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_selfpowered</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_selfpowered</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">vbus_session</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_active</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">vbus_draw</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mA</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">pullup</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_on</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_config_params</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_dcd_config_params</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">udc_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">udc_stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Those two are deprecated */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">));</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_gadget - represents a usb slave device</span>
<span class="cm"> * @ops: Function pointers used to access hardware-specific operations.</span>
<span class="cm"> * @ep0: Endpoint zero, used when reading or writing responses to</span>
<span class="cm"> *	driver setup() requests</span>
<span class="cm"> * @ep_list: List of other endpoints supported by the device.</span>
<span class="cm"> * @speed: Speed of current connection to USB host.</span>
<span class="cm"> * @max_speed: Maximal speed the UDC can handle.  UDC must support this</span>
<span class="cm"> *      and all slower speeds.</span>
<span class="cm"> * @sg_supported: true if we can handle scatter-gather</span>
<span class="cm"> * @is_otg: True if the USB device port uses a Mini-AB jack, so that the</span>
<span class="cm"> *	gadget driver must provide a USB OTG descriptor.</span>
<span class="cm"> * @is_a_peripheral: False unless is_otg, the &quot;A&quot; end of a USB cable</span>
<span class="cm"> *	is in the Mini-AB jack, and HNP has been used to switch roles</span>
<span class="cm"> *	so that the &quot;A&quot; device currently acts as A-Peripheral, not A-Host.</span>
<span class="cm"> * @a_hnp_support: OTG device feature flag, indicating that the A-Host</span>
<span class="cm"> *	supports HNP at this port.</span>
<span class="cm"> * @a_alt_hnp_support: OTG device feature flag, indicating that the A-Host</span>
<span class="cm"> *	only supports HNP on a different root port.</span>
<span class="cm"> * @b_hnp_enable: OTG device feature flag, indicating that the A-Host</span>
<span class="cm"> *	enabled HNP support.</span>
<span class="cm"> * @name: Identifies the controller hardware type.  Used in diagnostics</span>
<span class="cm"> *	and sometimes configuration.</span>
<span class="cm"> * @dev: Driver model state for this abstract device.</span>
<span class="cm"> *</span>
<span class="cm"> * Gadgets have a mostly-portable &quot;gadget driver&quot; implementing device</span>
<span class="cm"> * functions, handling all usb configurations and interfaces.  Gadget</span>
<span class="cm"> * drivers talk to hardware-specific code indirectly, through ops vectors.</span>
<span class="cm"> * That insulates the gadget driver from hardware details, and packages</span>
<span class="cm"> * the hardware endpoints through generic i/o queues.  The &quot;usb_gadget&quot;</span>
<span class="cm"> * and &quot;usb_ep&quot; interfaces provide that insulation from the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * Except for the driver data, all fields in this structure are</span>
<span class="cm"> * read-only to the gadget driver.  That driver data is part of the</span>
<span class="cm"> * &quot;driver model&quot; infrastructure in 2.6 (and later) kernels, and for</span>
<span class="cm"> * earlier systems is grouped in a similar structure that&#39;s not known</span>
<span class="cm"> * to the rest of the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Values of the three OTG device feature flags are updated before the</span>
<span class="cm"> * setup() call corresponding to USB_REQ_SET_CONFIGURATION, and before</span>
<span class="cm"> * driver suspend() calls.  They are valid only when is_otg, and when the</span>
<span class="cm"> * device is acting as a B-Peripheral (so is_a_peripheral is false).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_gadget</span> <span class="p">{</span>
	<span class="cm">/* readonly to gadget driver */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_gadget_ops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ep</span>			<span class="o">*</span><span class="n">ep0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">ep_list</span><span class="p">;</span>	<span class="cm">/* of usb_ep */</span>
	<span class="k">enum</span> <span class="n">usb_device_speed</span>		<span class="n">speed</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_device_speed</span>		<span class="n">max_speed</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">sg_supported</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">is_otg</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">is_a_peripheral</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">b_hnp_enable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">a_hnp_support</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">a_alt_hnp_support</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>			<span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_gadget_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
	<span class="p">{</span> <span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_gadget_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
	<span class="p">{</span> <span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="nf">dev_to_usb_gadget</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_gadget</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* iterates the non-control endpoints; &#39;tmp&#39; is a struct usb_ep pointer */</span>
<span class="cp">#define gadget_for_each_ep(tmp, gadget) \</span>
<span class="cp">	list_for_each_entry(tmp, &amp;(gadget)-&gt;ep_list, ep_list)</span>


<span class="cm">/**</span>
<span class="cm"> * gadget_is_dualspeed - return true iff the hardware handles high speed</span>
<span class="cm"> * @g: controller that might support both high and full speeds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">gadget_is_dualspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_USB_GADGET_DUALSPEED</span>
	<span class="cm">/* runtime test would check &quot;g-&gt;max_speed&quot; ... that might be</span>
<span class="cm">	 * useful to work around hardware bugs, but is mostly pointless</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gadget_is_superspeed() - return true if the hardware handles</span>
<span class="cm"> * supperspeed</span>
<span class="cm"> * @g: controller that might support supper speed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">gadget_is_superspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_USB_GADGET_SUPERSPEED</span>
	<span class="cm">/*</span>
<span class="cm">	 * runtime test would check &quot;g-&gt;max_speed&quot; ... that might be</span>
<span class="cm">	 * useful to work around hardware bugs, but is mostly pointless</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gadget_is_otg - return true iff the hardware is OTG-ready</span>
<span class="cm"> * @g: controller that might have a Mini-AB connector</span>
<span class="cm"> *</span>
<span class="cm"> * This is a runtime test, since kernels with a USB-OTG stack sometimes</span>
<span class="cm"> * run on boards which only have a Mini-B (or Mini-A) connector.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">gadget_is_otg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_USB_OTG</span>
	<span class="k">return</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">is_otg</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_frame_number - returns the current frame number</span>
<span class="cm"> * @gadget: controller that reports the frame number</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the usb frame number, normally eleven bits from a SOF packet,</span>
<span class="cm"> * or negative errno if this device doesn&#39;t support this capability.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_frame_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_frame</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_wakeup - tries to wake up the host connected to this gadget</span>
<span class="cm"> * @gadget: controller used to wake up the host</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative error code if the hardware</span>
<span class="cm"> * doesn&#39;t support such attempts, or its support has not been enabled</span>
<span class="cm"> * by the usb host.  Drivers must return device descriptors that report</span>
<span class="cm"> * their ability to support this, or hosts won&#39;t enable it.</span>
<span class="cm"> *</span>
<span class="cm"> * This may also try to use SRP to wake the host and start enumeration,</span>
<span class="cm"> * even if OTG isn&#39;t otherwise in use.  OTG devices may also start</span>
<span class="cm"> * remote wakeup even when hosts don&#39;t explicitly enable it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">wakeup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">wakeup</span><span class="p">(</span><span class="n">gadget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_set_selfpowered - sets the device selfpowered feature.</span>
<span class="cm"> * @gadget:the device being declared as self-powered</span>
<span class="cm"> *</span>
<span class="cm"> * this affects the device status reported by the hardware driver</span>
<span class="cm"> * to reflect that it now has a local power supply.</span>
<span class="cm"> *</span>
<span class="cm"> * returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_set_selfpowered</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_selfpowered</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_selfpowered</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_clear_selfpowered - clear the device selfpowered feature.</span>
<span class="cm"> * @gadget:the device being declared as bus-powered</span>
<span class="cm"> *</span>
<span class="cm"> * this affects the device status reported by the hardware driver.</span>
<span class="cm"> * some hardware may not support bus-powered operation, in which</span>
<span class="cm"> * case this feature&#39;s value can never change.</span>
<span class="cm"> *</span>
<span class="cm"> * returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_clear_selfpowered</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_selfpowered</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_selfpowered</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_vbus_connect - Notify controller that VBUS is powered</span>
<span class="cm"> * @gadget:The device which now has VBUS power.</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call is used by a driver for an external transceiver (or GPIO)</span>
<span class="cm"> * that detects a VBUS power session starting.  Common responses include</span>
<span class="cm"> * resuming the controller, activating the D+ (or D-) pullup to let the</span>
<span class="cm"> * host detect that a USB device is attached, and starting to draw power</span>
<span class="cm"> * (8mA or possibly more, especially after SET_CONFIGURATION).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_vbus_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vbus_session</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vbus_session</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_vbus_draw - constrain controller&#39;s VBUS power usage</span>
<span class="cm"> * @gadget:The device whose VBUS usage is being described</span>
<span class="cm"> * @mA:How much current to draw, in milliAmperes.  This should be twice</span>
<span class="cm"> *	the value listed in the configuration descriptor bMaxPower field.</span>
<span class="cm"> *</span>
<span class="cm"> * This call is used by gadget drivers during SET_CONFIGURATION calls,</span>
<span class="cm"> * reporting how much power the device may consume.  For example, this</span>
<span class="cm"> * could affect how quickly batteries are recharged.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_vbus_draw</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mA</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vbus_draw</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vbus_draw</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="n">mA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_vbus_disconnect - notify controller about VBUS session end</span>
<span class="cm"> * @gadget:the device whose VBUS supply is being described</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This call is used by a driver for an external transceiver (or GPIO)</span>
<span class="cm"> * that detects a VBUS power session ending.  Common responses include</span>
<span class="cm"> * reversing everything done in usb_gadget_vbus_connect().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_vbus_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vbus_session</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">vbus_session</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_connect - software-controlled connect to USB host</span>
<span class="cm"> * @gadget:the peripheral being connected</span>
<span class="cm"> *</span>
<span class="cm"> * Enables the D+ (or potentially D-) pullup.  The host will start</span>
<span class="cm"> * enumerating this gadget when the pullup is active and a VBUS session</span>
<span class="cm"> * is active (the link is powered).  This pullup is always enabled unless</span>
<span class="cm"> * usb_gadget_disconnect() has been used to disable it.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pullup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pullup</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_disconnect - software-controlled disconnect from USB host</span>
<span class="cm"> * @gadget:the peripheral being disconnected</span>
<span class="cm"> *</span>
<span class="cm"> * Disables the D+ (or potentially D-) pullup, which the host may see</span>
<span class="cm"> * as a disconnect (when a VBUS session is active).  Not all systems</span>
<span class="cm"> * support software pullup controls.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine may be used during the gadget driver bind() call to prevent</span>
<span class="cm"> * the peripheral from ever being visible to the USB host, unless later</span>
<span class="cm"> * usb_gadget_connect() is called.  For example, user mode components may</span>
<span class="cm"> * need to be activated before the system can talk to hosts.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else negative errno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_gadget_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pullup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gadget</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pullup</span><span class="p">(</span><span class="n">gadget</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_gadget_driver - driver for usb &#39;slave&#39; devices</span>
<span class="cm"> * @function: String describing the gadget&#39;s function</span>
<span class="cm"> * @max_speed: Highest speed the driver handles.</span>
<span class="cm"> * @setup: Invoked for ep0 control requests that aren&#39;t handled by</span>
<span class="cm"> *	the hardware level driver. Most calls must be handled by</span>
<span class="cm"> *	the gadget driver, including descriptor and configuration</span>
<span class="cm"> *	management.  The 16 bit members of the setup data are in</span>
<span class="cm"> *	USB byte order. Called in_interrupt; this may not sleep.  Driver</span>
<span class="cm"> *	queues a response to ep0, or returns negative to stall.</span>
<span class="cm"> * @disconnect: Invoked after all transfers have been stopped,</span>
<span class="cm"> *	when the host is disconnected.  May be called in_interrupt; this</span>
<span class="cm"> *	may not sleep.  Some devices can&#39;t detect disconnect, so this might</span>
<span class="cm"> *	not be called except as part of controller shutdown.</span>
<span class="cm"> * @unbind: Invoked when the driver is unbound from a gadget,</span>
<span class="cm"> *	usually from rmmod (after a disconnect is reported).</span>
<span class="cm"> *	Called in a context that permits sleeping.</span>
<span class="cm"> * @suspend: Invoked on USB suspend.  May be called in_interrupt.</span>
<span class="cm"> * @resume: Invoked on USB resume.  May be called in_interrupt.</span>
<span class="cm"> * @driver: Driver model state for this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Devices are disabled till a gadget driver successfully bind()s, which</span>
<span class="cm"> * means the driver will handle setup() requests needed to enumerate (and</span>
<span class="cm"> * meet &quot;chapter 9&quot; requirements) then do some useful work.</span>
<span class="cm"> *</span>
<span class="cm"> * If gadget-&gt;is_otg is true, the gadget driver must provide an OTG</span>
<span class="cm"> * descriptor during enumeration, or else fail the bind() call.  In such</span>
<span class="cm"> * cases, no USB traffic may flow until both bind() returns without</span>
<span class="cm"> * having called usb_gadget_disconnect(), and the USB host stack has</span>
<span class="cm"> * initialized.</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers use hardware-specific knowledge to configure the usb hardware.</span>
<span class="cm"> * endpoint addressing is only one of several hardware characteristics that</span>
<span class="cm"> * are in descriptors the ep0 implementation returns from setup() calls.</span>
<span class="cm"> *</span>
<span class="cm"> * Except for ep0 implementation, most driver code shouldn&#39;t need change to</span>
<span class="cm"> * run on top of different usb controllers.  It&#39;ll use endpoints set up by</span>
<span class="cm"> * that ep0 implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * The usb controller driver handles a few standard usb requests.  Those</span>
<span class="cm"> * include set_address, and feature flags for devices, interfaces, and</span>
<span class="cm"> * endpoints (the get_status, set_feature, and clear_feature requests).</span>
<span class="cm"> *</span>
<span class="cm"> * Accordingly, the driver&#39;s setup() callback must always implement all</span>
<span class="cm"> * get_descriptor requests, returning at least a device descriptor and</span>
<span class="cm"> * a configuration descriptor.  Drivers must make sure the endpoint</span>
<span class="cm"> * descriptors match any hardware constraints. Some hardware also constrains</span>
<span class="cm"> * other descriptors. (The pxa250 allows only configurations 1, 2, or 3).</span>
<span class="cm"> *</span>
<span class="cm"> * The driver&#39;s setup() callback must also implement set_configuration,</span>
<span class="cm"> * and should also implement set_interface, get_configuration, and</span>
<span class="cm"> * get_interface.  Setting a configuration (or interface) is where</span>
<span class="cm"> * endpoints should be activated or (config 0) shut down.</span>
<span class="cm"> *</span>
<span class="cm"> * (Note that only the default control endpoint is supported.  Neither</span>
<span class="cm"> * hosts nor devices generally support control traffic except to ep0.)</span>
<span class="cm"> *</span>
<span class="cm"> * Most devices will ignore USB suspend/resume operations, and so will</span>
<span class="cm"> * not provide those callbacks.  However, some may need to change modes</span>
<span class="cm"> * when the host is not longer directing those activities.  For example,</span>
<span class="cm"> * local controls (buttons, dials, etc) may need to be re-enabled since</span>
<span class="cm"> * the (remote) host can&#39;t do that any longer; or an error state might</span>
<span class="cm"> * be cleared, to make the device behave identically whether or not</span>
<span class="cm"> * power is maintained.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="p">{</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">function</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_device_speed</span>	<span class="n">max_speed</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">unbind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* FIXME support safe rmmod */</span>
	<span class="k">struct</span> <span class="n">device_driver</span>	<span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>



<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* driver modules register and unregister, as usual.</span>
<span class="cm"> * these calls must be made in a context that can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * these will usually be implemented directly by the hardware-dependent</span>
<span class="cm"> * usb bus interface driver, which will only support a single driver.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_probe_driver - probe a gadget driver</span>
<span class="cm"> * @driver: the driver being registered</span>
<span class="cm"> * @bind: the driver&#39;s bind callback</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Call this in your gadget driver&#39;s module initialization function,</span>
<span class="cm"> * to tell the underlying usb controller driver about your driver.</span>
<span class="cm"> * The @bind() function will be called to bind it to a gadget before this</span>
<span class="cm"> * registration call returns.  It&#39;s expected that the @bind() function will</span>
<span class="cm"> * be in init sections.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">usb_gadget_probe_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">));</span>

<span class="cm">/**</span>
<span class="cm"> * usb_gadget_unregister_driver - unregister a gadget driver</span>
<span class="cm"> * @driver:the driver being unregistered</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Call this in your gadget driver&#39;s module cleanup function,</span>
<span class="cm"> * to tell the underlying usb controller that your driver is</span>
<span class="cm"> * going away.  If the controller is connected to a USB host,</span>
<span class="cm"> * it will first disconnect().  The driver is also requested</span>
<span class="cm"> * to unbind() and clean up any device state, before this procedure</span>
<span class="cm"> * finally returns.  It&#39;s expected that the unbind() functions</span>
<span class="cm"> * will in in exit sections, so may not be linked in some kernels.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">usb_gadget_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_add_gadget_udc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_del_gadget_udc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* utility to simplify dealing with string descriptors */</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_string - wraps a C string and its USB id</span>
<span class="cm"> * @id:the (nonzero) ID for this string</span>
<span class="cm"> * @s:the string, in UTF-8 encoding</span>
<span class="cm"> *</span>
<span class="cm"> * If you&#39;re using usb_gadget_get_string(), use this to wrap a string</span>
<span class="cm"> * together with its ID.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_string</span> <span class="p">{</span>
	<span class="n">u8</span>			<span class="n">id</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_gadget_strings - a set of USB strings in a given language</span>
<span class="cm"> * @language:identifies the strings&#39; language (0x0409 for en-us)</span>
<span class="cm"> * @strings:array of strings with their ids</span>
<span class="cm"> *</span>
<span class="cm"> * If you&#39;re using usb_gadget_get_string(), use this to wrap all the</span>
<span class="cm"> * strings for a given language.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_gadget_strings</span> <span class="p">{</span>
	<span class="n">u16</span>			<span class="n">language</span><span class="p">;</span>	<span class="cm">/* 0x0409 for en-us */</span>
	<span class="k">struct</span> <span class="n">usb_string</span>	<span class="o">*</span><span class="n">strings</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* put descriptor for string with that id into buf (buflen &gt;= 256) */</span>
<span class="kt">int</span> <span class="n">usb_gadget_get_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget_strings</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* utility to simplify managing config descriptors */</span>

<span class="cm">/* write vector of descriptors into buffer */</span>
<span class="kt">int</span> <span class="n">usb_descriptor_fillbuf</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">**</span><span class="p">);</span>

<span class="cm">/* build config descriptor from single descriptor vector */</span>
<span class="kt">int</span> <span class="n">usb_gadget_config_buf</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">usb_config_descriptor</span> <span class="o">*</span><span class="n">config</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">buflen</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">**</span><span class="n">desc</span><span class="p">);</span>

<span class="cm">/* copy a NULL-terminated vector of descriptors */</span>
<span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">**</span><span class="n">usb_copy_descriptors</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">**</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_free_descriptors - free descriptors returned by usb_copy_descriptors()</span>
<span class="cm"> * @v: vector of descriptors</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_free_descriptors</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* utility to simplify map/unmap of usb_requests to/from DMA */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_gadget_map_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_in</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_gadget_unmap_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">gadget</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_in</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* utility wrapping a simple endpoint selection policy */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usb_ep_autoconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="p">);</span>


<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">usb_ep_autoconfig_ss</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_ss_ep_comp_descriptor</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_ep_autoconfig_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_USB_GADGET_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
