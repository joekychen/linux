<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › usb › composite.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>composite.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * composite.h -- framework for usb gadgets which are composite devices</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 David Brownell</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef	__LINUX_USB_COMPOSITE_H</span>
<span class="cp">#define	__LINUX_USB_COMPOSITE_H</span>

<span class="cm">/*</span>
<span class="cm"> * This framework is an optional layer on top of the USB Gadget interface,</span>
<span class="cm"> * making it easier to build (a) Composite devices, supporting multiple</span>
<span class="cm"> * functions within any single configuration, and (b) Multi-configuration</span>
<span class="cm"> * devices, also supporting multiple functions but without necessarily</span>
<span class="cm"> * having more than one function per configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * Example:  a device with a single configuration supporting both network</span>
<span class="cm"> * link and mass storage functions is a composite device.  Those functions</span>
<span class="cm"> * might alternatively be packaged in individual configurations, but in</span>
<span class="cm"> * the composite model the host can use both functions at the same time.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>
<span class="cp">#include &lt;linux/usb/gadget.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * USB function drivers should return USB_GADGET_DELAYED_STATUS if they</span>
<span class="cm"> * wish to delay the data/status stages of the control transfer till they</span>
<span class="cm"> * are ready. The control transfer will then be kept from completing till</span>
<span class="cm"> * all the function drivers that requested for USB_GADGET_DELAYED_STAUS</span>
<span class="cm"> * invoke usb_composite_setup_continue().</span>
<span class="cm"> */</span>
<span class="cp">#define USB_GADGET_DELAYED_STATUS       0x7fff	</span><span class="cm">/* Impossibly large value */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">usb_configuration</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_function - describes one function of a configuration</span>
<span class="cm"> * @name: For diagnostics, identifies the function.</span>
<span class="cm"> * @strings: tables of strings, keyed by identifiers assigned during bind()</span>
<span class="cm"> *	and by language IDs provided in control requests</span>
<span class="cm"> * @descriptors: Table of full (or low) speed descriptors, using interface and</span>
<span class="cm"> *	string identifiers assigned during @bind().  If this pointer is null,</span>
<span class="cm"> *	the function will not be available at full speed (or at low speed).</span>
<span class="cm"> * @hs_descriptors: Table of high speed descriptors, using interface and</span>
<span class="cm"> *	string identifiers assigned during @bind().  If this pointer is null,</span>
<span class="cm"> *	the function will not be available at high speed.</span>
<span class="cm"> * @ss_descriptors: Table of super speed descriptors, using interface and</span>
<span class="cm"> *	string identifiers assigned during @bind(). If this</span>
<span class="cm"> *	pointer is null after initiation, the function will not</span>
<span class="cm"> *	be available at super speed.</span>
<span class="cm"> * @config: assigned when @usb_add_function() is called; this is the</span>
<span class="cm"> *	configuration with which this function is associated.</span>
<span class="cm"> * @bind: Before the gadget can register, all of its functions bind() to the</span>
<span class="cm"> *	available resources including string and interface identifiers used</span>
<span class="cm"> *	in interface or class descriptors; endpoints; I/O buffers; and so on.</span>
<span class="cm"> * @unbind: Reverses @bind; called as a side effect of unregistering the</span>
<span class="cm"> *	driver which added this function.</span>
<span class="cm"> * @set_alt: (REQUIRED) Reconfigures altsettings; function drivers may</span>
<span class="cm"> *	initialize usb_ep.driver data at this time (when it is used).</span>
<span class="cm"> *	Note that setting an interface to its current altsetting resets</span>
<span class="cm"> *	interface state, and that all interfaces have a disabled state.</span>
<span class="cm"> * @get_alt: Returns the active altsetting.  If this is not provided,</span>
<span class="cm"> *	then only altsetting zero is supported.</span>
<span class="cm"> * @disable: (REQUIRED) Indicates the function should be disabled.  Reasons</span>
<span class="cm"> *	include host resetting or reconfiguring the gadget, and disconnection.</span>
<span class="cm"> * @setup: Used for interface-specific control requests.</span>
<span class="cm"> * @suspend: Notifies functions when the host stops sending USB traffic.</span>
<span class="cm"> * @resume: Notifies functions when the host restarts USB traffic.</span>
<span class="cm"> * @get_status: Returns function status as a reply to</span>
<span class="cm"> *	GetStatus() request when the recepient is Interface.</span>
<span class="cm"> * @func_suspend: callback to be called when</span>
<span class="cm"> *	SetFeature(FUNCTION_SUSPEND) is reseived</span>
<span class="cm"> *</span>
<span class="cm"> * A single USB function uses one or more interfaces, and should in most</span>
<span class="cm"> * cases support operation at both full and high speeds.  Each function is</span>
<span class="cm"> * associated by @usb_add_function() with a one configuration; that function</span>
<span class="cm"> * causes @bind() to be called so resources can be allocated as part of</span>
<span class="cm"> * setting up a gadget driver.  Those resources include endpoints, which</span>
<span class="cm"> * should be allocated using @usb_ep_autoconfig().</span>
<span class="cm"> *</span>
<span class="cm"> * To support dual speed operation, a function driver provides descriptors</span>
<span class="cm"> * for both high and full speed operation.  Except in rare cases that don&#39;t</span>
<span class="cm"> * involve bulk endpoints, each speed needs different endpoint descriptors.</span>
<span class="cm"> *</span>
<span class="cm"> * Function drivers choose their own strategies for managing instance data.</span>
<span class="cm"> * The simplest strategy just declares it &quot;static&#39;, which means the function</span>
<span class="cm"> * can only be activated once.  If the function needs to be exposed in more</span>
<span class="cm"> * than one configuration at a given speed, it needs to support multiple</span>
<span class="cm"> * usb_function structures (one for each configuration).</span>
<span class="cm"> *</span>
<span class="cm"> * A more complex strategy might encapsulate a @usb_function structure inside</span>
<span class="cm"> * a driver-specific instance structure to allows multiple activations.  An</span>
<span class="cm"> * example of multiple activations might be a CDC ACM function that supports</span>
<span class="cm"> * two or more distinct instances within the same configuration, providing</span>
<span class="cm"> * several independent logical data links to a USB host.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_function</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget_strings</span>	<span class="o">**</span><span class="n">strings</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_descriptor_header</span>	<span class="o">**</span><span class="n">descriptors</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_descriptor_header</span>	<span class="o">**</span><span class="n">hs_descriptors</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_descriptor_header</span>	<span class="o">**</span><span class="n">ss_descriptors</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_configuration</span>	<span class="o">*</span><span class="n">config</span><span class="p">;</span>

	<span class="cm">/* REVISIT:  bind() functions can be marked __init, which</span>
<span class="cm">	 * makes trouble for section mismatch analysis.  See if</span>
<span class="cm">	 * we can&#39;t restructure things to avoid mismatching.</span>
<span class="cm">	 * Related:  unbind() may kfree() but bind() won&#39;t...</span>
<span class="cm">	 */</span>

	<span class="cm">/* configuration management:  bind/unbind */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">unbind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* runtime state management */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">set_alt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">interface</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">alt</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">get_alt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">interface</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* USB 3.0 additions */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">get_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">func_suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">,</span>
						<span class="n">u8</span> <span class="n">suspend_opt</span><span class="p">);</span>
	<span class="cm">/* private: */</span>
	<span class="cm">/* internals */</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">list</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">endpoints</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">usb_add_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">usb_function_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">usb_function_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">usb_interface_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">config_ep_by_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_gadget</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_function</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_ep</span> <span class="o">*</span><span class="n">_ep</span><span class="p">);</span>

<span class="cp">#define	MAX_CONFIG_INTERFACES		16	</span><span class="cm">/* arbitrary; max 255 */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_configuration - represents one gadget configuration</span>
<span class="cm"> * @label: For diagnostics, describes the configuration.</span>
<span class="cm"> * @strings: Tables of strings, keyed by identifiers assigned during @bind()</span>
<span class="cm"> *	and by language IDs provided in control requests.</span>
<span class="cm"> * @descriptors: Table of descriptors preceding all function descriptors.</span>
<span class="cm"> *	Examples include OTG and vendor-specific descriptors.</span>
<span class="cm"> * @unbind: Reverses @bind; called as a side effect of unregistering the</span>
<span class="cm"> *	driver which added this configuration.</span>
<span class="cm"> * @setup: Used to delegate control requests that aren&#39;t handled by standard</span>
<span class="cm"> *	device infrastructure or directed at a specific interface.</span>
<span class="cm"> * @bConfigurationValue: Copied into configuration descriptor.</span>
<span class="cm"> * @iConfiguration: Copied into configuration descriptor.</span>
<span class="cm"> * @bmAttributes: Copied into configuration descriptor.</span>
<span class="cm"> * @bMaxPower: Copied into configuration descriptor.</span>
<span class="cm"> * @cdev: assigned by @usb_add_config() before calling @bind(); this is</span>
<span class="cm"> *	the device associated with this configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * Configurations are building blocks for gadget drivers structured around</span>
<span class="cm"> * function drivers.  Simple USB gadgets require only one function and one</span>
<span class="cm"> * configuration, and handle dual-speed hardware by always providing the same</span>
<span class="cm"> * functionality.  Slightly more complex gadgets may have more than one</span>
<span class="cm"> * single-function configuration at a given speed; or have configurations</span>
<span class="cm"> * that only work at one speed.</span>
<span class="cm"> *</span>
<span class="cm"> * Composite devices are, by definition, ones with configurations which</span>
<span class="cm"> * include more than one function.</span>
<span class="cm"> *</span>
<span class="cm"> * The lifecycle of a usb_configuration includes allocation, initialization</span>
<span class="cm"> * of the fields described above, and calling @usb_add_config() to set up</span>
<span class="cm"> * internal data and bind it to a specific device.  The configuration&#39;s</span>
<span class="cm"> * @bind() method is then used to initialize all the functions and then</span>
<span class="cm"> * call @usb_add_function() for them.</span>
<span class="cm"> *</span>
<span class="cm"> * Those functions would normally be independent of each other, but that&#39;s</span>
<span class="cm"> * not mandatory.  CDC WMC devices are an example where functions often</span>
<span class="cm"> * depend on other functions, with some functions subsidiary to others.</span>
<span class="cm"> * Such interdependency may be managed in any way, so long as all of the</span>
<span class="cm"> * descriptors complete by the time the composite driver returns from</span>
<span class="cm"> * its bind() routine.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_configuration</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">label</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget_strings</span>	<span class="o">**</span><span class="n">strings</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_descriptor_header</span> <span class="o">**</span><span class="n">descriptors</span><span class="p">;</span>

	<span class="cm">/* REVISIT:  bind() functions can be marked __init, which</span>
<span class="cm">	 * makes trouble for section mismatch analysis.  See if</span>
<span class="cm">	 * we can&#39;t restructure things to avoid mismatching...</span>
<span class="cm">	 */</span>

	<span class="cm">/* configuration management: unbind/setup */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">unbind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_ctrlrequest</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* fields in the config descriptor */</span>
	<span class="n">u8</span>			<span class="n">bConfigurationValue</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">iConfiguration</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">bmAttributes</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">bMaxPower</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_composite_dev</span>	<span class="o">*</span><span class="n">cdev</span><span class="p">;</span>

	<span class="cm">/* private: */</span>
	<span class="cm">/* internals */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">functions</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">next_interface_id</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">superspeed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">highspeed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">fullspeed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_function</span>	<span class="o">*</span><span class="n">interface</span><span class="p">[</span><span class="n">MAX_CONFIG_INTERFACES</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">usb_add_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">));</span>

<span class="kt">void</span> <span class="n">usb_remove_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_configuration</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_composite_driver - groups configurations into a gadget</span>
<span class="cm"> * @name: For diagnostics, identifies the driver.</span>
<span class="cm"> * @iProduct: Used as iProduct override if @dev-&gt;iProduct is not set.</span>
<span class="cm"> *	If NULL value of @name is taken.</span>
<span class="cm"> * @iManufacturer: Used as iManufacturer override if @dev-&gt;iManufacturer is</span>
<span class="cm"> *	not set. If NULL a default &quot;&lt;system&gt; &lt;release&gt; with &lt;udc&gt;&quot; value</span>
<span class="cm"> *	will be used.</span>
<span class="cm"> * @iSerialNumber: Used as iSerialNumber override if @dev-&gt;iSerialNumber is</span>
<span class="cm"> *	not set.</span>
<span class="cm"> * @dev: Template descriptor for the device, including default device</span>
<span class="cm"> *	identifiers.</span>
<span class="cm"> * @strings: tables of strings, keyed by identifiers assigned during bind()</span>
<span class="cm"> *	and language IDs provided in control requests</span>
<span class="cm"> * @max_speed: Highest speed the driver supports.</span>
<span class="cm"> * @needs_serial: set to 1 if the gadget needs userspace to provide</span>
<span class="cm"> * 	a serial number.  If one is not provided, warning will be printed.</span>
<span class="cm"> * @unbind: Reverses bind; called as a side effect of unregistering</span>
<span class="cm"> *	this driver.</span>
<span class="cm"> * @disconnect: optional driver disconnect method</span>
<span class="cm"> * @suspend: Notifies when the host stops sending USB traffic,</span>
<span class="cm"> *	after function notifications</span>
<span class="cm"> * @resume: Notifies configuration when the host restarts USB traffic,</span>
<span class="cm"> *	before function notifications</span>
<span class="cm"> *</span>
<span class="cm"> * Devices default to reporting self powered operation.  Devices which rely</span>
<span class="cm"> * on bus powered operation should report this in their @bind() method.</span>
<span class="cm"> *</span>
<span class="cm"> * Before returning from bind, various fields in the template descriptor</span>
<span class="cm"> * may be overridden.  These include the idVendor/idProduct/bcdDevice values</span>
<span class="cm"> * normally to bind the appropriate host side driver, and the three strings</span>
<span class="cm"> * (iManufacturer, iProduct, iSerialNumber) normally used to provide user</span>
<span class="cm"> * meaningful device identifiers.  (The strings will not be defined unless</span>
<span class="cm"> * they are defined in @dev and @strings.)  The correct ep0 maxpacket size</span>
<span class="cm"> * is also reported, as defined by the underlying controller driver.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_composite_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>				<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>				<span class="o">*</span><span class="n">iProduct</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>				<span class="o">*</span><span class="n">iManufacturer</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>				<span class="o">*</span><span class="n">iSerialNumber</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_descriptor</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_gadget_strings</span>		<span class="o">**</span><span class="n">strings</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_device_speed</span>			<span class="n">max_speed</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">needs_serial</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">unbind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* global suspend hooks */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_composite_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_composite_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_composite_setup_continue</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * struct usb_composite_device - represents one composite usb gadget</span>
<span class="cm"> * @gadget: read-only, abstracts the gadget&#39;s usb peripheral controller</span>
<span class="cm"> * @req: used for control responses; buffer is pre-allocated</span>
<span class="cm"> * @bufsiz: size of buffer pre-allocated in @req</span>
<span class="cm"> * @config: the currently active configuration</span>
<span class="cm"> *</span>
<span class="cm"> * One of these devices is allocated and initialized before the</span>
<span class="cm"> * associated device driver&#39;s bind() is called.</span>
<span class="cm"> *</span>
<span class="cm"> * OPEN ISSUE:  it appears that some WUSB devices will need to be</span>
<span class="cm"> * built by combining a normal (wired) gadget with a wireless one.</span>
<span class="cm"> * This revision of the gadget framework should probably try to make</span>
<span class="cm"> * sure doing that won&#39;t hurt too much.</span>
<span class="cm"> *</span>
<span class="cm"> * One notion for how to handle Wireless USB devices involves:</span>
<span class="cm"> * (a) a second gadget here, discovery mechanism TBD, but likely</span>
<span class="cm"> *     needing separate &quot;register/unregister WUSB gadget&quot; calls;</span>
<span class="cm"> * (b) updates to usb_gadget to include flags &quot;is it wireless&quot;,</span>
<span class="cm"> *     &quot;is it wired&quot;, plus (presumably in a wrapper structure)</span>
<span class="cm"> *     bandgroup and PHY info;</span>
<span class="cm"> * (c) presumably a wireless_ep wrapping a usb_ep, and reporting</span>
<span class="cm"> *     wireless-specific parameters like maxburst and maxsequence;</span>
<span class="cm"> * (d) configurations that are specific to wireless links;</span>
<span class="cm"> * (e) function drivers that understand wireless configs and will</span>
<span class="cm"> *     support wireless for (additional) function instances;</span>
<span class="cm"> * (f) a function to support association setup (like CBAF), not</span>
<span class="cm"> *     necessarily requiring a wireless adapter;</span>
<span class="cm"> * (g) composite device setup that can create one or more wireless</span>
<span class="cm"> *     configs, including appropriate association setup support;</span>
<span class="cm"> * (h) more, TBD.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_gadget</span>		<span class="o">*</span><span class="n">gadget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_request</span>		<span class="o">*</span><span class="n">req</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">bufsiz</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_configuration</span>	<span class="o">*</span><span class="n">config</span><span class="p">;</span>

	<span class="cm">/* private: */</span>
	<span class="cm">/* internals */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">suspended</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device_descriptor</span>	<span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">configs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_composite_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">next_string_id</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">manufacturer_override</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">product_override</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">serial_override</span><span class="p">;</span>

	<span class="cm">/* the gadget driver won&#39;t enable the data pullup</span>
<span class="cm">	 * while the deactivation count is nonzero.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span>			<span class="n">deactivations</span><span class="p">;</span>

	<span class="cm">/* the composite driver won&#39;t complete the control transfer&#39;s</span>
<span class="cm">	 * data/status stages till delayed_status is zero.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>				<span class="n">delayed_status</span><span class="p">;</span>

	<span class="cm">/* protects deactivations and delayed_status counts*/</span>
	<span class="n">spinlock_t</span>			<span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_string_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_string_ids_tab</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">usb_string</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_string_ids_n</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_composite_dev</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">);</span>


<span class="cm">/* messaging utils */</span>
<span class="cp">#define DBG(d, fmt, args...) \</span>
<span class="cp">	dev_dbg(&amp;(d)-&gt;gadget-&gt;dev , fmt , ## args)</span>
<span class="cp">#define VDBG(d, fmt, args...) \</span>
<span class="cp">	dev_vdbg(&amp;(d)-&gt;gadget-&gt;dev , fmt , ## args)</span>
<span class="cp">#define ERROR(d, fmt, args...) \</span>
<span class="cp">	dev_err(&amp;(d)-&gt;gadget-&gt;dev , fmt , ## args)</span>
<span class="cp">#define WARNING(d, fmt, args...) \</span>
<span class="cp">	dev_warn(&amp;(d)-&gt;gadget-&gt;dev , fmt , ## args)</span>
<span class="cp">#define INFO(d, fmt, args...) \</span>
<span class="cp">	dev_info(&amp;(d)-&gt;gadget-&gt;dev , fmt , ## args)</span>

<span class="cp">#endif	</span><span class="cm">/* __LINUX_USB_COMPOSITE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
