<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › usb › serial.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>serial.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * USB Serial Converter stuff</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright (C) 1999 - 2012</span>
<span class="cm"> *	    Greg Kroah-Hartman (greg@kroah.com)</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_USB_SERIAL_H</span>
<span class="cp">#define __LINUX_USB_SERIAL_H</span>

<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sysrq.h&gt;</span>
<span class="cp">#include &lt;linux/kfifo.h&gt;</span>

<span class="cp">#define SERIAL_TTY_MAJOR	188	</span><span class="cm">/* Nice legal number now */</span><span class="cp"></span>
<span class="cp">#define SERIAL_TTY_MINORS	254	</span><span class="cm">/* loads of devices :) */</span><span class="cp"></span>
<span class="cp">#define SERIAL_TTY_NO_MINOR	255	</span><span class="cm">/* No minor was assigned */</span><span class="cp"></span>

<span class="cm">/* The maximum number of ports one device can grab at once */</span>
<span class="cp">#define MAX_NUM_PORTS		8</span>

<span class="cm">/* parity check flag */</span>
<span class="cp">#define RELEVANT_IFLAG(iflag)	(iflag &amp; (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))</span>

<span class="cm">/* USB serial flags */</span>
<span class="cp">#define USB_SERIAL_WRITE_BUSY	0</span>

<span class="cm">/**</span>
<span class="cm"> * usb_serial_port: structure for the specific ports of a device.</span>
<span class="cm"> * @serial: pointer back to the struct usb_serial owner of this port.</span>
<span class="cm"> * @port: pointer to the corresponding tty_port for this port.</span>
<span class="cm"> * @lock: spinlock to grab when updating portions of this structure.</span>
<span class="cm"> * @number: the number of the port (the minor number).</span>
<span class="cm"> * @interrupt_in_buffer: pointer to the interrupt in buffer for this port.</span>
<span class="cm"> * @interrupt_in_urb: pointer to the interrupt in struct urb for this port.</span>
<span class="cm"> * @interrupt_in_endpointAddress: endpoint address for the interrupt in pipe</span>
<span class="cm"> *	for this port.</span>
<span class="cm"> * @interrupt_out_buffer: pointer to the interrupt out buffer for this port.</span>
<span class="cm"> * @interrupt_out_size: the size of the interrupt_out_buffer, in bytes.</span>
<span class="cm"> * @interrupt_out_urb: pointer to the interrupt out struct urb for this port.</span>
<span class="cm"> * @interrupt_out_endpointAddress: endpoint address for the interrupt out pipe</span>
<span class="cm"> *	for this port.</span>
<span class="cm"> * @bulk_in_buffer: pointer to the bulk in buffer for this port.</span>
<span class="cm"> * @bulk_in_size: the size of the bulk_in_buffer, in bytes.</span>
<span class="cm"> * @read_urb: pointer to the bulk in struct urb for this port.</span>
<span class="cm"> * @bulk_in_endpointAddress: endpoint address for the bulk in pipe for this</span>
<span class="cm"> *	port.</span>
<span class="cm"> * @bulk_in_buffers: pointers to the bulk in buffers for this port</span>
<span class="cm"> * @read_urbs: pointers to the bulk in urbs for this port</span>
<span class="cm"> * @read_urbs_free: status bitmap the for bulk in urbs</span>
<span class="cm"> * @bulk_out_buffer: pointer to the bulk out buffer for this port.</span>
<span class="cm"> * @bulk_out_size: the size of the bulk_out_buffer, in bytes.</span>
<span class="cm"> * @write_urb: pointer to the bulk out struct urb for this port.</span>
<span class="cm"> * @write_fifo: kfifo used to buffer outgoing data</span>
<span class="cm"> * @bulk_out_buffers: pointers to the bulk out buffers for this port</span>
<span class="cm"> * @write_urbs: pointers to the bulk out urbs for this port</span>
<span class="cm"> * @write_urbs_free: status bitmap the for bulk out urbs</span>
<span class="cm"> * @tx_bytes: number of bytes currently in host stack queues</span>
<span class="cm"> * @bulk_out_endpointAddress: endpoint address for the bulk out pipe for this</span>
<span class="cm"> *	port.</span>
<span class="cm"> * @flags: usb serial port flags</span>
<span class="cm"> * @write_wait: a wait_queue_head_t used by the port.</span>
<span class="cm"> * @work: work queue entry for the line discipline waking up.</span>
<span class="cm"> * @throttled: nonzero if the read urb is inactive to throttle the device</span>
<span class="cm"> * @throttle_req: nonzero if the tty wants to throttle us</span>
<span class="cm"> * @dev: pointer to the serial device</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used by the usb-serial core and drivers for the specific</span>
<span class="cm"> * ports of a device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_serial</span>	<span class="o">*</span><span class="n">serial</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span>		<span class="n">port</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">number</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">interrupt_in_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">interrupt_in_urb</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">interrupt_in_endpointAddress</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">interrupt_out_buffer</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">interrupt_out_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">interrupt_out_urb</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">interrupt_out_endpointAddress</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">bulk_in_buffer</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bulk_in_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">read_urb</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">bulk_in_endpointAddress</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">bulk_in_buffers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">read_urbs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">read_urbs_free</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">bulk_out_buffer</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bulk_out_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">write_urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kfifo</span>		<span class="n">write_fifo</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">bulk_out_buffers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">write_urbs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">write_urbs_free</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">bulk_out_endpointAddress</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">tx_bytes</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">write_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">throttled</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">throttle_req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sysrq</span><span class="p">;</span> <span class="cm">/* sysrq timeout */</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)</span>

<span class="cm">/* get and set the port private data pointer helper functions */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">usb_get_serial_port_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_set_serial_port_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_serial - structure used by the usb-serial core for a device</span>
<span class="cm"> * @dev: pointer to the struct usb_device for this device</span>
<span class="cm"> * @type: pointer to the struct usb_serial_driver for this device</span>
<span class="cm"> * @interface: pointer to the struct usb_interface for this device</span>
<span class="cm"> * @minor: the starting minor number for this device</span>
<span class="cm"> * @num_ports: the number of ports this device has</span>
<span class="cm"> * @num_interrupt_in: number of interrupt in endpoints we have</span>
<span class="cm"> * @num_interrupt_out: number of interrupt out endpoints we have</span>
<span class="cm"> * @num_bulk_in: number of bulk in endpoints we have</span>
<span class="cm"> * @num_bulk_out: number of bulk out endpoints we have</span>
<span class="cm"> * @port: array of struct usb_serial_port structures for the different ports.</span>
<span class="cm"> * @private: place to put any driver specific information that is needed.  The</span>
<span class="cm"> *	usb-serial driver is required to manage this data, the usb-serial core</span>
<span class="cm"> *	will not touch this.  Use usb_get_serial_data() and</span>
<span class="cm"> *	usb_set_serial_data() to access this.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_serial</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_serial_driver</span>	<span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_interface</span>		<span class="o">*</span><span class="n">interface</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">disconnected</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">suspending</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">attached</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">minor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">num_ports</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>			<span class="n">num_port_pointers</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="n">num_interrupt_in</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="n">num_interrupt_out</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="n">num_bulk_in</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="n">num_bulk_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_serial_port</span>		<span class="o">*</span><span class="n">port</span><span class="p">[</span><span class="n">MAX_NUM_PORTS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">kref</span>			<span class="n">kref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">disc_mutex</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">private</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_usb_serial(d) container_of(d, struct usb_serial, kref)</span>

<span class="cm">/* get and set the serial private data pointer helper functions */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">usb_get_serial_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">serial</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_set_serial_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">serial</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_serial_driver - describes a usb serial driver</span>
<span class="cm"> * @description: pointer to a string that describes this driver.  This string</span>
<span class="cm"> *	used in the syslog messages when a device is inserted or removed.</span>
<span class="cm"> * @id_table: pointer to a list of usb_device_id structures that define all</span>
<span class="cm"> *	of the devices this structure can support.</span>
<span class="cm"> * @num_ports: the number of different ports this device will have.</span>
<span class="cm"> * @bulk_in_size: minimum number of bytes to allocate for bulk-in buffer</span>
<span class="cm"> *	(0 = end-point size)</span>
<span class="cm"> * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)</span>
<span class="cm"> * @calc_num_ports: pointer to a function to determine how many ports this</span>
<span class="cm"> *	device has dynamically.  It will be called after the probe()</span>
<span class="cm"> *	callback is called, but before attach()</span>
<span class="cm"> * @probe: pointer to the driver&#39;s probe function.</span>
<span class="cm"> *	This will be called when the device is inserted into the system,</span>
<span class="cm"> *	but before the device has been fully initialized by the usb_serial</span>
<span class="cm"> *	subsystem.  Use this function to download any firmware to the device,</span>
<span class="cm"> *	or any other early initialization that might be needed.</span>
<span class="cm"> *	Return 0 to continue on with the initialization sequence.  Anything</span>
<span class="cm"> *	else will abort it.</span>
<span class="cm"> * @attach: pointer to the driver&#39;s attach function.</span>
<span class="cm"> *	This will be called when the struct usb_serial structure is fully set</span>
<span class="cm"> *	set up.  Do any local initialization of the device, or any private</span>
<span class="cm"> *	memory structure allocation at this point in time.</span>
<span class="cm"> * @disconnect: pointer to the driver&#39;s disconnect function.  This will be</span>
<span class="cm"> *	called when the device is unplugged or unbound from the driver.</span>
<span class="cm"> * @release: pointer to the driver&#39;s release function.  This will be called</span>
<span class="cm"> *	when the usb_serial data structure is about to be destroyed.</span>
<span class="cm"> * @usb_driver: pointer to the struct usb_driver that controls this</span>
<span class="cm"> *	device.  This is necessary to allow dynamic ids to be added to</span>
<span class="cm"> *	the driver from sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is defines a USB Serial driver.  It provides all of</span>
<span class="cm"> * the information that the USB serial core code needs.  If the function</span>
<span class="cm"> * pointers are defined, then the USB serial core code will call them when</span>
<span class="cm"> * the corresponding tty port functions are called.  If they are not</span>
<span class="cm"> * called, the generic serial function will be used instead.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver.owner field should be set to the module owner of this driver.</span>
<span class="cm"> * The driver.name field should be set to the name of this driver (remember</span>
<span class="cm"> * it will show up in sysfs, so it needs to be short and to the point.</span>
<span class="cm"> * Using the module name is a good idea.)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_serial_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">num_ports</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">driver_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_driver</span>	<span class="n">driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_driver</span>	<span class="o">*</span><span class="n">usb_driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_dynids</span>	<span class="n">dynids</span><span class="p">;</span>

	<span class="kt">size_t</span>			<span class="n">bulk_in_size</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">bulk_out_size</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">attach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">calc_num_ports</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">port_probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">port_remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>

	<span class="cm">/* serial function calls */</span>
	<span class="cm">/* Called by console and by the tty layer */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
	<span class="cm">/* Called only by the tty layer */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">write_room</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_termios</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">break_ctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">break_state</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">chars_in_buffer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">throttle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unthrottle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">tiocmget</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">tiocmset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">get_icount</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">serial_icounter_struct</span> <span class="o">*</span><span class="n">icount</span><span class="p">);</span>
	<span class="cm">/* Called by the tty layer for port level work. There may or may not</span>
<span class="cm">	   be an attached tty at this point */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dtr_rts</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">carrier_raised</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
	<span class="cm">/* Called by the usb serial hooks to allow the user to rework the</span>
<span class="cm">	   termios state */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init_termios</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="cm">/* USB events */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_int_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_int_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_bulk_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_bulk_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
	<span class="cm">/* Called by the generic read bulk callback */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">process_read_urb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
	<span class="cm">/* Called by the generic write implementation */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare_write_buffer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#define to_usb_serial_driver(d) \</span>
<span class="cp">	container_of(d, struct usb_serial_driver, driver)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_register_drivers</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_driver</span> <span class="o">*</span><span class="k">const</span> <span class="n">serial_drivers</span><span class="p">[],</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_deregister_drivers</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_driver</span> <span class="o">*</span><span class="k">const</span> <span class="n">serial_drivers</span><span class="p">[]);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_port_softint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ezusb_writememory</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">bRequest</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ezusb_set_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reset_bit</span><span class="p">);</span>

<span class="cm">/* USB Serial console functions */</span>
<span class="cp">#ifdef CONFIG_USB_SERIAL_CONSOLE</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_console_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">debug</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_console_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_console_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_serial_console_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">debug</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_serial_console_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_serial_console_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cm">/* Functions needed by other parts of the usbserial core */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">usb_serial_get_by_index</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_generic_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_generic_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_generic_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_generic_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_generic_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_read_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_write_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial</span> <span class="o">*</span><span class="n">serial</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_generic_register</span><span class="p">(</span><span class="kt">int</span> <span class="n">debug</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_deregister</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_generic_submit_read_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
						 <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_generic_process_read_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_generic_prepare_write_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_handle_sysrq_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_handle_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_handle_dcd_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_port</span> <span class="o">*</span><span class="n">usb_port</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_serial_bus_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_driver</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_serial_bus_deregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_serial_driver</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_serial_driver</span> <span class="n">usb_serial_generic_device</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">usb_serial_bus_type</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">usb_serial_tty_driver</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_serial_debug_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">debug</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s - length = %d, data = &quot;</span><span class="p">,</span>
			   <span class="n">function</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%.2x &quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Use our own dbg macro */</span>
<span class="cp">#undef dbg</span>
<span class="cp">#define dbg(format, arg...)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (debug)							\</span>
<span class="cp">		printk(KERN_DEBUG &quot;%s: &quot; format &quot;\n&quot;, __FILE__, ##arg);	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Macro for reporting errors in write path to avoid inifinite loop</span>
<span class="cm"> * when port is used as a console.</span>
<span class="cm"> */</span>
<span class="cp">#define dev_err_console(usport, fmt, ...)				\</span>
<span class="cp">do {									\</span>
<span class="cp">	static bool __print_once;					\</span>
<span class="cp">	struct usb_serial_port *__port = (usport);			\</span>
<span class="cp">									\</span>
<span class="cp">	if (!__port-&gt;port.console || !__print_once) {			\</span>
<span class="cp">		__print_once = true;					\</span>
<span class="cp">		dev_err(&amp;__port-&gt;dev, fmt, ##__VA_ARGS__);		\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * module_usb_serial_driver() - Helper macro for registering a USB Serial driver</span>
<span class="cm"> * @__serial_drivers: list of usb_serial drivers to register</span>
<span class="cm"> * @__ids: all device ids that @__serial_drivers bind to</span>
<span class="cm"> *</span>
<span class="cm"> * Helper macro for USB serial drivers which do not do anything special</span>
<span class="cm"> * in module init/exit. This eliminates a lot of boilerplate. Each</span>
<span class="cm"> * module may only use this macro once, and calling it replaces</span>
<span class="cm"> * module_init() and module_exit()</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define usb_serial_module_driver(__name, __serial_drivers, __ids)	\</span>
<span class="cp">static int __init usb_serial_module_init(void)				\</span>
<span class="cp">{									\</span>
<span class="cp">	return usb_serial_register_drivers(__serial_drivers,		\</span>
<span class="cp">					   __name, __ids);		\</span>
<span class="cp">}									\</span>
<span class="cp">module_init(usb_serial_module_init);					\</span>
<span class="cp">static void __exit usb_serial_module_exit(void)				\</span>
<span class="cp">{									\</span>
<span class="cp">	usb_serial_deregister_drivers(__serial_drivers);		\</span>
<span class="cp">}									\</span>
<span class="cp">module_exit(usb_serial_module_exit);</span>

<span class="cp">#define module_usb_serial_driver(__serial_drivers, __ids)		\</span>
<span class="cp">	usb_serial_module_driver(KBUILD_MODNAME, __serial_drivers, __ids)</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_USB_SERIAL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
