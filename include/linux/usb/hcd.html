<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › usb › hcd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hcd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2001-2002 by David Brownell</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __USB_CORE_HCD_H</span>
<span class="cp">#define __USB_CORE_HCD_H</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/rwsem.h&gt;</span>

<span class="cp">#define MAX_TOPO_LEVEL		6</span>

<span class="cm">/* This file contains declarations of usbcore internals that are mostly</span>
<span class="cm"> * used or exposed by Host Controller Drivers.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * USB Packet IDs (PIDs)</span>
<span class="cm"> */</span>
<span class="cp">#define USB_PID_EXT			0xf0	</span><span class="cm">/* USB 2.0 LPM ECN */</span><span class="cp"></span>
<span class="cp">#define USB_PID_OUT			0xe1</span>
<span class="cp">#define USB_PID_ACK			0xd2</span>
<span class="cp">#define USB_PID_DATA0			0xc3</span>
<span class="cp">#define USB_PID_PING			0xb4	</span><span class="cm">/* USB 2.0 */</span><span class="cp"></span>
<span class="cp">#define USB_PID_SOF			0xa5</span>
<span class="cp">#define USB_PID_NYET			0x96	</span><span class="cm">/* USB 2.0 */</span><span class="cp"></span>
<span class="cp">#define USB_PID_DATA2			0x87	</span><span class="cm">/* USB 2.0 */</span><span class="cp"></span>
<span class="cp">#define USB_PID_SPLIT			0x78	</span><span class="cm">/* USB 2.0 */</span><span class="cp"></span>
<span class="cp">#define USB_PID_IN			0x69</span>
<span class="cp">#define USB_PID_NAK			0x5a</span>
<span class="cp">#define USB_PID_DATA1			0x4b</span>
<span class="cp">#define USB_PID_PREAMBLE		0x3c	</span><span class="cm">/* Token mode */</span><span class="cp"></span>
<span class="cp">#define USB_PID_ERR			0x3c	</span><span class="cm">/* USB 2.0: handshake mode */</span><span class="cp"></span>
<span class="cp">#define USB_PID_SETUP			0x2d</span>
<span class="cp">#define USB_PID_STALL			0x1e</span>
<span class="cp">#define USB_PID_MDATA			0x0f	</span><span class="cm">/* USB 2.0 */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * USB Host Controller Driver (usb_hcd) framework</span>
<span class="cm"> *</span>
<span class="cm"> * Since &quot;struct usb_bus&quot; is so thin, you can&#39;t share much code in it.</span>
<span class="cm"> * This framework is a layer over that, and should be more sharable.</span>
<span class="cm"> *</span>
<span class="cm"> * @authorized_default: Specifies if new devices are authorized to</span>
<span class="cm"> *                      connect by default or they require explicit</span>
<span class="cm"> *                      user space authorization; this bit is settable</span>
<span class="cm"> *                      through /sys/class/usb_host/X/authorized_default.</span>
<span class="cm"> *                      For the rest is RO, so we don&#39;t lock to r/w it.</span>
<span class="cm"> */</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * housekeeping</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">usb_bus</span>		<span class="n">self</span><span class="p">;</span>		<span class="cm">/* hcd is-a bus */</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">kref</span><span class="p">;</span>		<span class="cm">/* reference counter */</span>

	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">product_desc</span><span class="p">;</span>	<span class="cm">/* product/vendor string */</span>
	<span class="kt">int</span>			<span class="n">speed</span><span class="p">;</span>		<span class="cm">/* Speed for this roothub.</span>
<span class="cm">						 * May be different from</span>
<span class="cm">						 * hcd-&gt;driver-&gt;flags &amp; HCD_MASK</span>
<span class="cm">						 */</span>
	<span class="kt">char</span>			<span class="n">irq_descr</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>	<span class="cm">/* driver + bus # */</span>

	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">rh_timer</span><span class="p">;</span>	<span class="cm">/* drives root-hub polling */</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">*</span><span class="n">status_urb</span><span class="p">;</span>	<span class="cm">/* the current status urb */</span>
<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">wakeup_work</span><span class="p">;</span>	<span class="cm">/* for remote wakeup */</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * hardware info/state</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>	<span class="cm">/* hw-specific hooks */</span>

	<span class="cm">/* Flags that need to be manipulated atomically because they can</span>
<span class="cm">	 * change while the host controller is running.  Always use</span>
<span class="cm">	 * set_bit() or clear_bit() to change their values.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define HCD_FLAG_HW_ACCESSIBLE		0	</span><span class="cm">/* at full power */</span><span class="cp"></span>
<span class="cp">#define HCD_FLAG_POLL_RH		2	</span><span class="cm">/* poll for rh status? */</span><span class="cp"></span>
<span class="cp">#define HCD_FLAG_POLL_PENDING		3	</span><span class="cm">/* status has changed? */</span><span class="cp"></span>
<span class="cp">#define HCD_FLAG_WAKEUP_PENDING		4	</span><span class="cm">/* root hub is resuming? */</span><span class="cp"></span>
<span class="cp">#define HCD_FLAG_RH_RUNNING		5	</span><span class="cm">/* root hub is running? */</span><span class="cp"></span>
<span class="cp">#define HCD_FLAG_DEAD			6	</span><span class="cm">/* controller has died? */</span><span class="cp"></span>

	<span class="cm">/* The flags can be tested using these macros; they are likely to</span>
<span class="cm">	 * be slightly faster than test_bit().</span>
<span class="cm">	 */</span>
<span class="cp">#define HCD_HW_ACCESSIBLE(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_HW_ACCESSIBLE))</span>
<span class="cp">#define HCD_POLL_RH(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_RH))</span>
<span class="cp">#define HCD_POLL_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_PENDING))</span>
<span class="cp">#define HCD_WAKEUP_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_WAKEUP_PENDING))</span>
<span class="cp">#define HCD_RH_RUNNING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_RH_RUNNING))</span>
<span class="cp">#define HCD_DEAD(hcd)		((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_DEAD))</span>

	<span class="cm">/* Flags that get set only during HCD registration or removal. */</span>
	<span class="kt">unsigned</span>		<span class="n">rh_registered</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span><span class="cm">/* is root hub registered? */</span>
	<span class="kt">unsigned</span>		<span class="n">rh_pollable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* may we poll the root hub? */</span>
	<span class="kt">unsigned</span>		<span class="n">msix_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* driver has MSI-X enabled? */</span>

	<span class="cm">/* The next flag is a stopgap, to be removed when all the HCDs</span>
<span class="cm">	 * support the new root-hub polling mechanism. */</span>
	<span class="kt">unsigned</span>		<span class="n">uses_new_polling</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">wireless</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Wireless USB HCD */</span>
	<span class="kt">unsigned</span>		<span class="n">authorized_default</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">has_tt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Integrated TT in root hub */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>		<span class="cm">/* irq allocated */</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">regs</span><span class="p">;</span>		<span class="cm">/* device memory/io */</span>
	<span class="n">u64</span>			<span class="n">rsrc_start</span><span class="p">;</span>	<span class="cm">/* memory/io resource start */</span>
	<span class="n">u64</span>			<span class="n">rsrc_len</span><span class="p">;</span>	<span class="cm">/* memory/io resource length */</span>
	<span class="kt">unsigned</span>		<span class="n">power_budget</span><span class="p">;</span>	<span class="cm">/* in mA, 0 = no limit */</span>

	<span class="cm">/* bandwidth_mutex should be taken before adding or removing</span>
<span class="cm">	 * any new bus bandwidth constraints:</span>
<span class="cm">	 *   1. Before adding a configuration for a new device.</span>
<span class="cm">	 *   2. Before removing the configuration to put the device into</span>
<span class="cm">	 *      the addressed state.</span>
<span class="cm">	 *   3. Before selecting a different configuration.</span>
<span class="cm">	 *   4. Before selecting an alternate interface setting.</span>
<span class="cm">	 *</span>
<span class="cm">	 * bandwidth_mutex should be dropped after a successful control message</span>
<span class="cm">	 * to the device, or resetting the bandwidth after a failed attempt.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="o">*</span><span class="n">bandwidth_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">shared_hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">primary_hcd</span><span class="p">;</span>


<span class="cp">#define HCD_BUFFER_POOLS	4</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">pool</span><span class="p">[</span><span class="n">HCD_BUFFER_POOLS</span><span class="p">];</span>

	<span class="kt">int</span>			<span class="n">state</span><span class="p">;</span>
<span class="cp">#	define	__ACTIVE		0x01</span>
<span class="cp">#	define	__SUSPEND		0x04</span>
<span class="cp">#	define	__TRANSIENT		0x80</span>

<span class="cp">#	define	HC_STATE_HALT		0</span>
<span class="cp">#	define	HC_STATE_RUNNING	(__ACTIVE)</span>
<span class="cp">#	define	HC_STATE_QUIESCING	(__SUSPEND|__TRANSIENT|__ACTIVE)</span>
<span class="cp">#	define	HC_STATE_RESUMING	(__SUSPEND|__TRANSIENT)</span>
<span class="cp">#	define	HC_STATE_SUSPENDED	(__SUSPEND)</span>

<span class="cp">#define	HC_IS_RUNNING(state) ((state) &amp; __ACTIVE)</span>
<span class="cp">#define	HC_IS_SUSPENDED(state) ((state) &amp; __SUSPEND)</span>

	<span class="cm">/* more shared queuing code would be good; it should support</span>
<span class="cm">	 * smarter scheduling, handle transaction translators, etc;</span>
<span class="cm">	 * input size of periodic table to an interrupt scheduler.</span>
<span class="cm">	 * (ohci 32, uhci 1024, ehci 256/512/1024).</span>
<span class="cm">	 */</span>

	<span class="cm">/* The HC driver&#39;s private data is stored at the end of</span>
<span class="cm">	 * this structure.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hcd_priv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">s64</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/* 2.4 does this a bit differently ... */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="nf">hcd_to_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">hcd</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="nf">bus_to_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_hcd</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">hcd_timeout</span> <span class="p">{</span>	<span class="cm">/* timeouts we allocate */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">timeout_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">timer</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>


<span class="k">struct</span> <span class="n">hc_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">description</span><span class="p">;</span>	<span class="cm">/* &quot;ehci-hcd&quot; etc */</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">product_desc</span><span class="p">;</span>	<span class="cm">/* product/vendor string */</span>
	<span class="kt">size_t</span>		<span class="n">hcd_priv_size</span><span class="p">;</span>	<span class="cm">/* size of private data */</span>

	<span class="cm">/* irq handler */</span>
	<span class="n">irqreturn_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">irq</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define	HCD_MEMORY	0x0001		</span><span class="cm">/* HC regs use memory (else I/O) */</span><span class="cp"></span>
<span class="cp">#define	HCD_LOCAL_MEM	0x0002		</span><span class="cm">/* HC needs local memory */</span><span class="cp"></span>
<span class="cp">#define	HCD_SHARED	0x0004		</span><span class="cm">/* Two (or more) usb_hcds share HW */</span><span class="cp"></span>
<span class="cp">#define	HCD_USB11	0x0010		</span><span class="cm">/* USB 1.1 */</span><span class="cp"></span>
<span class="cp">#define	HCD_USB2	0x0020		</span><span class="cm">/* USB 2.0 */</span><span class="cp"></span>
<span class="cp">#define	HCD_USB3	0x0040		</span><span class="cm">/* USB 3.0 */</span><span class="cp"></span>
<span class="cp">#define	HCD_MASK	0x0070</span>

	<span class="cm">/* called to init HCD and root hub */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/* NOTE:  these suspend/resume calls relate to the HC as</span>
<span class="cm">	 * a whole, not just the root hub; they&#39;re for PCI bus glue.</span>
<span class="cm">	 */</span>
	<span class="cm">/* called after suspending the hub, before entering D3 etc */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">pci_suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">do_wakeup</span><span class="p">);</span>

	<span class="cm">/* called after entering D0 (etc), before resuming the hub */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">pci_resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">hibernated</span><span class="p">);</span>

	<span class="cm">/* cleanly make HCD stop writing memory and doing I/O */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/* shutdown HCD */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/* return current frame number */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_frame_number</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

	<span class="cm">/* manage i/o requests, device state */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">urb_enqueue</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">urb_dequeue</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * (optional) these hooks allow an HCD to override the default DMA</span>
<span class="cm">	 * mapping and unmapping routines.  In general, they shouldn&#39;t be</span>
<span class="cm">	 * necessary unless the host controller has special DMA requirements,</span>
<span class="cm">	 * such as alignment contraints.  If these are not specified, the</span>
<span class="cm">	 * general usb_hcd_(un)?map_urb_for_dma functions will be used instead</span>
<span class="cm">	 * (and it may be a good idea to call these functions in your HCD</span>
<span class="cm">	 * implementation)</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">map_urb_for_dma</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				   <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">unmap_urb_for_dma</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>

	<span class="cm">/* hw synch, freeing endpoint resources that urb_dequeue can&#39;t */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">endpoint_disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* (optional) reset any endpoint state such as sequence number</span>
<span class="cm">	   and current window */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">endpoint_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>

	<span class="cm">/* root hub support */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">hub_status_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">hub_control</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
				<span class="n">u16</span> <span class="n">typeReq</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wValue</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wIndex</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">wLength</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">bus_suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">bus_resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">start_port_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">port_num</span><span class="p">);</span>

		<span class="cm">/* force handover of high-speed port to full-speed companion */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">relinquish_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
		<span class="cm">/* has a port been handed over to a companion? */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">port_handed_over</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

		<span class="cm">/* CLEAR_TT_BUFFER completion callback */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">clear_tt_buffer_complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* xHCI specific functions */</span>
		<span class="cm">/* Called by usb_alloc_dev to alloc HC device structures */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">alloc_dev</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">);</span>
		<span class="cm">/* Called by usb_disconnect to free HC device structures */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">free_dev</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* Change a group of bulk endpoints to support multiple stream IDs */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">alloc_streams</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_streams</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="cm">/* Reverts a group of bulk endpoints back to not using stream IDs.</span>
<span class="cm">	 * Can fail if we run out of memory.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">free_streams</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>

	<span class="cm">/* Bandwidth computation functions */</span>
	<span class="cm">/* Note that add_endpoint() can only be called once per endpoint before</span>
<span class="cm">	 * check_bandwidth() or reset_bandwidth() must be called.</span>
<span class="cm">	 * drop_endpoint() can only be called once per endpoint also.</span>
<span class="cm">	 * A call to xhci_drop_endpoint() followed by a call to</span>
<span class="cm">	 * xhci_add_endpoint() will add the endpoint to the schedule with</span>
<span class="cm">	 * possibly new parameters denoted by a different endpoint descriptor</span>
<span class="cm">	 * in usb_host_endpoint.  A call to xhci_add_endpoint() followed by a</span>
<span class="cm">	 * call to xhci_drop_endpoint() is not allowed.</span>
<span class="cm">	 */</span>
		<span class="cm">/* Allocate endpoint resources and add them to a new schedule */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">add_endpoint</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="p">);</span>
		<span class="cm">/* Drop an endpoint from a new schedule */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">drop_endpoint</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="p">);</span>
		<span class="cm">/* Check that a new hardware configuration, set using</span>
<span class="cm">		 * endpoint_enable and endpoint_disable, does not exceed bus</span>
<span class="cm">		 * bandwidth.  This must be called before any set configuration</span>
<span class="cm">		 * or set interface requests are sent to the device.</span>
<span class="cm">		 */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">check_bandwidth</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">);</span>
		<span class="cm">/* Reset the device schedule to the last known good schedule,</span>
<span class="cm">		 * which was set from a previous successful call to</span>
<span class="cm">		 * check_bandwidth().  This reverts any add_endpoint() and</span>
<span class="cm">		 * drop_endpoint() calls since that last successful call.</span>
<span class="cm">		 * Used for when a check_bandwidth() call fails due to resource</span>
<span class="cm">		 * or bandwidth constraints.</span>
<span class="cm">		 */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">reset_bandwidth</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">);</span>
		<span class="cm">/* Returns the hardware-chosen device address */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">address_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>
		<span class="cm">/* Notifies the HCD after a hub descriptor is fetched.</span>
<span class="cm">		 * Will block.</span>
<span class="cm">		 */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">update_hub_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_tt</span> <span class="o">*</span><span class="n">tt</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">reset_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">);</span>
		<span class="cm">/* Notifies the HCD after a device is connected and its</span>
<span class="cm">		 * address is set</span>
<span class="cm">		 */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">update_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_usb2_hw_lpm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="cm">/* USB 3.0 Link Power Management */</span>
		<span class="cm">/* Returns the USB3 hub-encoded value for the U1/U2 timeout. */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">enable_usb3_lpm_timeout</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">);</span>
		<span class="cm">/* The xHCI host controller can still fail the command to</span>
<span class="cm">		 * disable the LPM timeouts, so this can return an error code.</span>
<span class="cm">		 */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">disable_usb3_lpm_timeout</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">usb3_link_state</span> <span class="n">state</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_link_urb_to_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_check_unlink_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_unlink_urb_from_ep</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_submit_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_unlink_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_giveback_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_map_urb_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_unmap_urb_setup_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_unmap_urb_for_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_flush_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_disable_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_reset_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_synchronize_unlinks</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_alloc_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">new_config</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">old_alt</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">new_alt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_get_frame_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_create_hcd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_name</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_create_shared_hcd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hc_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_name</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">shared_hcd</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">usb_get_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_put_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_is_primary_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_add_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_remove_hcd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">platform_device</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_platform_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">struct</span> <span class="n">pci_dev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_device_id</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hcd_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_pci_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">usb_hcd_pci_pm_ops</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cm">/* pci-ish (pdev null is ok) buffer alloc/mapping support */</span>
<span class="kt">int</span> <span class="n">hcd_buffer_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hcd_buffer_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">hcd_buffer_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
	<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hcd_buffer_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">);</span>

<span class="cm">/* generic bus glue, needed for host controllers that don&#39;t use PCI */</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">usb_hcd_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__hcd</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hc_died</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_poll_rh_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_wakeup_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">hdev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">portnum</span><span class="p">);</span>

<span class="cm">/* The D0/D1 toggle bits ... USE WITH CAUTION (they&#39;re almost hcd-internal) */</span>
<span class="cp">#define usb_gettoggle(dev, ep, out) (((dev)-&gt;toggle[out] &gt;&gt; (ep)) &amp; 1)</span>
<span class="cp">#define	usb_dotoggle(dev, ep, out)  ((dev)-&gt;toggle[out] ^= (1 &lt;&lt; (ep)))</span>
<span class="cp">#define usb_settoggle(dev, ep, out, bit) \</span>
<span class="cp">		((dev)-&gt;toggle[out] = ((dev)-&gt;toggle[out] &amp; ~(1 &lt;&lt; (ep))) | \</span>
<span class="cp">		 ((bit) &lt;&lt; (ep)))</span>

<span class="cm">/* -------------------------------------------------------------------------- */</span>

<span class="cm">/* Enumeration is only for the hub driver, or HCD virtual root hubs */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_alloc_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_new_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">**</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_get_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_destroy_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * HCD Root Hub support</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/usb/ch11.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * As of USB 2.0, full/low speed devices are segregated into trees.</span>
<span class="cm"> * One type grows from USB 1.1 host controllers (OHCI, UHCI etc).</span>
<span class="cm"> * The other type grows from high speed hubs when they connect to</span>
<span class="cm"> * full/low speed devices using &quot;Transaction Translators&quot; (TTs).</span>
<span class="cm"> *</span>
<span class="cm"> * TTs should only be known to the hub driver, and high speed bus</span>
<span class="cm"> * drivers (only EHCI for now).  They affect periodic scheduling and</span>
<span class="cm"> * sometimes control/bulk error recovery.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">usb_device</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">usb_tt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">hub</span><span class="p">;</span>	<span class="cm">/* upstream highspeed hub */</span>
	<span class="kt">int</span>			<span class="n">multi</span><span class="p">;</span>	<span class="cm">/* true means one TT per port */</span>
	<span class="kt">unsigned</span>		<span class="n">think_time</span><span class="p">;</span>	<span class="cm">/* think time in ns */</span>

	<span class="cm">/* for control/bulk error recovery (CLEAR_TT_BUFFER) */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">clear_list</span><span class="p">;</span>	<span class="cm">/* of usb_tt_clear */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">clear_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">usb_tt_clear</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">clear_list</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">tt</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">devinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_hcd</span>		<span class="o">*</span><span class="n">hcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_hub_clear_tt_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_ep0_reinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* (shifted) direction/type/recipient from the USB 2.0 spec, table 9.2 */</span>
<span class="cp">#define DeviceRequest \</span>
<span class="cp">	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_DEVICE)&lt;&lt;8)</span>
<span class="cp">#define DeviceOutRequest \</span>
<span class="cp">	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_DEVICE)&lt;&lt;8)</span>

<span class="cp">#define InterfaceRequest \</span>
<span class="cp">	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)&lt;&lt;8)</span>

<span class="cp">#define EndpointRequest \</span>
<span class="cp">	((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)&lt;&lt;8)</span>
<span class="cp">#define EndpointOutRequest \</span>
<span class="cp">	((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)&lt;&lt;8)</span>

<span class="cm">/* class requests from the USB 2.0 hub spec, table 11-15 */</span>
<span class="cm">/* GetBusState and SetHubDescriptor are optional, omitted */</span>
<span class="cp">#define ClearHubFeature		(0x2000 | USB_REQ_CLEAR_FEATURE)</span>
<span class="cp">#define ClearPortFeature	(0x2300 | USB_REQ_CLEAR_FEATURE)</span>
<span class="cp">#define GetHubDescriptor	(0xa000 | USB_REQ_GET_DESCRIPTOR)</span>
<span class="cp">#define GetHubStatus		(0xa000 | USB_REQ_GET_STATUS)</span>
<span class="cp">#define GetPortStatus		(0xa300 | USB_REQ_GET_STATUS)</span>
<span class="cp">#define SetHubFeature		(0x2000 | USB_REQ_SET_FEATURE)</span>
<span class="cp">#define SetPortFeature		(0x2300 | USB_REQ_SET_FEATURE)</span>


<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* class requests from USB 3.0 hub spec, table 10-5 */</span>
<span class="cp">#define SetHubDepth		(0x3000 | HUB_SET_DEPTH)</span>
<span class="cp">#define GetPortErrorCount	(0x8000 | HUB_GET_PORT_ERR_COUNT)</span>

<span class="cm">/*</span>
<span class="cm"> * Generic bandwidth allocation constants/support</span>
<span class="cm"> */</span>
<span class="cp">#define FRAME_TIME_USECS	1000L</span>
<span class="cp">#define BitTime(bytecount) (7 * 8 * bytecount / 6) </span><span class="cm">/* with integer truncation */</span><span class="cp"></span>
		<span class="cm">/* Trying not to use worst-case bit-stuffing</span>
<span class="cm">		 * of (7/6 * 8 * bytecount) = 9.33 * bytecount */</span>
		<span class="cm">/* bytecount = data payload byte count */</span>

<span class="cp">#define NS_TO_US(ns)	((ns + 500L) / 1000L)</span>
			<span class="cm">/* convert &amp; round nanoseconds to microseconds */</span>


<span class="cm">/*</span>
<span class="cm"> * Full/low speed bandwidth allocation constants/support.</span>
<span class="cm"> */</span>
<span class="cp">#define BW_HOST_DELAY	1000L		</span><span class="cm">/* nanoseconds */</span><span class="cp"></span>
<span class="cp">#define BW_HUB_LS_SETUP	333L		</span><span class="cm">/* nanoseconds */</span><span class="cp"></span>
			<span class="cm">/* 4 full-speed bit times (est.) */</span>

<span class="cp">#define FRAME_TIME_BITS			12000L	</span><span class="cm">/* frame = 1 millisecond */</span><span class="cp"></span>
<span class="cp">#define FRAME_TIME_MAX_BITS_ALLOC	(90L * FRAME_TIME_BITS / 100L)</span>
<span class="cp">#define FRAME_TIME_MAX_USECS_ALLOC	(90L * FRAME_TIME_USECS / 100L)</span>

<span class="cm">/*</span>
<span class="cm"> * Ceiling [nano/micro]seconds (typical) for that many bytes at high speed</span>
<span class="cm"> * ISO is a bit less, no ACK ... from USB 2.0 spec, 5.11.3 (and needed</span>
<span class="cm"> * to preallocate bandwidth)</span>
<span class="cm"> */</span>
<span class="cp">#define USB2_HOST_DELAY	5	</span><span class="cm">/* nsec, guess */</span><span class="cp"></span>
<span class="cp">#define HS_NSECS(bytes) (((55 * 8 * 2083) \</span>
<span class="cp">	+ (2083UL * (3 + BitTime(bytes))))/1000 \</span>
<span class="cp">	+ USB2_HOST_DELAY)</span>
<span class="cp">#define HS_NSECS_ISO(bytes) (((38 * 8 * 2083) \</span>
<span class="cp">	+ (2083UL * (3 + BitTime(bytes))))/1000 \</span>
<span class="cp">	+ USB2_HOST_DELAY)</span>
<span class="cp">#define HS_USECS(bytes)		NS_TO_US(HS_NSECS(bytes))</span>
<span class="cp">#define HS_USECS_ISO(bytes)	NS_TO_US(HS_NSECS_ISO(bytes))</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">usb_calc_bus_time</span><span class="p">(</span><span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_input</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">isoc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytecount</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_set_device_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
		<span class="k">enum</span> <span class="n">usb_device_state</span> <span class="n">new_state</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* exported only within usbcore */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">usb_bus_list</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">usb_bus_list_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">wait_queue_head_t</span> <span class="n">usb_kill_urb_queue</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_find_interface_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">);</span>

<span class="cp">#define usb_endpoint_out(ep_dir)	(!((ep_dir) &amp; USB_DIR_IN))</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_root_hub_lost_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rhdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hcd_bus_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rhdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hcd_bus_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">rhdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_hcd_resume_root_hub</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_hcd</span> <span class="o">*</span><span class="n">hcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_SUSPEND */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)</span>

<span class="k">struct</span> <span class="n">usb_mon_operations</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">urb_submit</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">urb_submit_error</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">urb_complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
	<span class="cm">/* void (*urb_unlink)(struct usb_bus *bus, struct urb *urb); */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_mon_operations</span> <span class="o">*</span><span class="n">mon_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usbmon_urb_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">monitored</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">mon_ops</span><span class="o">-&gt;</span><span class="n">urb_submit</span><span class="p">)(</span><span class="n">bus</span><span class="p">,</span> <span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usbmon_urb_submit_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">monitored</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">mon_ops</span><span class="o">-&gt;</span><span class="n">urb_submit_error</span><span class="p">)(</span><span class="n">bus</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usbmon_urb_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">monitored</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">mon_ops</span><span class="o">-&gt;</span><span class="n">urb_complete</span><span class="p">)(</span><span class="n">bus</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">usb_mon_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_mon_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_mon_deregister</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usbmon_urb_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usbmon_urb_submit_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usbmon_urb_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_USB_MON || CONFIG_USB_MON_MODULE */</span><span class="cp"></span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* random stuff */</span>

<span class="cp">#define	RUN_CONTEXT (in_irq() ? &quot;in_irq&quot; \</span>
<span class="cp">		: (in_interrupt() ? &quot;in_interrupt&quot; : &quot;can sleep&quot;))</span>


<span class="cm">/* This rwsem is for use only by the hub driver and ehci-hcd.</span>
<span class="cm"> * Nobody else should touch it.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">ehci_cf_port_reset_rwsem</span><span class="p">;</span>

<span class="cm">/* Keep track of which host controller drivers are loaded */</span>
<span class="cp">#define USB_UHCI_LOADED		0</span>
<span class="cp">#define USB_OHCI_LOADED		1</span>
<span class="cp">#define USB_EHCI_LOADED		2</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usb_hcds_loaded</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __USB_CORE_HCD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
