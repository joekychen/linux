<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › usb › ehci_def.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ehci_def.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2001-2002 by David Brownell</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software Foundation,</span>
<span class="cm"> * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_USB_EHCI_DEF_H</span>
<span class="cp">#define __LINUX_USB_EHCI_DEF_H</span>

<span class="cm">/* EHCI register interface, corresponds to EHCI Revision 0.95 specification */</span>

<span class="cm">/* Section 2.2 Host Controller Capability Registers */</span>
<span class="k">struct</span> <span class="n">ehci_caps</span> <span class="p">{</span>
	<span class="cm">/* these fields are specified as 8 and 16 bit registers,</span>
<span class="cm">	 * but some hosts can&#39;t perform 8 or 16 bit PCI accesses.</span>
<span class="cm">	 * some hosts treat caplength and hciversion as parts of a 32-bit</span>
<span class="cm">	 * register, others treat them as two separate registers, this</span>
<span class="cm">	 * affects the memory map for big endian controllers.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>		<span class="n">hc_capbase</span><span class="p">;</span>
<span class="cp">#define HC_LENGTH(ehci, p)	(0x00ff&amp;((p) &gt;&gt; </span><span class="cm">/* bits 7:0 / offset 00h */</span><span class="cp"> \</span>
<span class="cp">				(ehci_big_endian_capbase(ehci) ? 24 : 0)))</span>
<span class="cp">#define HC_VERSION(ehci, p)	(0xffff&amp;((p) &gt;&gt; </span><span class="cm">/* bits 31:16 / offset 02h */</span><span class="cp"> \</span>
<span class="cp">				(ehci_big_endian_capbase(ehci) ? 0 : 16)))</span>
	<span class="n">u32</span>		<span class="n">hcs_params</span><span class="p">;</span>     <span class="cm">/* HCSPARAMS - offset 0x4 */</span>
<span class="cp">#define HCS_DEBUG_PORT(p)	(((p)&gt;&gt;20)&amp;0xf)	</span><span class="cm">/* bits 23:20, debug port? */</span><span class="cp"></span>
<span class="cp">#define HCS_INDICATOR(p)	((p)&amp;(1 &lt;&lt; 16))	</span><span class="cm">/* true: has port indicators */</span><span class="cp"></span>
<span class="cp">#define HCS_N_CC(p)		(((p)&gt;&gt;12)&amp;0xf)	</span><span class="cm">/* bits 15:12, #companion HCs */</span><span class="cp"></span>
<span class="cp">#define HCS_N_PCC(p)		(((p)&gt;&gt;8)&amp;0xf)	</span><span class="cm">/* bits 11:8, ports per CC */</span><span class="cp"></span>
<span class="cp">#define HCS_PORTROUTED(p)	((p)&amp;(1 &lt;&lt; 7))	</span><span class="cm">/* true: port routing */</span><span class="cp"></span>
<span class="cp">#define HCS_PPC(p)		((p)&amp;(1 &lt;&lt; 4))	</span><span class="cm">/* true: port power control */</span><span class="cp"></span>
<span class="cp">#define HCS_N_PORTS(p)		(((p)&gt;&gt;0)&amp;0xf)	</span><span class="cm">/* bits 3:0, ports on HC */</span><span class="cp"></span>

	<span class="n">u32</span>		<span class="n">hcc_params</span><span class="p">;</span>      <span class="cm">/* HCCPARAMS - offset 0x8 */</span>
<span class="cm">/* EHCI 1.1 addendum */</span>
<span class="cp">#define HCC_32FRAME_PERIODIC_LIST(p)	((p)&amp;(1 &lt;&lt; 19))</span>
<span class="cp">#define HCC_PER_PORT_CHANGE_EVENT(p)	((p)&amp;(1 &lt;&lt; 18))</span>
<span class="cp">#define HCC_LPM(p)			((p)&amp;(1 &lt;&lt; 17))</span>
<span class="cp">#define HCC_HW_PREFETCH(p)		((p)&amp;(1 &lt;&lt; 16))</span>

<span class="cp">#define HCC_EXT_CAPS(p)		(((p)&gt;&gt;8)&amp;0xff)	</span><span class="cm">/* for pci extended caps */</span><span class="cp"></span>
<span class="cp">#define HCC_ISOC_CACHE(p)       ((p)&amp;(1 &lt;&lt; 7))  </span><span class="cm">/* true: can cache isoc frame */</span><span class="cp"></span>
<span class="cp">#define HCC_ISOC_THRES(p)       (((p)&gt;&gt;4)&amp;0x7)  </span><span class="cm">/* bits 6:4, uframes cached */</span><span class="cp"></span>
<span class="cp">#define HCC_CANPARK(p)		((p)&amp;(1 &lt;&lt; 2))  </span><span class="cm">/* true: can park on async qh */</span><span class="cp"></span>
<span class="cp">#define HCC_PGM_FRAMELISTLEN(p) ((p)&amp;(1 &lt;&lt; 1))  </span><span class="cm">/* true: periodic_size changes*/</span><span class="cp"></span>
<span class="cp">#define HCC_64BIT_ADDR(p)       ((p)&amp;(1))       </span><span class="cm">/* true: can use 64-bit addr */</span><span class="cp"></span>
	<span class="n">u8</span>		<span class="n">portroute</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	 <span class="cm">/* nibbles for routing - offset 0xC */</span>
<span class="p">};</span>


<span class="cm">/* Section 2.3 Host Controller Operational Registers */</span>
<span class="k">struct</span> <span class="n">ehci_regs</span> <span class="p">{</span>

	<span class="cm">/* USBCMD: offset 0x00 */</span>
	<span class="n">u32</span>		<span class="n">command</span><span class="p">;</span>

<span class="cm">/* EHCI 1.1 addendum */</span>
<span class="cp">#define CMD_HIRD	(0xf&lt;&lt;24)	</span><span class="cm">/* host initiated resume duration */</span><span class="cp"></span>
<span class="cp">#define CMD_PPCEE	(1&lt;&lt;15)		</span><span class="cm">/* per port change event enable */</span><span class="cp"></span>
<span class="cp">#define CMD_FSP		(1&lt;&lt;14)		</span><span class="cm">/* fully synchronized prefetch */</span><span class="cp"></span>
<span class="cp">#define CMD_ASPE	(1&lt;&lt;13)		</span><span class="cm">/* async schedule prefetch enable */</span><span class="cp"></span>
<span class="cp">#define CMD_PSPE	(1&lt;&lt;12)		</span><span class="cm">/* periodic schedule prefetch enable */</span><span class="cp"></span>
<span class="cm">/* 23:16 is r/w intr rate, in microframes; default &quot;8&quot; == 1/msec */</span>
<span class="cp">#define CMD_PARK	(1&lt;&lt;11)		</span><span class="cm">/* enable &quot;park&quot; on async qh */</span><span class="cp"></span>
<span class="cp">#define CMD_PARK_CNT(c)	(((c)&gt;&gt;8)&amp;3)	</span><span class="cm">/* how many transfers to park for */</span><span class="cp"></span>
<span class="cp">#define CMD_LRESET	(1&lt;&lt;7)		</span><span class="cm">/* partial reset (no ports, etc) */</span><span class="cp"></span>
<span class="cp">#define CMD_IAAD	(1&lt;&lt;6)		</span><span class="cm">/* &quot;doorbell&quot; interrupt async advance */</span><span class="cp"></span>
<span class="cp">#define CMD_ASE		(1&lt;&lt;5)		</span><span class="cm">/* async schedule enable */</span><span class="cp"></span>
<span class="cp">#define CMD_PSE		(1&lt;&lt;4)		</span><span class="cm">/* periodic schedule enable */</span><span class="cp"></span>
<span class="cm">/* 3:2 is periodic frame list size */</span>
<span class="cp">#define CMD_RESET	(1&lt;&lt;1)		</span><span class="cm">/* reset HC not bus */</span><span class="cp"></span>
<span class="cp">#define CMD_RUN		(1&lt;&lt;0)		</span><span class="cm">/* start/stop HC */</span><span class="cp"></span>

	<span class="cm">/* USBSTS: offset 0x04 */</span>
	<span class="n">u32</span>		<span class="n">status</span><span class="p">;</span>
<span class="cp">#define STS_PPCE_MASK	(0xff&lt;&lt;16)	</span><span class="cm">/* Per-Port change event 1-16 */</span><span class="cp"></span>
<span class="cp">#define STS_ASS		(1&lt;&lt;15)		</span><span class="cm">/* Async Schedule Status */</span><span class="cp"></span>
<span class="cp">#define STS_PSS		(1&lt;&lt;14)		</span><span class="cm">/* Periodic Schedule Status */</span><span class="cp"></span>
<span class="cp">#define STS_RECL	(1&lt;&lt;13)		</span><span class="cm">/* Reclamation */</span><span class="cp"></span>
<span class="cp">#define STS_HALT	(1&lt;&lt;12)		</span><span class="cm">/* Not running (any reason) */</span><span class="cp"></span>
<span class="cm">/* some bits reserved */</span>
	<span class="cm">/* these STS_* flags are also intr_enable bits (USBINTR) */</span>
<span class="cp">#define STS_IAA		(1&lt;&lt;5)		</span><span class="cm">/* Interrupted on async advance */</span><span class="cp"></span>
<span class="cp">#define STS_FATAL	(1&lt;&lt;4)		</span><span class="cm">/* such as some PCI access errors */</span><span class="cp"></span>
<span class="cp">#define STS_FLR		(1&lt;&lt;3)		</span><span class="cm">/* frame list rolled over */</span><span class="cp"></span>
<span class="cp">#define STS_PCD		(1&lt;&lt;2)		</span><span class="cm">/* port change detect */</span><span class="cp"></span>
<span class="cp">#define STS_ERR		(1&lt;&lt;1)		</span><span class="cm">/* &quot;error&quot; completion (overflow, ...) */</span><span class="cp"></span>
<span class="cp">#define STS_INT		(1&lt;&lt;0)		</span><span class="cm">/* &quot;normal&quot; completion (short, ...) */</span><span class="cp"></span>

	<span class="cm">/* USBINTR: offset 0x08 */</span>
	<span class="n">u32</span>		<span class="n">intr_enable</span><span class="p">;</span>

	<span class="cm">/* FRINDEX: offset 0x0C */</span>
	<span class="n">u32</span>		<span class="n">frame_index</span><span class="p">;</span>	<span class="cm">/* current microframe number */</span>
	<span class="cm">/* CTRLDSSEGMENT: offset 0x10 */</span>
	<span class="n">u32</span>		<span class="n">segment</span><span class="p">;</span>	<span class="cm">/* address bits 63:32 if needed */</span>
	<span class="cm">/* PERIODICLISTBASE: offset 0x14 */</span>
	<span class="n">u32</span>		<span class="n">frame_list</span><span class="p">;</span>	<span class="cm">/* points to periodic list */</span>
	<span class="cm">/* ASYNCLISTADDR: offset 0x18 */</span>
	<span class="n">u32</span>		<span class="n">async_next</span><span class="p">;</span>	<span class="cm">/* address of next async queue head */</span>

	<span class="n">u32</span>		<span class="n">reserved</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

	<span class="cm">/* CONFIGFLAG: offset 0x40 */</span>
	<span class="n">u32</span>		<span class="n">configured_flag</span><span class="p">;</span>
<span class="cp">#define FLAG_CF		(1&lt;&lt;0)		</span><span class="cm">/* true: we&#39;ll support &quot;high speed&quot; */</span><span class="cp"></span>

	<span class="cm">/* PORTSC: offset 0x44 */</span>
	<span class="n">u32</span>		<span class="n">port_status</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* up to N_PORTS */</span>
<span class="cm">/* EHCI 1.1 addendum */</span>
<span class="cp">#define PORTSC_SUSPEND_STS_ACK 0</span>
<span class="cp">#define PORTSC_SUSPEND_STS_NYET 1</span>
<span class="cp">#define PORTSC_SUSPEND_STS_STALL 2</span>
<span class="cp">#define PORTSC_SUSPEND_STS_ERR 3</span>

<span class="cp">#define PORT_DEV_ADDR	(0x7f&lt;&lt;25)		</span><span class="cm">/* device address */</span><span class="cp"></span>
<span class="cp">#define PORT_SSTS	(0x3&lt;&lt;23)		</span><span class="cm">/* suspend status */</span><span class="cp"></span>
<span class="cm">/* 31:23 reserved */</span>
<span class="cp">#define PORT_WKOC_E	(1&lt;&lt;22)		</span><span class="cm">/* wake on overcurrent (enable) */</span><span class="cp"></span>
<span class="cp">#define PORT_WKDISC_E	(1&lt;&lt;21)		</span><span class="cm">/* wake on disconnect (enable) */</span><span class="cp"></span>
<span class="cp">#define PORT_WKCONN_E	(1&lt;&lt;20)		</span><span class="cm">/* wake on connect (enable) */</span><span class="cp"></span>
<span class="cm">/* 19:16 for port testing */</span>
<span class="cp">#define PORT_TEST(x)	(((x)&amp;0xf)&lt;&lt;16)	</span><span class="cm">/* Port Test Control */</span><span class="cp"></span>
<span class="cp">#define PORT_TEST_PKT	PORT_TEST(0x4)	</span><span class="cm">/* Port Test Control - packet test */</span><span class="cp"></span>
<span class="cp">#define PORT_TEST_FORCE	PORT_TEST(0x5)	</span><span class="cm">/* Port Test Control - force enable */</span><span class="cp"></span>
<span class="cp">#define PORT_LED_OFF	(0&lt;&lt;14)</span>
<span class="cp">#define PORT_LED_AMBER	(1&lt;&lt;14)</span>
<span class="cp">#define PORT_LED_GREEN	(2&lt;&lt;14)</span>
<span class="cp">#define PORT_LED_MASK	(3&lt;&lt;14)</span>
<span class="cp">#define PORT_OWNER	(1&lt;&lt;13)		</span><span class="cm">/* true: companion hc owns this port */</span><span class="cp"></span>
<span class="cp">#define PORT_POWER	(1&lt;&lt;12)		</span><span class="cm">/* true: has power (see PPC) */</span><span class="cp"></span>
<span class="cp">#define PORT_USB11(x) (((x)&amp;(3&lt;&lt;10)) == (1&lt;&lt;10))	</span><span class="cm">/* USB 1.1 device */</span><span class="cp"></span>
<span class="cm">/* 11:10 for detecting lowspeed devices (reset vs release ownership) */</span>
<span class="cm">/* 9 reserved */</span>
<span class="cp">#define PORT_LPM	(1&lt;&lt;9)		</span><span class="cm">/* LPM transaction */</span><span class="cp"></span>
<span class="cp">#define PORT_RESET	(1&lt;&lt;8)		</span><span class="cm">/* reset port */</span><span class="cp"></span>
<span class="cp">#define PORT_SUSPEND	(1&lt;&lt;7)		</span><span class="cm">/* suspend port */</span><span class="cp"></span>
<span class="cp">#define PORT_RESUME	(1&lt;&lt;6)		</span><span class="cm">/* resume it */</span><span class="cp"></span>
<span class="cp">#define PORT_OCC	(1&lt;&lt;5)		</span><span class="cm">/* over current change */</span><span class="cp"></span>
<span class="cp">#define PORT_OC		(1&lt;&lt;4)		</span><span class="cm">/* over current active */</span><span class="cp"></span>
<span class="cp">#define PORT_PEC	(1&lt;&lt;3)		</span><span class="cm">/* port enable change */</span><span class="cp"></span>
<span class="cp">#define PORT_PE		(1&lt;&lt;2)		</span><span class="cm">/* port enable */</span><span class="cp"></span>
<span class="cp">#define PORT_CSC	(1&lt;&lt;1)		</span><span class="cm">/* connect status change */</span><span class="cp"></span>
<span class="cp">#define PORT_CONNECT	(1&lt;&lt;0)		</span><span class="cm">/* device connected */</span><span class="cp"></span>
<span class="cp">#define PORT_RWC_BITS   (PORT_CSC | PORT_PEC | PORT_OCC)</span>
<span class="p">};</span>

<span class="cp">#define USBMODE		0x68		</span><span class="cm">/* USB Device mode */</span><span class="cp"></span>
<span class="cp">#define USBMODE_SDIS	(1&lt;&lt;3)		</span><span class="cm">/* Stream disable */</span><span class="cp"></span>
<span class="cp">#define USBMODE_BE	(1&lt;&lt;2)		</span><span class="cm">/* BE/LE endianness select */</span><span class="cp"></span>
<span class="cp">#define USBMODE_CM_HC	(3&lt;&lt;0)		</span><span class="cm">/* host controller mode */</span><span class="cp"></span>
<span class="cp">#define USBMODE_CM_IDLE	(0&lt;&lt;0)		</span><span class="cm">/* idle state */</span><span class="cp"></span>

<span class="cm">/* Moorestown has some non-standard registers, partially due to the fact that</span>
<span class="cm"> * its EHCI controller has both TT and LPM support. HOSTPCx are extensions to</span>
<span class="cm"> * PORTSCx</span>
<span class="cm"> */</span>
<span class="cp">#define HOSTPC0		0x84		</span><span class="cm">/* HOSTPC extension */</span><span class="cp"></span>
<span class="cp">#define HOSTPC_PHCD	(1&lt;&lt;22)		</span><span class="cm">/* Phy clock disable */</span><span class="cp"></span>
<span class="cp">#define HOSTPC_PSPD	(3&lt;&lt;25)		</span><span class="cm">/* Port speed detection */</span><span class="cp"></span>
<span class="cp">#define USBMODE_EX	0xc8		</span><span class="cm">/* USB Device mode extension */</span><span class="cp"></span>
<span class="cp">#define USBMODE_EX_VBPS	(1&lt;&lt;5)		</span><span class="cm">/* VBus Power Select On */</span><span class="cp"></span>
<span class="cp">#define USBMODE_EX_HC	(3&lt;&lt;0)		</span><span class="cm">/* host controller mode */</span><span class="cp"></span>
<span class="cp">#define TXFILLTUNING	0x24		</span><span class="cm">/* TX FIFO Tuning register */</span><span class="cp"></span>
<span class="cp">#define TXFIFO_DEFAULT	(8&lt;&lt;16)		</span><span class="cm">/* FIFO burst threshold 8 */</span><span class="cp"></span>

<span class="cm">/* Appendix C, Debug port ... intended for use with special &quot;debug devices&quot;</span>
<span class="cm"> * that can help if there&#39;s no serial console.  (nonstandard enumeration.)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ehci_dbg_port</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">control</span><span class="p">;</span>
<span class="cp">#define DBGP_OWNER	(1&lt;&lt;30)</span>
<span class="cp">#define DBGP_ENABLED	(1&lt;&lt;28)</span>
<span class="cp">#define DBGP_DONE	(1&lt;&lt;16)</span>
<span class="cp">#define DBGP_INUSE	(1&lt;&lt;10)</span>
<span class="cp">#define DBGP_ERRCODE(x)	(((x)&gt;&gt;7)&amp;0x07)</span>
<span class="cp">#	define DBGP_ERR_BAD	1</span>
<span class="cp">#	define DBGP_ERR_SIGNAL	2</span>
<span class="cp">#define DBGP_ERROR	(1&lt;&lt;6)</span>
<span class="cp">#define DBGP_GO		(1&lt;&lt;5)</span>
<span class="cp">#define DBGP_OUT	(1&lt;&lt;4)</span>
<span class="cp">#define DBGP_LEN(x)	(((x)&gt;&gt;0)&amp;0x0f)</span>
	<span class="n">u32</span>	<span class="n">pids</span><span class="p">;</span>
<span class="cp">#define DBGP_PID_GET(x)		(((x)&gt;&gt;16)&amp;0xff)</span>
<span class="cp">#define DBGP_PID_SET(data, tok)	(((data)&lt;&lt;8)|(tok))</span>
	<span class="n">u32</span>	<span class="n">data03</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">data47</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">address</span><span class="p">;</span>
<span class="cp">#define DBGP_EPADDR(dev, ep)	(((dev)&lt;&lt;8)|(ep))</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_EARLY_PRINTK_DBGP</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">early_dbgp_init</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">console</span> <span class="n">early_dbgp_console</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_EARLY_PRINTK_DBGP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_EARLY_PRINTK_DBGP</span>
<span class="cm">/* Call backs from ehci host driver to ehci debug driver */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dbgp_external_startup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dbgp_reset_prep</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dbgp_reset_prep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dbgp_external_startup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_USB_EHCI_DEF_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
