<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › tty.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tty.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_TTY_H</span>
<span class="cp">#define _LINUX_TTY_H</span>

<span class="cm">/*</span>
<span class="cm"> * &#39;tty.h&#39; defines some structures used by tty_io.c and some defines.</span>
<span class="cm"> */</span>

<span class="cp">#define NR_LDISCS		30</span>

<span class="cm">/* line disciplines */</span>
<span class="cp">#define N_TTY		0</span>
<span class="cp">#define N_SLIP		1</span>
<span class="cp">#define N_MOUSE		2</span>
<span class="cp">#define N_PPP		3</span>
<span class="cp">#define N_STRIP		4</span>
<span class="cp">#define N_AX25		5</span>
<span class="cp">#define N_X25		6	</span><span class="cm">/* X.25 async */</span><span class="cp"></span>
<span class="cp">#define N_6PACK		7</span>
<span class="cp">#define N_MASC		8	</span><span class="cm">/* Reserved for Mobitex module &lt;kaz@cafe.net&gt; */</span><span class="cp"></span>
<span class="cp">#define N_R3964		9	</span><span class="cm">/* Reserved for Simatic R3964 module */</span><span class="cp"></span>
<span class="cp">#define N_PROFIBUS_FDL	10	</span><span class="cm">/* Reserved for Profibus */</span><span class="cp"></span>
<span class="cp">#define N_IRDA		11	</span><span class="cm">/* Linux IrDa - http://irda.sourceforge.net/ */</span><span class="cp"></span>
<span class="cp">#define N_SMSBLOCK	12	</span><span class="cm">/* SMS block mode - for talking to GSM data */</span><span class="cp"></span>
				<span class="cm">/* cards about SMS messages */</span>
<span class="cp">#define N_HDLC		13	</span><span class="cm">/* synchronous HDLC */</span><span class="cp"></span>
<span class="cp">#define N_SYNC_PPP	14	</span><span class="cm">/* synchronous PPP */</span><span class="cp"></span>
<span class="cp">#define N_HCI		15	</span><span class="cm">/* Bluetooth HCI UART */</span><span class="cp"></span>
<span class="cp">#define N_GIGASET_M101	16	</span><span class="cm">/* Siemens Gigaset M101 serial DECT adapter */</span><span class="cp"></span>
<span class="cp">#define N_SLCAN		17	</span><span class="cm">/* Serial / USB serial CAN Adaptors */</span><span class="cp"></span>
<span class="cp">#define N_PPS		18	</span><span class="cm">/* Pulse per Second */</span><span class="cp"></span>
<span class="cp">#define N_V253		19	</span><span class="cm">/* Codec control over voice modem */</span><span class="cp"></span>
<span class="cp">#define N_CAIF		20      </span><span class="cm">/* CAIF protocol for talking to modems */</span><span class="cp"></span>
<span class="cp">#define N_GSM0710	21	</span><span class="cm">/* GSM 0710 Mux */</span><span class="cp"></span>
<span class="cp">#define N_TI_WL		22	</span><span class="cm">/* for TI&#39;s WL BT, FM, GPS combo chips */</span><span class="cp"></span>
<span class="cp">#define N_TRACESINK	23	</span><span class="cm">/* Trace data routing for MIPI P1149.7 */</span><span class="cp"></span>
<span class="cp">#define N_TRACEROUTER	24	</span><span class="cm">/* Trace data routing for MIPI P1149.7 */</span><span class="cp"></span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/termios.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/tty_driver.h&gt;</span>
<span class="cp">#include &lt;linux/tty_ldisc.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>



<span class="cm">/*</span>
<span class="cm"> * (Note: the *_driver.minor_start values 1, 64, 128, 192 are</span>
<span class="cm"> * hardcoded at present.)</span>
<span class="cm"> */</span>
<span class="cp">#define NR_UNIX98_PTY_DEFAULT	4096      </span><span class="cm">/* Default maximum for Unix98 ptys */</span><span class="cp"></span>
<span class="cp">#define NR_UNIX98_PTY_RESERVE	1024	  </span><span class="cm">/* Default reserve for main devpts */</span><span class="cp"></span>
<span class="cp">#define NR_UNIX98_PTY_MAX	(1 &lt;&lt; MINORBITS) </span><span class="cm">/* Absolute limit */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This character is the same as _POSIX_VDISABLE: it cannot be used as</span>
<span class="cm"> * a c_cc[] character, but indicates that a particular special character</span>
<span class="cm"> * isn&#39;t in use (eg VINTR has no character etc)</span>
<span class="cm"> */</span>
<span class="cp">#define __DISABLED_CHAR &#39;\0&#39;</span>

<span class="k">struct</span> <span class="n">tty_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_buffer</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">char_buf_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">flag_buf_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">commit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read</span><span class="p">;</span>
	<span class="cm">/* Data points here */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We default to dicing tty buffer allocations to this many characters</span>
<span class="cm"> * in order to avoid multiple page allocations. We know the size of</span>
<span class="cm"> * tty_buffer itself but it must also be taken into account that the</span>
<span class="cm"> * the buffer is 256 byte aligned. See tty_buffer_find for the allocation</span>
<span class="cm"> * logic this must match</span>
<span class="cm"> */</span>

<span class="cp">#define TTY_BUFFER_PAGE	(((PAGE_SIZE - sizeof(struct tty_buffer)) / 2) &amp; ~0xFF)</span>


<span class="k">struct</span> <span class="n">tty_bufhead</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_buffer</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>	<span class="cm">/* Queue head */</span>
	<span class="k">struct</span> <span class="n">tty_buffer</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>	<span class="cm">/* Active buffer */</span>
	<span class="k">struct</span> <span class="n">tty_buffer</span> <span class="o">*</span><span class="n">free</span><span class="p">;</span>	<span class="cm">/* Free queue head */</span>
	<span class="kt">int</span> <span class="n">memory_used</span><span class="p">;</span>		<span class="cm">/* Buffer space used excluding</span>
<span class="cm">								free queue */</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * When a break, frame error, or parity error happens, these codes are</span>
<span class="cm"> * stuffed into the flags buffer.</span>
<span class="cm"> */</span>
<span class="cp">#define TTY_NORMAL	0</span>
<span class="cp">#define TTY_BREAK	1</span>
<span class="cp">#define TTY_FRAME	2</span>
<span class="cp">#define TTY_PARITY	3</span>
<span class="cp">#define TTY_OVERRUN	4</span>

<span class="cp">#define INTR_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VINTR])</span>
<span class="cp">#define QUIT_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VQUIT])</span>
<span class="cp">#define ERASE_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VERASE])</span>
<span class="cp">#define KILL_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VKILL])</span>
<span class="cp">#define EOF_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VEOF])</span>
<span class="cp">#define TIME_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VTIME])</span>
<span class="cp">#define MIN_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VMIN])</span>
<span class="cp">#define SWTC_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VSWTC])</span>
<span class="cp">#define START_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VSTART])</span>
<span class="cp">#define STOP_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VSTOP])</span>
<span class="cp">#define SUSP_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VSUSP])</span>
<span class="cp">#define EOL_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VEOL])</span>
<span class="cp">#define REPRINT_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VREPRINT])</span>
<span class="cp">#define DISCARD_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VDISCARD])</span>
<span class="cp">#define WERASE_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VWERASE])</span>
<span class="cp">#define LNEXT_CHAR(tty)	((tty)-&gt;termios-&gt;c_cc[VLNEXT])</span>
<span class="cp">#define EOL2_CHAR(tty) ((tty)-&gt;termios-&gt;c_cc[VEOL2])</span>

<span class="cp">#define _I_FLAG(tty, f)	((tty)-&gt;termios-&gt;c_iflag &amp; (f))</span>
<span class="cp">#define _O_FLAG(tty, f)	((tty)-&gt;termios-&gt;c_oflag &amp; (f))</span>
<span class="cp">#define _C_FLAG(tty, f)	((tty)-&gt;termios-&gt;c_cflag &amp; (f))</span>
<span class="cp">#define _L_FLAG(tty, f)	((tty)-&gt;termios-&gt;c_lflag &amp; (f))</span>

<span class="cp">#define I_IGNBRK(tty)	_I_FLAG((tty), IGNBRK)</span>
<span class="cp">#define I_BRKINT(tty)	_I_FLAG((tty), BRKINT)</span>
<span class="cp">#define I_IGNPAR(tty)	_I_FLAG((tty), IGNPAR)</span>
<span class="cp">#define I_PARMRK(tty)	_I_FLAG((tty), PARMRK)</span>
<span class="cp">#define I_INPCK(tty)	_I_FLAG((tty), INPCK)</span>
<span class="cp">#define I_ISTRIP(tty)	_I_FLAG((tty), ISTRIP)</span>
<span class="cp">#define I_INLCR(tty)	_I_FLAG((tty), INLCR)</span>
<span class="cp">#define I_IGNCR(tty)	_I_FLAG((tty), IGNCR)</span>
<span class="cp">#define I_ICRNL(tty)	_I_FLAG((tty), ICRNL)</span>
<span class="cp">#define I_IUCLC(tty)	_I_FLAG((tty), IUCLC)</span>
<span class="cp">#define I_IXON(tty)	_I_FLAG((tty), IXON)</span>
<span class="cp">#define I_IXANY(tty)	_I_FLAG((tty), IXANY)</span>
<span class="cp">#define I_IXOFF(tty)	_I_FLAG((tty), IXOFF)</span>
<span class="cp">#define I_IMAXBEL(tty)	_I_FLAG((tty), IMAXBEL)</span>
<span class="cp">#define I_IUTF8(tty)	_I_FLAG((tty), IUTF8)</span>

<span class="cp">#define O_OPOST(tty)	_O_FLAG((tty), OPOST)</span>
<span class="cp">#define O_OLCUC(tty)	_O_FLAG((tty), OLCUC)</span>
<span class="cp">#define O_ONLCR(tty)	_O_FLAG((tty), ONLCR)</span>
<span class="cp">#define O_OCRNL(tty)	_O_FLAG((tty), OCRNL)</span>
<span class="cp">#define O_ONOCR(tty)	_O_FLAG((tty), ONOCR)</span>
<span class="cp">#define O_ONLRET(tty)	_O_FLAG((tty), ONLRET)</span>
<span class="cp">#define O_OFILL(tty)	_O_FLAG((tty), OFILL)</span>
<span class="cp">#define O_OFDEL(tty)	_O_FLAG((tty), OFDEL)</span>
<span class="cp">#define O_NLDLY(tty)	_O_FLAG((tty), NLDLY)</span>
<span class="cp">#define O_CRDLY(tty)	_O_FLAG((tty), CRDLY)</span>
<span class="cp">#define O_TABDLY(tty)	_O_FLAG((tty), TABDLY)</span>
<span class="cp">#define O_BSDLY(tty)	_O_FLAG((tty), BSDLY)</span>
<span class="cp">#define O_VTDLY(tty)	_O_FLAG((tty), VTDLY)</span>
<span class="cp">#define O_FFDLY(tty)	_O_FLAG((tty), FFDLY)</span>

<span class="cp">#define C_BAUD(tty)	_C_FLAG((tty), CBAUD)</span>
<span class="cp">#define C_CSIZE(tty)	_C_FLAG((tty), CSIZE)</span>
<span class="cp">#define C_CSTOPB(tty)	_C_FLAG((tty), CSTOPB)</span>
<span class="cp">#define C_CREAD(tty)	_C_FLAG((tty), CREAD)</span>
<span class="cp">#define C_PARENB(tty)	_C_FLAG((tty), PARENB)</span>
<span class="cp">#define C_PARODD(tty)	_C_FLAG((tty), PARODD)</span>
<span class="cp">#define C_HUPCL(tty)	_C_FLAG((tty), HUPCL)</span>
<span class="cp">#define C_CLOCAL(tty)	_C_FLAG((tty), CLOCAL)</span>
<span class="cp">#define C_CIBAUD(tty)	_C_FLAG((tty), CIBAUD)</span>
<span class="cp">#define C_CRTSCTS(tty)	_C_FLAG((tty), CRTSCTS)</span>

<span class="cp">#define L_ISIG(tty)	_L_FLAG((tty), ISIG)</span>
<span class="cp">#define L_ICANON(tty)	_L_FLAG((tty), ICANON)</span>
<span class="cp">#define L_XCASE(tty)	_L_FLAG((tty), XCASE)</span>
<span class="cp">#define L_ECHO(tty)	_L_FLAG((tty), ECHO)</span>
<span class="cp">#define L_ECHOE(tty)	_L_FLAG((tty), ECHOE)</span>
<span class="cp">#define L_ECHOK(tty)	_L_FLAG((tty), ECHOK)</span>
<span class="cp">#define L_ECHONL(tty)	_L_FLAG((tty), ECHONL)</span>
<span class="cp">#define L_NOFLSH(tty)	_L_FLAG((tty), NOFLSH)</span>
<span class="cp">#define L_TOSTOP(tty)	_L_FLAG((tty), TOSTOP)</span>
<span class="cp">#define L_ECHOCTL(tty)	_L_FLAG((tty), ECHOCTL)</span>
<span class="cp">#define L_ECHOPRT(tty)	_L_FLAG((tty), ECHOPRT)</span>
<span class="cp">#define L_ECHOKE(tty)	_L_FLAG((tty), ECHOKE)</span>
<span class="cp">#define L_FLUSHO(tty)	_L_FLAG((tty), FLUSHO)</span>
<span class="cp">#define L_PENDIN(tty)	_L_FLAG((tty), PENDIN)</span>
<span class="cp">#define L_IEXTEN(tty)	_L_FLAG((tty), IEXTEN)</span>
<span class="cp">#define L_EXTPROC(tty)	_L_FLAG((tty), EXTPROC)</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">signal_struct</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Port level information. Each device keeps its own port level information</span>
<span class="cm"> * so provide a common structure for those ports wanting to use common support</span>
<span class="cm"> * routines.</span>
<span class="cm"> *</span>
<span class="cm"> * The tty port has a different lifetime to the tty so must be kept apart.</span>
<span class="cm"> * In addition be careful as tty -&gt; port mappings are valid for the life</span>
<span class="cm"> * of the tty object but in many cases port -&gt; tty mappings are valid only</span>
<span class="cm"> * until a hangup so don&#39;t use the wrong path.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">tty_port</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="p">{</span>
	<span class="cm">/* Return 1 if the carrier is raised */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">carrier_raised</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
	<span class="cm">/* Control the DTR line */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dtr_rts</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">raise</span><span class="p">);</span>
	<span class="cm">/* Called when the last close completes or a hangup finishes</span>
<span class="cm">	   IFF the port was initialized. Do not use to free resources. Called</span>
<span class="cm">	   under the port mutex to serialize against activate/shutdowns */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">drop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
	<span class="cm">/* Called under the port mutex from tty_port_open, serialized using</span>
<span class="cm">	   the port mutex */</span>
        <span class="cm">/* FIXME: long term getting the tty argument *out* of this would be</span>
<span class="cm">           good for consoles */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">activate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
	<span class="cm">/* Called on the final put of a port */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destruct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="p">};</span>
	
<span class="k">struct</span> <span class="n">tty_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span>	<span class="o">*</span><span class="n">tty</span><span class="p">;</span>		<span class="cm">/* Back pointer */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>	<span class="cm">/* Port operations */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* Lock protecting tty field */</span>
	<span class="kt">int</span>			<span class="n">blocked_open</span><span class="p">;</span>	<span class="cm">/* Waiting to open */</span>
	<span class="kt">int</span>			<span class="n">count</span><span class="p">;</span>		<span class="cm">/* Usage count */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">open_wait</span><span class="p">;</span>	<span class="cm">/* Open waiters */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">close_wait</span><span class="p">;</span>	<span class="cm">/* Close waiters */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">delta_msr_wait</span><span class="p">;</span>	<span class="cm">/* Modem status change */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* TTY flags ASY_*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">console</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* port is a console */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">mutex</span><span class="p">;</span>		<span class="cm">/* Locking */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">buf_mutex</span><span class="p">;</span>	<span class="cm">/* Buffer alloc lock */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">xmit_buf</span><span class="p">;</span>	<span class="cm">/* Optional buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">close_delay</span><span class="p">;</span>	<span class="cm">/* Close port delay */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">closing_wait</span><span class="p">;</span>	<span class="cm">/* Delay for output */</span>
	<span class="kt">int</span>			<span class="n">drain_delay</span><span class="p">;</span>	<span class="cm">/* Set to zero if no pure time</span>
<span class="cm">						   based drain is needed else</span>
<span class="cm">						   set to size of fifo */</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">kref</span><span class="p">;</span>		<span class="cm">/* Ref counter */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Where all of the state associated with a tty is kept while the tty</span>
<span class="cm"> * is open.  Since the termios state should be kept even if the tty</span>
<span class="cm"> * has been closed --- for things like the baud rate, etc --- it is</span>
<span class="cm"> * not stored here, but rather a pointer to the real state is stored</span>
<span class="cm"> * here.  Possible the winsize structure should have the same</span>
<span class="cm"> * treatment, but (1) the default 80x24 is usually right and (2) it&#39;s</span>
<span class="cm"> * most often used by a windowing system, which will set the correct</span>
<span class="cm"> * size each time the window is created or resized anyway.</span>
<span class="cm"> * 						- TYT, 9/14/92</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">tty_operations</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tty_struct</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">magic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Protects ldisc changes: Lock tty not pty */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ldisc_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ldisc</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">termios_mutex</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ctrl_lock</span><span class="p">;</span>
	<span class="cm">/* Termios values are protected by the termios mutex */</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">,</span> <span class="o">*</span><span class="n">termios_locked</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">termiox</span> <span class="o">*</span><span class="n">termiox</span><span class="p">;</span>	<span class="cm">/* May be NULL for unsupported */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">;</span>		<span class="cm">/* Protected by ctrl lock */</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">winsize</span> <span class="n">winsize</span><span class="p">;</span>		<span class="cm">/* termios mutex */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">stopped</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">hw_stopped</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">flow_stopped</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">packet</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">low_latency</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">warned</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ctrl_status</span><span class="p">;</span>	<span class="cm">/* ctrl_lock */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">receive_room</span><span class="p">;</span>	<span class="cm">/* Bytes free for queue */</span>

	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">fasync</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_bufhead</span> <span class="n">buf</span><span class="p">;</span>		<span class="cm">/* Locked internally */</span>
	<span class="kt">int</span> <span class="n">alt_speed</span><span class="p">;</span>		<span class="cm">/* For magic substitution of 38400 bps */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">write_wait</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">read_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">hangup_work</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">disc_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tty_files</span><span class="p">;</span>

<span class="cp">#define N_TTY_BUF_SIZE 4096</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following is data for the N_TTY line discipline.  For</span>
<span class="cm">	 * historical reasons, this is included in the tty structure.</span>
<span class="cm">	 * Mostly locked by the BKL.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">column</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lnext</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">erasing</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">raw</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">real_raw</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">icanon</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">closing</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">echo_overrun</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">minimum_to_wake</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overrun_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_overrun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">process_char_map</span><span class="p">[</span><span class="mi">256</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">read_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read_tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">read_flags</span><span class="p">[</span><span class="n">N_TTY_BUF_SIZE</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">echo_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">echo_pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">echo_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">canon_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">canon_head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">canon_column</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">atomic_read_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">atomic_write_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">output_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">echo_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">write_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_cnt</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">read_lock</span><span class="p">;</span>
	<span class="cm">/* If the tty has a pending do_SAK, queue it here - akpm */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">SAK_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Each of a tty&#39;s open files has private_data pointing to tty_file_private */</span>
<span class="k">struct</span> <span class="n">tty_file_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* tty magic number */</span>
<span class="cp">#define TTY_MAGIC		0x5401</span>

<span class="cm">/*</span>
<span class="cm"> * These bits are used in the flags field of the tty structure.</span>
<span class="cm"> *</span>
<span class="cm"> * So that interrupts won&#39;t be able to mess up the queues,</span>
<span class="cm"> * copy_to_cooked must be atomic with respect to itself, as must</span>
<span class="cm"> * tty-&gt;write.  Thus, you must use the inline functions set_bit() and</span>
<span class="cm"> * clear_bit() to make things atomic.</span>
<span class="cm"> */</span>
<span class="cp">#define TTY_THROTTLED 		0	</span><span class="cm">/* Call unthrottle() at threshold min */</span><span class="cp"></span>
<span class="cp">#define TTY_IO_ERROR 		1	</span><span class="cm">/* Cause an I/O error (may be no ldisc too) */</span><span class="cp"></span>
<span class="cp">#define TTY_OTHER_CLOSED 	2	</span><span class="cm">/* Other side (if any) has closed */</span><span class="cp"></span>
<span class="cp">#define TTY_EXCLUSIVE 		3	</span><span class="cm">/* Exclusive open mode */</span><span class="cp"></span>
<span class="cp">#define TTY_DEBUG 		4	</span><span class="cm">/* Debugging */</span><span class="cp"></span>
<span class="cp">#define TTY_DO_WRITE_WAKEUP 	5	</span><span class="cm">/* Call write_wakeup after queuing new */</span><span class="cp"></span>
<span class="cp">#define TTY_PUSH 		6	</span><span class="cm">/* n_tty private */</span><span class="cp"></span>
<span class="cp">#define TTY_CLOSING 		7	</span><span class="cm">/* -&gt;close() in progress */</span><span class="cp"></span>
<span class="cp">#define TTY_LDISC 		9	</span><span class="cm">/* Line discipline attached */</span><span class="cp"></span>
<span class="cp">#define TTY_LDISC_CHANGING 	10	</span><span class="cm">/* Line discipline changing */</span><span class="cp"></span>
<span class="cp">#define TTY_LDISC_OPEN	 	11	</span><span class="cm">/* Line discipline is open */</span><span class="cp"></span>
<span class="cp">#define TTY_HW_COOK_OUT 	14	</span><span class="cm">/* Hardware can do output cooking */</span><span class="cp"></span>
<span class="cp">#define TTY_HW_COOK_IN 		15	</span><span class="cm">/* Hardware can do input cooking */</span><span class="cp"></span>
<span class="cp">#define TTY_PTY_LOCK 		16	</span><span class="cm">/* pty private */</span><span class="cp"></span>
<span class="cp">#define TTY_NO_WRITE_SPLIT 	17	</span><span class="cm">/* Preserve write boundaries to driver */</span><span class="cp"></span>
<span class="cp">#define TTY_HUPPED 		18	</span><span class="cm">/* Post driver-&gt;hangup() */</span><span class="cp"></span>
<span class="cp">#define TTY_FLUSHING		19	</span><span class="cm">/* Flushing to ldisc in progress */</span><span class="cp"></span>
<span class="cp">#define TTY_FLUSHPENDING	20	</span><span class="cm">/* Queued buffer flush pending */</span><span class="cp"></span>
<span class="cp">#define TTY_HUPPING 		21	</span><span class="cm">/* -&gt;hangup() in progress */</span><span class="cp"></span>

<span class="cp">#define TTY_WRITE_FLUSH(tty) tty_write_flush((tty))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_write_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="n">tty_std_termios</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">console_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vcs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">tty_class</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_kref_get		-	get a tty reference</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *</span>
<span class="cm"> *	Return a new reference to a tty object. The caller must hold</span>
<span class="cm"> *	sufficient locks/counts to ensure that their existing reference cannot</span>
<span class="cm"> *	go away</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">tty_kref_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tty</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_kref_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_paranoia_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">routine</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tty_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_wait_until_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_check_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">stop_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">start_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">tty_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_read_raw_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bufp</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">buflen</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_write_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_put_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_driver_flush_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_do_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">winsize</span> <span class="o">*</span><span class="n">ws</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_driver_remove_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_free_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">is_current_pgrp_orphaned</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">tty_get_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">is_ignored</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_vhangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_vhangup_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_vhangup_self</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_unhangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_hung_up_p</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_SAK</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__do_SAK</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disassociate_ctty</span><span class="p">(</span><span class="kt">int</span> <span class="n">priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">no_tty</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_flush_to_ldisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_buffer_free_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_buffer_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_buffer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">speed_t</span> <span class="n">tty_get_baud_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">speed_t</span> <span class="n">tty_termios_baud_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">speed_t</span> <span class="n">tty_termios_input_baud_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_termios_encode_baud_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">,</span>
						<span class="n">speed_t</span> <span class="n">ibaud</span><span class="p">,</span> <span class="n">speed_t</span> <span class="n">obaud</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_encode_baud_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
						<span class="n">speed_t</span> <span class="n">ibaud</span><span class="p">,</span> <span class="n">speed_t</span> <span class="n">obaud</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_termios_copy_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_termios_hw_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">kt</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">tty_ldisc_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">tty_ldisc_ref_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_ldisc_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tty_ldiscs_proc_fops</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_ldisc_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">tty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_mode_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_perform_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">dev_t</span> <span class="n">tty_devnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">proc_clear_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">get_current_tty</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_default_fops</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">alloc_tty_struct</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_alloc_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_add_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_free_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_tty_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">initialize_tty_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">deinitialize_tty_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty_init_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_init_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_standard_install</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty_pair_get_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty_pair_get_pty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">tty_mutex</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">tty_files_lock</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_write_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_write_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ndelay</span><span class="p">);</span>
<span class="cp">#define tty_is_writelocked(tty)  (mutex_is_locked(&amp;tty-&gt;atomic_write_lock))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_port_alloc_xmit_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_free_xmit_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="nf">tty_port_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty_port_tty_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_tty_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_port_carrier_raised</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_raise_dtr_rts</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_lower_dtr_rts</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_port_block_til_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_port_close_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_close_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_port_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_port_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tty_port_users</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">blocked_open</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_register_ldisc</span><span class="p">(</span><span class="kt">int</span> <span class="n">disc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">new_ldisc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_unregister_ldisc</span><span class="p">(</span><span class="kt">int</span> <span class="n">disc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_set_ldisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ldisc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_ldisc_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">o_tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_ldisc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">o_tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_ldisc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_ldisc_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_ldisc_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cm">/* This last one is just for the tty layer internals and shouldn&#39;t be used elsewhere */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_ldisc_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>


<span class="cm">/* n_tty.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="n">tty_ldisc_N_TTY</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">n_tty_inherit_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>

<span class="cm">/* tty_audit.c */</span>
<span class="cp">#ifdef CONFIG_AUDIT</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_audit_add_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_audit_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_audit_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_audit_tiocsti</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tty_audit_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tty_audit_push_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
			       <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tty_audit_add_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tty_audit_tiocsti</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tty_audit_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tty_audit_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tty_audit_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tty_audit_push_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				      <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sessionid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* tty_io.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">tty_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* tty_ioctl.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">n_tty_ioctl_helper</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">n_tty_compat_ioctl_helper</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* serial.c */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">serial_console_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* pcxx.c */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pcxe_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>

<span class="cm">/* vt.c */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vt_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">vt_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/* tty_mutex.c */</span>
<span class="cm">/* functions for preparation of BKL removal */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__lockfunc</span> <span class="n">tty_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__acquires</span><span class="p">(</span><span class="n">tty_lock</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__lockfunc</span> <span class="n">tty_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__releases</span><span class="p">(</span><span class="n">tty_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * this shall be called only from where BTM is held (like close)</span>
<span class="cm"> *</span>
<span class="cm"> * We need this to ensure nobody waits for us to finish while we are waiting.</span>
<span class="cm"> * Without this we were encountering system stalls.</span>
<span class="cm"> *</span>
<span class="cm"> * This should be indeed removed with BTM removal later.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: BTM required. Nobody is allowed to hold port-&gt;mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tty_wait_until_sent_from_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		<span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tty_unlock</span><span class="p">();</span> <span class="cm">/* tty-&gt;ops-&gt;close holds the BTM, drop it while waiting */</span>
	<span class="n">tty_wait_until_sent</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="n">tty_lock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wait_event_interruptible_tty -- wait for a condition with the tty lock held</span>
<span class="cm"> *</span>
<span class="cm"> * The condition we are waiting for might take a long time to</span>
<span class="cm"> * become true, or might depend on another thread taking the</span>
<span class="cm"> * BTM. In either case, we need to drop the BTM to guarantee</span>
<span class="cm"> * forward progress. This is a leftover from the conversion</span>
<span class="cm"> * from the BKL and should eventually get removed as the BTM</span>
<span class="cm"> * falls out of use.</span>
<span class="cm"> *</span>
<span class="cm"> * Do not use in new code.</span>
<span class="cm"> */</span>
<span class="cp">#define wait_event_interruptible_tty(wq, condition)			\</span>
<span class="cp">({									\</span>
<span class="cp">	int __ret = 0;							\</span>
<span class="cp">	if (!(condition)) {						\</span>
<span class="cp">		__wait_event_interruptible_tty(wq, condition, __ret);	\</span>
<span class="cp">	}								\</span>
<span class="cp">	__ret;								\</span>
<span class="cp">})</span>

<span class="cp">#define __wait_event_interruptible_tty(wq, condition, ret)		\</span>
<span class="cp">do {									\</span>
<span class="cp">	DEFINE_WAIT(__wait);						\</span>
<span class="cp">									\</span>
<span class="cp">	for (;;) {							\</span>
<span class="cp">		prepare_to_wait(&amp;wq, &amp;__wait, TASK_INTERRUPTIBLE);	\</span>
<span class="cp">		if (condition)						\</span>
<span class="cp">			break;						\</span>
<span class="cp">		if (!signal_pending(current)) {				\</span>
<span class="cp">			tty_unlock();					\</span>
<span class="cp">			schedule();					\</span>
<span class="cp">			tty_lock();					\</span>
<span class="cp">			continue;					\</span>
<span class="cp">		}							\</span>
<span class="cp">		ret = -ERESTARTSYS;					\</span>
<span class="cp">		break;							\</span>
<span class="cp">	}								\</span>
<span class="cp">	finish_wait(&amp;wq, &amp;__wait);					\</span>
<span class="cp">} while (0)</span>


<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
