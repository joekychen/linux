<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › fscache-cache.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fscache-cache.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* General filesystem caching backing cache interface</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004-2007 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE!!! See:</span>
<span class="cm"> *</span>
<span class="cm"> *	Documentation/filesystems/caching/backend-api.txt</span>
<span class="cm"> *</span>
<span class="cm"> * for a description of the cache backend interface declared here.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_FSCACHE_CACHE_H</span>
<span class="cp">#define _LINUX_FSCACHE_CACHE_H</span>

<span class="cp">#include &lt;linux/fscache.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cp">#define NR_MAXCACHES BITS_PER_LONG</span>

<span class="k">struct</span> <span class="n">fscache_cache</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fscache_cache_ops</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fscache_object</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fscache_operation</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * cache tag definition</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fscache_cache_tag</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fscache_cache</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>		<span class="cm">/* cache referred to by this tag */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FSCACHE_TAG_RESERVED	0		</span><span class="cm">/* T if tag is reserved for a cache */</span><span class="cp"></span>
	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* tag name */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cache definition</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fscache_cache</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fscache_cache_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fscache_cache_tag</span> <span class="o">*</span><span class="n">tag</span><span class="p">;</span>		<span class="cm">/* tag representing this cache */</span>
	<span class="k">struct</span> <span class="n">kobject</span>		<span class="o">*</span><span class="n">kobj</span><span class="p">;</span>		<span class="cm">/* system representation of this cache */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">link</span><span class="p">;</span>		<span class="cm">/* link in list of caches */</span>
	<span class="kt">size_t</span>			<span class="n">max_index_size</span><span class="p">;</span>	<span class="cm">/* maximum size of index data */</span>
	<span class="kt">char</span>			<span class="n">identifier</span><span class="p">[</span><span class="mi">36</span><span class="p">];</span>	<span class="cm">/* cache label */</span>

	<span class="cm">/* node management */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">op_gc</span><span class="p">;</span>		<span class="cm">/* operation garbage collector */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">object_list</span><span class="p">;</span>	<span class="cm">/* list of data/index objects */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">op_gc_list</span><span class="p">;</span>	<span class="cm">/* list of ops to be deleted */</span>
	<span class="n">spinlock_t</span>		<span class="n">object_list_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">op_gc_list_lock</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">object_count</span><span class="p">;</span>	<span class="cm">/* no. of live objects in this cache */</span>
	<span class="k">struct</span> <span class="n">fscache_object</span>	<span class="o">*</span><span class="n">fsdef</span><span class="p">;</span>		<span class="cm">/* object for the fsdef index */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FSCACHE_IOERROR		0	</span><span class="cm">/* cache stopped on I/O error */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_CACHE_WITHDRAWN	1	</span><span class="cm">/* cache has been withdrawn */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">extern</span> <span class="n">wait_queue_head_t</span> <span class="n">fscache_cache_cleared_wq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * operation to be applied to a cache object</span>
<span class="cm"> * - retrieval initiation operations are done in the context of the process</span>
<span class="cm"> *   that issued them, and not in an async thread pool</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fscache_operation_release_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_operation</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fscache_operation_processor_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_operation</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">fscache_operation</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>		<span class="cm">/* record for async ops */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pend_link</span><span class="p">;</span>	<span class="cm">/* link in object-&gt;pending_ops */</span>
	<span class="k">struct</span> <span class="n">fscache_object</span>	<span class="o">*</span><span class="n">object</span><span class="p">;</span>	<span class="cm">/* object to be operated upon */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FSCACHE_OP_TYPE		0x000f	</span><span class="cm">/* operation type */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OP_ASYNC	0x0001	</span><span class="cm">/* - async op, processor may sleep for disk */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OP_MYTHREAD	0x0002	</span><span class="cm">/* - processing is done be issuing thread, not pool */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OP_WAITING	4	</span><span class="cm">/* cleared when op is woken */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OP_EXCLUSIVE	5	</span><span class="cm">/* exclusive op, other ops must wait */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OP_DEAD		6	</span><span class="cm">/* op is now dead */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OP_DEC_READ_CNT	7	</span><span class="cm">/* decrement object-&gt;n_reads on destruction */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OP_KEEP_FLAGS	0xc0	</span><span class="cm">/* flags to keep when repurposing an op */</span><span class="cp"></span>

	<span class="n">atomic_t</span>		<span class="n">usage</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">debug_id</span><span class="p">;</span>	<span class="cm">/* debugging ID */</span>

	<span class="cm">/* operation processor callback</span>
<span class="cm">	 * - can be NULL if FSCACHE_OP_WAITING is going to be used to perform</span>
<span class="cm">	 *   the op in a non-pool thread */</span>
	<span class="n">fscache_operation_processor_t</span> <span class="n">processor</span><span class="p">;</span>

	<span class="cm">/* operation releaser */</span>
	<span class="n">fscache_operation_release_t</span> <span class="n">release</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">fscache_op_debug_id</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_op_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_enqueue_operation</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_operation</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_put_operation</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_operation</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_operation_init - Do basic initialisation of an operation</span>
<span class="cm"> * @op: The operation to initialise</span>
<span class="cm"> * @release: The release function to assign</span>
<span class="cm"> *</span>
<span class="cm"> * Do basic initialisation of an operation.  The caller must still set flags,</span>
<span class="cm"> * object and processor if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fscache_operation_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_operation</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
					<span class="n">fscache_operation_processor_t</span> <span class="n">processor</span><span class="p">,</span>
					<span class="n">fscache_operation_release_t</span> <span class="n">release</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">fscache_op_work_func</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">debug_id</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fscache_op_debug_id</span><span class="p">);</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">processor</span> <span class="o">=</span> <span class="n">processor</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="n">release</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">pend_link</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * data read operation</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fscache_operation</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">mapping</span><span class="p">;</span>	<span class="cm">/* netfs pages */</span>
	<span class="n">fscache_rw_complete_t</span>	<span class="n">end_io_func</span><span class="p">;</span>	<span class="cm">/* function to call on I/O completion */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">context</span><span class="p">;</span>	<span class="cm">/* netfs read context (pinned) */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">to_do</span><span class="p">;</span>		<span class="cm">/* list of things to be done by the backend */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">start_time</span><span class="p">;</span>	<span class="cm">/* time at which retrieval started */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fscache_page_retrieval_func_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					     <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fscache_pages_retrieval_func_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="o">*</span><span class="n">nr_pages</span><span class="p">,</span>
					      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_get_retrieval - Get an extra reference on a retrieval operation</span>
<span class="cm"> * @op: The retrieval operation to get a reference on</span>
<span class="cm"> *</span>
<span class="cm"> * Get an extra reference on a retrieval operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="nf">fscache_get_retrieval</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">usage</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_enqueue_retrieval - Enqueue a retrieval operation for processing</span>
<span class="cm"> * @op: The retrieval operation affected</span>
<span class="cm"> *</span>
<span class="cm"> * Enqueue a retrieval operation for processing by the FS-Cache thread pool.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fscache_enqueue_retrieval</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fscache_enqueue_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_put_retrieval - Drop a reference to a retrieval operation</span>
<span class="cm"> * @op: The retrieval operation affected</span>
<span class="cm"> *</span>
<span class="cm"> * Drop a reference to a retrieval operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fscache_put_retrieval</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fscache_put_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cached page storage work item</span>
<span class="cm"> * - used to do three things:</span>
<span class="cm"> *   - batch writes to the cache</span>
<span class="cm"> *   - do cache writes asynchronously</span>
<span class="cm"> *   - defer writes until cache object lookup completion</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fscache_storage</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fscache_operation</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">pgoff_t</span>			<span class="n">store_limit</span><span class="p">;</span>	<span class="cm">/* don&#39;t write more than this */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cache operations</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fscache_cache_ops</span> <span class="p">{</span>
	<span class="cm">/* name of cache provider */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* allocate an object record for a cookie */</span>
	<span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_object</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">fscache_cookie</span> <span class="o">*</span><span class="n">cookie</span><span class="p">);</span>

	<span class="cm">/* look up the object for a cookie</span>
<span class="cm">	 * - return -ETIMEDOUT to be requeued</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lookup_object</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* finished looking up */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lookup_complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* increment the usage count on this object (may fail if unmounting) */</span>
	<span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">grab_object</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* pin an object in the cache */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pin_object</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* unpin an object in the cache */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unpin_object</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* store the updated auxiliary data on an object */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">update_object</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* discard the resources pinned by an object and effect retirement if</span>
<span class="cm">	 * necessary */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">drop_object</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* dispose of a reference to an object */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_object</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* sync a cache */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_cache</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">);</span>

	<span class="cm">/* notification that the attributes of a non-index object (such as</span>
<span class="cm">	 * i_size) have changed */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">attr_changed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

	<span class="cm">/* reserve space for an object&#39;s data and associated metadata */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reserve_space</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">);</span>

	<span class="cm">/* request a backing block for a page be read or allocated in the</span>
<span class="cm">	 * cache */</span>
	<span class="n">fscache_page_retrieval_func_t</span> <span class="n">read_or_alloc_page</span><span class="p">;</span>

	<span class="cm">/* request backing blocks for a list of pages be read or allocated in</span>
<span class="cm">	 * the cache */</span>
	<span class="n">fscache_pages_retrieval_func_t</span> <span class="n">read_or_alloc_pages</span><span class="p">;</span>

	<span class="cm">/* request a backing block for a page be allocated in the cache so that</span>
<span class="cm">	 * it can be written directly */</span>
	<span class="n">fscache_page_retrieval_func_t</span> <span class="n">allocate_page</span><span class="p">;</span>

	<span class="cm">/* request backing blocks for pages be allocated in the cache so that</span>
<span class="cm">	 * they can be written directly */</span>
	<span class="n">fscache_pages_retrieval_func_t</span> <span class="n">allocate_pages</span><span class="p">;</span>

	<span class="cm">/* write a page to its backing block in the cache */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_storage</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/* detach backing block from a page (optional)</span>
<span class="cm">	 * - must release the cookie lock before returning</span>
<span class="cm">	 * - may sleep</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">uncache_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/* dissociate a cache from all the pages it was backing */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dissociate_pages</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * data file or index object cookie</span>
<span class="cm"> * - a file will only appear in one cache</span>
<span class="cm"> * - a request to cache a file may or may not be honoured, subject to</span>
<span class="cm"> *   constraints such as disk space</span>
<span class="cm"> * - indices are created on disk just-in-time</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fscache_cookie</span> <span class="p">{</span>
	<span class="n">atomic_t</span>			<span class="n">usage</span><span class="p">;</span>		<span class="cm">/* number of users of this cookie */</span>
	<span class="n">atomic_t</span>			<span class="n">n_children</span><span class="p">;</span>	<span class="cm">/* number of children of this cookie */</span>
	<span class="n">spinlock_t</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="n">stores_lock</span><span class="p">;</span>	<span class="cm">/* lock on page store tree */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>		<span class="n">backing_objects</span><span class="p">;</span> <span class="cm">/* object(s) backing this file/index */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fscache_cookie_def</span>	<span class="o">*</span><span class="n">def</span><span class="p">;</span>		<span class="cm">/* definition */</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span>		<span class="o">*</span><span class="n">parent</span><span class="p">;</span>	<span class="cm">/* parent of this entry */</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">netfs_data</span><span class="p">;</span>	<span class="cm">/* back pointer to netfs */</span>
	<span class="k">struct</span> <span class="n">radix_tree_root</span>		<span class="n">stores</span><span class="p">;</span>		<span class="cm">/* pages to be stored on this cookie */</span>
<span class="cp">#define FSCACHE_COOKIE_PENDING_TAG	0		</span><span class="cm">/* pages tag: pending write to cache */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_COOKIE_STORING_TAG	1		</span><span class="cm">/* pages tag: writing to cache */</span><span class="cp"></span>

	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FSCACHE_COOKIE_LOOKING_UP	0	</span><span class="cm">/* T if non-index cookie being looked up still */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_COOKIE_CREATING		1	</span><span class="cm">/* T if non-index object being created still */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_COOKIE_NO_DATA_YET	2	</span><span class="cm">/* T if new object with no cached data yet */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_COOKIE_PENDING_FILL	3	</span><span class="cm">/* T if pending initial fill on object */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_COOKIE_FILLING		4	</span><span class="cm">/* T if filling object incrementally */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_COOKIE_UNAVAILABLE	5	</span><span class="cm">/* T if cookie is unavailable (error, etc) */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">fscache_cookie</span> <span class="n">fscache_fsdef_index</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * on-disk cache file or index handle</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fscache_object</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">fscache_object_state</span> <span class="p">{</span>
		<span class="n">FSCACHE_OBJECT_INIT</span><span class="p">,</span>		<span class="cm">/* object in initial unbound state */</span>
		<span class="n">FSCACHE_OBJECT_LOOKING_UP</span><span class="p">,</span>	<span class="cm">/* looking up object */</span>
		<span class="n">FSCACHE_OBJECT_CREATING</span><span class="p">,</span>	<span class="cm">/* creating object */</span>

		<span class="cm">/* active states */</span>
		<span class="n">FSCACHE_OBJECT_AVAILABLE</span><span class="p">,</span>	<span class="cm">/* cleaning up object after creation */</span>
		<span class="n">FSCACHE_OBJECT_ACTIVE</span><span class="p">,</span>		<span class="cm">/* object is usable */</span>
		<span class="n">FSCACHE_OBJECT_UPDATING</span><span class="p">,</span>	<span class="cm">/* object is updating */</span>

		<span class="cm">/* terminal states */</span>
		<span class="n">FSCACHE_OBJECT_DYING</span><span class="p">,</span>		<span class="cm">/* object waiting for accessors to finish */</span>
		<span class="n">FSCACHE_OBJECT_LC_DYING</span><span class="p">,</span>	<span class="cm">/* object cleaning up after lookup/create */</span>
		<span class="n">FSCACHE_OBJECT_ABORT_INIT</span><span class="p">,</span>	<span class="cm">/* abort the init state */</span>
		<span class="n">FSCACHE_OBJECT_RELEASING</span><span class="p">,</span>	<span class="cm">/* releasing object */</span>
		<span class="n">FSCACHE_OBJECT_RECYCLING</span><span class="p">,</span>	<span class="cm">/* retiring object */</span>
		<span class="n">FSCACHE_OBJECT_WITHDRAWING</span><span class="p">,</span>	<span class="cm">/* withdrawing object */</span>
		<span class="n">FSCACHE_OBJECT_DEAD</span><span class="p">,</span>		<span class="cm">/* object is now dead */</span>
		<span class="n">FSCACHE_OBJECT__NSTATES</span>
	<span class="p">}</span> <span class="n">state</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">debug_id</span><span class="p">;</span>	<span class="cm">/* debugging ID */</span>
	<span class="kt">int</span>			<span class="n">n_children</span><span class="p">;</span>	<span class="cm">/* number of child objects */</span>
	<span class="kt">int</span>			<span class="n">n_ops</span><span class="p">;</span>		<span class="cm">/* number of ops outstanding on object */</span>
	<span class="kt">int</span>			<span class="n">n_obj_ops</span><span class="p">;</span>	<span class="cm">/* number of object ops outstanding on object */</span>
	<span class="kt">int</span>			<span class="n">n_in_progress</span><span class="p">;</span>	<span class="cm">/* number of ops in progress */</span>
	<span class="kt">int</span>			<span class="n">n_exclusive</span><span class="p">;</span>	<span class="cm">/* number of exclusive ops queued */</span>
	<span class="n">atomic_t</span>		<span class="n">n_reads</span><span class="p">;</span>	<span class="cm">/* number of read ops in progress */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* state and operations lock */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lookup_jif</span><span class="p">;</span>	<span class="cm">/* time at which lookup started */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">event_mask</span><span class="p">;</span>	<span class="cm">/* events this object is interested in */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">events</span><span class="p">;</span>		<span class="cm">/* events to be processed by this object</span>
<span class="cm">						 * (order is important - using fls) */</span>
<span class="cp">#define FSCACHE_OBJECT_EV_REQUEUE	0	</span><span class="cm">/* T if object should be requeued */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_EV_UPDATE	1	</span><span class="cm">/* T if object should be updated */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_EV_CLEARED	2	</span><span class="cm">/* T if accessors all gone */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_EV_ERROR		3	</span><span class="cm">/* T if fatal error occurred during processing */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_EV_RELEASE	4	</span><span class="cm">/* T if netfs requested object release */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_EV_RETIRE	5	</span><span class="cm">/* T if netfs requested object retirement */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_EV_WITHDRAW	6	</span><span class="cm">/* T if cache requested object withdrawal */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_EVENTS_MASK	0x7f	</span><span class="cm">/* mask of all events*/</span><span class="cp"></span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FSCACHE_OBJECT_LOCK		0	</span><span class="cm">/* T if object is busy being processed */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_PENDING_WRITE	1	</span><span class="cm">/* T if object has pending write */</span><span class="cp"></span>
<span class="cp">#define FSCACHE_OBJECT_WAITING		2	</span><span class="cm">/* T if object is waiting on its parent */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">cache_link</span><span class="p">;</span>	<span class="cm">/* link in cache-&gt;object_list */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">cookie_link</span><span class="p">;</span>	<span class="cm">/* link in cookie-&gt;backing_objects */</span>
	<span class="k">struct</span> <span class="n">fscache_cache</span>	<span class="o">*</span><span class="n">cache</span><span class="p">;</span>		<span class="cm">/* cache that supplied this object */</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span>	<span class="o">*</span><span class="n">cookie</span><span class="p">;</span>	<span class="cm">/* netfs&#39;s file/index object */</span>
	<span class="k">struct</span> <span class="n">fscache_object</span>	<span class="o">*</span><span class="n">parent</span><span class="p">;</span>	<span class="cm">/* parent object */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>		<span class="cm">/* attention scheduling record */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dependents</span><span class="p">;</span>	<span class="cm">/* FIFO of dependent objects */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dep_link</span><span class="p">;</span>	<span class="cm">/* link in parent&#39;s dependents list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">pending_ops</span><span class="p">;</span>	<span class="cm">/* unstarted operations on this object */</span>
<span class="cp">#ifdef CONFIG_FSCACHE_OBJECT_LIST</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">objlist_link</span><span class="p">;</span>	<span class="cm">/* link in global object list */</span>
<span class="cp">#endif</span>
	<span class="n">pgoff_t</span>			<span class="n">store_limit</span><span class="p">;</span>	<span class="cm">/* current storage limit */</span>
	<span class="n">loff_t</span>			<span class="n">store_limit_l</span><span class="p">;</span>	<span class="cm">/* current storage limit */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fscache_object_states</span><span class="p">[];</span>

<span class="cp">#define fscache_object_is_active(obj)			      \</span>
<span class="cp">	(!test_bit(FSCACHE_IOERROR, &amp;(obj)-&gt;cache-&gt;flags) &amp;&amp;  \</span>
<span class="cp">	 (obj)-&gt;state &gt;= FSCACHE_OBJECT_AVAILABLE &amp;&amp;	      \</span>
<span class="cp">	 (obj)-&gt;state &lt; FSCACHE_OBJECT_DYING)</span>

<span class="cp">#define fscache_object_is_dead(obj)				\</span>
<span class="cp">	(test_bit(FSCACHE_IOERROR, &amp;(obj)-&gt;cache-&gt;flags) &amp;&amp;	\</span>
<span class="cp">	 (obj)-&gt;state &gt;= FSCACHE_OBJECT_DYING)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_object_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_object_init - Initialise a cache object description</span>
<span class="cm"> * @object: Object description</span>
<span class="cm"> *</span>
<span class="cm"> * Initialise a cache object description to its basic values.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/filesystems/caching/backend-api.txt for a complete</span>
<span class="cm"> * description.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">fscache_object_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fscache_cookie</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">object_count</span><span class="p">);</span>

	<span class="n">object</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FSCACHE_OBJECT_INIT</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">cache_link</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">cookie_link</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">fscache_object_work_func</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">dependents</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">dep_link</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">pending_ops</span><span class="p">);</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">n_children</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">n_ops</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">n_in_progress</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">n_exclusive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">event_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">store_limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">store_limit_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_object_lookup_negative</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_obtained_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FSCACHE_OBJECT_LIST</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_object_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define fscache_object_destroy(object) do {} while(0)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_object_destroyed - Note destruction of an object in a cache</span>
<span class="cm"> * @cache: The cache from which the object came</span>
<span class="cm"> *</span>
<span class="cm"> * Note the destruction and deallocation of an object record in a cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fscache_object_destroyed</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">object_count</span><span class="p">))</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fscache_cache_cleared_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_object_lookup_error - Note an object encountered an error</span>
<span class="cm"> * @object: The object on which the error was encountered</span>
<span class="cm"> *</span>
<span class="cm"> * Note that an object encountered a fatal error (usually an I/O error) and</span>
<span class="cm"> * that it should be withdrawn as soon as possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fscache_object_lookup_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">FSCACHE_OBJECT_EV_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_set_store_limit - Set the maximum size to be stored in an object</span>
<span class="cm"> * @object: The object to set the maximum on</span>
<span class="cm"> * @i_size: The limit to set in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Set the maximum size an object is permitted to reach, implying the highest</span>
<span class="cm"> * byte that may be written.  Intended to be called by the attr_changed() op.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/filesystems/caching/backend-api.txt for a complete</span>
<span class="cm"> * description.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">fscache_set_store_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">store_limit_l</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="n">object</span><span class="o">-&gt;</span><span class="n">store_limit</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span>
		<span class="n">object</span><span class="o">-&gt;</span><span class="n">store_limit</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fscache_end_io - End a retrieval operation on a page</span>
<span class="cm"> * @op: The FS-Cache operation covering the retrieval</span>
<span class="cm"> * @page: The page that was to be fetched</span>
<span class="cm"> * @error: The error code (0 if successful)</span>
<span class="cm"> *</span>
<span class="cm"> * Note the end of an operation to retrieve a page, as covered by a particular</span>
<span class="cm"> * operation record.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fscache_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">end_io_func</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * out-of-line cache backend functions</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">fscache_init_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">fscache_cache_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">idfmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">fscache_add_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">fsdef</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tagname</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_withdraw_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_io_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">pagevec</span> <span class="o">*</span><span class="n">pagevec</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">fscache_object_sleep_till_congested</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeoutp</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">enum</span> <span class="n">fscache_checkaux</span> <span class="n">fscache_check_aux</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					       <span class="kt">uint16_t</span> <span class="n">datalen</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_FSCACHE_CACHE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
