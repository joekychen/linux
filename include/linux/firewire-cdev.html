<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › firewire-cdev.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>firewire-cdev.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Char device interface.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2007  Kristian Hoegsberg &lt;krh@bitplanet.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR</span>
<span class="cm"> * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,</span>
<span class="cm"> * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="cm"> * DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_FIREWIRE_CDEV_H</span>
<span class="cp">#define _LINUX_FIREWIRE_CDEV_H</span>

<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/firewire-constants.h&gt;</span>

<span class="cm">/* available since kernel version 2.6.22 */</span>
<span class="cp">#define FW_CDEV_EVENT_BUS_RESET				0x00</span>
<span class="cp">#define FW_CDEV_EVENT_RESPONSE				0x01</span>
<span class="cp">#define FW_CDEV_EVENT_REQUEST				0x02</span>
<span class="cp">#define FW_CDEV_EVENT_ISO_INTERRUPT			0x03</span>

<span class="cm">/* available since kernel version 2.6.30 */</span>
<span class="cp">#define FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED		0x04</span>
<span class="cp">#define FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED		0x05</span>

<span class="cm">/* available since kernel version 2.6.36 */</span>
<span class="cp">#define FW_CDEV_EVENT_REQUEST2				0x06</span>
<span class="cp">#define FW_CDEV_EVENT_PHY_PACKET_SENT			0x07</span>
<span class="cp">#define FW_CDEV_EVENT_PHY_PACKET_RECEIVED		0x08</span>
<span class="cp">#define FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL	0x09</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_common - Common part of all fw_cdev_event_ types</span>
<span class="cm"> * @closure:	For arbitrary use by userspace</span>
<span class="cm"> * @type:	Discriminates the fw_cdev_event_ types</span>
<span class="cm"> *</span>
<span class="cm"> * This struct may be used to access generic members of all fw_cdev_event_</span>
<span class="cm"> * types regardless of the specific type.</span>
<span class="cm"> *</span>
<span class="cm"> * Data passed in the @closure field for a request will be returned in the</span>
<span class="cm"> * corresponding event.  It is big enough to hold a pointer on all platforms.</span>
<span class="cm"> * The ioctl used to set @closure depends on the @type of event.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_common</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_bus_reset - Sent when a bus reset occurred</span>
<span class="cm"> * @closure:	See &amp;fw_cdev_event_common; set by %FW_CDEV_IOC_GET_INFO ioctl</span>
<span class="cm"> * @type:	See &amp;fw_cdev_event_common; always %FW_CDEV_EVENT_BUS_RESET</span>
<span class="cm"> * @node_id:       New node ID of this node</span>
<span class="cm"> * @local_node_id: Node ID of the local node, i.e. of the controller</span>
<span class="cm"> * @bm_node_id:    Node ID of the bus manager</span>
<span class="cm"> * @irm_node_id:   Node ID of the iso resource manager</span>
<span class="cm"> * @root_node_id:  Node ID of the root node</span>
<span class="cm"> * @generation:    New bus generation</span>
<span class="cm"> *</span>
<span class="cm"> * This event is sent when the bus the device belongs to goes through a bus</span>
<span class="cm"> * reset.  It provides information about the new bus configuration, such as</span>
<span class="cm"> * new node ID for this device, new root ID, and others.</span>
<span class="cm"> *</span>
<span class="cm"> * If @bm_node_id is 0xffff right after bus reset it can be reread by an</span>
<span class="cm"> * %FW_CDEV_IOC_GET_INFO ioctl after bus manager selection was finished.</span>
<span class="cm"> * Kernels with ABI version &lt; 4 do not set @bm_node_id.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_bus_reset</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">node_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">local_node_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">bm_node_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">irm_node_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">root_node_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">generation</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_response - Sent when a response packet was received</span>
<span class="cm"> * @closure:	See &amp;fw_cdev_event_common; set by %FW_CDEV_IOC_SEND_REQUEST</span>
<span class="cm"> *		or %FW_CDEV_IOC_SEND_BROADCAST_REQUEST</span>
<span class="cm"> *		or %FW_CDEV_IOC_SEND_STREAM_PACKET ioctl</span>
<span class="cm"> * @type:	See &amp;fw_cdev_event_common; always %FW_CDEV_EVENT_RESPONSE</span>
<span class="cm"> * @rcode:	Response code returned by the remote node</span>
<span class="cm"> * @length:	Data length, i.e. the response&#39;s payload size in bytes</span>
<span class="cm"> * @data:	Payload data, if any</span>
<span class="cm"> *</span>
<span class="cm"> * This event is sent when the stack receives a response to an outgoing request</span>
<span class="cm"> * sent by %FW_CDEV_IOC_SEND_REQUEST ioctl.  The payload data for responses</span>
<span class="cm"> * carrying data (read and lock responses) follows immediately and can be</span>
<span class="cm"> * accessed through the @data field.</span>
<span class="cm"> *</span>
<span class="cm"> * The event is also generated after conclusions of transactions that do not</span>
<span class="cm"> * involve response packets.  This includes unified write transactions,</span>
<span class="cm"> * broadcast write transactions, and transmission of asynchronous stream</span>
<span class="cm"> * packets.  @rcode indicates success or failure of such transmissions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_response</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">rcode</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_request - Old version of &amp;fw_cdev_event_request2</span>
<span class="cm"> * @type:	See &amp;fw_cdev_event_common; always %FW_CDEV_EVENT_REQUEST</span>
<span class="cm"> *</span>
<span class="cm"> * This event is sent instead of &amp;fw_cdev_event_request2 if the kernel or</span>
<span class="cm"> * the client implements ABI version &lt;= 3.  &amp;fw_cdev_event_request lacks</span>
<span class="cm"> * essential information; use &amp;fw_cdev_event_request2 instead.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_request</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tcode</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_request2 - Sent on incoming request to an address region</span>
<span class="cm"> * @closure:	See &amp;fw_cdev_event_common; set by %FW_CDEV_IOC_ALLOCATE ioctl</span>
<span class="cm"> * @type:	See &amp;fw_cdev_event_common; always %FW_CDEV_EVENT_REQUEST2</span>
<span class="cm"> * @tcode:	Transaction code of the incoming request</span>
<span class="cm"> * @offset:	The offset into the 48-bit per-node address space</span>
<span class="cm"> * @source_node_id: Sender node ID</span>
<span class="cm"> * @destination_node_id: Destination node ID</span>
<span class="cm"> * @card:	The index of the card from which the request came</span>
<span class="cm"> * @generation:	Bus generation in which the request is valid</span>
<span class="cm"> * @handle:	Reference to the kernel-side pending request</span>
<span class="cm"> * @length:	Data length, i.e. the request&#39;s payload size in bytes</span>
<span class="cm"> * @data:	Incoming data, if any</span>
<span class="cm"> *</span>
<span class="cm"> * This event is sent when the stack receives an incoming request to an address</span>
<span class="cm"> * region registered using the %FW_CDEV_IOC_ALLOCATE ioctl.  The request is</span>
<span class="cm"> * guaranteed to be completely contained in the specified region.  Userspace is</span>
<span class="cm"> * responsible for sending the response by %FW_CDEV_IOC_SEND_RESPONSE ioctl,</span>
<span class="cm"> * using the same @handle.</span>
<span class="cm"> *</span>
<span class="cm"> * The payload data for requests carrying data (write and lock requests)</span>
<span class="cm"> * follows immediately and can be accessed through the @data field.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike &amp;fw_cdev_event_request, @tcode of lock requests is one of the</span>
<span class="cm"> * firewire-core specific %TCODE_LOCK_MASK_SWAP...%TCODE_LOCK_VENDOR_DEPENDENT,</span>
<span class="cm"> * i.e. encodes the extended transaction code.</span>
<span class="cm"> *</span>
<span class="cm"> * @card may differ from &amp;fw_cdev_get_info.card because requests are received</span>
<span class="cm"> * from all cards of the Linux host.  @source_node_id, @destination_node_id, and</span>
<span class="cm"> * @generation pertain to that card.  Destination node ID and bus generation may</span>
<span class="cm"> * therefore differ from the corresponding fields of the last</span>
<span class="cm"> * &amp;fw_cdev_event_bus_reset.</span>
<span class="cm"> *</span>
<span class="cm"> * @destination_node_id may also differ from the current node ID because of a</span>
<span class="cm"> * non-local bus ID part or in case of a broadcast write request.  Note, a</span>
<span class="cm"> * client must call an %FW_CDEV_IOC_SEND_RESPONSE ioctl even in case of a</span>
<span class="cm"> * broadcast write request; the kernel will then release the kernel-side pending</span>
<span class="cm"> * request but will not actually send a response packet.</span>
<span class="cm"> *</span>
<span class="cm"> * In case of a write request to FCP_REQUEST or FCP_RESPONSE, the kernel already</span>
<span class="cm"> * sent a write response immediately after the request was received; in this</span>
<span class="cm"> * case the client must still call an %FW_CDEV_IOC_SEND_RESPONSE ioctl to</span>
<span class="cm"> * release the kernel-side pending request, though another response won&#39;t be</span>
<span class="cm"> * sent.</span>
<span class="cm"> *</span>
<span class="cm"> * If the client subsequently needs to initiate requests to the sender node of</span>
<span class="cm"> * an &amp;fw_cdev_event_request2, it needs to use a device file with matching</span>
<span class="cm"> * card index, node ID, and generation for outbound requests.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_request2</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tcode</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">source_node_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">destination_node_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">card</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">generation</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_iso_interrupt - Sent when an iso packet was completed</span>
<span class="cm"> * @closure:	See &amp;fw_cdev_event_common;</span>
<span class="cm"> *		set by %FW_CDEV_CREATE_ISO_CONTEXT ioctl</span>
<span class="cm"> * @type:	See &amp;fw_cdev_event_common; always %FW_CDEV_EVENT_ISO_INTERRUPT</span>
<span class="cm"> * @cycle:	Cycle counter of the last completed packet</span>
<span class="cm"> * @header_length: Total length of following headers, in bytes</span>
<span class="cm"> * @header:	Stripped headers, if any</span>
<span class="cm"> *</span>
<span class="cm"> * This event is sent when the controller has completed an &amp;fw_cdev_iso_packet</span>
<span class="cm"> * with the %FW_CDEV_ISO_INTERRUPT bit set, when explicitly requested with</span>
<span class="cm"> * %FW_CDEV_IOC_FLUSH_ISO, or when there have been so many completed packets</span>
<span class="cm"> * without the interrupt bit set that the kernel&#39;s internal buffer for @header</span>
<span class="cm"> * is about to overflow.  (In the last case, kernels with ABI version &lt; 5 drop</span>
<span class="cm"> * header data up to the next interrupt packet.)</span>
<span class="cm"> *</span>
<span class="cm"> * Isochronous transmit events (context type %FW_CDEV_ISO_CONTEXT_TRANSMIT):</span>
<span class="cm"> *</span>
<span class="cm"> * In version 3 and some implementations of version 2 of the ABI, &amp;header_length</span>
<span class="cm"> * is a multiple of 4 and &amp;header contains timestamps of all packets up until</span>
<span class="cm"> * the interrupt packet.  The format of the timestamps is as described below for</span>
<span class="cm"> * isochronous reception.  In version 1 of the ABI, &amp;header_length was 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Isochronous receive events (context type %FW_CDEV_ISO_CONTEXT_RECEIVE):</span>
<span class="cm"> *</span>
<span class="cm"> * The headers stripped of all packets up until and including the interrupt</span>
<span class="cm"> * packet are returned in the @header field.  The amount of header data per</span>
<span class="cm"> * packet is as specified at iso context creation by</span>
<span class="cm"> * &amp;fw_cdev_create_iso_context.header_size.</span>
<span class="cm"> *</span>
<span class="cm"> * Hence, _interrupt.header_length / _context.header_size is the number of</span>
<span class="cm"> * packets received in this interrupt event.  The client can now iterate</span>
<span class="cm"> * through the mmap()&#39;ed DMA buffer according to this number of packets and</span>
<span class="cm"> * to the buffer sizes as the client specified in &amp;fw_cdev_queue_iso.</span>
<span class="cm"> *</span>
<span class="cm"> * Since version 2 of this ABI, the portion for each packet in _interrupt.header</span>
<span class="cm"> * consists of the 1394 isochronous packet header, followed by a timestamp</span>
<span class="cm"> * quadlet if &amp;fw_cdev_create_iso_context.header_size &gt; 4, followed by quadlets</span>
<span class="cm"> * from the packet payload if &amp;fw_cdev_create_iso_context.header_size &gt; 8.</span>
<span class="cm"> *</span>
<span class="cm"> * Format of 1394 iso packet header:  16 bits data_length, 2 bits tag, 6 bits</span>
<span class="cm"> * channel, 4 bits tcode, 4 bits sy, in big endian byte order.</span>
<span class="cm"> * data_length is the actual received size of the packet without the four</span>
<span class="cm"> * 1394 iso packet header bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * Format of timestamp:  16 bits invalid, 3 bits cycleSeconds, 13 bits</span>
<span class="cm"> * cycleCount, in big endian byte order.</span>
<span class="cm"> *</span>
<span class="cm"> * In version 1 of the ABI, no timestamp quadlet was inserted; instead, payload</span>
<span class="cm"> * data followed directly after the 1394 is header if header_size &gt; 4.</span>
<span class="cm"> * Behaviour of ver. 1 of this ABI is no longer available since ABI ver. 2.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_iso_interrupt</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">cycle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_iso_interrupt_mc - An iso buffer chunk was completed</span>
<span class="cm"> * @closure:	See &amp;fw_cdev_event_common;</span>
<span class="cm"> *		set by %FW_CDEV_CREATE_ISO_CONTEXT ioctl</span>
<span class="cm"> * @type:	%FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL</span>
<span class="cm"> * @completed:	Offset into the receive buffer; data before this offset is valid</span>
<span class="cm"> *</span>
<span class="cm"> * This event is sent in multichannel contexts (context type</span>
<span class="cm"> * %FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL) for &amp;fw_cdev_iso_packet buffer</span>
<span class="cm"> * chunks that have been completely filled and that have the</span>
<span class="cm"> * %FW_CDEV_ISO_INTERRUPT bit set, or when explicitly requested with</span>
<span class="cm"> * %FW_CDEV_IOC_FLUSH_ISO.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer is continuously filled with the following data, per packet:</span>
<span class="cm"> *  - the 1394 iso packet header as described at &amp;fw_cdev_event_iso_interrupt,</span>
<span class="cm"> *    but in little endian byte order,</span>
<span class="cm"> *  - packet payload (as many bytes as specified in the data_length field of</span>
<span class="cm"> *    the 1394 iso packet header) in big endian byte order,</span>
<span class="cm"> *  - 0...3 padding bytes as needed to align the following trailer quadlet,</span>
<span class="cm"> *  - trailer quadlet, containing the reception timestamp as described at</span>
<span class="cm"> *    &amp;fw_cdev_event_iso_interrupt, but in little endian byte order.</span>
<span class="cm"> *</span>
<span class="cm"> * Hence the per-packet size is data_length (rounded up to a multiple of 4) + 8.</span>
<span class="cm"> * When processing the data, stop before a packet that would cross the</span>
<span class="cm"> * @completed offset.</span>
<span class="cm"> *</span>
<span class="cm"> * A packet near the end of a buffer chunk will typically spill over into the</span>
<span class="cm"> * next queued buffer chunk.  It is the responsibility of the client to check</span>
<span class="cm"> * for this condition, assemble a broken-up packet from its parts, and not to</span>
<span class="cm"> * re-queue any buffer chunks in which as yet unread packet parts reside.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_iso_interrupt_mc</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">completed</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_iso_resource - Iso resources were allocated or freed</span>
<span class="cm"> * @closure:	See &amp;fw_cdev_event_common;</span>
<span class="cm"> *		set by %FW_CDEV_IOC_(DE)ALLOCATE_ISO_RESOURCE(_ONCE) ioctl</span>
<span class="cm"> * @type:	%FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED or</span>
<span class="cm"> *		%FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED</span>
<span class="cm"> * @handle:	Reference by which an allocated resource can be deallocated</span>
<span class="cm"> * @channel:	Isochronous channel which was (de)allocated, if any</span>
<span class="cm"> * @bandwidth:	Bandwidth allocation units which were (de)allocated, if any</span>
<span class="cm"> *</span>
<span class="cm"> * An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED event is sent after an isochronous</span>
<span class="cm"> * resource was allocated at the IRM.  The client has to check @channel and</span>
<span class="cm"> * @bandwidth for whether the allocation actually succeeded.</span>
<span class="cm"> *</span>
<span class="cm"> * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event is sent after an isochronous</span>
<span class="cm"> * resource was deallocated at the IRM.  It is also sent when automatic</span>
<span class="cm"> * reallocation after a bus reset failed.</span>
<span class="cm"> *</span>
<span class="cm"> * @channel is &lt;0 if no channel was (de)allocated or if reallocation failed.</span>
<span class="cm"> * @bandwidth is 0 if no bandwidth was (de)allocated or if reallocation failed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_iso_resource</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">bandwidth</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_event_phy_packet - A PHY packet was transmitted or received</span>
<span class="cm"> * @closure:	See &amp;fw_cdev_event_common; set by %FW_CDEV_IOC_SEND_PHY_PACKET</span>
<span class="cm"> *		or %FW_CDEV_IOC_RECEIVE_PHY_PACKETS ioctl</span>
<span class="cm"> * @type:	%FW_CDEV_EVENT_PHY_PACKET_SENT or %..._RECEIVED</span>
<span class="cm"> * @rcode:	%RCODE_..., indicates success or failure of transmission</span>
<span class="cm"> * @length:	Data length in bytes</span>
<span class="cm"> * @data:	Incoming data</span>
<span class="cm"> *</span>
<span class="cm"> * If @type is %FW_CDEV_EVENT_PHY_PACKET_SENT, @length is 0 and @data empty,</span>
<span class="cm"> * except in case of a ping packet:  Then, @length is 4, and @data[0] is the</span>
<span class="cm"> * ping time in 49.152MHz clocks if @rcode is %RCODE_COMPLETE.</span>
<span class="cm"> *</span>
<span class="cm"> * If @type is %FW_CDEV_EVENT_PHY_PACKET_RECEIVED, @length is 8 and @data</span>
<span class="cm"> * consists of the two PHY packet quadlets, in host byte order.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_event_phy_packet</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">rcode</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * union fw_cdev_event - Convenience union of fw_cdev_event_ types</span>
<span class="cm"> * @common:		Valid for all types</span>
<span class="cm"> * @bus_reset:		Valid if @common.type == %FW_CDEV_EVENT_BUS_RESET</span>
<span class="cm"> * @response:		Valid if @common.type == %FW_CDEV_EVENT_RESPONSE</span>
<span class="cm"> * @request:		Valid if @common.type == %FW_CDEV_EVENT_REQUEST</span>
<span class="cm"> * @request2:		Valid if @common.type == %FW_CDEV_EVENT_REQUEST2</span>
<span class="cm"> * @iso_interrupt:	Valid if @common.type == %FW_CDEV_EVENT_ISO_INTERRUPT</span>
<span class="cm"> * @iso_interrupt_mc:	Valid if @common.type ==</span>
<span class="cm"> *				%FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL</span>
<span class="cm"> * @iso_resource:	Valid if @common.type ==</span>
<span class="cm"> *				%FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED or</span>
<span class="cm"> *				%FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED</span>
<span class="cm"> * @phy_packet:		Valid if @common.type ==</span>
<span class="cm"> *				%FW_CDEV_EVENT_PHY_PACKET_SENT or</span>
<span class="cm"> *				%FW_CDEV_EVENT_PHY_PACKET_RECEIVED</span>
<span class="cm"> *</span>
<span class="cm"> * Convenience union for userspace use.  Events could be read(2) into an</span>
<span class="cm"> * appropriately aligned char buffer and then cast to this union for further</span>
<span class="cm"> * processing.  Note that for a request, response or iso_interrupt event,</span>
<span class="cm"> * the data[] or header[] may make the size of the full event larger than</span>
<span class="cm"> * sizeof(union fw_cdev_event).  Also note that if you attempt to read(2)</span>
<span class="cm"> * an event into a buffer that is not large enough for it, the data that does</span>
<span class="cm"> * not fit will be discarded so that the next read(2) will return a new event.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">fw_cdev_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_common</span>		<span class="n">common</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_bus_reset</span>		<span class="n">bus_reset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_response</span>		<span class="n">response</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_request</span>		<span class="n">request</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_request2</span>		<span class="n">request2</span><span class="p">;</span>		<span class="cm">/* added in 2.6.36 */</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_iso_interrupt</span>	<span class="n">iso_interrupt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_iso_interrupt_mc</span>	<span class="n">iso_interrupt_mc</span><span class="p">;</span>	<span class="cm">/* added in 2.6.36 */</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_iso_resource</span>	<span class="n">iso_resource</span><span class="p">;</span>		<span class="cm">/* added in 2.6.30 */</span>
	<span class="k">struct</span> <span class="n">fw_cdev_event_phy_packet</span>		<span class="n">phy_packet</span><span class="p">;</span>		<span class="cm">/* added in 2.6.36 */</span>
<span class="p">};</span>

<span class="cm">/* available since kernel version 2.6.22 */</span>
<span class="cp">#define FW_CDEV_IOC_GET_INFO           _IOWR(&#39;#&#39;, 0x00, struct fw_cdev_get_info)</span>
<span class="cp">#define FW_CDEV_IOC_SEND_REQUEST        _IOW(&#39;#&#39;, 0x01, struct fw_cdev_send_request)</span>
<span class="cp">#define FW_CDEV_IOC_ALLOCATE           _IOWR(&#39;#&#39;, 0x02, struct fw_cdev_allocate)</span>
<span class="cp">#define FW_CDEV_IOC_DEALLOCATE          _IOW(&#39;#&#39;, 0x03, struct fw_cdev_deallocate)</span>
<span class="cp">#define FW_CDEV_IOC_SEND_RESPONSE       _IOW(&#39;#&#39;, 0x04, struct fw_cdev_send_response)</span>
<span class="cp">#define FW_CDEV_IOC_INITIATE_BUS_RESET  _IOW(&#39;#&#39;, 0x05, struct fw_cdev_initiate_bus_reset)</span>
<span class="cp">#define FW_CDEV_IOC_ADD_DESCRIPTOR     _IOWR(&#39;#&#39;, 0x06, struct fw_cdev_add_descriptor)</span>
<span class="cp">#define FW_CDEV_IOC_REMOVE_DESCRIPTOR   _IOW(&#39;#&#39;, 0x07, struct fw_cdev_remove_descriptor)</span>
<span class="cp">#define FW_CDEV_IOC_CREATE_ISO_CONTEXT _IOWR(&#39;#&#39;, 0x08, struct fw_cdev_create_iso_context)</span>
<span class="cp">#define FW_CDEV_IOC_QUEUE_ISO          _IOWR(&#39;#&#39;, 0x09, struct fw_cdev_queue_iso)</span>
<span class="cp">#define FW_CDEV_IOC_START_ISO           _IOW(&#39;#&#39;, 0x0a, struct fw_cdev_start_iso)</span>
<span class="cp">#define FW_CDEV_IOC_STOP_ISO            _IOW(&#39;#&#39;, 0x0b, struct fw_cdev_stop_iso)</span>

<span class="cm">/* available since kernel version 2.6.24 */</span>
<span class="cp">#define FW_CDEV_IOC_GET_CYCLE_TIMER     _IOR(&#39;#&#39;, 0x0c, struct fw_cdev_get_cycle_timer)</span>

<span class="cm">/* available since kernel version 2.6.30 */</span>
<span class="cp">#define FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE       _IOWR(&#39;#&#39;, 0x0d, struct fw_cdev_allocate_iso_resource)</span>
<span class="cp">#define FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE      _IOW(&#39;#&#39;, 0x0e, struct fw_cdev_deallocate)</span>
<span class="cp">#define FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE   _IOW(&#39;#&#39;, 0x0f, struct fw_cdev_allocate_iso_resource)</span>
<span class="cp">#define FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE_ONCE _IOW(&#39;#&#39;, 0x10, struct fw_cdev_allocate_iso_resource)</span>
<span class="cp">#define FW_CDEV_IOC_GET_SPEED                     _IO(&#39;#&#39;, 0x11) </span><span class="cm">/* returns speed code */</span><span class="cp"></span>
<span class="cp">#define FW_CDEV_IOC_SEND_BROADCAST_REQUEST       _IOW(&#39;#&#39;, 0x12, struct fw_cdev_send_request)</span>
<span class="cp">#define FW_CDEV_IOC_SEND_STREAM_PACKET           _IOW(&#39;#&#39;, 0x13, struct fw_cdev_send_stream_packet)</span>

<span class="cm">/* available since kernel version 2.6.34 */</span>
<span class="cp">#define FW_CDEV_IOC_GET_CYCLE_TIMER2   _IOWR(&#39;#&#39;, 0x14, struct fw_cdev_get_cycle_timer2)</span>

<span class="cm">/* available since kernel version 2.6.36 */</span>
<span class="cp">#define FW_CDEV_IOC_SEND_PHY_PACKET    _IOWR(&#39;#&#39;, 0x15, struct fw_cdev_send_phy_packet)</span>
<span class="cp">#define FW_CDEV_IOC_RECEIVE_PHY_PACKETS _IOW(&#39;#&#39;, 0x16, struct fw_cdev_receive_phy_packets)</span>
<span class="cp">#define FW_CDEV_IOC_SET_ISO_CHANNELS    _IOW(&#39;#&#39;, 0x17, struct fw_cdev_set_iso_channels)</span>

<span class="cm">/* available since kernel version 3.4 */</span>
<span class="cp">#define FW_CDEV_IOC_FLUSH_ISO           _IOW(&#39;#&#39;, 0x18, struct fw_cdev_flush_iso)</span>

<span class="cm">/*</span>
<span class="cm"> * ABI version history</span>
<span class="cm"> *  1  (2.6.22)  - initial version</span>
<span class="cm"> *     (2.6.24)  - added %FW_CDEV_IOC_GET_CYCLE_TIMER</span>
<span class="cm"> *  2  (2.6.30)  - changed &amp;fw_cdev_event_iso_interrupt.header if</span>
<span class="cm"> *                 &amp;fw_cdev_create_iso_context.header_size is 8 or more</span>
<span class="cm"> *               - added %FW_CDEV_IOC_*_ISO_RESOURCE*,</span>
<span class="cm"> *                 %FW_CDEV_IOC_GET_SPEED, %FW_CDEV_IOC_SEND_BROADCAST_REQUEST,</span>
<span class="cm"> *                 %FW_CDEV_IOC_SEND_STREAM_PACKET</span>
<span class="cm"> *     (2.6.32)  - added time stamp to xmit &amp;fw_cdev_event_iso_interrupt</span>
<span class="cm"> *     (2.6.33)  - IR has always packet-per-buffer semantics now, not one of</span>
<span class="cm"> *                 dual-buffer or packet-per-buffer depending on hardware</span>
<span class="cm"> *               - shared use and auto-response for FCP registers</span>
<span class="cm"> *  3  (2.6.34)  - made &amp;fw_cdev_get_cycle_timer reliable</span>
<span class="cm"> *               - added %FW_CDEV_IOC_GET_CYCLE_TIMER2</span>
<span class="cm"> *  4  (2.6.36)  - added %FW_CDEV_EVENT_REQUEST2, %FW_CDEV_EVENT_PHY_PACKET_*,</span>
<span class="cm"> *                 and &amp;fw_cdev_allocate.region_end</span>
<span class="cm"> *               - implemented &amp;fw_cdev_event_bus_reset.bm_node_id</span>
<span class="cm"> *               - added %FW_CDEV_IOC_SEND_PHY_PACKET, _RECEIVE_PHY_PACKETS</span>
<span class="cm"> *               - added %FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL,</span>
<span class="cm"> *                 %FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL, and</span>
<span class="cm"> *                 %FW_CDEV_IOC_SET_ISO_CHANNELS</span>
<span class="cm"> *  5  (3.4)     - send %FW_CDEV_EVENT_ISO_INTERRUPT events when needed to</span>
<span class="cm"> *                 avoid dropping data</span>
<span class="cm"> *               - added %FW_CDEV_IOC_FLUSH_ISO</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_get_info - General purpose information ioctl</span>
<span class="cm"> * @version:	The version field is just a running serial number.  Both an</span>
<span class="cm"> *		input parameter (ABI version implemented by the client) and</span>
<span class="cm"> *		output parameter (ABI version implemented by the kernel).</span>
<span class="cm"> *		A client shall fill in the ABI @version for which the client</span>
<span class="cm"> *		was implemented.  This is necessary for forward compatibility.</span>
<span class="cm"> * @rom_length:	If @rom is non-zero, up to @rom_length bytes of Configuration</span>
<span class="cm"> *		ROM will be copied into that user space address.  In either</span>
<span class="cm"> *		case, @rom_length is updated with the actual length of the</span>
<span class="cm"> *		Configuration ROM.</span>
<span class="cm"> * @rom:	If non-zero, address of a buffer to be filled by a copy of the</span>
<span class="cm"> *		device&#39;s Configuration ROM</span>
<span class="cm"> * @bus_reset:	If non-zero, address of a buffer to be filled by a</span>
<span class="cm"> *		&amp;struct fw_cdev_event_bus_reset with the current state</span>
<span class="cm"> *		of the bus.  This does not cause a bus reset to happen.</span>
<span class="cm"> * @bus_reset_closure: Value of &amp;closure in this and subsequent bus reset events</span>
<span class="cm"> * @card:	The index of the card this device belongs to</span>
<span class="cm"> *</span>
<span class="cm"> * The %FW_CDEV_IOC_GET_INFO ioctl is usually the very first one which a client</span>
<span class="cm"> * performs right after it opened a /dev/fw* file.</span>
<span class="cm"> *</span>
<span class="cm"> * As a side effect, reception of %FW_CDEV_EVENT_BUS_RESET events to be read(2)</span>
<span class="cm"> * is started by this ioctl.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_get_info</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">rom_length</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">rom</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">bus_reset</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">bus_reset_closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">card</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_send_request - Send an asynchronous request packet</span>
<span class="cm"> * @tcode:	Transaction code of the request</span>
<span class="cm"> * @length:	Length of outgoing payload, in bytes</span>
<span class="cm"> * @offset:	48-bit offset at destination node</span>
<span class="cm"> * @closure:	Passed back to userspace in the response event</span>
<span class="cm"> * @data:	Userspace pointer to payload</span>
<span class="cm"> * @generation:	The bus generation where packet is valid</span>
<span class="cm"> *</span>
<span class="cm"> * Send a request to the device.  This ioctl implements all outgoing requests.</span>
<span class="cm"> * Both quadlet and block request specify the payload as a pointer to the data</span>
<span class="cm"> * in the @data field.  Once the transaction completes, the kernel writes an</span>
<span class="cm"> * &amp;fw_cdev_event_response event back.  The @closure field is passed back to</span>
<span class="cm"> * user space in the response event.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_send_request</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">tcode</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">generation</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_send_response - Send an asynchronous response packet</span>
<span class="cm"> * @rcode:	Response code as determined by the userspace handler</span>
<span class="cm"> * @length:	Length of outgoing payload, in bytes</span>
<span class="cm"> * @data:	Userspace pointer to payload</span>
<span class="cm"> * @handle:	The handle from the &amp;fw_cdev_event_request</span>
<span class="cm"> *</span>
<span class="cm"> * Send a response to an incoming request.  By setting up an address range using</span>
<span class="cm"> * the %FW_CDEV_IOC_ALLOCATE ioctl, userspace can listen for incoming requests.  An</span>
<span class="cm"> * incoming request will generate an %FW_CDEV_EVENT_REQUEST, and userspace must</span>
<span class="cm"> * send a reply using this ioctl.  The event has a handle to the kernel-side</span>
<span class="cm"> * pending transaction, which should be used with this ioctl.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_send_response</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">rcode</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_allocate - Allocate a CSR in an address range</span>
<span class="cm"> * @offset:	Start offset of the address range</span>
<span class="cm"> * @closure:	To be passed back to userspace in request events</span>
<span class="cm"> * @length:	Length of the CSR, in bytes</span>
<span class="cm"> * @handle:	Handle to the allocation, written by the kernel</span>
<span class="cm"> * @region_end:	First address above the address range (added in ABI v4, 2.6.36)</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate an address range in the 48-bit address space on the local node</span>
<span class="cm"> * (the controller).  This allows userspace to listen for requests with an</span>
<span class="cm"> * offset within that address range.  Every time when the kernel receives a</span>
<span class="cm"> * request within the range, an &amp;fw_cdev_event_request2 event will be emitted.</span>
<span class="cm"> * (If the kernel or the client implements ABI version &lt;= 3, an</span>
<span class="cm"> * &amp;fw_cdev_event_request will be generated instead.)</span>
<span class="cm"> *</span>
<span class="cm"> * The @closure field is passed back to userspace in these request events.</span>
<span class="cm"> * The @handle field is an out parameter, returning a handle to the allocated</span>
<span class="cm"> * range to be used for later deallocation of the range.</span>
<span class="cm"> *</span>
<span class="cm"> * The address range is allocated on all local nodes.  The address allocation</span>
<span class="cm"> * is exclusive except for the FCP command and response registers.  If an</span>
<span class="cm"> * exclusive address region is already in use, the ioctl fails with errno set</span>
<span class="cm"> * to %EBUSY.</span>
<span class="cm"> *</span>
<span class="cm"> * If kernel and client implement ABI version &gt;= 4, the kernel looks up a free</span>
<span class="cm"> * spot of size @length inside [@offset..@region_end) and, if found, writes</span>
<span class="cm"> * the start address of the new CSR back in @offset.  I.e. @offset is an</span>
<span class="cm"> * in and out parameter.  If this automatic placement of a CSR in a bigger</span>
<span class="cm"> * address range is not desired, the client simply needs to set @region_end</span>
<span class="cm"> * = @offset + @length.</span>
<span class="cm"> *</span>
<span class="cm"> * If the kernel or the client implements ABI version &lt;= 3, @region_end is</span>
<span class="cm"> * ignored and effectively assumed to be @offset + @length.</span>
<span class="cm"> *</span>
<span class="cm"> * @region_end is only present in a kernel header &gt;= 2.6.36.  If necessary,</span>
<span class="cm"> * this can for example be tested by #ifdef FW_CDEV_EVENT_REQUEST2.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_allocate</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">region_end</span><span class="p">;</span>	<span class="cm">/* available since kernel version 2.6.36 */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_deallocate - Free a CSR address range or isochronous resource</span>
<span class="cm"> * @handle:	Handle to the address range or iso resource, as returned by the</span>
<span class="cm"> *		kernel when the range or resource was allocated</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_deallocate</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FW_CDEV_LONG_RESET	0</span>
<span class="cp">#define FW_CDEV_SHORT_RESET	1</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_initiate_bus_reset - Initiate a bus reset</span>
<span class="cm"> * @type:	%FW_CDEV_SHORT_RESET or %FW_CDEV_LONG_RESET</span>
<span class="cm"> *</span>
<span class="cm"> * Initiate a bus reset for the bus this device is on.  The bus reset can be</span>
<span class="cm"> * either the original (long) bus reset or the arbitrated (short) bus reset</span>
<span class="cm"> * introduced in 1394a-2000.</span>
<span class="cm"> *</span>
<span class="cm"> * The ioctl returns immediately.  A subsequent &amp;fw_cdev_event_bus_reset</span>
<span class="cm"> * indicates when the reset actually happened.  Since ABI v4, this may be</span>
<span class="cm"> * considerably later than the ioctl because the kernel ensures a grace period</span>
<span class="cm"> * between subsequent bus resets as per IEEE 1394 bus management specification.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_initiate_bus_reset</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_add_descriptor - Add contents to the local node&#39;s config ROM</span>
<span class="cm"> * @immediate:	If non-zero, immediate key to insert before pointer</span>
<span class="cm"> * @key:	Upper 8 bits of root directory pointer</span>
<span class="cm"> * @data:	Userspace pointer to contents of descriptor block</span>
<span class="cm"> * @length:	Length of descriptor block data, in quadlets</span>
<span class="cm"> * @handle:	Handle to the descriptor, written by the kernel</span>
<span class="cm"> *</span>
<span class="cm"> * Add a descriptor block and optionally a preceding immediate key to the local</span>
<span class="cm"> * node&#39;s Configuration ROM.</span>
<span class="cm"> *</span>
<span class="cm"> * The @key field specifies the upper 8 bits of the descriptor root directory</span>
<span class="cm"> * pointer and the @data and @length fields specify the contents. The @key</span>
<span class="cm"> * should be of the form 0xXX000000. The offset part of the root directory entry</span>
<span class="cm"> * will be filled in by the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * If not 0, the @immediate field specifies an immediate key which will be</span>
<span class="cm"> * inserted before the root directory pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * @immediate, @key, and @data array elements are CPU-endian quadlets.</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, the kernel adds the descriptor and writes back a @handle to</span>
<span class="cm"> * the kernel-side object to be used for later removal of the descriptor block</span>
<span class="cm"> * and immediate key.  The kernel will also generate a bus reset to signal the</span>
<span class="cm"> * change of the Configuration ROM to other nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * This ioctl affects the Configuration ROMs of all local nodes.</span>
<span class="cm"> * The ioctl only succeeds on device files which represent a local node.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_add_descriptor</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">immediate</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_remove_descriptor - Remove contents from the Configuration ROM</span>
<span class="cm"> * @handle:	Handle to the descriptor, as returned by the kernel when the</span>
<span class="cm"> *		descriptor was added</span>
<span class="cm"> *</span>
<span class="cm"> * Remove a descriptor block and accompanying immediate key from the local</span>
<span class="cm"> * nodes&#39; Configuration ROMs.  The kernel will also generate a bus reset to</span>
<span class="cm"> * signal the change of the Configuration ROM to other nodes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_remove_descriptor</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FW_CDEV_ISO_CONTEXT_TRANSMIT			0</span>
<span class="cp">#define FW_CDEV_ISO_CONTEXT_RECEIVE			1</span>
<span class="cp">#define FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL	2 </span><span class="cm">/* added in 2.6.36 */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_create_iso_context - Create a context for isochronous I/O</span>
<span class="cm"> * @type:	%FW_CDEV_ISO_CONTEXT_TRANSMIT or %FW_CDEV_ISO_CONTEXT_RECEIVE or</span>
<span class="cm"> *		%FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span>
<span class="cm"> * @header_size: Header size to strip in single-channel reception</span>
<span class="cm"> * @channel:	Channel to bind to in single-channel reception or transmission</span>
<span class="cm"> * @speed:	Transmission speed</span>
<span class="cm"> * @closure:	To be returned in &amp;fw_cdev_event_iso_interrupt or</span>
<span class="cm"> *		&amp;fw_cdev_event_iso_interrupt_multichannel</span>
<span class="cm"> * @handle:	Handle to context, written back by kernel</span>
<span class="cm"> *</span>
<span class="cm"> * Prior to sending or receiving isochronous I/O, a context must be created.</span>
<span class="cm"> * The context records information about the transmit or receive configuration</span>
<span class="cm"> * and typically maps to an underlying hardware resource.  A context is set up</span>
<span class="cm"> * for either sending or receiving.  It is bound to a specific isochronous</span>
<span class="cm"> * @channel.</span>
<span class="cm"> *</span>
<span class="cm"> * In case of multichannel reception, @header_size and @channel are ignored</span>
<span class="cm"> * and the channels are selected by %FW_CDEV_IOC_SET_ISO_CHANNELS.</span>
<span class="cm"> *</span>
<span class="cm"> * For %FW_CDEV_ISO_CONTEXT_RECEIVE contexts, @header_size must be at least 4</span>
<span class="cm"> * and must be a multiple of 4.  It is ignored in other context types.</span>
<span class="cm"> *</span>
<span class="cm"> * @speed is ignored in receive context types.</span>
<span class="cm"> *</span>
<span class="cm"> * If a context was successfully created, the kernel writes back a handle to the</span>
<span class="cm"> * context, which must be passed in for subsequent operations on that context.</span>
<span class="cm"> *</span>
<span class="cm"> * Limitations:</span>
<span class="cm"> * No more than one iso context can be created per fd.</span>
<span class="cm"> * The total number of contexts that all userspace and kernelspace drivers can</span>
<span class="cm"> * create on a card at a time is a hardware limit, typically 4 or 8 contexts per</span>
<span class="cm"> * direction, and of them at most one multichannel receive context.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_create_iso_context</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">header_size</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_set_iso_channels - Select channels in multichannel reception</span>
<span class="cm"> * @channels:	Bitmask of channels to listen to</span>
<span class="cm"> * @handle:	Handle of the mutichannel receive context</span>
<span class="cm"> *</span>
<span class="cm"> * @channels is the bitwise or of 1ULL &lt;&lt; n for each channel n to listen to.</span>
<span class="cm"> *</span>
<span class="cm"> * The ioctl fails with errno %EBUSY if there is already another receive context</span>
<span class="cm"> * on a channel in @channels.  In that case, the bitmask of all unoccupied</span>
<span class="cm"> * channels is returned in @channels.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_set_iso_channels</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">channels</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FW_CDEV_ISO_PAYLOAD_LENGTH(v)	(v)</span>
<span class="cp">#define FW_CDEV_ISO_INTERRUPT		(1 &lt;&lt; 16)</span>
<span class="cp">#define FW_CDEV_ISO_SKIP		(1 &lt;&lt; 17)</span>
<span class="cp">#define FW_CDEV_ISO_SYNC		(1 &lt;&lt; 17)</span>
<span class="cp">#define FW_CDEV_ISO_TAG(v)		((v) &lt;&lt; 18)</span>
<span class="cp">#define FW_CDEV_ISO_SY(v)		((v) &lt;&lt; 20)</span>
<span class="cp">#define FW_CDEV_ISO_HEADER_LENGTH(v)	((v) &lt;&lt; 24)</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_iso_packet - Isochronous packet</span>
<span class="cm"> * @control:	Contains the header length (8 uppermost bits),</span>
<span class="cm"> *		the sy field (4 bits), the tag field (2 bits), a sync flag</span>
<span class="cm"> *		or a skip flag (1 bit), an interrupt flag (1 bit), and the</span>
<span class="cm"> *		payload length (16 lowermost bits)</span>
<span class="cm"> * @header:	Header and payload in case of a transmit context.</span>
<span class="cm"> *</span>
<span class="cm"> * &amp;struct fw_cdev_iso_packet is used to describe isochronous packet queues.</span>
<span class="cm"> * Use the FW_CDEV_ISO_ macros to fill in @control.</span>
<span class="cm"> * The @header array is empty in case of receive contexts.</span>
<span class="cm"> *</span>
<span class="cm"> * Context type %FW_CDEV_ISO_CONTEXT_TRANSMIT:</span>
<span class="cm"> *</span>
<span class="cm"> * @control.HEADER_LENGTH must be a multiple of 4.  It specifies the numbers of</span>
<span class="cm"> * bytes in @header that will be prepended to the packet&#39;s payload.  These bytes</span>
<span class="cm"> * are copied into the kernel and will not be accessed after the ioctl has</span>
<span class="cm"> * returned.</span>
<span class="cm"> *</span>
<span class="cm"> * The @control.SY and TAG fields are copied to the iso packet header.  These</span>
<span class="cm"> * fields are specified by IEEE 1394a and IEC 61883-1.</span>
<span class="cm"> *</span>
<span class="cm"> * The @control.SKIP flag specifies that no packet is to be sent in a frame.</span>
<span class="cm"> * When using this, all other fields except @control.INTERRUPT must be zero.</span>
<span class="cm"> *</span>
<span class="cm"> * When a packet with the @control.INTERRUPT flag set has been completed, an</span>
<span class="cm"> * &amp;fw_cdev_event_iso_interrupt event will be sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Context type %FW_CDEV_ISO_CONTEXT_RECEIVE:</span>
<span class="cm"> *</span>
<span class="cm"> * @control.HEADER_LENGTH must be a multiple of the context&#39;s header_size.</span>
<span class="cm"> * If the HEADER_LENGTH is larger than the context&#39;s header_size, multiple</span>
<span class="cm"> * packets are queued for this entry.</span>
<span class="cm"> *</span>
<span class="cm"> * The @control.SY and TAG fields are ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * If the @control.SYNC flag is set, the context drops all packets until a</span>
<span class="cm"> * packet with a sy field is received which matches &amp;fw_cdev_start_iso.sync.</span>
<span class="cm"> *</span>
<span class="cm"> * @control.PAYLOAD_LENGTH defines how many payload bytes can be received for</span>
<span class="cm"> * one packet (in addition to payload quadlets that have been defined as headers</span>
<span class="cm"> * and are stripped and returned in the &amp;fw_cdev_event_iso_interrupt structure).</span>
<span class="cm"> * If more bytes are received, the additional bytes are dropped.  If less bytes</span>
<span class="cm"> * are received, the remaining bytes in this part of the payload buffer will not</span>
<span class="cm"> * be written to, not even by the next packet.  I.e., packets received in</span>
<span class="cm"> * consecutive frames will not necessarily be consecutive in memory.  If an</span>
<span class="cm"> * entry has queued multiple packets, the PAYLOAD_LENGTH is divided equally</span>
<span class="cm"> * among them.</span>
<span class="cm"> *</span>
<span class="cm"> * When a packet with the @control.INTERRUPT flag set has been completed, an</span>
<span class="cm"> * &amp;fw_cdev_event_iso_interrupt event will be sent.  An entry that has queued</span>
<span class="cm"> * multiple receive packets is completed when its last packet is completed.</span>
<span class="cm"> *</span>
<span class="cm"> * Context type %FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL:</span>
<span class="cm"> *</span>
<span class="cm"> * Here, &amp;fw_cdev_iso_packet would be more aptly named _iso_buffer_chunk since</span>
<span class="cm"> * it specifies a chunk of the mmap()&#39;ed buffer, while the number and alignment</span>
<span class="cm"> * of packets to be placed into the buffer chunk is not known beforehand.</span>
<span class="cm"> *</span>
<span class="cm"> * @control.PAYLOAD_LENGTH is the size of the buffer chunk and specifies room</span>
<span class="cm"> * for header, payload, padding, and trailer bytes of one or more packets.</span>
<span class="cm"> * It must be a multiple of 4.</span>
<span class="cm"> *</span>
<span class="cm"> * @control.HEADER_LENGTH, TAG and SY are ignored.  SYNC is treated as described</span>
<span class="cm"> * for single-channel reception.</span>
<span class="cm"> *</span>
<span class="cm"> * When a buffer chunk with the @control.INTERRUPT flag set has been filled</span>
<span class="cm"> * entirely, an &amp;fw_cdev_event_iso_interrupt_mc event will be sent.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_iso_packet</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">control</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_queue_iso - Queue isochronous packets for I/O</span>
<span class="cm"> * @packets:	Userspace pointer to an array of &amp;fw_cdev_iso_packet</span>
<span class="cm"> * @data:	Pointer into mmap()&#39;ed payload buffer</span>
<span class="cm"> * @size:	Size of the @packets array, in bytes</span>
<span class="cm"> * @handle:	Isochronous context handle</span>
<span class="cm"> *</span>
<span class="cm"> * Queue a number of isochronous packets for reception or transmission.</span>
<span class="cm"> * This ioctl takes a pointer to an array of &amp;fw_cdev_iso_packet structs,</span>
<span class="cm"> * which describe how to transmit from or receive into a contiguous region</span>
<span class="cm"> * of a mmap()&#39;ed payload buffer.  As part of transmit packet descriptors,</span>
<span class="cm"> * a series of headers can be supplied, which will be prepended to the</span>
<span class="cm"> * payload during DMA.</span>
<span class="cm"> *</span>
<span class="cm"> * The kernel may or may not queue all packets, but will write back updated</span>
<span class="cm"> * values of the @packets, @data and @size fields, so the ioctl can be</span>
<span class="cm"> * resubmitted easily.</span>
<span class="cm"> *</span>
<span class="cm"> * In case of a multichannel receive context, @data must be quadlet-aligned</span>
<span class="cm"> * relative to the buffer start.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_queue_iso</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">packets</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FW_CDEV_ISO_CONTEXT_MATCH_TAG0		 1</span>
<span class="cp">#define FW_CDEV_ISO_CONTEXT_MATCH_TAG1		 2</span>
<span class="cp">#define FW_CDEV_ISO_CONTEXT_MATCH_TAG2		 4</span>
<span class="cp">#define FW_CDEV_ISO_CONTEXT_MATCH_TAG3		 8</span>
<span class="cp">#define FW_CDEV_ISO_CONTEXT_MATCH_ALL_TAGS	15</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_start_iso - Start an isochronous transmission or reception</span>
<span class="cm"> * @cycle:	Cycle in which to start I/O.  If @cycle is greater than or</span>
<span class="cm"> *		equal to 0, the I/O will start on that cycle.</span>
<span class="cm"> * @sync:	Determines the value to wait for for receive packets that have</span>
<span class="cm"> *		the %FW_CDEV_ISO_SYNC bit set</span>
<span class="cm"> * @tags:	Tag filter bit mask.  Only valid for isochronous reception.</span>
<span class="cm"> *		Determines the tag values for which packets will be accepted.</span>
<span class="cm"> *		Use FW_CDEV_ISO_CONTEXT_MATCH_ macros to set @tags.</span>
<span class="cm"> * @handle:	Isochronous context handle within which to transmit or receive</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_start_iso</span> <span class="p">{</span>
	<span class="n">__s32</span> <span class="n">cycle</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sync</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_stop_iso - Stop an isochronous transmission or reception</span>
<span class="cm"> * @handle:	Handle of isochronous context to stop</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_stop_iso</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_flush_iso - flush completed iso packets</span>
<span class="cm"> * @handle:	handle of isochronous context to flush</span>
<span class="cm"> *</span>
<span class="cm"> * For %FW_CDEV_ISO_CONTEXT_TRANSMIT or %FW_CDEV_ISO_CONTEXT_RECEIVE contexts,</span>
<span class="cm"> * report any completed packets.</span>
<span class="cm"> *</span>
<span class="cm"> * For %FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL contexts, report the current</span>
<span class="cm"> * offset in the receive buffer, if it has changed; this is typically in the</span>
<span class="cm"> * middle of some buffer chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * Any %FW_CDEV_EVENT_ISO_INTERRUPT or %FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL</span>
<span class="cm"> * events generated by this ioctl are sent synchronously, i.e., are available</span>
<span class="cm"> * for reading from the file descriptor when this ioctl returns.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_flush_iso</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_get_cycle_timer - read cycle timer register</span>
<span class="cm"> * @local_time:   system time, in microseconds since the Epoch</span>
<span class="cm"> * @cycle_timer:  Cycle Time register contents</span>
<span class="cm"> *</span>
<span class="cm"> * Same as %FW_CDEV_IOC_GET_CYCLE_TIMER2, but fixed to use %CLOCK_REALTIME</span>
<span class="cm"> * and only with microseconds resolution.</span>
<span class="cm"> *</span>
<span class="cm"> * In version 1 and 2 of the ABI, this ioctl returned unreliable (non-</span>
<span class="cm"> * monotonic) @cycle_timer values on certain controllers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_get_cycle_timer</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">local_time</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">cycle_timer</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_get_cycle_timer2 - read cycle timer register</span>
<span class="cm"> * @tv_sec:       system time, seconds</span>
<span class="cm"> * @tv_nsec:      system time, sub-seconds part in nanoseconds</span>
<span class="cm"> * @clk_id:       input parameter, clock from which to get the system time</span>
<span class="cm"> * @cycle_timer:  Cycle Time register contents</span>
<span class="cm"> *</span>
<span class="cm"> * The %FW_CDEV_IOC_GET_CYCLE_TIMER2 ioctl reads the isochronous cycle timer</span>
<span class="cm"> * and also the system clock.  This allows to correlate reception time of</span>
<span class="cm"> * isochronous packets with system time.</span>
<span class="cm"> *</span>
<span class="cm"> * @clk_id lets you choose a clock like with POSIX&#39; clock_gettime function.</span>
<span class="cm"> * Supported @clk_id values are POSIX&#39; %CLOCK_REALTIME and %CLOCK_MONOTONIC</span>
<span class="cm"> * and Linux&#39; %CLOCK_MONOTONIC_RAW.</span>
<span class="cm"> *</span>
<span class="cm"> * @cycle_timer consists of 7 bits cycleSeconds, 13 bits cycleCount, and</span>
<span class="cm"> * 12 bits cycleOffset, in host byte order.  Cf. the Cycle Time register</span>
<span class="cm"> * per IEEE 1394 or Isochronous Cycle Timer register per OHCI-1394.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_get_cycle_timer2</span> <span class="p">{</span>
	<span class="n">__s64</span> <span class="n">tv_sec</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">tv_nsec</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">clk_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">cycle_timer</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_allocate_iso_resource - (De)allocate a channel or bandwidth</span>
<span class="cm"> * @closure:	Passed back to userspace in corresponding iso resource events</span>
<span class="cm"> * @channels:	Isochronous channels of which one is to be (de)allocated</span>
<span class="cm"> * @bandwidth:	Isochronous bandwidth units to be (de)allocated</span>
<span class="cm"> * @handle:	Handle to the allocation, written by the kernel (only valid in</span>
<span class="cm"> *		case of %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE ioctls)</span>
<span class="cm"> *</span>
<span class="cm"> * The %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE ioctl initiates allocation of an</span>
<span class="cm"> * isochronous channel and/or of isochronous bandwidth at the isochronous</span>
<span class="cm"> * resource manager (IRM).  Only one of the channels specified in @channels is</span>
<span class="cm"> * allocated.  An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED is sent after</span>
<span class="cm"> * communication with the IRM, indicating success or failure in the event data.</span>
<span class="cm"> * The kernel will automatically reallocate the resources after bus resets.</span>
<span class="cm"> * Should a reallocation fail, an %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event</span>
<span class="cm"> * will be sent.  The kernel will also automatically deallocate the resources</span>
<span class="cm"> * when the file descriptor is closed.</span>
<span class="cm"> *</span>
<span class="cm"> * The %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE ioctl can be used to initiate</span>
<span class="cm"> * deallocation of resources which were allocated as described above.</span>
<span class="cm"> * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event concludes this operation.</span>
<span class="cm"> *</span>
<span class="cm"> * The %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE ioctl is a variant of allocation</span>
<span class="cm"> * without automatic re- or deallocation.</span>
<span class="cm"> * An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED event concludes this operation,</span>
<span class="cm"> * indicating success or failure in its data.</span>
<span class="cm"> *</span>
<span class="cm"> * The %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE_ONCE ioctl works like</span>
<span class="cm"> * %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE except that resources are freed</span>
<span class="cm"> * instead of allocated.</span>
<span class="cm"> * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event concludes this operation.</span>
<span class="cm"> *</span>
<span class="cm"> * To summarize, %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE allocates iso resources</span>
<span class="cm"> * for the lifetime of the fd or @handle.</span>
<span class="cm"> * In contrast, %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE allocates iso resources</span>
<span class="cm"> * for the duration of a bus generation.</span>
<span class="cm"> *</span>
<span class="cm"> * @channels is a host-endian bitfield with the least significant bit</span>
<span class="cm"> * representing channel 0 and the most significant bit representing channel 63:</span>
<span class="cm"> * 1ULL &lt;&lt; c for each channel c that is a candidate for (de)allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * @bandwidth is expressed in bandwidth allocation units, i.e. the time to send</span>
<span class="cm"> * one quadlet of data (payload or header data) at speed S1600.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_allocate_iso_resource</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">channels</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">bandwidth</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_send_stream_packet - send an asynchronous stream packet</span>
<span class="cm"> * @length:	Length of outgoing payload, in bytes</span>
<span class="cm"> * @tag:	Data format tag</span>
<span class="cm"> * @channel:	Isochronous channel to transmit to</span>
<span class="cm"> * @sy:		Synchronization code</span>
<span class="cm"> * @closure:	Passed back to userspace in the response event</span>
<span class="cm"> * @data:	Userspace pointer to payload</span>
<span class="cm"> * @generation:	The bus generation where packet is valid</span>
<span class="cm"> * @speed:	Speed to transmit at</span>
<span class="cm"> *</span>
<span class="cm"> * The %FW_CDEV_IOC_SEND_STREAM_PACKET ioctl sends an asynchronous stream packet</span>
<span class="cm"> * to every device which is listening to the specified channel.  The kernel</span>
<span class="cm"> * writes an &amp;fw_cdev_event_response event which indicates success or failure of</span>
<span class="cm"> * the transmission.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_send_stream_packet</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sy</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">generation</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">speed</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_send_phy_packet - send a PHY packet</span>
<span class="cm"> * @closure:	Passed back to userspace in the PHY-packet-sent event</span>
<span class="cm"> * @data:	First and second quadlet of the PHY packet</span>
<span class="cm"> * @generation:	The bus generation where packet is valid</span>
<span class="cm"> *</span>
<span class="cm"> * The %FW_CDEV_IOC_SEND_PHY_PACKET ioctl sends a PHY packet to all nodes</span>
<span class="cm"> * on the same card as this device.  After transmission, an</span>
<span class="cm"> * %FW_CDEV_EVENT_PHY_PACKET_SENT event is generated.</span>
<span class="cm"> *</span>
<span class="cm"> * The payload @data[] shall be specified in host byte order.  Usually,</span>
<span class="cm"> * @data[1] needs to be the bitwise inverse of @data[0].  VersaPHY packets</span>
<span class="cm"> * are an exception to this rule.</span>
<span class="cm"> *</span>
<span class="cm"> * The ioctl is only permitted on device files which represent a local node.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_send_phy_packet</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__u32</span> <span class="n">generation</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_cdev_receive_phy_packets - start reception of PHY packets</span>
<span class="cm"> * @closure: Passed back to userspace in phy packet events</span>
<span class="cm"> *</span>
<span class="cm"> * This ioctl activates issuing of %FW_CDEV_EVENT_PHY_PACKET_RECEIVED due to</span>
<span class="cm"> * incoming PHY packets from any node on the same bus as the device.</span>
<span class="cm"> *</span>
<span class="cm"> * The ioctl is only permitted on device files which represent a local node.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_cdev_receive_phy_packets</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">closure</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FW_CDEV_VERSION 3 </span><span class="cm">/* Meaningless legacy macro; don&#39;t use it. */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_FIREWIRE_CDEV_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
