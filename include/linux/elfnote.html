<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › elfnote.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>elfnote.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_ELFNOTE_H</span>
<span class="cp">#define _LINUX_ELFNOTE_H</span>
<span class="cm">/*</span>
<span class="cm"> * Helper macros to generate ELF Note structures, which are put into a</span>
<span class="cm"> * PT_NOTE segment of the final vmlinux image.  These are useful for</span>
<span class="cm"> * including name-value pairs of metadata into the kernel binary (or</span>
<span class="cm"> * modules?) for use by external programs.</span>
<span class="cm"> *</span>
<span class="cm"> * Each note has three parts: a name, a type and a desc.  The name is</span>
<span class="cm"> * intended to distinguish the note&#39;s originator, so it would be a</span>
<span class="cm"> * company, project, subsystem, etc; it must be in a suitable form for</span>
<span class="cm"> * use in a section name.  The type is an integer which is used to tag</span>
<span class="cm"> * the data, and is considered to be within the &quot;name&quot; namespace (so</span>
<span class="cm"> * &quot;FooCo&quot;&#39;s type 42 is distinct from &quot;BarProj&quot;&#39;s type 42).  The</span>
<span class="cm"> * &quot;desc&quot; field is the actual data.  There are no constraints on the</span>
<span class="cm"> * desc field&#39;s contents, though typically they&#39;re fairly small.</span>
<span class="cm"> *</span>
<span class="cm"> * All notes from a given NAME are put into a section named</span>
<span class="cm"> * .note.NAME.  When the kernel image is finally linked, all the notes</span>
<span class="cm"> * are packed into a single .notes section, which is mapped into the</span>
<span class="cm"> * PT_NOTE segment.  Because notes for a given name are grouped into</span>
<span class="cm"> * the same section, they&#39;ll all be adjacent the output file.</span>
<span class="cm"> *</span>
<span class="cm"> * This file defines macros for both C and assembler use.  Their</span>
<span class="cm"> * syntax is slightly different, but they&#39;re semantically similar.</span>
<span class="cm"> *</span>
<span class="cm"> * See the ELF specification for more detail about ELF notes.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __ASSEMBLER__</span>
<span class="cm">/*</span>
<span class="cm"> * Generate a structure with the same shape as Elf{32,64}_Nhdr (which</span>
<span class="cm"> * turn out to be the same size and shape), followed by the name and</span>
<span class="cm"> * desc data with appropriate padding.  The &#39;desctype&#39; argument is the</span>
<span class="cm"> * assembler pseudo op defining the type of the data e.g. .asciz while</span>
<span class="cm"> * &#39;descdata&#39; is the data itself e.g.  &quot;hello, world&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * e.g. ELFNOTE(XYZCo, 42, .asciz, &quot;forty-two&quot;)</span>
<span class="cm"> *      ELFNOTE(XYZCo, 12, .long, 0xdeadbeef)</span>
<span class="cm"> */</span>
<span class="cp">#define ELFNOTE_START(name, type, flags)	\</span>
<span class="cp">.pushsection .note.name, flags,@note	;	\</span>
<span class="cp">  .balign 4				;	\</span>
<span class="cp">  .long 2f - 1f		</span><span class="cm">/* namesz */</span><span class="cp">	;	\</span>
<span class="cp">  .long 4484f - 3f	</span><span class="cm">/* descsz */</span><span class="cp">	;	\</span>
<span class="cp">  .long type				;	\</span>
<span class="cp">1:.asciz #name				;	\</span>
<span class="cp">2:.balign 4				;	\</span>
<span class="cp">3:</span>

<span class="cp">#define ELFNOTE_END				\</span>
<span class="cp">4484:.balign 4				;	\</span>
<span class="cp">.popsection				;</span>

<span class="cp">#define ELFNOTE(name, type, desc)		\</span>
<span class="cp">	ELFNOTE_START(name, type, &quot;&quot;)		\</span>
<span class="cp">		desc			;	\</span>
<span class="cp">	ELFNOTE_END</span>

<span class="cp">#else	</span><span class="cm">/* !__ASSEMBLER__ */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cm">/*</span>
<span class="cm"> * Use an anonymous structure which matches the shape of</span>
<span class="cm"> * Elf{32,64}_Nhdr, but includes the name and desc data.  The size and</span>
<span class="cm"> * type of name and desc depend on the macro arguments.  &quot;name&quot; must</span>
<span class="cm"> * be a literal string, and &quot;desc&quot; must be passed by value.  You may</span>
<span class="cm"> * only define one note per line, since __LINE__ is used to generate</span>
<span class="cm"> * unique symbols.</span>
<span class="cm"> */</span>
<span class="cp">#define _ELFNOTE_PASTE(a,b)	a##b</span>
<span class="cp">#define _ELFNOTE(size, name, unique, type, desc)			\</span>
<span class="cp">	static const struct {						\</span>
<span class="cp">		struct elf##size##_note _nhdr;				\</span>
<span class="cp">		unsigned char _name[sizeof(name)]			\</span>
<span class="cp">		__attribute__((aligned(sizeof(Elf##size##_Word))));	\</span>
<span class="cp">		typeof(desc) _desc					\</span>
<span class="cp">			     __attribute__((aligned(sizeof(Elf##size##_Word)))); \</span>
<span class="cp">	} _ELFNOTE_PASTE(_note_, unique)				\</span>
<span class="cp">		__used							\</span>
<span class="cp">		__attribute__((section(&quot;.note.&quot; name),			\</span>
<span class="cp">			       aligned(sizeof(Elf##size##_Word)),	\</span>
<span class="cp">			       unused)) = {				\</span>
<span class="cp">		{							\</span>
<span class="cp">			sizeof(name),					\</span>
<span class="cp">			sizeof(desc),					\</span>
<span class="cp">			type,						\</span>
<span class="cp">		},							\</span>
<span class="cp">		name,							\</span>
<span class="cp">		desc							\</span>
<span class="cp">	}</span>
<span class="cp">#define ELFNOTE(size, name, type, desc)		\</span>
<span class="cp">	_ELFNOTE(size, name, __LINE__, type, desc)</span>

<span class="cp">#define ELFNOTE32(name, type, desc) ELFNOTE(32, name, type, desc)</span>
<span class="cp">#define ELFNOTE64(name, type, desc) ELFNOTE(64, name, type, desc)</span>
<span class="cp">#endif	</span><span class="cm">/* __ASSEMBLER__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_ELFNOTE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
