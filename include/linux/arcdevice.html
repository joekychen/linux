<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › arcdevice.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>arcdevice.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET         An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *              operating system.  NET  is implemented using the  BSD Socket</span>
<span class="cm"> *              interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *              Definitions used by the ARCnet driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:     Avery Pennarun and David Woodhouse</span>
<span class="cm"> *</span>
<span class="cm"> *              This program is free software; you can redistribute it and/or</span>
<span class="cm"> *              modify it under the terms of the GNU General Public License</span>
<span class="cm"> *              as published by the Free Software Foundation; either version</span>
<span class="cm"> *              2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_ARCDEVICE_H</span>
<span class="cp">#define _LINUX_ARCDEVICE_H</span>

<span class="cp">#include &lt;asm/timex.h&gt;</span>
<span class="cp">#include &lt;linux/if_arcnet.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include  &lt;linux/irqreturn.h&gt;</span>

<span class="cp">#ifndef bool</span>
<span class="cp">#define bool int</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * RECON_THRESHOLD is the maximum number of RECON messages to receive</span>
<span class="cm"> * within one minute before printing a &quot;cabling problem&quot; warning. The</span>
<span class="cm"> * default value should be fine.</span>
<span class="cm"> *</span>
<span class="cm"> * After that, a &quot;cabling restored&quot; message will be printed on the next IRQ</span>
<span class="cm"> * if no RECON messages have been received for 10 seconds.</span>
<span class="cm"> *</span>
<span class="cm"> * Do not define RECON_THRESHOLD at all if you want to disable this feature.</span>
<span class="cm"> */</span>
<span class="cp">#define RECON_THRESHOLD 30</span>


<span class="cm">/*</span>
<span class="cm"> * Define this to the minimum &quot;timeout&quot; value.  If a transmit takes longer</span>
<span class="cm"> * than TX_TIMEOUT jiffies, Linux will abort the TX and retry.  On a large</span>
<span class="cm"> * network, or one with heavy network traffic, this timeout may need to be</span>
<span class="cm"> * increased.  The larger it is, though, the longer it will be between</span>
<span class="cm"> * necessary transmits - don&#39;t set this too high.</span>
<span class="cm"> */</span>
<span class="cp">#define TX_TIMEOUT (HZ * 200 / 1000)</span>


<span class="cm">/* Display warnings about the driver being an ALPHA version. */</span>
<span class="cp">#undef ALPHA_WARNING</span>


<span class="cm">/*</span>
<span class="cm"> * Debugging bitflags: each option can be enabled individually.</span>
<span class="cm"> * </span>
<span class="cm"> * Note: only debug flags included in the ARCNET_DEBUG_MAX define will</span>
<span class="cm"> *   actually be available.  GCC will (at least, GCC 2.7.0 will) notice</span>
<span class="cm"> *   lines using a BUGLVL not in ARCNET_DEBUG_MAX and automatically optimize</span>
<span class="cm"> *   them out.</span>
<span class="cm"> */</span>
<span class="cp">#define D_NORMAL	1	</span><span class="cm">/* important operational info             */</span><span class="cp"></span>
<span class="cp">#define D_EXTRA		2	</span><span class="cm">/* useful, but non-vital information      */</span><span class="cp"></span>
<span class="cp">#define	D_INIT		4	</span><span class="cm">/* show init/probe messages               */</span><span class="cp"></span>
<span class="cp">#define D_INIT_REASONS	8	</span><span class="cm">/* show reasons for discarding probes     */</span><span class="cp"></span>
<span class="cp">#define D_RECON		32	</span><span class="cm">/* print a message whenever token is lost */</span><span class="cp"></span>
<span class="cp">#define D_PROTO		64	</span><span class="cm">/* debug auto-protocol support            */</span><span class="cp"></span>
<span class="cm">/* debug levels below give LOTS of output during normal operation! */</span>
<span class="cp">#define D_DURING	128	</span><span class="cm">/* trace operations (including irq&#39;s)     */</span><span class="cp"></span>
<span class="cp">#define D_TX	        256	</span><span class="cm">/* show tx packets                        */</span><span class="cp"></span>
<span class="cp">#define D_RX		512	</span><span class="cm">/* show rx packets                        */</span><span class="cp"></span>
<span class="cp">#define D_SKB		1024	</span><span class="cm">/* show skb&#39;s                             */</span><span class="cp"></span>
<span class="cp">#define D_SKB_SIZE	2048	</span><span class="cm">/* show skb sizes			  */</span><span class="cp"></span>
<span class="cp">#define D_TIMING	4096	</span><span class="cm">/* show time needed to copy buffers to card */</span><span class="cp"></span>
<span class="cp">#define D_DEBUG         8192    </span><span class="cm">/* Very detailed debug line for line */</span><span class="cp"></span>

<span class="cp">#ifndef ARCNET_DEBUG_MAX</span>
<span class="cp">#define ARCNET_DEBUG_MAX (127)	</span><span class="cm">/* change to ~0 if you want detailed debugging */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifndef ARCNET_DEBUG</span>
<span class="cp">#define ARCNET_DEBUG (D_NORMAL|D_EXTRA)</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">arcnet_debug</span><span class="p">;</span>

<span class="cm">/* macros to simplify debug checking */</span>
<span class="cp">#define BUGLVL(x) if ((ARCNET_DEBUG_MAX)&amp;arcnet_debug&amp;(x))</span>
<span class="cp">#define BUGMSG2(x,msg,args...) do { BUGLVL(x) printk(msg, ## args); } while (0)</span>
<span class="cp">#define BUGMSG(x,msg,args...) \</span>
<span class="cp">	BUGMSG2(x, &quot;%s%6s: &quot; msg, \</span>
<span class="cp">            x==D_NORMAL	? KERN_WARNING \</span>
<span class="cp">            		: x &lt; D_DURING ? KERN_INFO : KERN_DEBUG, \</span>
<span class="cp">	    dev-&gt;name , ## args)</span>

<span class="cm">/* see how long a function call takes to run, expressed in CPU cycles */</span>
<span class="cp">#define TIME(name, bytes, call) BUGLVL(D_TIMING) { \</span>
<span class="cp">	    unsigned long _x, _y; \</span>
<span class="cp">	    _x = get_cycles(); \</span>
<span class="cp">	    call; \</span>
<span class="cp">	    _y = get_cycles(); \</span>
<span class="cp">	    BUGMSG(D_TIMING, \</span>
<span class="cp">	       &quot;%s: %d bytes in %lu cycles == &quot; \</span>
<span class="cp">	       &quot;%lu Kbytes/100Mcycle\n&quot;,\</span>
<span class="cp">		   name, bytes, _y - _x, \</span>
<span class="cp">		   100000000 / 1024 * bytes / (_y - _x + 1));\</span>
<span class="cp">	} \</span>
<span class="cp">	else { \</span>
<span class="cp">		    call;\</span>
<span class="cp">	}</span>


<span class="cm">/*</span>
<span class="cm"> * Time needed to reset the card - in ms (milliseconds).  This works on my</span>
<span class="cm"> * SMC PC100.  I can&#39;t find a reference that tells me just how long I</span>
<span class="cm"> * should wait.</span>
<span class="cm"> */</span>
<span class="cp">#define RESETtime (300)</span>

<span class="cm">/*</span>
<span class="cm"> * These are the max/min lengths of packet payload, not including the</span>
<span class="cm"> * arc_hardware header, but definitely including the soft header.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: packet sizes 254, 255, 256 are impossible because of the way</span>
<span class="cm"> * ARCnet registers work  That&#39;s why RFC1201 defines &quot;exception&quot; packets.</span>
<span class="cm"> * In non-RFC1201 protocols, we have to just tack some extra bytes on the</span>
<span class="cm"> * end.</span>
<span class="cm"> */</span>
<span class="cp">#define MTU	253		</span><span class="cm">/* normal packet max size */</span><span class="cp"></span>
<span class="cp">#define MinTU	257		</span><span class="cm">/* extended packet min size */</span><span class="cp"></span>
<span class="cp">#define XMTU	508		</span><span class="cm">/* extended packet max size */</span><span class="cp"></span>

<span class="cm">/* status/interrupt mask bit fields */</span>
<span class="cp">#define TXFREEflag	0x01	</span><span class="cm">/* transmitter available */</span><span class="cp"></span>
<span class="cp">#define TXACKflag       0x02	</span><span class="cm">/* transmitted msg. ackd */</span><span class="cp"></span>
<span class="cp">#define RECONflag       0x04	</span><span class="cm">/* network reconfigured */</span><span class="cp"></span>
<span class="cp">#define TESTflag        0x08	</span><span class="cm">/* test flag */</span><span class="cp"></span>
<span class="cp">#define EXCNAKflag      0x08    </span><span class="cm">/* excesive nak flag */</span><span class="cp"></span>
<span class="cp">#define RESETflag       0x10	</span><span class="cm">/* power-on-reset */</span><span class="cp"></span>
<span class="cp">#define RES1flag        0x20	</span><span class="cm">/* reserved - usually set by jumper */</span><span class="cp"></span>
<span class="cp">#define RES2flag        0x40	</span><span class="cm">/* reserved - usually set by jumper */</span><span class="cp"></span>
<span class="cp">#define NORXflag        0x80	</span><span class="cm">/* receiver inhibited */</span><span class="cp"></span>

<span class="cm">/* Flags used for IO-mapped memory operations */</span>
<span class="cp">#define AUTOINCflag     0x40	</span><span class="cm">/* Increase location with each access */</span><span class="cp"></span>
<span class="cp">#define IOMAPflag       0x02	</span><span class="cm">/* (for 90xx) Use IO mapped memory, not mmap */</span><span class="cp"></span>
<span class="cp">#define ENABLE16flag    0x80	</span><span class="cm">/* (for 90xx) Enable 16-bit mode */</span><span class="cp"></span>

<span class="cm">/* in the command register, the following bits have these meanings:</span>
<span class="cm"> *                0-2     command</span>
<span class="cm"> *                3-4     page number (for enable rcv/xmt command)</span>
<span class="cm"> *                 7      receive broadcasts</span>
<span class="cm"> */</span>
<span class="cp">#define NOTXcmd         0x01	</span><span class="cm">/* disable transmitter */</span><span class="cp"></span>
<span class="cp">#define NORXcmd         0x02	</span><span class="cm">/* disable receiver */</span><span class="cp"></span>
<span class="cp">#define TXcmd           0x03	</span><span class="cm">/* enable transmitter */</span><span class="cp"></span>
<span class="cp">#define RXcmd           0x04	</span><span class="cm">/* enable receiver */</span><span class="cp"></span>
<span class="cp">#define CONFIGcmd       0x05	</span><span class="cm">/* define configuration */</span><span class="cp"></span>
<span class="cp">#define CFLAGScmd       0x06	</span><span class="cm">/* clear flags */</span><span class="cp"></span>
<span class="cp">#define TESTcmd         0x07	</span><span class="cm">/* load test flags */</span><span class="cp"></span>

<span class="cm">/* flags for &quot;clear flags&quot; command */</span>
<span class="cp">#define RESETclear      0x08	</span><span class="cm">/* power-on-reset */</span><span class="cp"></span>
<span class="cp">#define CONFIGclear     0x10	</span><span class="cm">/* system reconfigured */</span><span class="cp"></span>

<span class="cp">#define EXCNAKclear     0x0E    </span><span class="cm">/* Clear and acknowledge the excive nak bit */</span><span class="cp"></span>

<span class="cm">/* flags for &quot;load test flags&quot; command */</span>
<span class="cp">#define TESTload        0x08	</span><span class="cm">/* test flag (diagnostic) */</span><span class="cp"></span>

<span class="cm">/* byte deposited into first address of buffers on reset */</span>
<span class="cp">#define TESTvalue       0321	</span><span class="cm">/* that&#39;s octal for 0xD1 :) */</span><span class="cp"></span>

<span class="cm">/* for &quot;enable receiver&quot; command */</span>
<span class="cp">#define RXbcasts        0x80	</span><span class="cm">/* receive broadcasts */</span><span class="cp"></span>

<span class="cm">/* flags for &quot;define configuration&quot; command */</span>
<span class="cp">#define NORMALconf      0x00	</span><span class="cm">/* 1-249 byte packets */</span><span class="cp"></span>
<span class="cp">#define EXTconf         0x08	</span><span class="cm">/* 250-504 byte packets */</span><span class="cp"></span>

<span class="cm">/* card feature flags, set during auto-detection.</span>
<span class="cm"> * (currently only used by com20020pci)</span>
<span class="cm"> */</span>
<span class="cp">#define ARC_IS_5MBIT    1   </span><span class="cm">/* card default speed is 5MBit */</span><span class="cp"></span>
<span class="cp">#define ARC_CAN_10MBIT  2   </span><span class="cm">/* card uses COM20022, supporting 10MBit,</span>
<span class="cm">				 but default is 2.5MBit. */</span><span class="cp"></span>


<span class="cm">/* information needed to define an encapsulation driver */</span>
<span class="k">struct</span> <span class="n">ArcProto</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">suffix</span><span class="p">;</span>		<span class="cm">/* a for RFC1201, e for ether-encap, etc. */</span>
	<span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>		<span class="cm">/* largest possible packet */</span>
	<span class="kt">int</span> <span class="n">is_ip</span><span class="p">;</span>              <span class="cm">/* This is a ip plugin - not a raw thing */</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rx</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufnum</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">archdr</span> <span class="o">*</span> <span class="n">pkthdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">build_header</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ethproto</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">daddr</span><span class="p">);</span>

	<span class="cm">/* these functions return &#39;1&#39; if the skb can now be freed */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare_tx</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">archdr</span> <span class="o">*</span> <span class="n">pkt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">bufnum</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">continue_tx</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufnum</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ack_tx</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">acked</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ArcProto</span> <span class="o">*</span><span class="n">arc_proto_map</span><span class="p">[</span><span class="mi">256</span><span class="p">],</span> <span class="o">*</span><span class="n">arc_proto_default</span><span class="p">,</span>
	<span class="o">*</span><span class="n">arc_bcast_proto</span><span class="p">,</span> <span class="o">*</span><span class="n">arc_raw_proto</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * &quot;Incoming&quot; is information needed for each address that could be sending</span>
<span class="cm"> * to us.  Mostly for partially-received split packets.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">Incoming</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>	<span class="cm">/* packet data buffer             */</span>
	<span class="n">__be16</span> <span class="n">sequence</span><span class="p">;</span>	<span class="cm">/* sequence number of assembly    */</span>
	<span class="kt">uint8_t</span> <span class="n">lastpacket</span><span class="p">,</span>	<span class="cm">/* number of last packet (from 1) */</span>
		<span class="n">numpackets</span><span class="p">;</span>	<span class="cm">/* number of packets in split     */</span>
<span class="p">};</span>


<span class="cm">/* only needed for RFC1201 */</span>
<span class="k">struct</span> <span class="n">Outgoing</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ArcProto</span> <span class="o">*</span><span class="n">proto</span><span class="p">;</span>	<span class="cm">/* protocol driver that owns this:</span>
<span class="cm">				 *   if NULL, no packet is pending.</span>
<span class="cm">				 */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>	<span class="cm">/* buffer from upper levels */</span>
	<span class="k">struct</span> <span class="n">archdr</span> <span class="o">*</span><span class="n">pkt</span><span class="p">;</span>	<span class="cm">/* a pointer into the skb */</span>
	<span class="kt">uint16_t</span> <span class="n">length</span><span class="p">,</span>	<span class="cm">/* bytes total */</span>
		<span class="n">dataleft</span><span class="p">,</span>	<span class="cm">/* bytes left */</span>
		<span class="n">segnum</span><span class="p">,</span>		<span class="cm">/* segment being sent */</span>
		<span class="n">numsegs</span><span class="p">;</span>	<span class="cm">/* number of segments */</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">arcnet_local</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">config</span><span class="p">,</span>		<span class="cm">/* current value of CONFIG register */</span>
		<span class="n">timeout</span><span class="p">,</span>	<span class="cm">/* Extended timeout for COM20020 */</span>
		<span class="n">backplane</span><span class="p">,</span>	<span class="cm">/* Backplane flag for COM20020 */</span>
		<span class="n">clockp</span><span class="p">,</span>		<span class="cm">/* COM20020 clock divider */</span>
		<span class="n">clockm</span><span class="p">,</span>		<span class="cm">/* COM20020 clock multiplier flag */</span>
		<span class="n">setup</span><span class="p">,</span>		<span class="cm">/* Contents of setup1 register */</span>
		<span class="n">setup2</span><span class="p">,</span>		<span class="cm">/* Contents of setup2 register */</span>
		<span class="n">intmask</span><span class="p">;</span>	<span class="cm">/* current value of INTMASK register */</span>
	<span class="kt">uint8_t</span> <span class="n">default_proto</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>	<span class="cm">/* default encap to use for each host */</span>
	<span class="kt">int</span>	<span class="n">cur_tx</span><span class="p">,</span>		<span class="cm">/* buffer used by current transmit, or -1 */</span>
		<span class="n">next_tx</span><span class="p">,</span>	<span class="cm">/* buffer where a packet is ready to send */</span>
		<span class="n">cur_rx</span><span class="p">;</span>		<span class="cm">/* current receive buffer */</span>
	<span class="kt">int</span>	<span class="n">lastload_dest</span><span class="p">,</span>	<span class="cm">/* can last loaded packet be acked? */</span>
		<span class="n">lasttrans_dest</span><span class="p">;</span>	<span class="cm">/* can last TX&#39;d packet be acked? */</span>
	<span class="kt">int</span>	<span class="n">timed_out</span><span class="p">;</span>	<span class="cm">/* need to process TX timeout and drop packet */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_timeout</span><span class="p">;</span>	<span class="cm">/* time of last reported timeout */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">card_name</span><span class="p">;</span>	<span class="cm">/* card ident string */</span>
	<span class="kt">int</span> <span class="n">card_flags</span><span class="p">;</span>		<span class="cm">/* special card features */</span>


	<span class="cm">/* On preemtive and SMB a lock is needed */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Buffer management: an ARCnet card has 4 x 512-byte buffers, each of</span>
<span class="cm">	 * which can be used for either sending or receiving.  The new dynamic</span>
<span class="cm">	 * buffer management routines use a simple circular queue of available</span>
<span class="cm">	 * buffers, and take them as they&#39;re needed.  This way, we simplify</span>
<span class="cm">	 * situations in which we (for example) want to pre-load a transmit</span>
<span class="cm">	 * buffer, or start receiving while we copy a received packet to</span>
<span class="cm">	 * memory.</span>
<span class="cm">	 * </span>
<span class="cm">	 * The rules: only the interrupt handler is allowed to _add_ buffers to</span>
<span class="cm">	 * the queue; thus, this doesn&#39;t require a lock.  Both the interrupt</span>
<span class="cm">	 * handler and the transmit function will want to _remove_ buffers, so</span>
<span class="cm">	 * we need to handle the situation where they try to do it at the same</span>
<span class="cm">	 * time.</span>
<span class="cm">	 * </span>
<span class="cm">	 * If next_buf == first_free_buf, the queue is empty.  Since there are</span>
<span class="cm">	 * only four possible buffers, the queue should never be full.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">buf_lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buf_queue</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">next_buf</span><span class="p">,</span> <span class="n">first_free_buf</span><span class="p">;</span>

	<span class="cm">/* network &quot;reconfiguration&quot; handling */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_recon</span><span class="p">;</span> <span class="cm">/* time of &quot;first&quot; RECON message to count */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_recon</span><span class="p">;</span>  <span class="cm">/* time of most recent RECON */</span>
	<span class="kt">int</span> <span class="n">num_recons</span><span class="p">;</span>		<span class="cm">/* number of RECONs between first and last. */</span>
	<span class="n">bool</span> <span class="n">network_down</span><span class="p">;</span>	<span class="cm">/* do we think the network is down? */</span>

	<span class="n">bool</span> <span class="n">excnak_pending</span><span class="p">;</span>    <span class="cm">/* We just got an excesive nak interrupt */</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint16_t</span> <span class="n">sequence</span><span class="p">;</span>	<span class="cm">/* sequence number (incs with each packet) */</span>
		<span class="n">__be16</span> <span class="n">aborted_seq</span><span class="p">;</span>

		<span class="k">struct</span> <span class="n">Incoming</span> <span class="n">incoming</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>	<span class="cm">/* one from each address */</span>
	<span class="p">}</span> <span class="n">rfc1201</span><span class="p">;</span>

	<span class="cm">/* really only used by rfc1201, but we&#39;ll pretend it&#39;s not */</span>
	<span class="k">struct</span> <span class="n">Outgoing</span> <span class="n">outgoing</span><span class="p">;</span>	<span class="cm">/* packet currently being sent */</span>

	<span class="cm">/* hardware-specific functions */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">command</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">);</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">intmask</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">really_reset</span><span class="p">);</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">);</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">);</span>

		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy_to_card</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy_from_card</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">hw</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mem_start</span><span class="p">;</span>	<span class="cm">/* pointer to ioremap&#39;ed MMIO */</span>
<span class="p">};</span>


<span class="cp">#define ARCRESET(x)  (lp-&gt;hw.reset(dev, (x)))</span>
<span class="cp">#define ACOMMAND(x)  (lp-&gt;hw.command(dev, (x)))</span>
<span class="cp">#define ASTATUS()    (lp-&gt;hw.status(dev))</span>
<span class="cp">#define AINTMASK(x)  (lp-&gt;hw.intmask(dev, (x)))</span>



<span class="cp">#if ARCNET_DEBUG_MAX &amp; D_SKB</span>
<span class="kt">void</span> <span class="n">arcnet_dump_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define arcnet_dump_skb(dev,skb,desc) ;</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">arcnet_unregister_proto</span><span class="p">(</span><span class="k">struct</span> <span class="n">ArcProto</span> <span class="o">*</span><span class="n">proto</span><span class="p">);</span>
<span class="n">irqreturn_t</span> <span class="n">arcnet_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">alloc_arcdev</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">arcnet_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">arcnet_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="n">netdev_tx_t</span> <span class="n">arcnet_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">arcnet_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif				</span><span class="cm">/* _LINUX_ARCDEVICE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
