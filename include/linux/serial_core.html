<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › serial_core.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>serial_core.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/drivers/char/serial_core.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2000 Deep Blue Solutions Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cp">#ifndef LINUX_SERIAL_CORE_H</span>
<span class="cp">#define LINUX_SERIAL_CORE_H</span>

<span class="cp">#include &lt;linux/serial.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The type definitions.  These are from Ted Ts&#39;o&#39;s serial.h</span>
<span class="cm"> */</span>
<span class="cp">#define PORT_UNKNOWN	0</span>
<span class="cp">#define PORT_8250	1</span>
<span class="cp">#define PORT_16450	2</span>
<span class="cp">#define PORT_16550	3</span>
<span class="cp">#define PORT_16550A	4</span>
<span class="cp">#define PORT_CIRRUS	5</span>
<span class="cp">#define PORT_16650	6</span>
<span class="cp">#define PORT_16650V2	7</span>
<span class="cp">#define PORT_16750	8</span>
<span class="cp">#define PORT_STARTECH	9</span>
<span class="cp">#define PORT_16C950	10</span>
<span class="cp">#define PORT_16654	11</span>
<span class="cp">#define PORT_16850	12</span>
<span class="cp">#define PORT_RSA	13</span>
<span class="cp">#define PORT_NS16550A	14</span>
<span class="cp">#define PORT_XSCALE	15</span>
<span class="cp">#define PORT_RM9000	16	</span><span class="cm">/* PMC-Sierra RM9xxx internal UART */</span><span class="cp"></span>
<span class="cp">#define PORT_OCTEON	17	</span><span class="cm">/* Cavium OCTEON internal UART */</span><span class="cp"></span>
<span class="cp">#define PORT_AR7	18	</span><span class="cm">/* Texas Instruments AR7 internal UART */</span><span class="cp"></span>
<span class="cp">#define PORT_U6_16550A	19	</span><span class="cm">/* ST-Ericsson U6xxx internal UART */</span><span class="cp"></span>
<span class="cp">#define PORT_TEGRA	20	</span><span class="cm">/* NVIDIA Tegra internal UART */</span><span class="cp"></span>
<span class="cp">#define PORT_XR17D15X	21	</span><span class="cm">/* Exar XR17D15x UART */</span><span class="cp"></span>
<span class="cp">#define PORT_MAX_8250	21	</span><span class="cm">/* max port ID */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ARM specific type numbers.  These are not currently guaranteed</span>
<span class="cm"> * to be implemented, and will change in the future.  These are</span>
<span class="cm"> * separate so any additions to the old serial.c that occur before</span>
<span class="cm"> * we are merged can be easily merged here.</span>
<span class="cm"> */</span>
<span class="cp">#define PORT_PXA	31</span>
<span class="cp">#define PORT_AMBA	32</span>
<span class="cp">#define PORT_CLPS711X	33</span>
<span class="cp">#define PORT_SA1100	34</span>
<span class="cp">#define PORT_UART00	35</span>
<span class="cp">#define PORT_21285	37</span>

<span class="cm">/* Sparc type numbers.  */</span>
<span class="cp">#define PORT_SUNZILOG	38</span>
<span class="cp">#define PORT_SUNSAB	39</span>

<span class="cm">/* DEC */</span>
<span class="cp">#define PORT_DZ		46</span>
<span class="cp">#define PORT_ZS		47</span>

<span class="cm">/* Parisc type numbers. */</span>
<span class="cp">#define PORT_MUX	48</span>

<span class="cm">/* Atmel AT91 / AT32 SoC */</span>
<span class="cp">#define PORT_ATMEL	49</span>

<span class="cm">/* Macintosh Zilog type numbers */</span>
<span class="cp">#define PORT_MAC_ZILOG	50	</span><span class="cm">/* m68k : not yet implemented */</span><span class="cp"></span>
<span class="cp">#define PORT_PMAC_ZILOG	51</span>

<span class="cm">/* SH-SCI */</span>
<span class="cp">#define PORT_SCI	52</span>
<span class="cp">#define PORT_SCIF	53</span>
<span class="cp">#define PORT_IRDA	54</span>

<span class="cm">/* Samsung S3C2410 SoC and derivatives thereof */</span>
<span class="cp">#define PORT_S3C2410    55</span>

<span class="cm">/* SGI IP22 aka Indy / Challenge S / Indigo 2 */</span>
<span class="cp">#define PORT_IP22ZILOG	56</span>

<span class="cm">/* Sharp LH7a40x -- an ARM9 SoC series */</span>
<span class="cp">#define PORT_LH7A40X	57</span>

<span class="cm">/* PPC CPM type number */</span>
<span class="cp">#define PORT_CPM        58</span>

<span class="cm">/* MPC52xx (and MPC512x) type numbers */</span>
<span class="cp">#define PORT_MPC52xx	59</span>

<span class="cm">/* IBM icom */</span>
<span class="cp">#define PORT_ICOM	60</span>

<span class="cm">/* Samsung S3C2440 SoC */</span>
<span class="cp">#define PORT_S3C2440	61</span>

<span class="cm">/* Motorola i.MX SoC */</span>
<span class="cp">#define PORT_IMX	62</span>

<span class="cm">/* Marvell MPSC */</span>
<span class="cp">#define PORT_MPSC	63</span>

<span class="cm">/* TXX9 type number */</span>
<span class="cp">#define PORT_TXX9	64</span>

<span class="cm">/* NEC VR4100 series SIU/DSIU */</span>
<span class="cp">#define PORT_VR41XX_SIU		65</span>
<span class="cp">#define PORT_VR41XX_DSIU	66</span>

<span class="cm">/* Samsung S3C2400 SoC */</span>
<span class="cp">#define PORT_S3C2400	67</span>

<span class="cm">/* M32R SIO */</span>
<span class="cp">#define PORT_M32R_SIO	68</span>

<span class="cm">/*Digi jsm */</span>
<span class="cp">#define PORT_JSM        69</span>

<span class="cp">#define PORT_PNX8XXX	70</span>

<span class="cm">/* Hilscher netx */</span>
<span class="cp">#define PORT_NETX	71</span>

<span class="cm">/* SUN4V Hypervisor Console */</span>
<span class="cp">#define PORT_SUNHV	72</span>

<span class="cp">#define PORT_S3C2412	73</span>

<span class="cm">/* Xilinx uartlite */</span>
<span class="cp">#define PORT_UARTLITE	74</span>

<span class="cm">/* Blackfin bf5xx */</span>
<span class="cp">#define PORT_BFIN	75</span>

<span class="cm">/* Micrel KS8695 */</span>
<span class="cp">#define PORT_KS8695	76</span>

<span class="cm">/* Broadcom SB1250, etc. SOC */</span>
<span class="cp">#define PORT_SB1250_DUART	77</span>

<span class="cm">/* Freescale ColdFire */</span>
<span class="cp">#define PORT_MCF	78</span>

<span class="cm">/* Blackfin SPORT */</span>
<span class="cp">#define PORT_BFIN_SPORT		79</span>

<span class="cm">/* MN10300 on-chip UART numbers */</span>
<span class="cp">#define PORT_MN10300		80</span>
<span class="cp">#define PORT_MN10300_CTS	81</span>

<span class="cp">#define PORT_SC26XX	82</span>

<span class="cm">/* SH-SCI */</span>
<span class="cp">#define PORT_SCIFA	83</span>

<span class="cp">#define PORT_S3C6400	84</span>

<span class="cm">/* NWPSERIAL */</span>
<span class="cp">#define PORT_NWPSERIAL	85</span>

<span class="cm">/* MAX3100 */</span>
<span class="cp">#define PORT_MAX3100    86</span>

<span class="cm">/* Timberdale UART */</span>
<span class="cp">#define PORT_TIMBUART	87</span>

<span class="cm">/* Qualcomm MSM SoCs */</span>
<span class="cp">#define PORT_MSM	88</span>

<span class="cm">/* BCM63xx family SoCs */</span>
<span class="cp">#define PORT_BCM63XX	89</span>

<span class="cm">/* Aeroflex Gaisler GRLIB APBUART */</span>
<span class="cp">#define PORT_APBUART    90</span>

<span class="cm">/* Altera UARTs */</span>
<span class="cp">#define PORT_ALTERA_JTAGUART	91</span>
<span class="cp">#define PORT_ALTERA_UART	92</span>

<span class="cm">/* SH-SCI */</span>
<span class="cp">#define PORT_SCIFB	93</span>

<span class="cm">/* MAX3107 */</span>
<span class="cp">#define PORT_MAX3107	94</span>

<span class="cm">/* High Speed UART for Medfield */</span>
<span class="cp">#define PORT_MFD	95</span>

<span class="cm">/* TI OMAP-UART */</span>
<span class="cp">#define PORT_OMAP	96</span>

<span class="cm">/* VIA VT8500 SoC */</span>
<span class="cp">#define PORT_VT8500	97</span>

<span class="cm">/* Xilinx PSS UART */</span>
<span class="cp">#define PORT_XUARTPS	98</span>

<span class="cm">/* Atheros AR933X SoC */</span>
<span class="cp">#define PORT_AR933X	99</span>

<span class="cm">/* Energy Micro efm32 SoC */</span>
<span class="cp">#define PORT_EFMUART   100</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/circ_buf.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/sysrq.h&gt;</span>
<span class="cp">#include &lt;linux/pps_kernel.h&gt;</span>

<span class="k">struct</span> <span class="n">uart_port</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">serial_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This structure describes all the operations that can be</span>
<span class="cm"> * done on the physical hardware.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uart_ops</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">tx_empty</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">set_mctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mctrl</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_mctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">stop_tx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">start_tx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">send_xchar</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">stop_rx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">enable_ms</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">break_ctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctl</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">startup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">flush_buffer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">set_termios</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">set_ldisc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">pm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldstate</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">set_wake</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return a string describing the type of the port</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">type</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release IO and memory resources used by the port.</span>
<span class="cm">	 * This includes iounmap if necessary.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">release_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Request IO and memory resources used by the port.</span>
<span class="cm">	 * This includes iomapping the port if necessary.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">request_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">config_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">verify_port</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">serial_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CONSOLE_POLL</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">poll_put_char</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">poll_get_char</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define NO_POLL_CHAR		0x00ff0000</span>
<span class="cp">#define UART_CONFIG_TYPE	(1 &lt;&lt; 0)</span>
<span class="cp">#define UART_CONFIG_IRQ		(1 &lt;&lt; 1)</span>

<span class="k">struct</span> <span class="n">uart_icount</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cts</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">dsr</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rng</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">dcd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">frame</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">overrun</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">parity</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">brk</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">buf_overrun</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__bitwise__</span> <span class="n">upf_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">uart_port</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>			<span class="cm">/* port lock */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">iobase</span><span class="p">;</span>			<span class="cm">/* in/out[bwl] */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__iomem</span>	<span class="o">*</span><span class="n">membase</span><span class="p">;</span>		<span class="cm">/* read/write[bwl] */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">serial_in</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">serial_out</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">set_termios</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span>
				               <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
				               <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">handle_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">pm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">handle_break</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>			<span class="cm">/* irq number */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">irqflags</span><span class="p">;</span>		<span class="cm">/* irq flags  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">uartclk</span><span class="p">;</span>		<span class="cm">/* base uart clock */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">fifosize</span><span class="p">;</span>		<span class="cm">/* tx fifo size */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">x_char</span><span class="p">;</span>			<span class="cm">/* xon/xoff char */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">regshift</span><span class="p">;</span>		<span class="cm">/* reg offset shift */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">iotype</span><span class="p">;</span>			<span class="cm">/* io access style */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">unused1</span><span class="p">;</span>

<span class="cp">#define UPIO_PORT		(0)</span>
<span class="cp">#define UPIO_HUB6		(1)</span>
<span class="cp">#define UPIO_MEM		(2)</span>
<span class="cp">#define UPIO_MEM32		(3)</span>
<span class="cp">#define UPIO_AU			(4)			</span><span class="cm">/* Au1x00 type IO */</span><span class="cp"></span>
<span class="cp">#define UPIO_TSI		(5)			</span><span class="cm">/* Tsi108/109 type IO */</span><span class="cp"></span>
<span class="cp">#define UPIO_RM9000		(6)			</span><span class="cm">/* RM9000 type IO */</span><span class="cp"></span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">read_status_mask</span><span class="p">;</span>	<span class="cm">/* driver specific */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ignore_status_mask</span><span class="p">;</span>	<span class="cm">/* driver specific */</span>
	<span class="k">struct</span> <span class="n">uart_state</span>	<span class="o">*</span><span class="n">state</span><span class="p">;</span>			<span class="cm">/* pointer to parent state */</span>
	<span class="k">struct</span> <span class="n">uart_icount</span>	<span class="n">icount</span><span class="p">;</span>			<span class="cm">/* statistics */</span>

	<span class="k">struct</span> <span class="n">console</span>		<span class="o">*</span><span class="n">cons</span><span class="p">;</span>			<span class="cm">/* struct console, if any */</span>
<span class="cp">#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">sysrq</span><span class="p">;</span>			<span class="cm">/* sysrq timeout */</span>
<span class="cp">#endif</span>

	<span class="n">upf_t</span>			<span class="n">flags</span><span class="p">;</span>

<span class="cp">#define UPF_FOURPORT		((__force upf_t) (1 &lt;&lt; 1))</span>
<span class="cp">#define UPF_SAK			((__force upf_t) (1 &lt;&lt; 2))</span>
<span class="cp">#define UPF_SPD_MASK		((__force upf_t) (0x1030))</span>
<span class="cp">#define UPF_SPD_HI		((__force upf_t) (0x0010))</span>
<span class="cp">#define UPF_SPD_VHI		((__force upf_t) (0x0020))</span>
<span class="cp">#define UPF_SPD_CUST		((__force upf_t) (0x0030))</span>
<span class="cp">#define UPF_SPD_SHI		((__force upf_t) (0x1000))</span>
<span class="cp">#define UPF_SPD_WARP		((__force upf_t) (0x1010))</span>
<span class="cp">#define UPF_SKIP_TEST		((__force upf_t) (1 &lt;&lt; 6))</span>
<span class="cp">#define UPF_AUTO_IRQ		((__force upf_t) (1 &lt;&lt; 7))</span>
<span class="cp">#define UPF_HARDPPS_CD		((__force upf_t) (1 &lt;&lt; 11))</span>
<span class="cp">#define UPF_LOW_LATENCY		((__force upf_t) (1 &lt;&lt; 13))</span>
<span class="cp">#define UPF_BUGGY_UART		((__force upf_t) (1 &lt;&lt; 14))</span>
<span class="cp">#define UPF_NO_TXEN_TEST	((__force upf_t) (1 &lt;&lt; 15))</span>
<span class="cp">#define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 &lt;&lt; 16))</span>
<span class="cp">#define UPF_CONS_FLOW		((__force upf_t) (1 &lt;&lt; 23))</span>
<span class="cp">#define UPF_SHARE_IRQ		((__force upf_t) (1 &lt;&lt; 24))</span>
<span class="cp">#define UPF_EXAR_EFR		((__force upf_t) (1 &lt;&lt; 25))</span>
<span class="cp">#define UPF_BUG_THRE		((__force upf_t) (1 &lt;&lt; 26))</span>
<span class="cm">/* The exact UART type is known and should not be probed.  */</span>
<span class="cp">#define UPF_FIXED_TYPE		((__force upf_t) (1 &lt;&lt; 27))</span>
<span class="cp">#define UPF_BOOT_AUTOCONF	((__force upf_t) (1 &lt;&lt; 28))</span>
<span class="cp">#define UPF_FIXED_PORT		((__force upf_t) (1 &lt;&lt; 29))</span>
<span class="cp">#define UPF_DEAD		((__force upf_t) (1 &lt;&lt; 30))</span>
<span class="cp">#define UPF_IOREMAP		((__force upf_t) (1 &lt;&lt; 31))</span>

<span class="cp">#define UPF_CHANGE_MASK		((__force upf_t) (0x17fff))</span>
<span class="cp">#define UPF_USR_MASK		((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">mctrl</span><span class="p">;</span>			<span class="cm">/* current modem ctrl settings */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">timeout</span><span class="p">;</span>		<span class="cm">/* character-based timeout */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">type</span><span class="p">;</span>			<span class="cm">/* port type */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">uart_ops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">custom_divisor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">line</span><span class="p">;</span>			<span class="cm">/* port index */</span>
	<span class="n">resource_size_t</span>		<span class="n">mapbase</span><span class="p">;</span>		<span class="cm">/* for ioremap */</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>			<span class="cm">/* parent device */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">hub6</span><span class="p">;</span>			<span class="cm">/* this should be in the 8250 driver */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">suspended</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">irq_wake</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">unused</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>		<span class="cm">/* generic platform data pointer */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">serial_port_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">up</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">up</span><span class="o">-&gt;</span><span class="n">serial_in</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">serial_port_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">up</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up</span><span class="o">-&gt;</span><span class="n">serial_out</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the state information which is persistent across opens.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uart_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_port</span>		<span class="n">port</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">pm_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circ_buf</span>		<span class="n">xmit</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uart_port</span>	<span class="o">*</span><span class="n">uart_port</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define UART_XMIT_SIZE	PAGE_SIZE</span>


<span class="cm">/* number of characters left in xmit buffer before we ask for more */</span>
<span class="cp">#define WAKEUP_CHARS		256</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tty_driver</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">uart_driver</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span>		<span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">driver_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
	<span class="kt">int</span>			 <span class="n">major</span><span class="p">;</span>
	<span class="kt">int</span>			 <span class="n">minor</span><span class="p">;</span>
	<span class="kt">int</span>			 <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">console</span>		<span class="o">*</span><span class="n">cons</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * these are private; the low level driver should not</span>
<span class="cm">	 * touch these; they should be initialised to NULL</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">uart_state</span>	<span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_driver</span>	<span class="o">*</span><span class="n">tty_driver</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">uart_write_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Baud rate helpers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">uart_update_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflag</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">baud</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uart_get_baud_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uart_get_divisor</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">baud</span><span class="p">);</span>

<span class="cm">/* Base timer interval for polling */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uart_poll_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">6</span> <span class="o">?</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Console helpers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uart_get_console</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">ports</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uart_parse_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">baud</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">parity</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bits</span><span class="p">,</span>
			<span class="kt">int</span> <span class="o">*</span><span class="n">flow</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uart_set_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="kt">int</span> <span class="n">baud</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">parity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flow</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">uart_console_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uart_console_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">putchar</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * Port/driver registration/removal</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">uart_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">uart</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uart_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">uart</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uart_add_one_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uart_remove_one_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uart_match_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port2</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Power Management</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">uart_suspend_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uart_resume_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>

<span class="cp">#define uart_circ_empty(circ)		((circ)-&gt;head == (circ)-&gt;tail)</span>
<span class="cp">#define uart_circ_clear(circ)		((circ)-&gt;head = (circ)-&gt;tail = 0)</span>

<span class="cp">#define uart_circ_chars_pending(circ)	\</span>
<span class="cp">	(CIRC_CNT((circ)-&gt;head, (circ)-&gt;tail, UART_XMIT_SIZE))</span>

<span class="cp">#define uart_circ_chars_free(circ)	\</span>
<span class="cp">	(CIRC_SPACE((circ)-&gt;head, (circ)-&gt;tail, UART_XMIT_SIZE))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uart_tx_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">||</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following are helper functions for the low level drivers.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">uart_handle_dcd_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">uart_handle_cts_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">uart_insert_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">overrun</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>

<span class="cp">#ifdef SUPPORT_SYSRQ</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">uart_handle_sysrq_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sysrq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sysrq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">handle_sysrq</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">sysrq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">sysrq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define uart_handle_sysrq_char(port,ch) ({ (void)port; 0; })</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * We do the SysRQ and SAK checking like this...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uart_handle_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">handle_break</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">handle_break</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

<span class="cp">#ifdef SUPPORT_SYSRQ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cons</span> <span class="o">&amp;&amp;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sysrq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">sysrq</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">*</span><span class="mi">5</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">sysrq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_SAK</span><span class="p">)</span>
		<span class="n">do_SAK</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	UART_ENABLE_MS - determine if port should enable modem status irqs</span>
<span class="cm"> */</span>
<span class="cp">#define UART_ENABLE_MS(port,cflag)	((port)-&gt;flags &amp; UPF_HARDPPS_CD || \</span>
<span class="cp">					 (cflag) &amp; CRTSCTS || \</span>
<span class="cp">					 !((cflag) &amp; CLOCAL))</span>

<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* LINUX_SERIAL_CORE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
