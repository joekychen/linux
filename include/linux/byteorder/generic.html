<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › byteorder › generic.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>generic.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_BYTEORDER_GENERIC_H</span>
<span class="cp">#define _LINUX_BYTEORDER_GENERIC_H</span>

<span class="cm">/*</span>
<span class="cm"> * linux/byteorder_generic.h</span>
<span class="cm"> * Generic Byte-reordering support</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;... p&quot; macros, like le64_to_cpup, can be used with pointers</span>
<span class="cm"> * to unaligned data, but there will be a performance penalty on </span>
<span class="cm"> * some architectures.  Use get_unaligned for unaligned data.</span>
<span class="cm"> *</span>
<span class="cm"> * Francois-Rene Rideau &lt;fare@tunes.org&gt; 19970707</span>
<span class="cm"> *    gathered all the good ideas from all asm-foo/byteorder.h into one file,</span>
<span class="cm"> *    cleaned them up.</span>
<span class="cm"> *    I hope it is compliant with non-GCC compilers.</span>
<span class="cm"> *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,</span>
<span class="cm"> *    because I wasn&#39;t sure it would be ok to put it in types.h</span>
<span class="cm"> *    Upgraded it to 2.1.43</span>
<span class="cm"> * Francois-Rene Rideau &lt;fare@tunes.org&gt; 19971012</span>
<span class="cm"> *    Upgraded it to 2.1.57</span>
<span class="cm"> *    to please Linus T., replaced huge #ifdef&#39;s between little/big endian</span>
<span class="cm"> *    by nestedly #include&#39;d files.</span>
<span class="cm"> * Francois-Rene Rideau &lt;fare@tunes.org&gt; 19971205</span>
<span class="cm"> *    Made it to 2.1.71; now a facelift:</span>
<span class="cm"> *    Put files under include/linux/byteorder/</span>
<span class="cm"> *    Split swab from generic support.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO:</span>
<span class="cm"> *   = Regular kernel maintainers could also replace all these manual</span>
<span class="cm"> *    byteswap macros that remain, disseminated among drivers,</span>
<span class="cm"> *    after some grep or the sources...</span>
<span class="cm"> *   = Linus might want to rename all these macros and files to fit his taste,</span>
<span class="cm"> *    to fit his personal naming scheme.</span>
<span class="cm"> *   = it seems that a few drivers would also appreciate</span>
<span class="cm"> *    nybble swapping support...</span>
<span class="cm"> *   = every architecture could add their byteswap macro in asm/byteorder.h</span>
<span class="cm"> *    see how some architectures already do (i386, alpha, ppc, etc)</span>
<span class="cm"> *   = cpu_to_beXX and beXX_to_cpu might some day need to be well</span>
<span class="cm"> *    distinguished throughout the kernel. This is not the case currently,</span>
<span class="cm"> *    since little endian, big endian, and pdp endian machines needn&#39;t it.</span>
<span class="cm"> *    But this might be the case for, say, a port of Linux to 20/21 bit</span>
<span class="cm"> *    architectures (and F21 Linux addict around?).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The following macros are to be defined by &lt;asm/byteorder.h&gt;:</span>
<span class="cm"> *</span>
<span class="cm"> * Conversion of long and short int between network and host format</span>
<span class="cm"> *	ntohl(__u32 x)</span>
<span class="cm"> *	ntohs(__u16 x)</span>
<span class="cm"> *	htonl(__u32 x)</span>
<span class="cm"> *	htons(__u16 x)</span>
<span class="cm"> * It seems that some programs (which? where? or perhaps a standard? POSIX?)</span>
<span class="cm"> * might like the above to be functions, not macros (why?).</span>
<span class="cm"> * if that&#39;s true, then detect them, and take measures.</span>
<span class="cm"> * Anyway, the measure is: define only ___ntohl as a macro instead,</span>
<span class="cm"> * and in a separate file, have</span>
<span class="cm"> * unsigned long inline ntohl(x){return ___ntohl(x);}</span>
<span class="cm"> *</span>
<span class="cm"> * The same for constant arguments</span>
<span class="cm"> *	__constant_ntohl(__u32 x)</span>
<span class="cm"> *	__constant_ntohs(__u16 x)</span>
<span class="cm"> *	__constant_htonl(__u32 x)</span>
<span class="cm"> *	__constant_htons(__u16 x)</span>
<span class="cm"> *</span>
<span class="cm"> * Conversion of XX-bit integers (16- 32- or 64-)</span>
<span class="cm"> * between native CPU format and little/big endian format</span>
<span class="cm"> * 64-bit stuff only defined for proper architectures</span>
<span class="cm"> *	cpu_to_[bl]eXX(__uXX x)</span>
<span class="cm"> *	[bl]eXX_to_cpu(__uXX x)</span>
<span class="cm"> *</span>
<span class="cm"> * The same, but takes a pointer to the value to convert</span>
<span class="cm"> *	cpu_to_[bl]eXXp(__uXX x)</span>
<span class="cm"> *	[bl]eXX_to_cpup(__uXX x)</span>
<span class="cm"> *</span>
<span class="cm"> * The same, but change in situ</span>
<span class="cm"> *	cpu_to_[bl]eXXs(__uXX x)</span>
<span class="cm"> *	[bl]eXX_to_cpus(__uXX x)</span>
<span class="cm"> *</span>
<span class="cm"> * See asm-foo/byteorder.h for examples of how to provide</span>
<span class="cm"> * architecture-optimized versions</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define cpu_to_le64 __cpu_to_le64</span>
<span class="cp">#define le64_to_cpu __le64_to_cpu</span>
<span class="cp">#define cpu_to_le32 __cpu_to_le32</span>
<span class="cp">#define le32_to_cpu __le32_to_cpu</span>
<span class="cp">#define cpu_to_le16 __cpu_to_le16</span>
<span class="cp">#define le16_to_cpu __le16_to_cpu</span>
<span class="cp">#define cpu_to_be64 __cpu_to_be64</span>
<span class="cp">#define be64_to_cpu __be64_to_cpu</span>
<span class="cp">#define cpu_to_be32 __cpu_to_be32</span>
<span class="cp">#define be32_to_cpu __be32_to_cpu</span>
<span class="cp">#define cpu_to_be16 __cpu_to_be16</span>
<span class="cp">#define be16_to_cpu __be16_to_cpu</span>
<span class="cp">#define cpu_to_le64p __cpu_to_le64p</span>
<span class="cp">#define le64_to_cpup __le64_to_cpup</span>
<span class="cp">#define cpu_to_le32p __cpu_to_le32p</span>
<span class="cp">#define le32_to_cpup __le32_to_cpup</span>
<span class="cp">#define cpu_to_le16p __cpu_to_le16p</span>
<span class="cp">#define le16_to_cpup __le16_to_cpup</span>
<span class="cp">#define cpu_to_be64p __cpu_to_be64p</span>
<span class="cp">#define be64_to_cpup __be64_to_cpup</span>
<span class="cp">#define cpu_to_be32p __cpu_to_be32p</span>
<span class="cp">#define be32_to_cpup __be32_to_cpup</span>
<span class="cp">#define cpu_to_be16p __cpu_to_be16p</span>
<span class="cp">#define be16_to_cpup __be16_to_cpup</span>
<span class="cp">#define cpu_to_le64s __cpu_to_le64s</span>
<span class="cp">#define le64_to_cpus __le64_to_cpus</span>
<span class="cp">#define cpu_to_le32s __cpu_to_le32s</span>
<span class="cp">#define le32_to_cpus __le32_to_cpus</span>
<span class="cp">#define cpu_to_le16s __cpu_to_le16s</span>
<span class="cp">#define le16_to_cpus __le16_to_cpus</span>
<span class="cp">#define cpu_to_be64s __cpu_to_be64s</span>
<span class="cp">#define be64_to_cpus __be64_to_cpus</span>
<span class="cp">#define cpu_to_be32s __cpu_to_be32s</span>
<span class="cp">#define be32_to_cpus __be32_to_cpus</span>
<span class="cp">#define cpu_to_be16s __cpu_to_be16s</span>
<span class="cp">#define be16_to_cpus __be16_to_cpus</span>

<span class="cm">/*</span>
<span class="cm"> * They have to be macros in order to do the constant folding</span>
<span class="cm"> * correctly - if the argument passed into a inline function</span>
<span class="cm"> * it is no longer constant according to gcc..</span>
<span class="cm"> */</span>

<span class="cp">#undef ntohl</span>
<span class="cp">#undef ntohs</span>
<span class="cp">#undef htonl</span>
<span class="cp">#undef htons</span>

<span class="cp">#define ___htonl(x) __cpu_to_be32(x)</span>
<span class="cp">#define ___htons(x) __cpu_to_be16(x)</span>
<span class="cp">#define ___ntohl(x) __be32_to_cpu(x)</span>
<span class="cp">#define ___ntohs(x) __be16_to_cpu(x)</span>

<span class="cp">#define htonl(x) ___htonl(x)</span>
<span class="cp">#define ntohl(x) ___ntohl(x)</span>
<span class="cp">#define htons(x) ___htons(x)</span>
<span class="cp">#define ntohs(x) ___ntohs(x)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">le16_add_cpu</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">var</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">le32_add_cpu</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">var</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">le64_add_cpu</span><span class="p">(</span><span class="n">__le64</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">var</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">be16_add_cpu</span><span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">var</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">be32_add_cpu</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">var</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">be64_add_cpu</span><span class="p">(</span><span class="n">__be64</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">var</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_BYTEORDER_GENERIC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
