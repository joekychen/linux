<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › fs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_FS_H</span>
<span class="cp">#define _LINUX_FS_H</span>

<span class="cm">/*</span>
<span class="cm"> * This file has definitions for some important file table</span>
<span class="cm"> * structures etc.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/limits.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/blk_types.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * It&#39;s silly to have NR_OPEN bigger than NR_FILE, but you can change</span>
<span class="cm"> * the file limit at runtime and only root can increase the per-process</span>
<span class="cm"> * nr_file rlimit, so it&#39;s safe to set up a ridiculously high absolute</span>
<span class="cm"> * upper limit on files-per-process.</span>
<span class="cm"> *</span>
<span class="cm"> * Some programs (notably those using select()) may have to be </span>
<span class="cm"> * recompiled to take full advantage of the new limits..  </span>
<span class="cm"> */</span>

<span class="cm">/* Fixed constants first: */</span>
<span class="cp">#undef NR_OPEN</span>
<span class="cp">#define INR_OPEN_CUR 1024	</span><span class="cm">/* Initial setting for nfile rlimits */</span><span class="cp"></span>
<span class="cp">#define INR_OPEN_MAX 4096	</span><span class="cm">/* Hard limit for nfile rlimits */</span><span class="cp"></span>

<span class="cp">#define BLOCK_SIZE_BITS 10</span>
<span class="cp">#define BLOCK_SIZE (1&lt;&lt;BLOCK_SIZE_BITS)</span>

<span class="cp">#define SEEK_SET	0	</span><span class="cm">/* seek relative to beginning of file */</span><span class="cp"></span>
<span class="cp">#define SEEK_CUR	1	</span><span class="cm">/* seek relative to current file position */</span><span class="cp"></span>
<span class="cp">#define SEEK_END	2	</span><span class="cm">/* seek relative to end of file */</span><span class="cp"></span>
<span class="cp">#define SEEK_DATA	3	</span><span class="cm">/* seek to the next data */</span><span class="cp"></span>
<span class="cp">#define SEEK_HOLE	4	</span><span class="cm">/* seek to the next hole */</span><span class="cp"></span>
<span class="cp">#define SEEK_MAX	SEEK_HOLE</span>

<span class="k">struct</span> <span class="n">fstrim_range</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">minlen</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* And dynamically-tunable limits and defaults: */</span>
<span class="k">struct</span> <span class="n">files_stat_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_files</span><span class="p">;</span>		<span class="cm">/* read only */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_free_files</span><span class="p">;</span>	<span class="cm">/* read only */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_files</span><span class="p">;</span>		<span class="cm">/* tunable */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">inodes_stat_t</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_inodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_unused</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>		<span class="cm">/* padding for sysctl ABI compatibility */</span>
<span class="p">};</span>


<span class="cp">#define NR_FILE  8192	</span><span class="cm">/* this can well be larger on a larger system */</span><span class="cp"></span>

<span class="cp">#define MAY_EXEC		0x00000001</span>
<span class="cp">#define MAY_WRITE		0x00000002</span>
<span class="cp">#define MAY_READ		0x00000004</span>
<span class="cp">#define MAY_APPEND		0x00000008</span>
<span class="cp">#define MAY_ACCESS		0x00000010</span>
<span class="cp">#define MAY_OPEN		0x00000020</span>
<span class="cp">#define MAY_CHDIR		0x00000040</span>
<span class="cm">/* called from RCU mode, don&#39;t block */</span>
<span class="cp">#define MAY_NOT_BLOCK		0x00000080</span>

<span class="cm">/*</span>
<span class="cm"> * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond</span>
<span class="cm"> * to O_WRONLY and O_RDWR via the strange trick in __dentry_open()</span>
<span class="cm"> */</span>

<span class="cm">/* file is open for reading */</span>
<span class="cp">#define FMODE_READ		((__force fmode_t)0x1)</span>
<span class="cm">/* file is open for writing */</span>
<span class="cp">#define FMODE_WRITE		((__force fmode_t)0x2)</span>
<span class="cm">/* file is seekable */</span>
<span class="cp">#define FMODE_LSEEK		((__force fmode_t)0x4)</span>
<span class="cm">/* file can be accessed using pread */</span>
<span class="cp">#define FMODE_PREAD		((__force fmode_t)0x8)</span>
<span class="cm">/* file can be accessed using pwrite */</span>
<span class="cp">#define FMODE_PWRITE		((__force fmode_t)0x10)</span>
<span class="cm">/* File is opened for execution with sys_execve / sys_uselib */</span>
<span class="cp">#define FMODE_EXEC		((__force fmode_t)0x20)</span>
<span class="cm">/* File is opened with O_NDELAY (only set for block devices) */</span>
<span class="cp">#define FMODE_NDELAY		((__force fmode_t)0x40)</span>
<span class="cm">/* File is opened with O_EXCL (only set for block devices) */</span>
<span class="cp">#define FMODE_EXCL		((__force fmode_t)0x80)</span>
<span class="cm">/* File is opened using open(.., 3, ..) and is writeable only for ioctls</span>
<span class="cm">   (specialy hack for floppy.c) */</span>
<span class="cp">#define FMODE_WRITE_IOCTL	((__force fmode_t)0x100)</span>
<span class="cm">/* 32bit hashes as llseek() offset (for directories) */</span>
<span class="cp">#define FMODE_32BITHASH         ((__force fmode_t)0x200)</span>
<span class="cm">/* 64bit hashes as llseek() offset (for directories) */</span>
<span class="cp">#define FMODE_64BITHASH         ((__force fmode_t)0x400)</span>

<span class="cm">/*</span>
<span class="cm"> * Don&#39;t update ctime and mtime.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently a special hack for the XFS open_by_handle ioctl, but we&#39;ll</span>
<span class="cm"> * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.</span>
<span class="cm"> */</span>
<span class="cp">#define FMODE_NOCMTIME		((__force fmode_t)0x800)</span>

<span class="cm">/* Expect random access pattern */</span>
<span class="cp">#define FMODE_RANDOM		((__force fmode_t)0x1000)</span>

<span class="cm">/* File is huge (eg. /dev/kmem): treat loff_t as unsigned */</span>
<span class="cp">#define FMODE_UNSIGNED_OFFSET	((__force fmode_t)0x2000)</span>

<span class="cm">/* File is opened with O_PATH; almost nothing can be done with it */</span>
<span class="cp">#define FMODE_PATH		((__force fmode_t)0x4000)</span>

<span class="cm">/* File was opened by fanotify and shouldn&#39;t generate fanotify events */</span>
<span class="cp">#define FMODE_NONOTIFY		((__force fmode_t)0x1000000)</span>

<span class="cm">/*</span>
<span class="cm"> * The below are the various read and write types that we support. Some of</span>
<span class="cm"> * them include behavioral modifiers that send information down to the</span>
<span class="cm"> * block layer and IO scheduler. Terminology:</span>
<span class="cm"> *</span>
<span class="cm"> *	The block layer uses device plugging to defer IO a little bit, in</span>
<span class="cm"> *	the hope that we will see more IO very shortly. This increases</span>
<span class="cm"> *	coalescing of adjacent IO and thus reduces the number of IOs we</span>
<span class="cm"> *	have to send to the device. It also allows for better queuing,</span>
<span class="cm"> *	if the IO isn&#39;t mergeable. If the caller is going to be waiting</span>
<span class="cm"> *	for the IO, then he must ensure that the device is unplugged so</span>
<span class="cm"> *	that the IO is dispatched to the driver.</span>
<span class="cm"> *</span>
<span class="cm"> *	All IO is handled async in Linux. This is fine for background</span>
<span class="cm"> *	writes, but for reads or writes that someone waits for completion</span>
<span class="cm"> *	on, we want to notify the block layer and IO scheduler so that they</span>
<span class="cm"> *	know about it. That allows them to make better scheduling</span>
<span class="cm"> *	decisions. So when the below references &#39;sync&#39; and &#39;async&#39;, it</span>
<span class="cm"> *	is referencing this priority hint.</span>
<span class="cm"> *</span>
<span class="cm"> * With that in mind, the available types are:</span>
<span class="cm"> *</span>
<span class="cm"> * READ			A normal read operation. Device will be plugged.</span>
<span class="cm"> * READ_SYNC		A synchronous read. Device is not plugged, caller can</span>
<span class="cm"> *			immediately wait on this read without caring about</span>
<span class="cm"> *			unplugging.</span>
<span class="cm"> * READA		Used for read-ahead operations. Lower priority, and the</span>
<span class="cm"> *			block layer could (in theory) choose to ignore this</span>
<span class="cm"> *			request if it runs into resource problems.</span>
<span class="cm"> * WRITE		A normal async write. Device will be plugged.</span>
<span class="cm"> * WRITE_SYNC		Synchronous write. Identical to WRITE, but passes down</span>
<span class="cm"> *			the hint that someone will be waiting on this IO</span>
<span class="cm"> *			shortly. The write equivalent of READ_SYNC.</span>
<span class="cm"> * WRITE_ODIRECT	Special case write for O_DIRECT only.</span>
<span class="cm"> * WRITE_FLUSH		Like WRITE_SYNC but with preceding cache flush.</span>
<span class="cm"> * WRITE_FUA		Like WRITE_SYNC but data is guaranteed to be on</span>
<span class="cm"> *			non-volatile media on completion.</span>
<span class="cm"> * WRITE_FLUSH_FUA	Combination of WRITE_FLUSH and FUA. The IO is preceded</span>
<span class="cm"> *			by a cache flush and data is guaranteed to be on</span>
<span class="cm"> *			non-volatile media on completion.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define RW_MASK			REQ_WRITE</span>
<span class="cp">#define RWA_MASK		REQ_RAHEAD</span>

<span class="cp">#define READ			0</span>
<span class="cp">#define WRITE			RW_MASK</span>
<span class="cp">#define READA			RWA_MASK</span>

<span class="cp">#define READ_SYNC		(READ | REQ_SYNC)</span>
<span class="cp">#define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE)</span>
<span class="cp">#define WRITE_ODIRECT		(WRITE | REQ_SYNC)</span>
<span class="cp">#define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH)</span>
<span class="cp">#define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FUA)</span>
<span class="cp">#define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)</span>


<span class="cm">/*</span>
<span class="cm"> * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector</span>
<span class="cm"> * that indicates that they should check the contents of the iovec are</span>
<span class="cm"> * valid, but not check the memory that the iovec elements</span>
<span class="cm"> * points too.</span>
<span class="cm"> */</span>
<span class="cp">#define CHECK_IOVEC_ONLY -1</span>

<span class="cp">#define SEL_IN		1</span>
<span class="cp">#define SEL_OUT		2</span>
<span class="cp">#define SEL_EX		4</span>

<span class="cm">/* public flags for file_system_type */</span>
<span class="cp">#define FS_REQUIRES_DEV 1 </span>
<span class="cp">#define FS_BINARY_MOUNTDATA 2</span>
<span class="cp">#define FS_HAS_SUBTYPE 4</span>
<span class="cp">#define FS_REVAL_DOT	16384	</span><span class="cm">/* Check the paths &quot;.&quot;, &quot;..&quot; for staleness */</span><span class="cp"></span>
<span class="cp">#define FS_RENAME_DOES_D_MOVE	32768	</span><span class="cm">/* FS will handle d_move()</span>
<span class="cm">					 * during rename() internally.</span>
<span class="cm">					 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * These are the fs-independent mount-flags: up to 32 flags are supported</span>
<span class="cm"> */</span>
<span class="cp">#define MS_RDONLY	 1	</span><span class="cm">/* Mount read-only */</span><span class="cp"></span>
<span class="cp">#define MS_NOSUID	 2	</span><span class="cm">/* Ignore suid and sgid bits */</span><span class="cp"></span>
<span class="cp">#define MS_NODEV	 4	</span><span class="cm">/* Disallow access to device special files */</span><span class="cp"></span>
<span class="cp">#define MS_NOEXEC	 8	</span><span class="cm">/* Disallow program execution */</span><span class="cp"></span>
<span class="cp">#define MS_SYNCHRONOUS	16	</span><span class="cm">/* Writes are synced at once */</span><span class="cp"></span>
<span class="cp">#define MS_REMOUNT	32	</span><span class="cm">/* Alter flags of a mounted FS */</span><span class="cp"></span>
<span class="cp">#define MS_MANDLOCK	64	</span><span class="cm">/* Allow mandatory locks on an FS */</span><span class="cp"></span>
<span class="cp">#define MS_DIRSYNC	128	</span><span class="cm">/* Directory modifications are synchronous */</span><span class="cp"></span>
<span class="cp">#define MS_NOATIME	1024	</span><span class="cm">/* Do not update access times. */</span><span class="cp"></span>
<span class="cp">#define MS_NODIRATIME	2048	</span><span class="cm">/* Do not update directory access times */</span><span class="cp"></span>
<span class="cp">#define MS_BIND		4096</span>
<span class="cp">#define MS_MOVE		8192</span>
<span class="cp">#define MS_REC		16384</span>
<span class="cp">#define MS_VERBOSE	32768	</span><span class="cm">/* War is peace. Verbosity is silence.</span>
<span class="cm">				   MS_VERBOSE is deprecated. */</span><span class="cp"></span>
<span class="cp">#define MS_SILENT	32768</span>
<span class="cp">#define MS_POSIXACL	(1&lt;&lt;16)	</span><span class="cm">/* VFS does not apply the umask */</span><span class="cp"></span>
<span class="cp">#define MS_UNBINDABLE	(1&lt;&lt;17)	</span><span class="cm">/* change to unbindable */</span><span class="cp"></span>
<span class="cp">#define MS_PRIVATE	(1&lt;&lt;18)	</span><span class="cm">/* change to private */</span><span class="cp"></span>
<span class="cp">#define MS_SLAVE	(1&lt;&lt;19)	</span><span class="cm">/* change to slave */</span><span class="cp"></span>
<span class="cp">#define MS_SHARED	(1&lt;&lt;20)	</span><span class="cm">/* change to shared */</span><span class="cp"></span>
<span class="cp">#define MS_RELATIME	(1&lt;&lt;21)	</span><span class="cm">/* Update atime relative to mtime/ctime. */</span><span class="cp"></span>
<span class="cp">#define MS_KERNMOUNT	(1&lt;&lt;22) </span><span class="cm">/* this is a kern_mount call */</span><span class="cp"></span>
<span class="cp">#define MS_I_VERSION	(1&lt;&lt;23) </span><span class="cm">/* Update inode I_version field */</span><span class="cp"></span>
<span class="cp">#define MS_STRICTATIME	(1&lt;&lt;24) </span><span class="cm">/* Always perform atime updates */</span><span class="cp"></span>
<span class="cp">#define MS_NOSEC	(1&lt;&lt;28)</span>
<span class="cp">#define MS_BORN		(1&lt;&lt;29)</span>
<span class="cp">#define MS_ACTIVE	(1&lt;&lt;30)</span>
<span class="cp">#define MS_NOUSER	(1&lt;&lt;31)</span>

<span class="cm">/*</span>
<span class="cm"> * Superblock flags that can be altered by MS_REMOUNT</span>
<span class="cm"> */</span>
<span class="cp">#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)</span>

<span class="cm">/*</span>
<span class="cm"> * Old magic mount flag and mask</span>
<span class="cm"> */</span>
<span class="cp">#define MS_MGC_VAL 0xC0ED0000</span>
<span class="cp">#define MS_MGC_MSK 0xffff0000</span>

<span class="cm">/* Inode flags - they have nothing to superblock flags now */</span>

<span class="cp">#define S_SYNC		1	</span><span class="cm">/* Writes are synced at once */</span><span class="cp"></span>
<span class="cp">#define S_NOATIME	2	</span><span class="cm">/* Do not update access times */</span><span class="cp"></span>
<span class="cp">#define S_APPEND	4	</span><span class="cm">/* Append-only file */</span><span class="cp"></span>
<span class="cp">#define S_IMMUTABLE	8	</span><span class="cm">/* Immutable file */</span><span class="cp"></span>
<span class="cp">#define S_DEAD		16	</span><span class="cm">/* removed, but still open directory */</span><span class="cp"></span>
<span class="cp">#define S_NOQUOTA	32	</span><span class="cm">/* Inode is not counted to quota */</span><span class="cp"></span>
<span class="cp">#define S_DIRSYNC	64	</span><span class="cm">/* Directory modifications are synchronous */</span><span class="cp"></span>
<span class="cp">#define S_NOCMTIME	128	</span><span class="cm">/* Do not update file c/mtime */</span><span class="cp"></span>
<span class="cp">#define S_SWAPFILE	256	</span><span class="cm">/* Do not truncate: swapon got its bmaps */</span><span class="cp"></span>
<span class="cp">#define S_PRIVATE	512	</span><span class="cm">/* Inode is fs-internal */</span><span class="cp"></span>
<span class="cp">#define S_IMA		1024	</span><span class="cm">/* Inode has an associated IMA struct */</span><span class="cp"></span>
<span class="cp">#define S_AUTOMOUNT	2048	</span><span class="cm">/* Automount/referral quasi-directory */</span><span class="cp"></span>
<span class="cp">#define S_NOSEC		4096	</span><span class="cm">/* no suid or xattr security attributes */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Note that nosuid etc flags are inode-specific: setting some file-system</span>
<span class="cm"> * flags just means all the inodes inherit those flags by default. It might be</span>
<span class="cm"> * possible to override it selectively if you really wanted to with some</span>
<span class="cm"> * ioctl() that is not currently implemented.</span>
<span class="cm"> *</span>
<span class="cm"> * Exception: MS_RDONLY is always applied to the entire file system.</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately, it is possible to change a filesystems flags with it mounted</span>
<span class="cm"> * with files in use.  This means that all of the inodes will not have their</span>
<span class="cm"> * i_flags updated.  Hence, i_flags no longer inherit the superblock mount</span>
<span class="cm"> * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org</span>
<span class="cm"> */</span>
<span class="cp">#define __IS_FLG(inode,flg) ((inode)-&gt;i_sb-&gt;s_flags &amp; (flg))</span>

<span class="cp">#define IS_RDONLY(inode) ((inode)-&gt;i_sb-&gt;s_flags &amp; MS_RDONLY)</span>
<span class="cp">#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \</span>
<span class="cp">					((inode)-&gt;i_flags &amp; S_SYNC))</span>
<span class="cp">#define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \</span>
<span class="cp">					((inode)-&gt;i_flags &amp; (S_SYNC|S_DIRSYNC)))</span>
<span class="cp">#define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)</span>
<span class="cp">#define IS_NOATIME(inode)   __IS_FLG(inode, MS_RDONLY|MS_NOATIME)</span>
<span class="cp">#define IS_I_VERSION(inode)   __IS_FLG(inode, MS_I_VERSION)</span>

<span class="cp">#define IS_NOQUOTA(inode)	((inode)-&gt;i_flags &amp; S_NOQUOTA)</span>
<span class="cp">#define IS_APPEND(inode)	((inode)-&gt;i_flags &amp; S_APPEND)</span>
<span class="cp">#define IS_IMMUTABLE(inode)	((inode)-&gt;i_flags &amp; S_IMMUTABLE)</span>
<span class="cp">#define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)</span>

<span class="cp">#define IS_DEADDIR(inode)	((inode)-&gt;i_flags &amp; S_DEAD)</span>
<span class="cp">#define IS_NOCMTIME(inode)	((inode)-&gt;i_flags &amp; S_NOCMTIME)</span>
<span class="cp">#define IS_SWAPFILE(inode)	((inode)-&gt;i_flags &amp; S_SWAPFILE)</span>
<span class="cp">#define IS_PRIVATE(inode)	((inode)-&gt;i_flags &amp; S_PRIVATE)</span>
<span class="cp">#define IS_IMA(inode)		((inode)-&gt;i_flags &amp; S_IMA)</span>
<span class="cp">#define IS_AUTOMOUNT(inode)	((inode)-&gt;i_flags &amp; S_AUTOMOUNT)</span>
<span class="cp">#define IS_NOSEC(inode)		((inode)-&gt;i_flags &amp; S_NOSEC)</span>

<span class="cm">/* the read-only stuff doesn&#39;t really belong here, but any other place is</span>
<span class="cm">   probably as bad and I don&#39;t want to create yet another include file. */</span>

<span class="cp">#define BLKROSET   _IO(0x12,93)	</span><span class="cm">/* set device read-only (0 = read-write) */</span><span class="cp"></span>
<span class="cp">#define BLKROGET   _IO(0x12,94)	</span><span class="cm">/* get read-only status (0 = read_write) */</span><span class="cp"></span>
<span class="cp">#define BLKRRPART  _IO(0x12,95)	</span><span class="cm">/* re-read partition table */</span><span class="cp"></span>
<span class="cp">#define BLKGETSIZE _IO(0x12,96)	</span><span class="cm">/* return device size /512 (long *arg) */</span><span class="cp"></span>
<span class="cp">#define BLKFLSBUF  _IO(0x12,97)	</span><span class="cm">/* flush buffer cache */</span><span class="cp"></span>
<span class="cp">#define BLKRASET   _IO(0x12,98)	</span><span class="cm">/* set read ahead for block device */</span><span class="cp"></span>
<span class="cp">#define BLKRAGET   _IO(0x12,99)	</span><span class="cm">/* get current read ahead setting */</span><span class="cp"></span>
<span class="cp">#define BLKFRASET  _IO(0x12,100)</span><span class="cm">/* set filesystem (mm/filemap.c) read-ahead */</span><span class="cp"></span>
<span class="cp">#define BLKFRAGET  _IO(0x12,101)</span><span class="cm">/* get filesystem (mm/filemap.c) read-ahead */</span><span class="cp"></span>
<span class="cp">#define BLKSECTSET _IO(0x12,102)</span><span class="cm">/* set max sectors per request (ll_rw_blk.c) */</span><span class="cp"></span>
<span class="cp">#define BLKSECTGET _IO(0x12,103)</span><span class="cm">/* get max sectors per request (ll_rw_blk.c) */</span><span class="cp"></span>
<span class="cp">#define BLKSSZGET  _IO(0x12,104)</span><span class="cm">/* get block device sector size */</span><span class="cp"></span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define BLKPG      _IO(0x12,105)/* See blkpg.h */</span>

<span class="c">/* Some people are morons.  Do not use sizeof! */</span>

<span class="c">#define BLKELVGET  _IOR(0x12,106,size_t)/* elevator get */</span>
<span class="c">#define BLKELVSET  _IOW(0x12,107,size_t)/* elevator set */</span>
<span class="c">/* This was here just to show that the number is taken -</span>
<span class="c">   probably all these _IO(0x12,*) ioctls should be moved to blkpg.h. */</span>
<span class="cp">#endif</span>
<span class="cm">/* A jump here: 108-111 have been used for various private purposes. */</span>
<span class="cp">#define BLKBSZGET  _IOR(0x12,112,size_t)</span>
<span class="cp">#define BLKBSZSET  _IOW(0x12,113,size_t)</span>
<span class="cp">#define BLKGETSIZE64 _IOR(0x12,114,size_t)	</span><span class="cm">/* return device size in bytes (u64 *arg) */</span><span class="cp"></span>
<span class="cp">#define BLKTRACESETUP _IOWR(0x12,115,struct blk_user_trace_setup)</span>
<span class="cp">#define BLKTRACESTART _IO(0x12,116)</span>
<span class="cp">#define BLKTRACESTOP _IO(0x12,117)</span>
<span class="cp">#define BLKTRACETEARDOWN _IO(0x12,118)</span>
<span class="cp">#define BLKDISCARD _IO(0x12,119)</span>
<span class="cp">#define BLKIOMIN _IO(0x12,120)</span>
<span class="cp">#define BLKIOOPT _IO(0x12,121)</span>
<span class="cp">#define BLKALIGNOFF _IO(0x12,122)</span>
<span class="cp">#define BLKPBSZGET _IO(0x12,123)</span>
<span class="cp">#define BLKDISCARDZEROES _IO(0x12,124)</span>
<span class="cp">#define BLKSECDISCARD _IO(0x12,125)</span>
<span class="cp">#define BLKROTATIONAL _IO(0x12,126)</span>

<span class="cp">#define BMAP_IOCTL 1		</span><span class="cm">/* obsolete - kept for compatibility */</span><span class="cp"></span>
<span class="cp">#define FIBMAP	   _IO(0x00,1)	</span><span class="cm">/* bmap access */</span><span class="cp"></span>
<span class="cp">#define FIGETBSZ   _IO(0x00,2)	</span><span class="cm">/* get the block size used for bmap */</span><span class="cp"></span>
<span class="cp">#define FIFREEZE	_IOWR(&#39;X&#39;, 119, int)	</span><span class="cm">/* Freeze */</span><span class="cp"></span>
<span class="cp">#define FITHAW		_IOWR(&#39;X&#39;, 120, int)	</span><span class="cm">/* Thaw */</span><span class="cp"></span>
<span class="cp">#define FITRIM		_IOWR(&#39;X&#39;, 121, struct fstrim_range)	</span><span class="cm">/* Trim */</span><span class="cp"></span>

<span class="cp">#define	FS_IOC_GETFLAGS			_IOR(&#39;f&#39;, 1, long)</span>
<span class="cp">#define	FS_IOC_SETFLAGS			_IOW(&#39;f&#39;, 2, long)</span>
<span class="cp">#define	FS_IOC_GETVERSION		_IOR(&#39;v&#39;, 1, long)</span>
<span class="cp">#define	FS_IOC_SETVERSION		_IOW(&#39;v&#39;, 2, long)</span>
<span class="cp">#define FS_IOC_FIEMAP			_IOWR(&#39;f&#39;, 11, struct fiemap)</span>
<span class="cp">#define FS_IOC32_GETFLAGS		_IOR(&#39;f&#39;, 1, int)</span>
<span class="cp">#define FS_IOC32_SETFLAGS		_IOW(&#39;f&#39;, 2, int)</span>
<span class="cp">#define FS_IOC32_GETVERSION		_IOR(&#39;v&#39;, 1, int)</span>
<span class="cp">#define FS_IOC32_SETVERSION		_IOW(&#39;v&#39;, 2, int)</span>

<span class="cm">/*</span>
<span class="cm"> * Inode flags (FS_IOC_GETFLAGS / FS_IOC_SETFLAGS)</span>
<span class="cm"> */</span>
<span class="cp">#define	FS_SECRM_FL			0x00000001 </span><span class="cm">/* Secure deletion */</span><span class="cp"></span>
<span class="cp">#define	FS_UNRM_FL			0x00000002 </span><span class="cm">/* Undelete */</span><span class="cp"></span>
<span class="cp">#define	FS_COMPR_FL			0x00000004 </span><span class="cm">/* Compress file */</span><span class="cp"></span>
<span class="cp">#define FS_SYNC_FL			0x00000008 </span><span class="cm">/* Synchronous updates */</span><span class="cp"></span>
<span class="cp">#define FS_IMMUTABLE_FL			0x00000010 </span><span class="cm">/* Immutable file */</span><span class="cp"></span>
<span class="cp">#define FS_APPEND_FL			0x00000020 </span><span class="cm">/* writes to file may only append */</span><span class="cp"></span>
<span class="cp">#define FS_NODUMP_FL			0x00000040 </span><span class="cm">/* do not dump file */</span><span class="cp"></span>
<span class="cp">#define FS_NOATIME_FL			0x00000080 </span><span class="cm">/* do not update atime */</span><span class="cp"></span>
<span class="cm">/* Reserved for compression usage... */</span>
<span class="cp">#define FS_DIRTY_FL			0x00000100</span>
<span class="cp">#define FS_COMPRBLK_FL			0x00000200 </span><span class="cm">/* One or more compressed clusters */</span><span class="cp"></span>
<span class="cp">#define FS_NOCOMP_FL			0x00000400 </span><span class="cm">/* Don&#39;t compress */</span><span class="cp"></span>
<span class="cp">#define FS_ECOMPR_FL			0x00000800 </span><span class="cm">/* Compression error */</span><span class="cp"></span>
<span class="cm">/* End compression flags --- maybe not all used */</span>
<span class="cp">#define FS_BTREE_FL			0x00001000 </span><span class="cm">/* btree format dir */</span><span class="cp"></span>
<span class="cp">#define FS_INDEX_FL			0x00001000 </span><span class="cm">/* hash-indexed directory */</span><span class="cp"></span>
<span class="cp">#define FS_IMAGIC_FL			0x00002000 </span><span class="cm">/* AFS directory */</span><span class="cp"></span>
<span class="cp">#define FS_JOURNAL_DATA_FL		0x00004000 </span><span class="cm">/* Reserved for ext3 */</span><span class="cp"></span>
<span class="cp">#define FS_NOTAIL_FL			0x00008000 </span><span class="cm">/* file tail should not be merged */</span><span class="cp"></span>
<span class="cp">#define FS_DIRSYNC_FL			0x00010000 </span><span class="cm">/* dirsync behaviour (directories only) */</span><span class="cp"></span>
<span class="cp">#define FS_TOPDIR_FL			0x00020000 </span><span class="cm">/* Top of directory hierarchies*/</span><span class="cp"></span>
<span class="cp">#define FS_EXTENT_FL			0x00080000 </span><span class="cm">/* Extents */</span><span class="cp"></span>
<span class="cp">#define FS_DIRECTIO_FL			0x00100000 </span><span class="cm">/* Use direct i/o */</span><span class="cp"></span>
<span class="cp">#define FS_NOCOW_FL			0x00800000 </span><span class="cm">/* Do not cow file */</span><span class="cp"></span>
<span class="cp">#define FS_RESERVED_FL			0x80000000 </span><span class="cm">/* reserved for ext2 lib */</span><span class="cp"></span>

<span class="cp">#define FS_FL_USER_VISIBLE		0x0003DFFF </span><span class="cm">/* User visible flags */</span><span class="cp"></span>
<span class="cp">#define FS_FL_USER_MODIFIABLE		0x000380FF </span><span class="cm">/* User modifiable flags */</span><span class="cp"></span>


<span class="cp">#define SYNC_FILE_RANGE_WAIT_BEFORE	1</span>
<span class="cp">#define SYNC_FILE_RANGE_WRITE		2</span>
<span class="cp">#define SYNC_FILE_RANGE_WAIT_AFTER	4</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/path.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/radix-tree.h&gt;</span>
<span class="cp">#include &lt;linux/prio_tree.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pid.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/semaphore.h&gt;</span>
<span class="cp">#include &lt;linux/fiemap.h&gt;</span>
<span class="cp">#include &lt;linux/rculist_bl.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/shrinker.h&gt;</span>
<span class="cp">#include &lt;linux/migrate_mode.h&gt;</span>
<span class="cp">#include &lt;linux/uidgid.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="k">struct</span> <span class="n">export_operations</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hd_geometry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iovec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">nameidata</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kiocb</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kobject</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pipe_inode_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">poll_table_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kstatfs</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vfsmount</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cred</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">inode_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">inode_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">files_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">files_stat_struct</span> <span class="n">files_stat</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_max_files</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_nr_open</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inodes_stat_t</span> <span class="n">inodes_stat</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">leases_enable</span><span class="p">,</span> <span class="n">lease_break_time</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">buffer_head</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">get_block_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">dio_iodone_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">ssize_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">is_async</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Attribute flags.  These should be or-ed together to figure out what</span>
<span class="cm"> * has been changed!</span>
<span class="cm"> */</span>
<span class="cp">#define ATTR_MODE	(1 &lt;&lt; 0)</span>
<span class="cp">#define ATTR_UID	(1 &lt;&lt; 1)</span>
<span class="cp">#define ATTR_GID	(1 &lt;&lt; 2)</span>
<span class="cp">#define ATTR_SIZE	(1 &lt;&lt; 3)</span>
<span class="cp">#define ATTR_ATIME	(1 &lt;&lt; 4)</span>
<span class="cp">#define ATTR_MTIME	(1 &lt;&lt; 5)</span>
<span class="cp">#define ATTR_CTIME	(1 &lt;&lt; 6)</span>
<span class="cp">#define ATTR_ATIME_SET	(1 &lt;&lt; 7)</span>
<span class="cp">#define ATTR_MTIME_SET	(1 &lt;&lt; 8)</span>
<span class="cp">#define ATTR_FORCE	(1 &lt;&lt; 9) </span><span class="cm">/* Not a change, but a change it */</span><span class="cp"></span>
<span class="cp">#define ATTR_ATTR_FLAG	(1 &lt;&lt; 10)</span>
<span class="cp">#define ATTR_KILL_SUID	(1 &lt;&lt; 11)</span>
<span class="cp">#define ATTR_KILL_SGID	(1 &lt;&lt; 12)</span>
<span class="cp">#define ATTR_FILE	(1 &lt;&lt; 13)</span>
<span class="cp">#define ATTR_KILL_PRIV	(1 &lt;&lt; 14)</span>
<span class="cp">#define ATTR_OPEN	(1 &lt;&lt; 15) </span><span class="cm">/* Truncating from open(O_TRUNC) */</span><span class="cp"></span>
<span class="cp">#define ATTR_TIMES_SET	(1 &lt;&lt; 16)</span>

<span class="cm">/*</span>
<span class="cm"> * This is the Inode Attributes structure, used for notify_change().  It</span>
<span class="cm"> * uses the above definitions as flags, to know which values have changed.</span>
<span class="cm"> * Also, in this manner, a Filesystem can look at only the values it cares</span>
<span class="cm"> * about.  Basically, these are the attributes that the VFS layer can</span>
<span class="cm"> * request to change from the FS layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Derek Atkins &lt;warlord@MIT.EDU&gt; 94-10-20</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iattr</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">ia_valid</span><span class="p">;</span>
	<span class="n">umode_t</span>		<span class="n">ia_mode</span><span class="p">;</span>
	<span class="n">kuid_t</span>		<span class="n">ia_uid</span><span class="p">;</span>
	<span class="n">kgid_t</span>		<span class="n">ia_gid</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">ia_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>	<span class="n">ia_atime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>	<span class="n">ia_mtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>	<span class="n">ia_ctime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not an attribute, but an auxiliary info for filesystems wanting to</span>
<span class="cm">	 * implement an ftruncate() like method.  NOTE: filesystem should</span>
<span class="cm">	 * check for (ia_valid &amp; ATTR_FILE), and not for (ia_file != NULL).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">ia_file</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Includes for diskquotas.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/quota.h&gt;</span>

<span class="cm">/** </span>
<span class="cm"> * enum positive_aop_returns - aop return codes with specific semantics</span>
<span class="cm"> *</span>
<span class="cm"> * @AOP_WRITEPAGE_ACTIVATE: Informs the caller that page writeback has</span>
<span class="cm"> * 			    completed, that the page is still locked, and</span>
<span class="cm"> * 			    should be considered active.  The VM uses this hint</span>
<span class="cm"> * 			    to return the page to the active list -- it won&#39;t</span>
<span class="cm"> * 			    be a candidate for writeback again in the near</span>
<span class="cm"> * 			    future.  Other callers must be careful to unlock</span>
<span class="cm"> * 			    the page if they get this return.  Returned by</span>
<span class="cm"> * 			    writepage(); </span>
<span class="cm"> *</span>
<span class="cm"> * @AOP_TRUNCATED_PAGE: The AOP method that was handed a locked page has</span>
<span class="cm"> *  			unlocked it and the page might have been truncated.</span>
<span class="cm"> *  			The caller should back up to acquiring a new page and</span>
<span class="cm"> *  			trying again.  The aop will be taking reasonable</span>
<span class="cm"> *  			precautions not to livelock.  If the caller held a page</span>
<span class="cm"> *  			reference, it should drop it before retrying.  Returned</span>
<span class="cm"> *  			by readpage().</span>
<span class="cm"> *</span>
<span class="cm"> * address_space_operation functions return these large constants to indicate</span>
<span class="cm"> * special semantics to the caller.  These are much larger than the bytes in a</span>
<span class="cm"> * page to allow for functions that return the number of bytes operated on in a</span>
<span class="cm"> * given page.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">positive_aop_returns</span> <span class="p">{</span>
	<span class="n">AOP_WRITEPAGE_ACTIVATE</span>	<span class="o">=</span> <span class="mh">0x80000</span><span class="p">,</span>
	<span class="n">AOP_TRUNCATED_PAGE</span>	<span class="o">=</span> <span class="mh">0x80001</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define AOP_FLAG_UNINTERRUPTIBLE	0x0001 </span><span class="cm">/* will not do a short write */</span><span class="cp"></span>
<span class="cp">#define AOP_FLAG_CONT_EXPAND		0x0002 </span><span class="cm">/* called from cont_expand */</span><span class="cp"></span>
<span class="cp">#define AOP_FLAG_NOFS			0x0004 </span><span class="cm">/* used by filesystem to direct</span>
<span class="cm">						* helper code (eg buffer layer)</span>
<span class="cm">						* to clear GFP_FS from alloc */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * oh the beauties of C type declarations.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">address_space</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">writeback_control</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iov_iter</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">iov_offset</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">size_t</span> <span class="n">iov_iter_copy_from_user_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">iov_iter_copy_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">iov_iter_advance</span><span class="p">(</span><span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">iov_iter_fault_in_readable</span><span class="p">(</span><span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">iov_iter_single_seg_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">iov_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">written</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov</span> <span class="o">=</span> <span class="n">iov</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">nr_segs</span> <span class="o">=</span> <span class="n">nr_segs</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">written</span><span class="p">;</span>

	<span class="n">iov_iter_advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">written</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">iov_iter_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;descriptor&quot; for what we&#39;re up to with a read.</span>
<span class="cm"> * This allows us to use the same read code yet</span>
<span class="cm"> * have multiple different users of the data that</span>
<span class="cm"> * we read from a file.</span>
<span class="cm"> *</span>
<span class="cm"> * The simplest case just copies the data to user</span>
<span class="cm"> * mode.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span> <span class="n">read_descriptor_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_actor_t</span><span class="p">)(</span><span class="n">read_descriptor_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">address_space_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">writepage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readpage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Write back some dirty pages from this mapping. */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">writepages</span><span class="p">)(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Set a page dirty.  Return true if this dirtied it */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_page_dirty</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readpages</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_begin</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_end</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">);</span>

	<span class="cm">/* Unfortunately this kludge is needed for FIBMAP. Don&#39;t use it */</span>
	<span class="n">sector_t</span> <span class="p">(</span><span class="o">*</span><span class="n">bmap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invalidatepage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">releasepage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freepage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">direct_IO</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_xip_mem</span><span class="p">)(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">pgoff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * migrate the contents of a page to the specified target. If sync</span>
<span class="cm">	 * is false, it must not block.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">migratepage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">migrate_mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">launder_page</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">is_partially_uptodate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="n">read_descriptor_t</span> <span class="o">*</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">error_remove_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">empty_aops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * pagecache_write_begin/pagecache_write_end must be used by general code</span>
<span class="cm"> * to write into the pagecache.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">pagecache_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pagecache_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">backing_dev_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">address_space</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">host</span><span class="p">;</span>		<span class="cm">/* owner: inode, block_device */</span>
	<span class="k">struct</span> <span class="n">radix_tree_root</span>	<span class="n">page_tree</span><span class="p">;</span>	<span class="cm">/* radix tree of all pages */</span>
	<span class="n">spinlock_t</span>		<span class="n">tree_lock</span><span class="p">;</span>	<span class="cm">/* and lock protecting it */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">i_mmap_writable</span><span class="p">;</span><span class="cm">/* count VM_SHARED mappings */</span>
	<span class="k">struct</span> <span class="n">prio_tree_root</span>	<span class="n">i_mmap</span><span class="p">;</span>		<span class="cm">/* tree of private and shared mappings */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_mmap_nonlinear</span><span class="p">;</span><span class="cm">/*list VM_NONLINEAR mappings */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">i_mmap_mutex</span><span class="p">;</span>	<span class="cm">/* protect tree, count, list */</span>
	<span class="cm">/* Protected by tree_lock together with the radix tree */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">nrpages</span><span class="p">;</span>	<span class="cm">/* number of total pages */</span>
	<span class="n">pgoff_t</span>			<span class="n">writeback_index</span><span class="p">;</span><span class="cm">/* writeback starts here */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="o">*</span><span class="n">a_ops</span><span class="p">;</span>	<span class="cm">/* methods */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* error bits/gfp mask */</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">backing_dev_info</span><span class="p">;</span> <span class="cm">/* device readahead, etc */</span>
	<span class="n">spinlock_t</span>		<span class="n">private_lock</span><span class="p">;</span>	<span class="cm">/* for use by the address_space */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">private_list</span><span class="p">;</span>	<span class="cm">/* ditto */</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">assoc_mapping</span><span class="p">;</span>	<span class="cm">/* ditto */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">))));</span>
	<span class="cm">/*</span>
<span class="cm">	 * On most architectures that alignment is already the case; but</span>
<span class="cm">	 * must be enforced here for CRIS, to let the least significant bit</span>
<span class="cm">	 * of struct page&#39;s &quot;mapping&quot; pointer be used for PAGE_MAPPING_ANON.</span>
<span class="cm">	 */</span>
<span class="k">struct</span> <span class="n">request_queue</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">block_device</span> <span class="p">{</span>
	<span class="n">dev_t</span>			<span class="n">bd_dev</span><span class="p">;</span>  <span class="cm">/* not a kdev_t - it&#39;s a search key */</span>
	<span class="kt">int</span>			<span class="n">bd_openers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span>		<span class="n">bd_inode</span><span class="p">;</span>	<span class="cm">/* will die */</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span>	<span class="n">bd_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">bd_mutex</span><span class="p">;</span>	<span class="cm">/* open/close mutex */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">bd_inodes</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span>			<span class="n">bd_claiming</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span>			<span class="n">bd_holder</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bd_holders</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">bd_write_holder</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SYSFS</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">bd_holder_disks</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span>	<span class="n">bd_contains</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">bd_block_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hd_struct</span> <span class="o">*</span>	<span class="n">bd_part</span><span class="p">;</span>
	<span class="cm">/* number of times partitions within this device have been opened. */</span>
	<span class="kt">unsigned</span>		<span class="n">bd_part_count</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">bd_invalidated</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span>	<span class="n">bd_disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span>  <span class="n">bd_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">bd_list</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Private data.  You must have bd_claim&#39;ed the block_device</span>
<span class="cm">	 * to use this.  NOTE:  bd_claim allows an owner to claim</span>
<span class="cm">	 * the same device multiple times, the owner must take special</span>
<span class="cm">	 * care to not mess up bd_private for that case.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">bd_private</span><span class="p">;</span>

	<span class="cm">/* The counter of freeze processes */</span>
	<span class="kt">int</span>			<span class="n">bd_fsfreeze_count</span><span class="p">;</span>
	<span class="cm">/* Mutex for freeze */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">bd_fsfreeze_mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Radix-tree tags, for tagging dirty and writeback pages within the pagecache</span>
<span class="cm"> * radix trees</span>
<span class="cm"> */</span>
<span class="cp">#define PAGECACHE_TAG_DIRTY	0</span>
<span class="cp">#define PAGECACHE_TAG_WRITEBACK	1</span>
<span class="cp">#define PAGECACHE_TAG_TOWRITE	2</span>

<span class="kt">int</span> <span class="n">mapping_tagged</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Might pages of this file be mapped into userspace?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mapping_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="o">!</span><span class="n">prio_tree_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">)</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_nonlinear</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Might pages of this file have been modified in userspace?</span>
<span class="cm"> * Note that i_mmap_writable counts all VM_SHARED vmas: do_mmap_pgoff</span>
<span class="cm"> * marks vma as VM_SHARED if it is shared, and the file was opened for</span>
<span class="cm"> * writing i.e. vma may be mprotected writable even if now readonly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mapping_writably_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_writable</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use sequence counter to get consistent i_size on 32-bit processors.</span>
<span class="cm"> */</span>
<span class="cp">#if BITS_PER_LONG==32 &amp;&amp; defined(CONFIG_SMP)</span>
<span class="cp">#include &lt;linux/seqlock.h&gt;</span>
<span class="cp">#define __NEED_I_SIZE_ORDERED</span>
<span class="cp">#define i_size_ordered_init(inode) seqcount_init(&amp;inode-&gt;i_size_seqcount)</span>
<span class="cp">#else</span>
<span class="cp">#define i_size_ordered_init(inode) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">posix_acl</span><span class="p">;</span>
<span class="cp">#define ACL_NOT_CACHED ((void *)(-1))</span>

<span class="cp">#define IOP_FASTPERM	0x0001</span>
<span class="cp">#define IOP_LOOKUP	0x0002</span>
<span class="cp">#define IOP_NOFOLLOW	0x0004</span>

<span class="cm">/*</span>
<span class="cm"> * Keep mostly read-only and often accessed (especially for</span>
<span class="cm"> * the RCU path lookup and &#39;stat&#39; data) fields at the beginning</span>
<span class="cm"> * of the &#39;struct inode&#39;</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
	<span class="n">umode_t</span>			<span class="n">i_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">i_opflags</span><span class="p">;</span>
	<span class="n">kuid_t</span>			<span class="n">i_uid</span><span class="p">;</span>
	<span class="n">kgid_t</span>			<span class="n">i_gid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">i_flags</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FS_POSIX_ACL</span>
	<span class="k">struct</span> <span class="n">posix_acl</span>	<span class="o">*</span><span class="n">i_acl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">posix_acl</span>	<span class="o">*</span><span class="n">i_default_acl</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span>	<span class="o">*</span><span class="n">i_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span>	<span class="o">*</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">i_mapping</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SECURITY</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">i_security</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Stat data, not accessed from path walking */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i_ino</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Filesystems may only read i_nlink directly.  They shall use the</span>
<span class="cm">	 * following functions for modification:</span>
<span class="cm">	 *</span>
<span class="cm">	 *    (set|clear|inc|drop)_nlink</span>
<span class="cm">	 *    inode_(inc|dec)_link_count</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_nlink</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__i_nlink</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">dev_t</span>			<span class="n">i_rdev</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">i_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>		<span class="n">i_atime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>		<span class="n">i_mtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>		<span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">i_lock</span><span class="p">;</span>	<span class="cm">/* i_blocks, i_bytes, maybe i_size */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>          <span class="n">i_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">blkcnt_t</span>		<span class="n">i_blocks</span><span class="p">;</span>

<span class="cp">#ifdef __NEED_I_SIZE_ORDERED</span>
	<span class="n">seqcount_t</span>		<span class="n">i_size_seqcount</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Misc */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">i_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">i_mutex</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">dirtied_when</span><span class="p">;</span>	<span class="cm">/* jiffies of first dirtying */</span>

	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">i_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_wb_list</span><span class="p">;</span>	<span class="cm">/* backing dev IO list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_lru</span><span class="p">;</span>		<span class="cm">/* inode LRU list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_sb_list</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_dentry</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">i_rcu</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">u64</span>			<span class="n">i_version</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">i_count</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">i_dio_count</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">i_writecount</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>	<span class="o">*</span><span class="n">i_fop</span><span class="p">;</span>	<span class="cm">/* former -&gt;i_op-&gt;default_file_ops */</span>
	<span class="k">struct</span> <span class="n">file_lock</span>	<span class="o">*</span><span class="n">i_flock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="n">i_data</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="k">struct</span> <span class="n">dquot</span>		<span class="o">*</span><span class="n">i_dquot</span><span class="p">[</span><span class="n">MAXQUOTAS</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">i_devices</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pipe_inode_info</span>	<span class="o">*</span><span class="n">i_pipe</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">i_bdev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cdev</span>		<span class="o">*</span><span class="n">i_cdev</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">__u32</span>			<span class="n">i_generation</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FSNOTIFY</span>
	<span class="n">__u32</span>			<span class="n">i_fsnotify_mask</span><span class="p">;</span> <span class="cm">/* all events this inode cares about */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">i_fsnotify_marks</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_IMA</span>
	<span class="n">atomic_t</span>		<span class="n">i_readcount</span><span class="p">;</span> <span class="cm">/* struct files open RO */</span>
<span class="cp">#endif</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">i_private</span><span class="p">;</span> <span class="cm">/* fs or device private pointer */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">inode_unhashed</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * inode-&gt;i_mutex nesting subclasses for the lock validator:</span>
<span class="cm"> *</span>
<span class="cm"> * 0: the object of the current VFS operation</span>
<span class="cm"> * 1: parent</span>
<span class="cm"> * 2: child/target</span>
<span class="cm"> * 3: quota file</span>
<span class="cm"> *</span>
<span class="cm"> * The locking order between these classes is</span>
<span class="cm"> * parent -&gt; child -&gt; normal -&gt; xattr -&gt; quota</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">inode_i_mutex_lock_class</span>
<span class="p">{</span>
	<span class="n">I_MUTEX_NORMAL</span><span class="p">,</span>
	<span class="n">I_MUTEX_PARENT</span><span class="p">,</span>
	<span class="n">I_MUTEX_CHILD</span><span class="p">,</span>
	<span class="n">I_MUTEX_XATTR</span><span class="p">,</span>
	<span class="n">I_MUTEX_QUOTA</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: in a 32bit arch with a preemptable kernel and</span>
<span class="cm"> * an UP compile the i_size_read/write must be atomic</span>
<span class="cm"> * with respect to the local cpu (unlike with preempt disabled),</span>
<span class="cm"> * but they don&#39;t need to be atomic with respect to other cpus like in</span>
<span class="cm"> * true SMP (so they need either to either locally disable irq around</span>
<span class="cm"> * the read or for example on x86 they can be still implemented as a</span>
<span class="cm"> * cmpxchg8b without the need of the lock prefix). For SMP compiles</span>
<span class="cm"> * and 64bit archs it makes no difference if preempt is enabled or not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">i_size_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if BITS_PER_LONG==32 &amp;&amp; defined(CONFIG_SMP)</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size_seqcount</span><span class="p">);</span>
		<span class="n">i_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size_seqcount</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">i_size</span><span class="p">;</span>
<span class="cp">#elif BITS_PER_LONG==32 &amp;&amp; defined(CONFIG_PREEMPT)</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">i_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">i_size</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: unlike i_size_read(), i_size_write() does need locking around it</span>
<span class="cm"> * (normally i_mutex), otherwise on 32bit/SMP an update of i_size_seqcount</span>
<span class="cm"> * can be lost, resulting in subsequent i_size_read() calls spinning forever.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i_size_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if BITS_PER_LONG==32 &amp;&amp; defined(CONFIG_SMP)</span>
	<span class="n">write_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size_seqcount</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="n">write_seqcount_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size_seqcount</span><span class="p">);</span>
<span class="cp">#elif BITS_PER_LONG==32 &amp;&amp; defined(CONFIG_PREEMPT)</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="cp">#else</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Helper functions so that in most cases filesystems will</span>
<span class="cm"> * not need to deal directly with kuid_t and kgid_t and can</span>
<span class="cm"> * instead deal with the raw numeric values that are stored</span>
<span class="cm"> * in the filesystem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">uid_t</span> <span class="nf">i_uid_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">from_kuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gid_t</span> <span class="nf">i_gid_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">from_kgid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i_uid_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">make_kuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">uid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i_gid_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">make_kgid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">gid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">iminor</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">imajor</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">I_BDEV</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">fown_struct</span> <span class="p">{</span>
	<span class="n">rwlock_t</span> <span class="n">lock</span><span class="p">;</span>          <span class="cm">/* protects pid, uid, euid fields */</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>	<span class="cm">/* pid or -pgrp where SIGIO should be sent */</span>
	<span class="k">enum</span> <span class="n">pid_type</span> <span class="n">pid_type</span><span class="p">;</span>	<span class="cm">/* Kind of process group SIGIO should be sent to */</span>
	<span class="n">kuid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">euid</span><span class="p">;</span>	<span class="cm">/* uid/euid of process setting the owner */</span>
	<span class="kt">int</span> <span class="n">signum</span><span class="p">;</span>		<span class="cm">/* posix.1b rt signal to be delivered on IO */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Track a single file&#39;s readahead state</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">file_ra_state</span> <span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">start</span><span class="p">;</span>			<span class="cm">/* where readahead started */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* # of readahead pages */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">async_size</span><span class="p">;</span>	<span class="cm">/* do asynchronous readahead when</span>
<span class="cm">					   there are only # of pages ahead */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ra_pages</span><span class="p">;</span>		<span class="cm">/* Maximum readahead window */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mmap_miss</span><span class="p">;</span>		<span class="cm">/* Cache miss stat for mmap accesses */</span>
	<span class="n">loff_t</span> <span class="n">prev_pos</span><span class="p">;</span>		<span class="cm">/* Cache last read() position */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Check if @index falls in the readahead windows.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ra_has_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;&amp;</span>
		<span class="n">index</span> <span class="o">&lt;</span>  <span class="n">ra</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">ra</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define FILE_MNT_WRITE_TAKEN	1</span>
<span class="cp">#define FILE_MNT_WRITE_RELEASED	2</span>

<span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * fu_list becomes invalid after file_free is called and queued via</span>
<span class="cm">	 * fu_rcuhead for RCU freeing</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">fu_list</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rcu_head</span> 	<span class="n">fu_rcuhead</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">f_u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span>		<span class="n">f_path</span><span class="p">;</span>
<span class="cp">#define f_dentry	f_path.dentry</span>
<span class="cp">#define f_vfsmnt	f_path.mnt</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>	<span class="o">*</span><span class="n">f_op</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.</span>
<span class="cm">	 * Must not be taken from IRQ context.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">f_lock</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span>			<span class="n">f_sb_list_cpu</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">atomic_long_t</span>		<span class="n">f_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> 		<span class="n">f_flags</span><span class="p">;</span>
	<span class="n">fmode_t</span>			<span class="n">f_mode</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">f_pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fown_struct</span>	<span class="n">f_owner</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span>	<span class="o">*</span><span class="n">f_cred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_ra_state</span>	<span class="n">f_ra</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">f_version</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">f_security</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* needed for tty driver, and maybe others */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_EPOLL</span>
	<span class="cm">/* Used by fs/eventpoll.c to link all the hooks to this file */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">f_ep_links</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">f_tfile_llink</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_EPOLL */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">address_space</span>	<span class="o">*</span><span class="n">f_mapping</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_WRITECOUNT</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">f_mnt_write_state</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">file_handle</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">handle_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handle_type</span><span class="p">;</span>
	<span class="cm">/* file identifier */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">f_handle</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define get_file(x)	atomic_long_inc(&amp;(x)-&gt;f_count)</span>
<span class="cp">#define fput_atomic(x)	atomic_long_add_unless(&amp;(x)-&gt;f_count, -1, 1)</span>
<span class="cp">#define file_count(x)	atomic_long_read(&amp;(x)-&gt;f_count)</span>

<span class="cp">#ifdef CONFIG_DEBUG_WRITECOUNT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_take_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mnt_write_state</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mnt_write_state</span> <span class="o">=</span> <span class="n">FILE_MNT_WRITE_TAKEN</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_release_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mnt_write_state</span> <span class="o">|=</span> <span class="n">FILE_MNT_WRITE_RELEASED</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_reset_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mnt_write_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_check_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * At this point, either both or neither of these bits</span>
<span class="cm">	 * should be set.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mnt_write_state</span> <span class="o">==</span> <span class="n">FILE_MNT_WRITE_TAKEN</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mnt_write_state</span> <span class="o">==</span> <span class="n">FILE_MNT_WRITE_RELEASED</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">file_check_writeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mnt_write_state</span> <span class="o">==</span> <span class="n">FILE_MNT_WRITE_TAKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;writeable file with no &quot;</span>
			    <span class="s">&quot;mnt_want_write()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_DEBUG_WRITECOUNT */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_take_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_release_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_reset_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_check_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">file_check_writeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_WRITECOUNT */</span><span class="cp"></span>

<span class="cp">#define	MAX_NON_LFS	((1UL&lt;&lt;31) - 1)</span>

<span class="cm">/* Page cache limit. The filesystems should put that into their s_maxbytes </span>
<span class="cm">   limits, otherwise bad things can happen in VM. */</span> 
<span class="cp">#if BITS_PER_LONG==32</span>
<span class="cp">#define MAX_LFS_FILESIZE	(((u64)PAGE_CACHE_SIZE &lt;&lt; (BITS_PER_LONG-1))-1) </span>
<span class="cp">#elif BITS_PER_LONG==64</span>
<span class="cp">#define MAX_LFS_FILESIZE 	0x7fffffffffffffffUL</span>
<span class="cp">#endif</span>

<span class="cp">#define FL_POSIX	1</span>
<span class="cp">#define FL_FLOCK	2</span>
<span class="cp">#define FL_ACCESS	8	</span><span class="cm">/* not trying to lock, just looking */</span><span class="cp"></span>
<span class="cp">#define FL_EXISTS	16	</span><span class="cm">/* when unlocking, test for existence */</span><span class="cp"></span>
<span class="cp">#define FL_LEASE	32	</span><span class="cm">/* lease held on this file */</span><span class="cp"></span>
<span class="cp">#define FL_CLOSE	64	</span><span class="cm">/* unlock on close */</span><span class="cp"></span>
<span class="cp">#define FL_SLEEP	128	</span><span class="cm">/* A blocking lock */</span><span class="cp"></span>
<span class="cp">#define FL_DOWNGRADE_PENDING	256 </span><span class="cm">/* Lease is being downgraded */</span><span class="cp"></span>
<span class="cp">#define FL_UNLOCK_PENDING	512 </span><span class="cm">/* Lease is being broken */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Special return value from posix_lock_file() and vfs_lock_file() for</span>
<span class="cm"> * asynchronous locking.</span>
<span class="cm"> */</span>
<span class="cp">#define FILE_LOCK_DEFERRED 1</span>

<span class="cm">/*</span>
<span class="cm"> * The POSIX file lock owner is determined by</span>
<span class="cm"> * the &quot;struct files_struct&quot; in the thread group</span>
<span class="cm"> * (or NULL for no owner - BSD locks).</span>
<span class="cm"> *</span>
<span class="cm"> * Lockd stuffs a &quot;host&quot; pointer into this.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">fl_owner_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">file_lock_operations</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fl_copy_lock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fl_release_private</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lock_manager_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lm_compare_owner</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lm_notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>	<span class="cm">/* unblock callback */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lm_grant</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lm_release_private</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lm_break</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lm_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lock_manager</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">locks_start_grace</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_manager</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">locks_end_grace</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_manager</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">locks_in_grace</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* that will die - we need it for nfs_lock_info */</span>
<span class="cp">#include &lt;linux/nfs_fs_i.h&gt;</span>

<span class="k">struct</span> <span class="n">file_lock</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl_next</span><span class="p">;</span>	<span class="cm">/* singly linked list for this inode  */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fl_link</span><span class="p">;</span>	<span class="cm">/* doubly linked list of all locks */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fl_block</span><span class="p">;</span>	<span class="cm">/* circular list of blocked processes */</span>
	<span class="n">fl_owner_t</span> <span class="n">fl_owner</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fl_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fl_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fl_pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">fl_nspid</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">fl_wait</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fl_file</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">fl_start</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">fl_end</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span>	<span class="n">fl_fasync</span><span class="p">;</span> <span class="cm">/* for lease break notifications */</span>
	<span class="cm">/* for lease breaks: */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fl_break_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fl_downgrade_time</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_lock_operations</span> <span class="o">*</span><span class="n">fl_ops</span><span class="p">;</span>	<span class="cm">/* Callbacks for filesystems */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">lock_manager_operations</span> <span class="o">*</span><span class="n">fl_lmops</span><span class="p">;</span>	<span class="cm">/* Callbacks for lockmanagers */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nfs_lock_info</span>	<span class="n">nfs_fl</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">nfs4_lock_info</span>	<span class="n">nfs4_fl</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>	<span class="cm">/* link in AFS vnode&#39;s pending_locks list */</span>
			<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>		<span class="cm">/* state of grant or error if -ve */</span>
		<span class="p">}</span> <span class="n">afs</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fl_u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The following constant reflects the upper bound of the file/locking space */</span>
<span class="cp">#ifndef OFFSET_MAX</span>
<span class="cp">#define INT_LIMIT(x)	(~((x)1 &lt;&lt; (sizeof(x)*8 - 1)))</span>
<span class="cp">#define OFFSET_MAX	INT_LIMIT(loff_t)</span>
<span class="cp">#define OFFT_OFFSET_MAX	INT_LIMIT(off_t)</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/fcntl.h&gt;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">send_sigio</span><span class="p">(</span><span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">band</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FILE_LOCKING</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fcntl_getlk</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flock</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fcntl_setlk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">flock</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fcntl_getlk64</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flock64</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fcntl_setlk64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">flock64</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">fcntl_setlease</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fcntl_getlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>

<span class="cm">/* fs/locks.c */</span>
<span class="kt">void</span> <span class="n">locks_free_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">locks_init_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span> <span class="n">locks_alloc_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">locks_copy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__locks_copy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">locks_remove_posix</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">fl_owner_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">locks_remove_flock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">locks_release_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">posix_test_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">posix_lock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">posix_lock_file_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">posix_unblock_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_test_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_lock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_cancel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">flock_lock_file_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__break_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lease_get_mtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">time</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_setlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_setlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lease_modify</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lock_may_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lock_may_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">locks_delete_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">waiter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lock_flocks</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unlock_flocks</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_FILE_LOCKING */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fcntl_getlk</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flock</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fcntl_setlk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flock</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fcntl_getlk64</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flock64</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fcntl_setlk64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flock64</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fcntl_setlease</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fcntl_getlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">locks_init_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__locks_copy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">locks_copy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">locks_remove_posix</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">locks_remove_flock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">posix_test_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">posix_lock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">conflock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOLCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">posix_lock_file_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOLCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">posix_unblock_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vfs_test_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vfs_lock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOLCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vfs_cancel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">flock_lock_file_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOLCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__break_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lease_get_mtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">generic_setlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">flp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vfs_setlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">lease</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lease_modify</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">before</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lock_may_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lock_may_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">locks_delete_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_flocks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_flocks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_FILE_LOCKING */</span><span class="cp"></span>


<span class="k">struct</span> <span class="n">fasync_struct</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">fa_lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">magic</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">fa_fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fasync_struct</span>	<span class="o">*</span><span class="n">fa_next</span><span class="p">;</span> <span class="cm">/* singly linked list */</span>
	<span class="k">struct</span> <span class="n">file</span>		<span class="o">*</span><span class="n">fa_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">fa_rcu</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FASYNC_MAGIC 0x4601</span>

<span class="cm">/* SMP safe fasync helpers: */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">fasync_insert_entry</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">**</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fasync_remove_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">**</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">fasync_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fasync_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* can be called from interrupts */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kill_fasync</span><span class="p">(</span><span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__f_setown</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">f_setown</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">f_delown</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">pid_t</span> <span class="n">f_getown</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">send_sigurg</span><span class="p">(</span><span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Umount options</span>
<span class="cm"> */</span>

<span class="cp">#define MNT_FORCE	0x00000001	</span><span class="cm">/* Attempt to forcibily umount */</span><span class="cp"></span>
<span class="cp">#define MNT_DETACH	0x00000002	</span><span class="cm">/* Just detach from the tree */</span><span class="cp"></span>
<span class="cp">#define MNT_EXPIRE	0x00000004	</span><span class="cm">/* Mark for expiry */</span><span class="cp"></span>
<span class="cp">#define UMOUNT_NOFOLLOW	0x00000008	</span><span class="cm">/* Don&#39;t follow symlink on umount */</span><span class="cp"></span>
<span class="cp">#define UMOUNT_UNUSED	0x80000000	</span><span class="cm">/* Flag guaranteed to be unused */</span><span class="cp"></span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">super_blocks</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">sb_lock</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">super_block</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">s_list</span><span class="p">;</span>		<span class="cm">/* Keep this first */</span>
	<span class="n">dev_t</span>			<span class="n">s_dev</span><span class="p">;</span>		<span class="cm">/* search index; _not_ kdev_t */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">s_dirt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">loff_t</span>			<span class="n">s_maxbytes</span><span class="p">;</span>	<span class="cm">/* Max file size */</span>
	<span class="k">struct</span> <span class="n">file_system_type</span>	<span class="o">*</span><span class="n">s_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span>	<span class="o">*</span><span class="n">s_op</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dquot_operations</span>	<span class="o">*</span><span class="n">dq_op</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">quotactl_ops</span>	<span class="o">*</span><span class="n">s_qcop</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">export_operations</span> <span class="o">*</span><span class="n">s_export_op</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">s_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">s_magic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">s_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">s_umount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">s_lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">s_count</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">s_active</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
	<span class="kt">void</span>                    <span class="o">*</span><span class="n">s_security</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">xattr_handler</span> <span class="o">**</span><span class="n">s_xattr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">s_inodes</span><span class="p">;</span>	<span class="cm">/* all inodes */</span>
	<span class="k">struct</span> <span class="n">hlist_bl_head</span>	<span class="n">s_anon</span><span class="p">;</span>		<span class="cm">/* anonymous dentries for (nfs) exporting */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">s_files</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">s_files</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">s_mounts</span><span class="p">;</span>	<span class="cm">/* list of mounts; _not_ for fs use */</span>
	<span class="cm">/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">s_dentry_lru</span><span class="p">;</span>	<span class="cm">/* unused dentry lru */</span>
	<span class="kt">int</span>			<span class="n">s_nr_dentry_unused</span><span class="p">;</span>	<span class="cm">/* # of dentry on lru */</span>

	<span class="cm">/* s_inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */</span>
	<span class="n">spinlock_t</span>		<span class="n">s_inode_lru_lock</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">s_inode_lru</span><span class="p">;</span>		<span class="cm">/* unused inode lru */</span>
	<span class="kt">int</span>			<span class="n">s_nr_inodes_unused</span><span class="p">;</span>	<span class="cm">/* # of inodes on lru */</span>

	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">s_bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">s_bdi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span>		<span class="o">*</span><span class="n">s_mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">s_instances</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">quota_info</span>	<span class="n">s_dquot</span><span class="p">;</span>	<span class="cm">/* Diskquota specific options */</span>

	<span class="kt">int</span>			<span class="n">s_frozen</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">s_wait_unfrozen</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">s_id</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>				<span class="cm">/* Informational name */</span>
	<span class="n">u8</span> <span class="n">s_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>				<span class="cm">/* UUID */</span>

	<span class="kt">void</span> 			<span class="o">*</span><span class="n">s_fs_info</span><span class="p">;</span>	<span class="cm">/* Filesystem private info */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">s_max_links</span><span class="p">;</span>
	<span class="n">fmode_t</span>			<span class="n">s_mode</span><span class="p">;</span>

	<span class="cm">/* Granularity of c/m/atime in ns.</span>
<span class="cm">	   Cannot be worse than a second */</span>
	<span class="n">u32</span>		   <span class="n">s_time_gran</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next field is for VFS *only*. No filesystems have any business</span>
<span class="cm">	 * even looking at it. You had been warned.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">s_vfs_rename_mutex</span><span class="p">;</span>	<span class="cm">/* Kludge */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Filesystem subtype.  If non-empty the filesystem type field</span>
<span class="cm">	 * in /proc/mounts will be &quot;type.subtype&quot;</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s_subtype</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Saved mount options for lazy filesystems using</span>
<span class="cm">	 * generic_show_options()</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">s_options</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">s_d_op</span><span class="p">;</span> <span class="cm">/* default d_op for dentries */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Saved pool identifier for cleancache (-1 means none)</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">cleancache_poolid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">shrinker</span> <span class="n">s_shrink</span><span class="p">;</span>	<span class="cm">/* per-sb shrinker handle */</span>

	<span class="cm">/* Number of inodes with nlink == 0 but still referenced */</span>
	<span class="n">atomic_long_t</span> <span class="n">s_remove_count</span><span class="p">;</span>

	<span class="cm">/* Being remounted read-only */</span>
	<span class="kt">int</span> <span class="n">s_readonly_remount</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* superblock cache pruning functions */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prune_icache_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_scan</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prune_dcache_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_scan</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Snapshotting support.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SB_UNFROZEN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SB_FREEZE_WRITE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SB_FREEZE_TRANS</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define vfs_check_frozen(sb, level) \</span>
<span class="cp">	wait_event((sb)-&gt;s_wait_unfrozen, ((sb)-&gt;s_frozen &lt; (level)))</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">inode_owner_or_capable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/* not quite ready to be deprecated, but... */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lock_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unlock_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * VFS helper functions..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">dev_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * VFS dentry helper functions.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dentry_unhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * VFS file helper functions.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">inode_init_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			<span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * VFS FS_IOC_FIEMAP helper definitions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fi_flags</span><span class="p">;</span>		<span class="cm">/* Flags as passed from user */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fi_extents_mapped</span><span class="p">;</span>	<span class="cm">/* Number of mapped extents */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fi_extents_max</span><span class="p">;</span>	<span class="cm">/* Size of fiemap_extent array */</span>
	<span class="k">struct</span> <span class="n">fiemap_extent</span> <span class="n">__user</span> <span class="o">*</span><span class="n">fi_extents_start</span><span class="p">;</span> <span class="cm">/* Start of</span>
<span class="cm">							fiemap_extent array */</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="n">phys</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fiemap_check_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fs_flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * File types</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! These match bits 12..15 of stat.st_mode</span>
<span class="cm"> * (ie &quot;(i_mode &gt;&gt; 12) &amp; 15&quot;).</span>
<span class="cm"> */</span>
<span class="cp">#define DT_UNKNOWN	0</span>
<span class="cp">#define DT_FIFO		1</span>
<span class="cp">#define DT_CHR		2</span>
<span class="cp">#define DT_DIR		4</span>
<span class="cp">#define DT_BLK		6</span>
<span class="cp">#define DT_REG		8</span>
<span class="cp">#define DT_LNK		10</span>
<span class="cp">#define DT_SOCK		12</span>
<span class="cp">#define DT_WHT		14</span>

<span class="cm">/*</span>
<span class="cm"> * This is the &quot;filldir&quot; function type, used by readdir() to let</span>
<span class="cm"> * the kernel specify what kind of dirent layout it wants to have.</span>
<span class="cm"> * This allows the kernel to read directories into kernel space or</span>
<span class="cm"> * to have different dirent layouts depending on the binary type.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filldir_t</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">block_device_operations</span><span class="p">;</span>

<span class="cm">/* These macros are for out of kernel modules to test that</span>
<span class="cm"> * the kernel supports the unlocked_ioctl and compat_ioctl</span>
<span class="cm"> * fields in struct file_operations. */</span>
<span class="cp">#define HAVE_COMPAT_IOCTL 1</span>
<span class="cp">#define HAVE_UNLOCKED_IOCTL 1</span>

<span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">aio_read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">aio_write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">filldir_t</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">unlocked_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fsync</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">aio_fsync</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fasync</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">sendpage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_unmapped_area</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_flags</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flock</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">splice_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">splice_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setlease</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="p">);</span>
	<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">fallocate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="n">loff_t</span> <span class="n">len</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">inode_operations</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">lookup</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">follow_link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">permission</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">get_acl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span><span class="n">umode_t</span><span class="p">,</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">symlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mkdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span><span class="n">umode_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mknod</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span><span class="n">umode_t</span><span class="p">,</span><span class="n">dev_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rename</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">truncate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span><span class="kt">size_t</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">getxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">listxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">removexattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fiemap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span>
		      <span class="n">u64</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">update_time</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">seq_file</span><span class="p">;</span>

<span class="kt">ssize_t</span> <span class="n">rw_copy_check_uvector</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">uvector</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fast_segs</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">fast_pointer</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">iovec</span> <span class="o">**</span><span class="n">ret_pointer</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">vfs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">vfs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">vfs_readv</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">vfs_writev</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">super_operations</span> <span class="p">{</span>
   	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

   	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dirty_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">drop_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">evict_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">freeze_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unfreeze_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remount_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">umount_begin</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show_options</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show_devname</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show_path</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">quota_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">quota_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bdev_try_to_free_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nr_cached_objects</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_cached_objects</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Inode state bits.  Protected by inode-&gt;i_lock</span>
<span class="cm"> *</span>
<span class="cm"> * Three bits determine the dirty state of the inode, I_DIRTY_SYNC,</span>
<span class="cm"> * I_DIRTY_DATASYNC and I_DIRTY_PAGES.</span>
<span class="cm"> *</span>
<span class="cm"> * Four bits define the lifetime of an inode.  Initially, inodes are I_NEW,</span>
<span class="cm"> * until that flag is cleared.  I_WILL_FREE, I_FREEING and I_CLEAR are set at</span>
<span class="cm"> * various stages of removing an inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Two bits are used for locking and completion notification, I_NEW and I_SYNC.</span>
<span class="cm"> *</span>
<span class="cm"> * I_DIRTY_SYNC		Inode is dirty, but doesn&#39;t have to be written on</span>
<span class="cm"> *			fdatasync().  i_atime is the usual cause.</span>
<span class="cm"> * I_DIRTY_DATASYNC	Data-related inode changes pending. We keep track of</span>
<span class="cm"> *			these changes separately from I_DIRTY_SYNC so that we</span>
<span class="cm"> *			don&#39;t have to write inode on fdatasync() when only</span>
<span class="cm"> *			mtime has changed in it.</span>
<span class="cm"> * I_DIRTY_PAGES	Inode has dirty pages.  Inode itself may be clean.</span>
<span class="cm"> * I_NEW		Serves as both a mutex and completion notification.</span>
<span class="cm"> *			New inodes set I_NEW.  If two processes both create</span>
<span class="cm"> *			the same inode, one of them will release its inode and</span>
<span class="cm"> *			wait for I_NEW to be released before returning.</span>
<span class="cm"> *			Inodes in I_WILL_FREE, I_FREEING or I_CLEAR state can</span>
<span class="cm"> *			also cause waiting on I_NEW, without I_NEW actually</span>
<span class="cm"> *			being set.  find_inode() uses this to prevent returning</span>
<span class="cm"> *			nearly-dead inodes.</span>
<span class="cm"> * I_WILL_FREE		Must be set when calling write_inode_now() if i_count</span>
<span class="cm"> *			is zero.  I_FREEING must be set when I_WILL_FREE is</span>
<span class="cm"> *			cleared.</span>
<span class="cm"> * I_FREEING		Set when inode is about to be freed but still has dirty</span>
<span class="cm"> *			pages or buffers attached or the inode itself is still</span>
<span class="cm"> *			dirty.</span>
<span class="cm"> * I_CLEAR		Added by clear_inode().  In this state the inode is</span>
<span class="cm"> *			clean and can be destroyed.  Inode keeps I_FREEING.</span>
<span class="cm"> *</span>
<span class="cm"> *			Inodes that are I_WILL_FREE, I_FREEING or I_CLEAR are</span>
<span class="cm"> *			prohibited for many purposes.  iget() must wait for</span>
<span class="cm"> *			the inode to be completely released, then create it</span>
<span class="cm"> *			anew.  Other functions will just ignore such inodes,</span>
<span class="cm"> *			if appropriate.  I_NEW is used for waiting.</span>
<span class="cm"> *</span>
<span class="cm"> * I_SYNC		Writeback of inode is running. The bit is set during</span>
<span class="cm"> *			data writeback, and cleared with a wakeup on the bit</span>
<span class="cm"> *			address once it is done. The bit is also used to pin</span>
<span class="cm"> *			the inode in memory for flusher thread.</span>
<span class="cm"> *</span>
<span class="cm"> * I_REFERENCED		Marks the inode as recently references on the LRU list.</span>
<span class="cm"> *</span>
<span class="cm"> * I_DIO_WAKEUP		Never set.  Only used as a key for wait_on_bit().</span>
<span class="cm"> *</span>
<span class="cm"> * Q: What is the difference between I_WILL_FREE and I_FREEING?</span>
<span class="cm"> */</span>
<span class="cp">#define I_DIRTY_SYNC		(1 &lt;&lt; 0)</span>
<span class="cp">#define I_DIRTY_DATASYNC	(1 &lt;&lt; 1)</span>
<span class="cp">#define I_DIRTY_PAGES		(1 &lt;&lt; 2)</span>
<span class="cp">#define __I_NEW			3</span>
<span class="cp">#define I_NEW			(1 &lt;&lt; __I_NEW)</span>
<span class="cp">#define I_WILL_FREE		(1 &lt;&lt; 4)</span>
<span class="cp">#define I_FREEING		(1 &lt;&lt; 5)</span>
<span class="cp">#define I_CLEAR			(1 &lt;&lt; 6)</span>
<span class="cp">#define __I_SYNC		7</span>
<span class="cp">#define I_SYNC			(1 &lt;&lt; __I_SYNC)</span>
<span class="cp">#define I_REFERENCED		(1 &lt;&lt; 8)</span>
<span class="cp">#define __I_DIO_WAKEUP		9</span>
<span class="cp">#define I_DIO_WAKEUP		(1 &lt;&lt; I_DIO_WAKEUP)</span>

<span class="cp">#define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__mark_inode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_inode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">I_DIRTY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mark_inode_dirty_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">I_DIRTY_SYNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">inc_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drop_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clear_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nlink</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inode_inc_link_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inode_dec_link_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * inode_inc_iversion - increments i_version</span>
<span class="cm"> * @inode: inode that need to be updated</span>
<span class="cm"> *</span>
<span class="cm"> * Every time the inode is modified, the i_version field will be incremented.</span>
<span class="cm"> * The filesystem has to be mounted with i_version flag</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inode_inc_iversion</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
       <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="o">++</span><span class="p">;</span>
       <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">file_time_flags</span> <span class="p">{</span>
	<span class="n">S_ATIME</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">S_MTIME</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">S_CTIME</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">S_VERSION</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">touch_atime</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_accessed</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NOATIME</span><span class="p">))</span>
		<span class="n">touch_atime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">sync_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sync_inode_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">file_system_type</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fs_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">mount</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kill_sb</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">fs_supers</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">s_lock_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">s_umount_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">s_vfs_rename_key</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">i_lock_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">i_mutex_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">i_mutex_dir_key</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mount_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">));</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mount_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">));</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mount_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">));</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mount_nodev</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">));</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mount_subtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">generic_shutdown_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kill_block_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kill_anon_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">kill_litter_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">deactivate_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">deactivate_locked_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">set_anon_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">get_anon_bdev</span><span class="p">(</span><span class="n">dev_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_anon_bdev</span><span class="p">(</span><span class="n">dev_t</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sget</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">mount_pseudo</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">dops</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cm">/* Alas, no aliases. Too much hassle with bringing module.h everywhere */</span>
<span class="cp">#define fops_get(fops) \</span>
<span class="cp">	(((fops) &amp;&amp; try_module_get((fops)-&gt;owner) ? (fops) : NULL))</span>
<span class="cp">#define fops_put(fops) \</span>
<span class="cp">	do { if (fops) module_put((fops)-&gt;owner); } while(0)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">unregister_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">kern_mount_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#define kern_mount(type) kern_mount_data(type, NULL)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kern_unmount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">may_umount_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">may_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">do_mount</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">collect_mounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drop_collected_mounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iterate_mounts</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">user_statfs</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fd_statfs</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_ustat</span><span class="p">(</span><span class="n">dev_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">freeze_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">super</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">thaw_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">super</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">our_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">current_umask</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* /sys/fs */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">fs_kobj</span><span class="p">;</span>

<span class="cp">#define MAX_RW_COUNT (INT_MAX &amp; PAGE_CACHE_MASK)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rw_verify_area</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cp">#define FLOCK_VERIFY_READ  1</span>
<span class="cp">#define FLOCK_VERIFY_WRITE 2</span>

<span class="cp">#ifdef CONFIG_FILE_LOCKING</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">locks_mandatory_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">locks_mandatory_area</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Candidates for mandatory locking have the setgid bit set</span>
<span class="cm"> * but no group execute bit -  an otherwise meaningless combination.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__mandatory_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">S_ISGID</span> <span class="o">|</span> <span class="n">S_IXGRP</span><span class="p">))</span> <span class="o">==</span> <span class="n">S_ISGID</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ... and these candidates should be on MS_MANDLOCK mounted fs,</span>
<span class="cm"> * otherwise these will be advisory locks</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mandatory_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">IS_MANDLOCK</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__mandatory_lock</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">locks_verify_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mandatory_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">locks_mandatory_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">locks_verify_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				    <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span> <span class="o">&amp;&amp;</span> <span class="n">mandatory_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">locks_mandatory_area</span><span class="p">(</span>
			<span class="n">FLOCK_VERIFY_WRITE</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span>
			<span class="n">size</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">?</span> <span class="n">size</span> <span class="o">:</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span>
			<span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">?</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">size</span>
			 <span class="o">:</span> <span class="n">size</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">break_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__break_lease</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_FILE_LOCKING */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">locks_mandatory_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">locks_mandatory_area</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__mandatory_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mandatory_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">locks_verify_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">locks_verify_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">break_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_FILE_LOCKING */</span><span class="cp"></span>

<span class="cm">/* fs/open.c */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_attrs</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_fallocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">do_sys_open</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			<span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file_open_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">dentry_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filp_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">getname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* fs/ioctl.c */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ioctl_preallocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">);</span>

<span class="cm">/* fs/dcache.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">vfs_caches_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">vfs_caches_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">names_cachep</span><span class="p">;</span>

<span class="cp">#define __getname_gfp(gfp)	kmem_cache_alloc(names_cachep, (gfp))</span>
<span class="cp">#define __getname()		__getname_gfp(GFP_KERNEL)</span>
<span class="cp">#define __putname(name)		kmem_cache_free(names_cachep, (void *)(name))</span>
<span class="cp">#ifndef CONFIG_AUDITSYSCALL</span>
<span class="cp">#define putname(name)   __putname(name)</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">putname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_blkdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_blkdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdget</span><span class="p">(</span><span class="n">dev_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdgrab</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bd_set_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">sector_t</span> <span class="n">blkdev_max_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bd_forget</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bdput</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">invalidate_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sync_blockdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kill_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">freeze_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">emergency_thaw_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">thaw_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fsync_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bd_forget</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sync_blockdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kill_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">invalidate_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">freeze_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">thaw_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sync_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">def_blk_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">def_chr_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">bad_sock_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">def_fifo_fops</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ioctl_by_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blkdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">compat_blkdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blkdev_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">holder</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">blkdev_get_by_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
					       <span class="kt">void</span> <span class="o">*</span><span class="n">holder</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">blkdev_get_by_dev</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
					      <span class="kt">void</span> <span class="o">*</span><span class="n">holder</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blkdev_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bd_link_disk_holder</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bd_unlink_disk_holder</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bd_link_disk_holder</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bd_unlink_disk_holder</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/* fs/char_dev.c */</span>
<span class="cp">#define CHRDEV_MAJOR_HASH_SIZE	255</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="n">dev_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_chrdev_region</span><span class="p">(</span><span class="n">dev_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__register_chrdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">baseminor</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__unregister_chrdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">baseminor</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">chrdev_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span><span class="kt">off_t</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">register_chrdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__register_chrdev</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unregister_chrdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__unregister_chrdev</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* fs/block_dev.c */</span>
<span class="cp">#define BDEVNAME_SIZE	32	</span><span class="cm">/* Largest string for a blockdev identifier */</span><span class="cp"></span>
<span class="cp">#define BDEVT_SIZE	10	</span><span class="cm">/* Largest string for MAJ:MIN for blkdev */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="cp">#define BLKDEV_MAJOR_HASH_SIZE	255</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__bdevname</span><span class="p">(</span><span class="n">dev_t</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bdevname</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">lookup_bdev</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">blkdev_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span><span class="kt">off_t</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="cp">#define BLKDEV_MAJOR_HASH_SIZE	0</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_special_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">dev_t</span><span class="p">);</span>

<span class="cm">/* Invalid inode operations -- fs/bad_inode.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">make_bad_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">is_bad_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">read_pipefifo_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">write_pipefifo_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">rdwr_pipefifo_fops</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="cm">/*</span>
<span class="cm"> * return READ, READA, or WRITE</span>
<span class="cm"> */</span>
<span class="cp">#define bio_rw(bio)		((bio)-&gt;bi_rw &amp; (RW_MASK | RWA_MASK))</span>

<span class="cm">/*</span>
<span class="cm"> * return data direction, READ or WRITE</span>
<span class="cm"> */</span>
<span class="cp">#define bio_data_dir(bio)	((bio)-&gt;bi_rw &amp; 1)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">check_disk_size_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">revalidate_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">check_disk_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__invalidate_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">invalidate_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">invalidate_mapping_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
					<span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">end</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">invalidate_remote_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">invalidate_mapping_pages</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">invalidate_inode_pages2</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">invalidate_inode_pages2_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
					 <span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">write_inode_now</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filemap_fdatawrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filemap_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filemap_fdatawait</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filemap_fdatawait_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span>
				   <span class="n">loff_t</span> <span class="n">lend</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				        <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lend</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__filemap_fdatawrite_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync_mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filemap_fdatawrite_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_fsync_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_write_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sync_supers</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">emergency_sync</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">emergency_remount</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="k">extern</span> <span class="n">sector_t</span> <span class="n">bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">notify_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">execute_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IXUGO</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_write_access() gets write permission for a file.</span>
<span class="cm"> * put_write_access() releases this write permission.</span>
<span class="cm"> * This is used for regular files.</span>
<span class="cm"> * We cannot support write (and maybe mmap read-write shared) accesses and</span>
<span class="cm"> * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode</span>
<span class="cm"> * can have the following values:</span>
<span class="cm"> * 0: no writers, no VM_DENYWRITE mappings</span>
<span class="cm"> * &lt; 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist</span>
<span class="cm"> * &gt; 0: (i_writecount) users are writing to the file.</span>
<span class="cm"> *</span>
<span class="cm"> * Normally we operate on that counter with atomic_{inc,dec} and it&#39;s safe</span>
<span class="cm"> * except for the cases where we don&#39;t hold i_writecount yet. Then we need to</span>
<span class="cm"> * use {get,deny}_write_access() - these functions check the sign and refuse</span>
<span class="cm"> * to do the change if sign is wrong.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_write_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_inc_unless_negative</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ETXTBSY</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">deny_write_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">atomic_dec_unless_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ETXTBSY</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_write_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">allow_write_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_IMA</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i_readcount_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_readcount</span><span class="p">));</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_readcount</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i_readcount_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_readcount</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i_readcount_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i_readcount_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_pipe_flags</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">create_read_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">create_write_pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_write_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">kernel_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">open_exec</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
 
<span class="cm">/* fs/dcache.c -- generic fs support functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">is_subdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">path_is_under</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ino_t</span> <span class="n">find_inode_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#include &lt;linux/err.h&gt;</span>

<span class="cm">/* needed for stackable file system support */</span>
<span class="k">extern</span> <span class="n">loff_t</span> <span class="n">default_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">loff_t</span> <span class="n">vfs_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">inode_init_always</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">inode_init_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">address_space_init_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ihold</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">igrab</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ino_t</span> <span class="n">iunique</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">ino_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">inode_needs_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_delete_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">generic_drop_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">||</span> <span class="n">inode_unhashed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ilookup5_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ilookup5</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">,</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ilookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">iget5_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">iget_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">insert_inode_locked4</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">insert_inode_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">lockdep_annotate_inode_mutex_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lockdep_annotate_inode_mutex_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span> <span class="p">};</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unlock_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">get_next_ino</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">iget_failed</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clear_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode_pseudo</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_inode_nonrcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">should_remove_suid</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">file_remove_suid</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__insert_inode_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hashval</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">insert_inode_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__remove_inode_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_inode_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode_unhashed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">__remove_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">inode_sb_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">submit_bio</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bdev_read_only</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_blocksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sb_set_blocksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sb_min_blocksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_file_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_file_readonly_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">file_read_actor</span><span class="p">(</span><span class="n">read_descriptor_t</span> <span class="o">*</span> <span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">generic_write_checks</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isblk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">generic_file_aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">__generic_file_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">generic_file_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">generic_file_direct_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">generic_file_buffered_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">ssize_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">do_sync_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">do_sync_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_segment_checks</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_segs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access_flags</span><span class="p">);</span>

<span class="cm">/* fs/block_dev.c */</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">blkdev_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">blkdev_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">block_sync_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cm">/* fs/splice.c */</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">generic_file_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">default_file_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">generic_file_splice_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">generic_splice_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">do_splice_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span>
<span class="n">file_ra_state_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">loff_t</span> <span class="n">noop_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">loff_t</span> <span class="n">no_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">loff_t</span> <span class="n">generic_file_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">loff_t</span> <span class="n">generic_file_llseek_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">origin</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">maxsize</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FS_XIP</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">xip_file_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			     <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xip_file_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">xip_file_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">xip_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">xip_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">dio_submit_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			    <span class="n">loff_t</span> <span class="n">file_offset</span><span class="p">);</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* need locking between buffered and direct access */</span>
	<span class="n">DIO_LOCKING</span>	<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>

	<span class="cm">/* filesystem does not support filling holes */</span>
	<span class="n">DIO_SKIP_HOLES</span>	<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">dio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>

<span class="kt">ssize_t</span> <span class="n">__blockdev_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">dio_iodone_t</span> <span class="n">end_io</span><span class="p">,</span>
	<span class="n">dio_submit_t</span> <span class="n">submit_io</span><span class="p">,</span>	<span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">blockdev_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
				    <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">get_block</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">DIO_LOCKING</span> <span class="o">|</span> <span class="n">DIO_SKIP_HOLES</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">inode_dio_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">inode_dio_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">generic_ro_fops</span><span class="p">;</span>

<span class="cp">#define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">page_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">page_follow_link_light</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">page_put_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__page_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">nofs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">page_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">page_symlink_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">generic_fillattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__inode_add_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">inode_add_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">inode_sub_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="n">loff_t</span> <span class="n">inode_get_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">inode_set_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">bytes</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">filldir_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_stat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_lstat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_fstat</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vfs_fstatat</span><span class="p">(</span><span class="kt">int</span> <span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_vfs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__generic_block_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
				  <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">len</span><span class="p">,</span>
				  <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_block_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">get_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">put_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">get_fs_type</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">get_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">get_super_thawed</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">get_active_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drop_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">iterate_supers</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">iterate_supers_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">,</span>
			        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcache_dir_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcache_dir_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">loff_t</span> <span class="n">dcache_dir_lseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dcache_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">filldir_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">noop_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">simple_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">generic_read_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">simple_dir_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">simple_dir_inode_operations</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tree_descr</span> <span class="p">{</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_alloc_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_descr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">simple_pin_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">**</span><span class="n">mount</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">simple_release_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">**</span><span class="n">mount</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">available</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">simple_write_to_buffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">available</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_file_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_check_addressable</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MIGRATION</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">buffer_migrate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">migrate_mode</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define buffer_migrate_page NULL</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">setattr_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">file_update_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">generic_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">save_mount_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">replace_mount_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ino_t</span> <span class="nf">parent_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ino_t</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t strictly need d_lock here? If the parent ino could change</span>
<span class="cm">	 * then surely we&#39;d have a deeper race in the caller?</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Transaction based IO helpers */</span>

<span class="cm">/*</span>
<span class="cm"> * An argresp is stored in an allocated page and holds the</span>
<span class="cm"> * size of the argument or response, along with its content</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">simple_transaction_argresp</span> <span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define SIMPLE_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct simple_transaction_argresp))</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">simple_transaction_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">simple_transaction_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">simple_transaction_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">simple_transaction_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * simple attribute files</span>
<span class="cm"> *</span>
<span class="cm"> * These attributes behave similar to those in sysfs:</span>
<span class="cm"> *</span>
<span class="cm"> * Writing to an attribute immediately sets a value, an open file can be</span>
<span class="cm"> * written to multiple times.</span>
<span class="cm"> *</span>
<span class="cm"> * Reading from an attribute creates a buffer from the value that might get</span>
<span class="cm"> * read with multiple read calls. When the attribute has been read</span>
<span class="cm"> * completely, no further read calls are possible until the file is opened</span>
<span class="cm"> * again.</span>
<span class="cm"> *</span>
<span class="cm"> * All attributes contain a text representation of a numeric value</span>
<span class="cm"> * that are accessed with the get() and set() functions.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFINE_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)		\</span>
<span class="cp">static int __fops ## _open(struct inode *inode, struct file *file)	\</span>
<span class="cp">{									\</span>
<span class="cp">	__simple_attr_check_format(__fmt, 0ull);			\</span>
<span class="cp">	return simple_attr_open(inode, file, __get, __set, __fmt);	\</span>
<span class="cp">}									\</span>
<span class="cp">static const struct file_operations __fops = {				\</span>
<span class="cp">	.owner	 = THIS_MODULE,						\</span>
<span class="cp">	.open	 = __fops ## _open,					\</span>
<span class="cp">	.release = simple_attr_release,					\</span>
<span class="cp">	.read	 = simple_attr_read,					\</span>
<span class="cp">	.write	 = simple_attr_write,					\</span>
<span class="cp">	.llseek	 = generic_file_llseek,					\</span>
<span class="cp">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="nf">__printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">__simple_attr_check_format</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="cm">/* don&#39;t do anything, just let the compiler check the arguments; */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">simple_attr_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="p">),</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">),</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">simple_attr_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">simple_attr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">simple_attr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ctl_table</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">proc_nr_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">proc_nr_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">proc_nr_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		   <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="n">get_filesystem_list</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cp">#define __FMODE_EXEC		((__force int) FMODE_EXEC)</span>
<span class="cp">#define __FMODE_NONOTIFY	((__force int) FMODE_NONOTIFY)</span>

<span class="cp">#define ACC_MODE(x) (&quot;\004\002\006\006&quot;[(x)&amp;O_ACCMODE])</span>
<span class="cp">#define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) &amp; O_ACCMODE) | \</span>
<span class="cp">					    (flag &amp; __FMODE_NONOTIFY)))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_sxid</span><span class="p">(</span><span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_ISUID</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_ISGID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IXGRP</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inode_has_no_xattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sxid</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_NOSEC</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOSEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_FS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
