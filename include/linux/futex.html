<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › futex.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>futex.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_FUTEX_H</span>
<span class="cp">#define _LINUX_FUTEX_H</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/* Second argument to futex syscall */</span>


<span class="cp">#define FUTEX_WAIT		0</span>
<span class="cp">#define FUTEX_WAKE		1</span>
<span class="cp">#define FUTEX_FD		2</span>
<span class="cp">#define FUTEX_REQUEUE		3</span>
<span class="cp">#define FUTEX_CMP_REQUEUE	4</span>
<span class="cp">#define FUTEX_WAKE_OP		5</span>
<span class="cp">#define FUTEX_LOCK_PI		6</span>
<span class="cp">#define FUTEX_UNLOCK_PI		7</span>
<span class="cp">#define FUTEX_TRYLOCK_PI	8</span>
<span class="cp">#define FUTEX_WAIT_BITSET	9</span>
<span class="cp">#define FUTEX_WAKE_BITSET	10</span>
<span class="cp">#define FUTEX_WAIT_REQUEUE_PI	11</span>
<span class="cp">#define FUTEX_CMP_REQUEUE_PI	12</span>

<span class="cp">#define FUTEX_PRIVATE_FLAG	128</span>
<span class="cp">#define FUTEX_CLOCK_REALTIME	256</span>
<span class="cp">#define FUTEX_CMD_MASK		~(FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME)</span>

<span class="cp">#define FUTEX_WAIT_PRIVATE	(FUTEX_WAIT | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_WAKE_PRIVATE	(FUTEX_WAKE | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_REQUEUE_PRIVATE	(FUTEX_REQUEUE | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_CMP_REQUEUE_PRIVATE (FUTEX_CMP_REQUEUE | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_WAKE_OP_PRIVATE	(FUTEX_WAKE_OP | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_LOCK_PI_PRIVATE	(FUTEX_LOCK_PI | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_UNLOCK_PI_PRIVATE	(FUTEX_UNLOCK_PI | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_TRYLOCK_PI_PRIVATE (FUTEX_TRYLOCK_PI | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_WAIT_BITSET_PRIVATE	(FUTEX_WAIT_BITSET | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_WAKE_BITSET_PRIVATE	(FUTEX_WAKE_BITSET | FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_WAIT_REQUEUE_PI_PRIVATE	(FUTEX_WAIT_REQUEUE_PI | \</span>
<span class="cp">					 FUTEX_PRIVATE_FLAG)</span>
<span class="cp">#define FUTEX_CMP_REQUEUE_PI_PRIVATE	(FUTEX_CMP_REQUEUE_PI | \</span>
<span class="cp">					 FUTEX_PRIVATE_FLAG)</span>

<span class="cm">/*</span>
<span class="cm"> * Support for robust futexes: the kernel cleans up held futexes at</span>
<span class="cm"> * thread exit time.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Per-lock list entry - embedded in user-space locks, somewhere close</span>
<span class="cm"> * to the futex field. (Note: user-space uses a double-linked list to</span>
<span class="cm"> * achieve O(1) list add and remove, but the kernel only needs to know</span>
<span class="cm"> * about the forward link)</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this structure is part of the syscall ABI, and must not be</span>
<span class="cm"> * changed.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">robust_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">robust_list</span> <span class="n">__user</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per-thread list head:</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this structure is part of the syscall ABI, and must only be</span>
<span class="cm"> * changed if the change is first communicated with the glibc folks.</span>
<span class="cm"> * (When an incompatible change is done, we&#39;ll increase the structure</span>
<span class="cm"> *  size, which glibc will detect)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">robust_list_head</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The head of the list. Points back to itself if empty:</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">robust_list</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This relative offset is set by user-space, it gives the kernel</span>
<span class="cm">	 * the relative position of the futex field to examine. This way</span>
<span class="cm">	 * we keep userspace flexible, to freely shape its data-structure,</span>
<span class="cm">	 * without hardcoding any particular offset into the kernel:</span>
<span class="cm">	 */</span>
	<span class="kt">long</span> <span class="n">futex_offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The death of the thread may race with userspace setting</span>
<span class="cm">	 * up a lock&#39;s links. So to handle this race, userspace first</span>
<span class="cm">	 * sets this field to the address of the to-be-taken lock,</span>
<span class="cm">	 * then does the lock acquire, and then adds itself to the</span>
<span class="cm">	 * list, and then clears this field. Hence the kernel will</span>
<span class="cm">	 * always have full knowledge of all locks that the thread</span>
<span class="cm">	 * _might_ have taken. We check the owner TID in any case,</span>
<span class="cm">	 * so only truly owned locks will be handled.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">robust_list</span> <span class="n">__user</span> <span class="o">*</span><span class="n">list_op_pending</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Are there any waiters for this robust futex:</span>
<span class="cm"> */</span>
<span class="cp">#define FUTEX_WAITERS		0x80000000</span>

<span class="cm">/*</span>
<span class="cm"> * The kernel signals via this bit that a thread holding a futex</span>
<span class="cm"> * has exited without unlocking the futex. The kernel also does</span>
<span class="cm"> * a FUTEX_WAKE on such futexes, after setting the bit, to wake</span>
<span class="cm"> * up any possible waiters:</span>
<span class="cm"> */</span>
<span class="cp">#define FUTEX_OWNER_DIED	0x40000000</span>

<span class="cm">/*</span>
<span class="cm"> * The rest of the robust-futex field is for the TID:</span>
<span class="cm"> */</span>
<span class="cp">#define FUTEX_TID_MASK		0x3fffffff</span>

<span class="cm">/*</span>
<span class="cm"> * This limit protects against a deliberately circular list.</span>
<span class="cm"> * (Not worth introducing an rlimit for it)</span>
<span class="cm"> */</span>
<span class="cp">#define ROBUST_LIST_LIMIT	2048</span>

<span class="cm">/*</span>
<span class="cm"> * bitset with all bits set for the FUTEX_xxx_BITSET OPs to request a</span>
<span class="cm"> * match of any bit.</span>
<span class="cm"> */</span>
<span class="cp">#define FUTEX_BITSET_MATCH_ANY	0xffffffff</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="k">struct</span> <span class="n">inode</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="k">union</span> <span class="n">ktime</span><span class="p">;</span>

<span class="kt">long</span> <span class="n">do_futex</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="k">union</span> <span class="n">ktime</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>
	      <span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val2</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val3</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">handle_futex_death</span><span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pi</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Futexes are matched on equal values of this key.</span>
<span class="cm"> * The key type depends on whether it&#39;s a shared or private mapping.</span>
<span class="cm"> * Don&#39;t rearrange members without looking at hash_futex().</span>
<span class="cm"> *</span>
<span class="cm"> * offset is aligned to a multiple of sizeof(u32) (== 4) by definition.</span>
<span class="cm"> * We use the two low order bits of offset to tell what is the kind of key :</span>
<span class="cm"> *  00 : Private process futex (PTHREAD_PROCESS_PRIVATE)</span>
<span class="cm"> *       (no reference on an inode or mm)</span>
<span class="cm"> *  01 : Shared futex (PTHREAD_PROCESS_SHARED)</span>
<span class="cm"> *	mapped on a file (reference on the underlying inode)</span>
<span class="cm"> *  10 : Shared futex (PTHREAD_PROCESS_SHARED)</span>
<span class="cm"> *       (but private mapping on an mm, and reference taken on it)</span>
<span class="cm">*/</span>

<span class="cp">#define FUT_OFF_INODE    1 </span><span class="cm">/* We set bit 0 if key has a reference on inode */</span><span class="cp"></span>
<span class="cp">#define FUT_OFF_MMSHARED 2 </span><span class="cm">/* We set bit 1 if key has a reference on mm */</span><span class="cp"></span>

<span class="k">union</span> <span class="n">futex_key</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">shared</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">word</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">both</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define FUTEX_KEY_INIT (union futex_key) { .both = { .ptr = NULL } }</span>

<span class="cp">#ifdef CONFIG_FUTEX</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_robust_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_pi_state_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">futex_cmpxchg_enabled</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">exit_robust_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">exit_pi_state_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#define FUTEX_OP_SET		0	</span><span class="cm">/* *(int *)UADDR2 = OPARG; */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_ADD		1	</span><span class="cm">/* *(int *)UADDR2 += OPARG; */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_OR		2	</span><span class="cm">/* *(int *)UADDR2 |= OPARG; */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_ANDN		3	</span><span class="cm">/* *(int *)UADDR2 &amp;= ~OPARG; */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_XOR		4	</span><span class="cm">/* *(int *)UADDR2 ^= OPARG; */</span><span class="cp"></span>

<span class="cp">#define FUTEX_OP_OPARG_SHIFT	8	</span><span class="cm">/* Use (1 &lt;&lt; OPARG) instead of OPARG.  */</span><span class="cp"></span>

<span class="cp">#define FUTEX_OP_CMP_EQ		0	</span><span class="cm">/* if (oldval == CMPARG) wake */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_CMP_NE		1	</span><span class="cm">/* if (oldval != CMPARG) wake */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_CMP_LT		2	</span><span class="cm">/* if (oldval &lt; CMPARG) wake */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_CMP_LE		3	</span><span class="cm">/* if (oldval &lt;= CMPARG) wake */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_CMP_GT		4	</span><span class="cm">/* if (oldval &gt; CMPARG) wake */</span><span class="cp"></span>
<span class="cp">#define FUTEX_OP_CMP_GE		5	</span><span class="cm">/* if (oldval &gt;= CMPARG) wake */</span><span class="cp"></span>

<span class="cm">/* FUTEX_WAKE_OP will perform atomically</span>
<span class="cm">   int oldval = *(int *)UADDR2;</span>
<span class="cm">   *(int *)UADDR2 = oldval OP OPARG;</span>
<span class="cm">   if (oldval CMP CMPARG)</span>
<span class="cm">     wake UADDR2;  */</span>

<span class="cp">#define FUTEX_OP(op, oparg, cmp, cmparg) \</span>
<span class="cp">  (((op &amp; 0xf) &lt;&lt; 28) | ((cmp &amp; 0xf) &lt;&lt; 24)		\</span>
<span class="cp">   | ((oparg &amp; 0xfff) &lt;&lt; 12) | (cmparg &amp; 0xfff))</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
