<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ftrace.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ftrace.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Ftrace header.  For implementation details beyond the random comments</span>
<span class="cm"> * scattered below, see: Documentation/trace/ftrace-design.txt</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_FTRACE_H</span>
<span class="cp">#define _LINUX_FTRACE_H</span>

<span class="cp">#include &lt;linux/trace_clock.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>

<span class="cp">#include &lt;asm/ftrace.h&gt;</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ftrace_hash</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FUNCTION_TRACER</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_enabled</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">ftrace_enable_sysctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		     <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ftrace_func_t</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * FTRACE_OPS_FL_* bits denote the state of ftrace_ops struct and are</span>
<span class="cm"> * set in the flags member.</span>
<span class="cm"> *</span>
<span class="cm"> * ENABLED - set/unset when ftrace_ops is registered/unregistered</span>
<span class="cm"> * GLOBAL  - set manualy by ftrace_ops user to denote the ftrace_ops</span>
<span class="cm"> *           is part of the global tracers sharing the same filter</span>
<span class="cm"> *           via set_ftrace_* debugfs files.</span>
<span class="cm"> * DYNAMIC - set when ftrace_ops is registered to denote dynamically</span>
<span class="cm"> *           allocated ftrace_ops which need special care</span>
<span class="cm"> * CONTROL - set manualy by ftrace_ops user to denote the ftrace_ops</span>
<span class="cm"> *           could be controled by following calls:</span>
<span class="cm"> *             ftrace_function_local_enable</span>
<span class="cm"> *             ftrace_function_local_disable</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FTRACE_OPS_FL_ENABLED</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">FTRACE_OPS_FL_GLOBAL</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">FTRACE_OPS_FL_DYNAMIC</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">FTRACE_OPS_FL_CONTROL</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="p">{</span>
	<span class="n">ftrace_func_t</span>			<span class="n">func</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_ops</span>		<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__percpu</span>			<span class="o">*</span><span class="n">disabled</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span>		<span class="o">*</span><span class="n">notrace_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ftrace_hash</span>		<span class="o">*</span><span class="n">filter_hash</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">function_trace_stop</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Type of the current tracing.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ftrace_tracing_type_t</span> <span class="p">{</span>
	<span class="n">FTRACE_TYPE_ENTER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Hook the call of the function */</span>
	<span class="n">FTRACE_TYPE_RETURN</span><span class="p">,</span>	<span class="cm">/* Hook the return of the function */</span>
<span class="p">};</span>

<span class="cm">/* Current tracing type, default is FTRACE_TYPE_ENTER */</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">ftrace_tracing_type_t</span> <span class="n">ftrace_tracing_type</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_stop - stop function tracer.</span>
<span class="cm"> *</span>
<span class="cm"> * A quick way to stop the function tracer. Note this an on off switch,</span>
<span class="cm"> * it is not something that is recursive like preempt_disable.</span>
<span class="cm"> * This does not disable the calling of mcount, it only stops the</span>
<span class="cm"> * calling of functions from mcount.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">function_trace_stop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_start - start the function tracer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the inverse of ftrace_stop. This does not enable</span>
<span class="cm"> * the function tracing if the function tracer is disabled. This only</span>
<span class="cm"> * sets the function tracer flag to continue calling the functions</span>
<span class="cm"> * from mcount.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">function_trace_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The ftrace_ops must be a static and should also</span>
<span class="cm"> * be read_mostly.  These functions do modify read_mostly variables</span>
<span class="cm"> * so use them sparely. Never free an ftrace_op or modify the</span>
<span class="cm"> * next pointer after it has been registered. Even after unregistering</span>
<span class="cm"> * it, the next pointer may still be used internally.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">register_ftrace_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">unregister_ftrace_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">clear_ftrace_function</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_function_local_enable - enable controlled ftrace_ops on current cpu</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables tracing on current cpu by decreasing</span>
<span class="cm"> * the per cpu control variable.</span>
<span class="cm"> * It must be called with preemption disabled and only on ftrace_ops</span>
<span class="cm"> * registered with FTRACE_OPS_FL_CONTROL. If called without preemption</span>
<span class="cm"> * disabled, this_cpu_ptr will complain when CONFIG_DEBUG_PREEMPT is enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_function_local_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_CONTROL</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">))</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_function_local_disable - enable controlled ftrace_ops on current cpu</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables tracing on current cpu by decreasing</span>
<span class="cm"> * the per cpu control variable.</span>
<span class="cm"> * It must be called with preemption disabled and only on ftrace_ops</span>
<span class="cm"> * registered with FTRACE_OPS_FL_CONTROL. If called without preemption</span>
<span class="cm"> * disabled, this_cpu_ptr will complain when CONFIG_DEBUG_PREEMPT is enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_function_local_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_CONTROL</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">))</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_function_local_disabled - returns ftrace_ops disabled value</span>
<span class="cm"> *                                  on current cpu</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns value of ftrace_ops::disabled on current cpu.</span>
<span class="cm"> * It must be called with preemption disabled and only on ftrace_ops</span>
<span class="cm"> * registered with FTRACE_OPS_FL_CONTROL. If called without preemption</span>
<span class="cm"> * disabled, this_cpu_ptr will complain when CONFIG_DEBUG_PREEMPT is enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ftrace_function_local_disabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FTRACE_OPS_FL_CONTROL</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">disabled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_stub</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_FUNCTION_TRACER */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * (un)register_ftrace_function must be a macro since the ops parameter</span>
<span class="cm"> * must not be evaluated.</span>
<span class="cm"> */</span>
<span class="cp">#define register_ftrace_function(ops) ({ 0; })</span>
<span class="cp">#define unregister_ftrace_function(ops) ({ 0; })</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_ftrace_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_kill</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_TRACER */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_STACK_TRACER</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stack_tracer_enabled</span><span class="p">;</span>
<span class="kt">int</span>
<span class="n">stack_trace_sysctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		   <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		   <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ftrace_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_DYNAMIC_FTRACE</span>

<span class="kt">int</span> <span class="n">ftrace_arch_code_modify_prepare</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ftrace_arch_code_modify_post_process</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ftrace_bug</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">seq_file</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="p">{</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent_ip</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">print</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">register_ftrace_function_probe</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>
<span class="n">unregister_ftrace_function_probe</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>
<span class="n">unregister_ftrace_function_probe_func</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ftrace_probe_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_ftrace_function_probe_all</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">glob</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_text_reserved</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">);</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FTRACE_FL_ENABLED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define FTRACE_FL_MASK		(0x3UL &lt;&lt; 30)</span>
<span class="cp">#define FTRACE_REF_MAX		((1 &lt;&lt; 30) - 1)</span>

<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ip</span><span class="p">;</span> <span class="cm">/* address of mcount call-site */</span>
		<span class="k">struct</span> <span class="n">dyn_ftrace</span>	<span class="o">*</span><span class="n">freelist</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dyn_arch_ftrace</span>		<span class="n">arch</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">ftrace_force_update</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ftrace_set_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ftrace_set_notrace</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ftrace_set_global_filter</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ftrace_set_global_notrace</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ftrace_free_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">register_ftrace_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">unregister_ftrace_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FTRACE_UPDATE_CALLS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">FTRACE_DISABLE_CALLS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">FTRACE_UPDATE_TRACE_FUNC</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">FTRACE_START_FUNC_RET</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">FTRACE_STOP_FUNC_RET</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FTRACE_UPDATE_IGNORE</span><span class="p">,</span>
	<span class="n">FTRACE_UPDATE_MAKE_CALL</span><span class="p">,</span>
	<span class="n">FTRACE_UPDATE_MAKE_NOP</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">FTRACE_ITER_FILTER</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">FTRACE_ITER_NOTRACE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">FTRACE_ITER_PRINTALL</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">FTRACE_ITER_DO_HASH</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">FTRACE_ITER_HASH</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="n">FTRACE_ITER_ENABLED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">arch_ftrace_update_code</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ftrace_rec_iter</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="n">ftrace_rec_iter_start</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="n">ftrace_rec_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">ftrace_rec_iter_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_rec_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>

<span class="cp">#define for_ftrace_rec_iter(iter)		\</span>
<span class="cp">	for (iter = ftrace_rec_iter_start();	\</span>
<span class="cp">	     iter;				\</span>
<span class="cp">	     iter = ftrace_rec_iter_next(iter))</span>


<span class="kt">int</span> <span class="n">ftrace_update_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ftrace_test_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ftrace_run_stop_machine</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ftrace_location</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">ftrace_func_t</span> <span class="n">ftrace_trace_function</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">ftrace_regex_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">ftrace_filter_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">ftrace_notrace_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="n">loff_t</span> <span class="n">ftrace_regex_lseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ftrace_regex_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span>
<span class="n">ftrace_set_early_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>

<span class="cm">/* defined in arch */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_ip_converted</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_dyn_arch_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_replace_code</span><span class="p">(</span><span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_update_ftrace_func</span><span class="p">(</span><span class="n">ftrace_func_t</span> <span class="n">func</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_caller</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_call</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mcount_call</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ftrace_modify_all_code</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">);</span>

<span class="cp">#ifndef FTRACE_ADDR</span>
<span class="cp">#define FTRACE_ADDR ((unsigned long)ftrace_caller)</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_graph_caller</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_enable_ftrace_graph_caller</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_disable_ftrace_graph_caller</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ftrace_enable_ftrace_graph_caller</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ftrace_disable_ftrace_graph_caller</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_make_nop - convert code into nop</span>
<span class="cm"> * @mod: module structure if called by module load initialization</span>
<span class="cm"> * @rec: the mcount call site record</span>
<span class="cm"> * @addr: the address that the call site should be calling</span>
<span class="cm"> *</span>
<span class="cm"> * This is a very sensitive operation and great care needs</span>
<span class="cm"> * to be taken by the arch.  The operation should carefully</span>
<span class="cm"> * read the location, check to see if what is read is indeed</span>
<span class="cm"> * what we expect it to be, and then on success of the compare,</span>
<span class="cm"> * it should write to the location.</span>
<span class="cm"> *</span>
<span class="cm"> * The code segment at @rec-&gt;ip should be a caller to @addr</span>
<span class="cm"> *</span>
<span class="cm"> * Return must be:</span>
<span class="cm"> *  0 on success</span>
<span class="cm"> *  -EFAULT on error reading the location</span>
<span class="cm"> *  -EINVAL on a failed compare of the contents</span>
<span class="cm"> *  -EPERM  on error writing to the location</span>
<span class="cm"> * Any other value will be considered a failure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_make_nop</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ftrace_make_call - convert a nop call site into a call to addr</span>
<span class="cm"> * @rec: the mcount call site record</span>
<span class="cm"> * @addr: the address that the call site should call</span>
<span class="cm"> *</span>
<span class="cm"> * This is a very sensitive operation and great care needs</span>
<span class="cm"> * to be taken by the arch.  The operation should carefully</span>
<span class="cm"> * read the location, check to see if what is read is indeed</span>
<span class="cm"> * what we expect it to be, and then on success of the compare,</span>
<span class="cm"> * it should write to the location.</span>
<span class="cm"> *</span>
<span class="cm"> * The code segment at @rec-&gt;ip should be a nop</span>
<span class="cm"> *</span>
<span class="cm"> * Return must be:</span>
<span class="cm"> *  0 on success</span>
<span class="cm"> *  -EFAULT on error reading the location</span>
<span class="cm"> *  -EINVAL on a failed compare of the contents</span>
<span class="cm"> *  -EPERM  on error writing to the location</span>
<span class="cm"> * Any other value will be considered a failure.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_make_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">dyn_ftrace</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/* May be defined in arch */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ftrace_arch_read_dyn_info</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">skip_trace</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_disable_daemon</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_enable_daemon</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skip_trace</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ftrace_force_update</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_disable_daemon</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_enable_daemon</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_release_mod</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">mod</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">register_ftrace_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ftrace_func_command</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unregister_ftrace_command</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmd_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ftrace_text_reserved</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Again users of functions that have ftrace_ops may not</span>
<span class="cm"> * have them defined when ftrace is not enabled, but these</span>
<span class="cm"> * functions may still be called. Use a macro instead of inline.</span>
<span class="cm"> */</span>
<span class="cp">#define ftrace_regex_open(ops, flag, inod, file) ({ -ENODEV; })</span>
<span class="cp">#define ftrace_set_early_filter(ops, buf, enable) do { } while (0)</span>
<span class="cp">#define ftrace_set_filter(ops, buf, len, reset) ({ -ENODEV; })</span>
<span class="cp">#define ftrace_set_notrace(ops, buf, len, reset) ({ -ENODEV; })</span>
<span class="cp">#define ftrace_free_filter(ops) do { } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">ftrace_filter_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">ftrace_notrace_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span>
			     <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">ftrace_regex_lseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ftrace_regex_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DYNAMIC_FTRACE */</span><span class="cp"></span>

<span class="cm">/* totally disable ftrace - can not re-enable after this */</span>
<span class="kt">void</span> <span class="n">ftrace_kill</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tracer_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FUNCTION_TRACER</span>
	<span class="n">ftrace_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ftrace disable/restore without lock. Some synchronization mechanism</span>
<span class="cm"> * must be used to prevent ftrace_enabled to be changed between</span>
<span class="cm"> * disable/restore.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ftrace_enabled_save</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FUNCTION_TRACER</span>
	<span class="kt">int</span> <span class="n">saved_ftrace_enabled</span> <span class="o">=</span> <span class="n">ftrace_enabled</span><span class="p">;</span>
	<span class="n">ftrace_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">saved_ftrace_enabled</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ftrace_enabled_restore</span><span class="p">(</span><span class="kt">int</span> <span class="n">enabled</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FUNCTION_TRACER</span>
	<span class="n">ftrace_enabled</span> <span class="o">=</span> <span class="n">enabled</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifndef HAVE_ARCH_CALLER_ADDR</span>
<span class="cp"># ifdef CONFIG_FRAME_POINTER</span>
<span class="cp">#  define CALLER_ADDR0 ((unsigned long)__builtin_return_address(0))</span>
<span class="cp">#  define CALLER_ADDR1 ((unsigned long)__builtin_return_address(1))</span>
<span class="cp">#  define CALLER_ADDR2 ((unsigned long)__builtin_return_address(2))</span>
<span class="cp">#  define CALLER_ADDR3 ((unsigned long)__builtin_return_address(3))</span>
<span class="cp">#  define CALLER_ADDR4 ((unsigned long)__builtin_return_address(4))</span>
<span class="cp">#  define CALLER_ADDR5 ((unsigned long)__builtin_return_address(5))</span>
<span class="cp">#  define CALLER_ADDR6 ((unsigned long)__builtin_return_address(6))</span>
<span class="cp"># else</span>
<span class="cp">#  define CALLER_ADDR0 ((unsigned long)__builtin_return_address(0))</span>
<span class="cp">#  define CALLER_ADDR1 0UL</span>
<span class="cp">#  define CALLER_ADDR2 0UL</span>
<span class="cp">#  define CALLER_ADDR3 0UL</span>
<span class="cp">#  define CALLER_ADDR4 0UL</span>
<span class="cp">#  define CALLER_ADDR5 0UL</span>
<span class="cp">#  define CALLER_ADDR6 0UL</span>
<span class="cp"># endif</span>
<span class="cp">#endif </span><span class="cm">/* ifndef HAVE_ARCH_CALLER_ADDR */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_IRQSOFF_TRACER</span>
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">time_hardirqs_on</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span><span class="p">);</span>
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">time_hardirqs_off</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span><span class="p">);</span>
<span class="cp">#else</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">time_hardirqs_on</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">time_hardirqs_off</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PREEMPT_TRACER</span>
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">trace_preempt_on</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span><span class="p">);</span>
  <span class="k">extern</span> <span class="kt">void</span> <span class="n">trace_preempt_off</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a1</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * Use defines instead of static inlines because some arches will make code out</span>
<span class="cm"> * of the CALLER_ADDR, when we really want these to be a real nop.</span>
<span class="cm"> */</span>
<span class="cp"># define trace_preempt_on(a0, a1) do { } while (0)</span>
<span class="cp"># define trace_preempt_off(a0, a1) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FTRACE_MCOUNT_RECORD</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Structure that defines an entry function trace.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ftrace_graph_ent</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">func</span><span class="p">;</span> <span class="cm">/* Current function */</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Structure that defines a return function trace.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ftrace_graph_ret</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">func</span><span class="p">;</span> <span class="cm">/* Current function */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">calltime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">rettime</span><span class="p">;</span>
	<span class="cm">/* Number of functions that overran the depth limit for current task */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overrun</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Type of the callback handlers for tracing function graph*/</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">trace_func_graph_ret_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ftrace_graph_ret</span> <span class="o">*</span><span class="p">);</span> <span class="cm">/* return */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">trace_func_graph_ent_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ftrace_graph_ent</span> <span class="o">*</span><span class="p">);</span> <span class="cm">/* entry */</span>

<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>

<span class="cm">/* for init task */</span>
<span class="cp">#define INIT_FTRACE_GRAPH		.ret_stack = NULL,</span>

<span class="cm">/*</span>
<span class="cm"> * Stack of return addresses for functions</span>
<span class="cm"> * of a thread.</span>
<span class="cm"> * Used in struct thread_info</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ftrace_ret_stack</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">func</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">calltime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">subtime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Primary handler of a function return.</span>
<span class="cm"> * It relays on ftrace_return_to_handler.</span>
<span class="cm"> * Defined in entry_32/64.S</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">return_to_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">ftrace_push_return_trace</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">func</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">depth</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">frame_pointer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Sometimes we don&#39;t want to trace a function with the function</span>
<span class="cm"> * graph tracer but we want them to keep traced by the usual function</span>
<span class="cm"> * tracer if the function graph tracer is not configured.</span>
<span class="cm"> */</span>
<span class="cp">#define __notrace_funcgraph		notrace</span>

<span class="cm">/*</span>
<span class="cm"> * We want to which function is an entrypoint of a hardirq.</span>
<span class="cm"> * That will help us to put a signal on output.</span>
<span class="cm"> */</span>
<span class="cp">#define __irq_entry		 __attribute__((__section__(&quot;.irqentry.text&quot;)))</span>

<span class="cm">/* Limits of hardirq entrypoints */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">__irqentry_text_start</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">__irqentry_text_end</span><span class="p">[];</span>

<span class="cp">#define FTRACE_RETFUNC_DEPTH 50</span>
<span class="cp">#define FTRACE_RETSTACK_ALLOC_SIZE 32</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_ftrace_graph</span><span class="p">(</span><span class="n">trace_func_graph_ret_t</span> <span class="n">retfunc</span><span class="p">,</span>
				<span class="n">trace_func_graph_ent_t</span> <span class="n">entryfunc</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_graph_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* The current handlers in use */</span>
<span class="k">extern</span> <span class="n">trace_func_graph_ret_t</span> <span class="n">ftrace_graph_return</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">trace_func_graph_ent_t</span> <span class="n">ftrace_graph_entry</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">unregister_ftrace_graph</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_graph_init_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_graph_exit_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ftrace_graph_init_idle_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">task_curr_ret_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">curr_ret_stack</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pause_graph_tracing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">tracing_graph_pause</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unpause_graph_tracing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">tracing_graph_pause</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_FUNCTION_GRAPH_TRACER */</span><span class="cp"></span>

<span class="cp">#define __notrace_funcgraph</span>
<span class="cp">#define __irq_entry</span>
<span class="cp">#define INIT_FTRACE_GRAPH</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_graph_init_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_graph_exit_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ftrace_graph_init_idle_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">register_ftrace_graph</span><span class="p">(</span><span class="n">trace_func_graph_ret_t</span> <span class="n">retfunc</span><span class="p">,</span>
			  <span class="n">trace_func_graph_ent_t</span> <span class="n">entryfunc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unregister_ftrace_graph</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">task_curr_ret_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pause_graph_tracing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unpause_graph_tracing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FUNCTION_GRAPH_TRACER */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_TRACING</span>

<span class="cm">/* flags for current-&gt;trace */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TSK_TRACE_FL_TRACE_BIT</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">TSK_TRACE_FL_GRAPH_BIT</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TSK_TRACE_FL_TRACE</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TSK_TRACE_FL_TRACE_BIT</span><span class="p">,</span>
	<span class="n">TSK_TRACE_FL_GRAPH</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TSK_TRACE_FL_GRAPH_BIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_tsk_trace_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TSK_TRACE_FL_TRACE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_tsk_trace_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TSK_TRACE_FL_TRACE_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_tsk_trace_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">&amp;</span> <span class="n">TSK_TRACE_FL_TRACE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_tsk_trace_graph</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TSK_TRACE_FL_GRAPH_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_tsk_trace_graph</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TSK_TRACE_FL_GRAPH_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_tsk_trace_graph</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">trace</span> <span class="o">&amp;</span> <span class="n">TSK_TRACE_FL_GRAPH</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">ftrace_dump_mode</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">enum</span> <span class="n">ftrace_dump_mode</span> <span class="n">ftrace_dump_on_oops</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PREEMPT</span>
<span class="cp">#define INIT_TRACE_RECURSION		.trace_recursion = 0,</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_TRACING */</span><span class="cp"></span>

<span class="cp">#ifndef INIT_TRACE_RECURSION</span>
<span class="cp">#define INIT_TRACE_RECURSION</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FTRACE_SYSCALLS</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arch_syscall_addr</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_FTRACE_SYSCALLS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_FTRACE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
