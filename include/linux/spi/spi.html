<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › spi › spi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>spi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2005 David Brownell</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_SPI_H</span>
<span class="cp">#define __LINUX_SPI_H</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * INTERFACES between SPI master-side drivers and SPI infrastructure.</span>
<span class="cm"> * (There&#39;s no SPI slave support for Linux yet...)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">spi_bus_type</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct spi_device - Master side proxy for an SPI slave device</span>
<span class="cm"> * @dev: Driver model representation of the device.</span>
<span class="cm"> * @master: SPI controller used with the device.</span>
<span class="cm"> * @max_speed_hz: Maximum clock rate to be used with this chip</span>
<span class="cm"> *	(on this board); may be changed by the device&#39;s driver.</span>
<span class="cm"> *	The spi_transfer.speed_hz can override this for each transfer.</span>
<span class="cm"> * @chip_select: Chipselect, distinguishing chips handled by @master.</span>
<span class="cm"> * @mode: The spi mode defines how data is clocked out and in.</span>
<span class="cm"> *	This may be changed by the device&#39;s driver.</span>
<span class="cm"> *	The &quot;active low&quot; default for chipselect mode can be overridden</span>
<span class="cm"> *	(by specifying SPI_CS_HIGH) as can the &quot;MSB first&quot; default for</span>
<span class="cm"> *	each word in a transfer (by specifying SPI_LSB_FIRST).</span>
<span class="cm"> * @bits_per_word: Data transfers involve one or more words; word sizes</span>
<span class="cm"> *	like eight or 12 bits are common.  In-memory wordsizes are</span>
<span class="cm"> *	powers of two bytes (e.g. 20 bit samples use 32 bits).</span>
<span class="cm"> *	This may be changed by the device&#39;s driver, or left at the</span>
<span class="cm"> *	default (0) indicating protocol words are eight bit bytes.</span>
<span class="cm"> *	The spi_transfer.bits_per_word can override this for each transfer.</span>
<span class="cm"> * @irq: Negative, or the number passed to request_irq() to receive</span>
<span class="cm"> *	interrupts from this device.</span>
<span class="cm"> * @controller_state: Controller&#39;s runtime state</span>
<span class="cm"> * @controller_data: Board-specific definitions for controller, such as</span>
<span class="cm"> *	FIFO initialization parameters; from board_info.controller_data</span>
<span class="cm"> * @modalias: Name of the driver to use with this device, or an alias</span>
<span class="cm"> *	for that name.  This appears in the sysfs &quot;modalias&quot; attribute</span>
<span class="cm"> *	for driver coldplugging, and in uevents used for hotplugging</span>
<span class="cm"> *</span>
<span class="cm"> * A @spi_device is used to interchange data between an SPI slave</span>
<span class="cm"> * (usually a discrete chip) and CPU memory.</span>
<span class="cm"> *</span>
<span class="cm"> * In @dev, the platform_data is used to hold information about this</span>
<span class="cm"> * device that&#39;s meaningful to the device&#39;s protocol driver, but not</span>
<span class="cm"> * to its controller.  One example might be an identifier for a chip</span>
<span class="cm"> * variant with slightly different functionality; another might be</span>
<span class="cm"> * information about how this particular board wires the chip&#39;s pins.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_master</span>	<span class="o">*</span><span class="n">master</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">max_speed_hz</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">chip_select</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">mode</span><span class="p">;</span>
<span class="cp">#define	SPI_CPHA	0x01			</span><span class="cm">/* clock phase */</span><span class="cp"></span>
<span class="cp">#define	SPI_CPOL	0x02			</span><span class="cm">/* clock polarity */</span><span class="cp"></span>
<span class="cp">#define	SPI_MODE_0	(0|0)			</span><span class="cm">/* (original MicroWire) */</span><span class="cp"></span>
<span class="cp">#define	SPI_MODE_1	(0|SPI_CPHA)</span>
<span class="cp">#define	SPI_MODE_2	(SPI_CPOL|0)</span>
<span class="cp">#define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)</span>
<span class="cp">#define	SPI_CS_HIGH	0x04			</span><span class="cm">/* chipselect active high? */</span><span class="cp"></span>
<span class="cp">#define	SPI_LSB_FIRST	0x08			</span><span class="cm">/* per-word bits-on-wire */</span><span class="cp"></span>
<span class="cp">#define	SPI_3WIRE	0x10			</span><span class="cm">/* SI/SO signals shared */</span><span class="cp"></span>
<span class="cp">#define	SPI_LOOP	0x20			</span><span class="cm">/* loopback mode */</span><span class="cp"></span>
<span class="cp">#define	SPI_NO_CS	0x40			</span><span class="cm">/* 1 dev/bus, no chipselect */</span><span class="cp"></span>
<span class="cp">#define	SPI_READY	0x80			</span><span class="cm">/* slave pulls low to pause */</span><span class="cp"></span>
	<span class="n">u8</span>			<span class="n">bits_per_word</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">irq</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">controller_state</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">controller_data</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">modalias</span><span class="p">[</span><span class="n">SPI_NAME_SIZE</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * likely need more hooks for more protocol options affecting how</span>
<span class="cm">	 * the controller talks to each chip, like:</span>
<span class="cm">	 *  - memory packing (12 bit samples into low bits, others zeroed)</span>
<span class="cm">	 *  - priority</span>
<span class="cm">	 *  - drop chipselect after each word</span>
<span class="cm">	 *  - chipselect delays</span>
<span class="cm">	 *  - ...</span>
<span class="cm">	 */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="nf">to_spi_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_device</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* most drivers won&#39;t need to care about device refcounting */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="nf">spi_dev_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">spi</span> <span class="o">&amp;&amp;</span> <span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="o">?</span> <span class="n">spi</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spi_dev_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ctldata is for the bus_master driver&#39;s runtime state */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">spi_get_ctldata</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spi_set_ctldata</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">controller_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* device driver data */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spi_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">spi_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">spi_message</span><span class="p">;</span>



<span class="cm">/**</span>
<span class="cm"> * struct spi_driver - Host side &quot;protocol&quot; driver</span>
<span class="cm"> * @id_table: List of SPI devices supported by this driver</span>
<span class="cm"> * @probe: Binds this driver to the spi device.  Drivers can verify</span>
<span class="cm"> *	that the device is actually present, and may need to configure</span>
<span class="cm"> *	characteristics (such as bits_per_word) which weren&#39;t needed for</span>
<span class="cm"> *	the initial configuration done during system setup.</span>
<span class="cm"> * @remove: Unbinds this driver from the spi device</span>
<span class="cm"> * @shutdown: Standard shutdown callback used during system state</span>
<span class="cm"> *	transitions such as powerdown/halt and kexec</span>
<span class="cm"> * @suspend: Standard suspend callback used during system state transitions</span>
<span class="cm"> * @resume: Standard resume callback used during system state transitions</span>
<span class="cm"> * @driver: SPI device drivers should initialize the name and owner</span>
<span class="cm"> *	field of this structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This represents the kind of device driver that uses SPI messages to</span>
<span class="cm"> * interact with the hardware at the other end of a SPI link.  It&#39;s called</span>
<span class="cm"> * a &quot;protocol&quot; driver because it works through messages rather than talking</span>
<span class="cm"> * directly to SPI hardware (which is what the underlying SPI controller</span>
<span class="cm"> * driver does to pass those messages).  These protocols are defined in the</span>
<span class="cm"> * specification for the device(s) supported by the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * As a rule, those device protocols represent the lowest level interface</span>
<span class="cm"> * supported by a driver, and it will support upper level interfaces too.</span>
<span class="cm"> * Examples of such upper levels include frameworks like MTD, networking,</span>
<span class="cm"> * MMC, RTC, filesystem character device nodes, and hardware monitoring.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_driver</span>	<span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">spi_driver</span> <span class="o">*</span><span class="nf">to_spi_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">drv</span> <span class="o">?</span> <span class="n">container_of</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_driver</span><span class="p">,</span> <span class="n">driver</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_driver</span> <span class="o">*</span><span class="n">sdrv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_unregister_driver - reverse effect of spi_register_driver</span>
<span class="cm"> * @sdrv: the driver to unregister</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spi_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_driver</span> <span class="o">*</span><span class="n">sdrv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdrv</span><span class="p">)</span>
		<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdrv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * module_spi_driver() - Helper macro for registering a SPI driver</span>
<span class="cm"> * @__spi_driver: spi_driver struct</span>
<span class="cm"> *</span>
<span class="cm"> * Helper macro for SPI drivers which do not do anything special in module</span>
<span class="cm"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span>
<span class="cm"> * use this macro once, and calling it replaces module_init() and module_exit()</span>
<span class="cm"> */</span>
<span class="cp">#define module_spi_driver(__spi_driver) \</span>
<span class="cp">	module_driver(__spi_driver, spi_register_driver, \</span>
<span class="cp">			spi_unregister_driver)</span>

<span class="cm">/**</span>
<span class="cm"> * struct spi_master - interface to SPI master controller</span>
<span class="cm"> * @dev: device interface to this driver</span>
<span class="cm"> * @list: link with the global spi_master list</span>
<span class="cm"> * @bus_num: board-specific (and often SOC-specific) identifier for a</span>
<span class="cm"> *	given SPI controller.</span>
<span class="cm"> * @num_chipselect: chipselects are used to distinguish individual</span>
<span class="cm"> *	SPI slaves, and are numbered from zero to num_chipselects.</span>
<span class="cm"> *	each slave has a chipselect signal, but it&#39;s common that not</span>
<span class="cm"> *	every chipselect is connected to a slave.</span>
<span class="cm"> * @dma_alignment: SPI controller constraint on DMA buffers alignment.</span>
<span class="cm"> * @mode_bits: flags understood by this controller driver</span>
<span class="cm"> * @flags: other constraints relevant to this driver</span>
<span class="cm"> * @bus_lock_spinlock: spinlock for SPI bus locking</span>
<span class="cm"> * @bus_lock_mutex: mutex for SPI bus locking</span>
<span class="cm"> * @bus_lock_flag: indicates that the SPI bus is locked for exclusive use</span>
<span class="cm"> * @setup: updates the device mode and clocking records used by a</span>
<span class="cm"> *	device&#39;s SPI controller; protocol code may call this.  This</span>
<span class="cm"> *	must fail if an unrecognized or unsupported mode is requested.</span>
<span class="cm"> *	It&#39;s always safe to call this unless transfers are pending on</span>
<span class="cm"> *	the device whose settings are being modified.</span>
<span class="cm"> * @transfer: adds a message to the controller&#39;s transfer queue.</span>
<span class="cm"> * @cleanup: frees controller-specific state</span>
<span class="cm"> * @queued: whether this master is providing an internal message queue</span>
<span class="cm"> * @kworker: thread struct for message pump</span>
<span class="cm"> * @kworker_task: pointer to task for message pump kworker thread</span>
<span class="cm"> * @pump_messages: work struct for scheduling work to the message pump</span>
<span class="cm"> * @queue_lock: spinlock to syncronise access to message queue</span>
<span class="cm"> * @queue: message queue</span>
<span class="cm"> * @cur_msg: the currently in-flight message</span>
<span class="cm"> * @busy: message pump is busy</span>
<span class="cm"> * @running: message pump is running</span>
<span class="cm"> * @rt: whether this queue is set to run as a realtime task</span>
<span class="cm"> * @prepare_transfer_hardware: a message will soon arrive from the queue</span>
<span class="cm"> *	so the subsystem requests the driver to prepare the transfer hardware</span>
<span class="cm"> *	by issuing this call</span>
<span class="cm"> * @transfer_one_message: the subsystem calls the driver to transfer a single</span>
<span class="cm"> *	message while queuing transfers that arrive in the meantime. When the</span>
<span class="cm"> *	driver is finished with this message, it must call</span>
<span class="cm"> *	spi_finalize_current_message() so the subsystem can issue the next</span>
<span class="cm"> *	transfer</span>
<span class="cm"> * @unprepare_transfer_hardware: there are currently no more messages on the</span>
<span class="cm"> *	queue so the subsystem notifies the driver that it may relax the</span>
<span class="cm"> *	hardware by issuing this call</span>
<span class="cm"> *</span>
<span class="cm"> * Each SPI master controller can communicate with one or more @spi_device</span>
<span class="cm"> * children.  These make a small bus, sharing MOSI, MISO and SCK signals</span>
<span class="cm"> * but not chip select signals.  Each device may be configured to use a</span>
<span class="cm"> * different clock rate, since those shared signals are ignored unless</span>
<span class="cm"> * the chip is selected.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver for an SPI controller manages access to those devices through</span>
<span class="cm"> * a queue of spi_message transactions, copying data between CPU memory and</span>
<span class="cm"> * an SPI slave device.  For each such message it queues, it calls the</span>
<span class="cm"> * message&#39;s completion function when the transaction completes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_master</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>	<span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* other than negative (== assign one dynamically), bus_num is fully</span>
<span class="cm">	 * board-specific.  usually that simplifies to being SOC-specific.</span>
<span class="cm">	 * example:  one SOC has three SPI controllers, numbered 0..2,</span>
<span class="cm">	 * and one board&#39;s schematics might show it using SPI-2.  software</span>
<span class="cm">	 * would normally use bus_num=2 for that controller.</span>
<span class="cm">	 */</span>
	<span class="n">s16</span>			<span class="n">bus_num</span><span class="p">;</span>

	<span class="cm">/* chipselects will be integral to many controllers; some others</span>
<span class="cm">	 * might use board-specific GPIOs.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span>			<span class="n">num_chipselect</span><span class="p">;</span>

	<span class="cm">/* some SPI controllers pose alignment requirements on DMAable</span>
<span class="cm">	 * buffers; let protocol drivers know about these requirements.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span>			<span class="n">dma_alignment</span><span class="p">;</span>

	<span class="cm">/* spi_device.mode flags understood by this controller driver */</span>
	<span class="n">u16</span>			<span class="n">mode_bits</span><span class="p">;</span>

	<span class="cm">/* other constraints relevant to this driver */</span>
	<span class="n">u16</span>			<span class="n">flags</span><span class="p">;</span>
<span class="cp">#define SPI_MASTER_HALF_DUPLEX	BIT(0)		</span><span class="cm">/* can&#39;t do full duplex */</span><span class="cp"></span>
<span class="cp">#define SPI_MASTER_NO_RX	BIT(1)		</span><span class="cm">/* can&#39;t do buffer read */</span><span class="cp"></span>
<span class="cp">#define SPI_MASTER_NO_TX	BIT(2)		</span><span class="cm">/* can&#39;t do buffer write */</span><span class="cp"></span>

	<span class="cm">/* lock and mutex for SPI bus locking */</span>
	<span class="n">spinlock_t</span>		<span class="n">bus_lock_spinlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">bus_lock_mutex</span><span class="p">;</span>

	<span class="cm">/* flag indicating that the SPI bus is locked for exclusive use */</span>
	<span class="n">bool</span>			<span class="n">bus_lock_flag</span><span class="p">;</span>

	<span class="cm">/* Setup mode and clock, etc (spi driver may call many times).</span>
<span class="cm">	 *</span>
<span class="cm">	 * IMPORTANT:  this may be called when transfers to another</span>
<span class="cm">	 * device are active.  DO NOT UPDATE SHARED REGISTERS in ways</span>
<span class="cm">	 * which could break those transfers.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>

	<span class="cm">/* bidirectional bulk transfers</span>
<span class="cm">	 *</span>
<span class="cm">	 * + The transfer() method may not sleep; its main role is</span>
<span class="cm">	 *   just to add the message to the queue.</span>
<span class="cm">	 * + For now there&#39;s no remove-from-queue operation, or</span>
<span class="cm">	 *   any other request management</span>
<span class="cm">	 * + To a given spi_device, message queueing is pure fifo</span>
<span class="cm">	 *</span>
<span class="cm">	 * + The master&#39;s main job is to process its message queue,</span>
<span class="cm">	 *   selecting a chip then transferring data</span>
<span class="cm">	 * + If there are multiple spi_device children, the i/o queue</span>
<span class="cm">	 *   arbitration algorithm is unspecified (round robin, fifo,</span>
<span class="cm">	 *   priority, reservations, preemption, etc)</span>
<span class="cm">	 *</span>
<span class="cm">	 * + Chipselect stays active during the entire message</span>
<span class="cm">	 *   (unless modified by spi_transfer.cs_change != 0).</span>
<span class="cm">	 * + The message transfers use clock and SPI mode parameters</span>
<span class="cm">	 *   previously established by setup() for this device</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">transfer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">mesg</span><span class="p">);</span>

	<span class="cm">/* called on release() to free memory provided by spi_master */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * These hooks are for drivers that want to use the generic</span>
<span class="cm">	 * master transfer queueing mechanism. If these are used, the</span>
<span class="cm">	 * transfer() function above must NOT be specified by the driver.</span>
<span class="cm">	 * Over time we expect SPI drivers to be phased over to this API.</span>
<span class="cm">	 */</span>
	<span class="n">bool</span>				<span class="n">queued</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kthread_worker</span>		<span class="n">kworker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>		<span class="o">*</span><span class="n">kworker_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kthread_work</span>		<span class="n">pump_messages</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="n">queue_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_message</span>		<span class="o">*</span><span class="n">cur_msg</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">busy</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">running</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">rt</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare_transfer_hardware</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">transfer_one_message</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">mesg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unprepare_transfer_hardware</span><span class="p">)(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">spi_master_get_devdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spi_master_set_devdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="nf">spi_master_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">master</span> <span class="o">||</span> <span class="o">!</span><span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">master</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spi_master_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* PM calls that need to be issued by the driver */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_master_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_master_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>

<span class="cm">/* Calls the driver make to interact with the message queue */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">spi_get_next_queued_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">spi_finalize_current_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>

<span class="cm">/* the spi driver core manages memory for the spi_master classdev */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span>
<span class="n">spi_alloc_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_register_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">spi_unregister_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">spi_busnum_to_master</span><span class="p">(</span><span class="n">u16</span> <span class="n">busnum</span><span class="p">);</span>

<span class="cm">/*---------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * I/O INTERFACE between SPI controller and protocol drivers</span>
<span class="cm"> *</span>
<span class="cm"> * Protocol drivers use a queue of spi_messages, each transferring data</span>
<span class="cm"> * between the controller and memory buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * The spi_messages themselves consist of a series of read+write transfer</span>
<span class="cm"> * segments.  Those segments always read the same number of bits as they</span>
<span class="cm"> * write; but one or the other is easily ignored by passing a null buffer</span>
<span class="cm"> * pointer.  (This is unlike most types of I/O API, because SPI hardware</span>
<span class="cm"> * is full duplex.)</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:  Allocation of spi_transfer and spi_message memory is entirely</span>
<span class="cm"> * up to the protocol driver, which guarantees the integrity of both (as</span>
<span class="cm"> * well as the data buffers) for as long as the message is queued.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct spi_transfer - a read/write buffer pair</span>
<span class="cm"> * @tx_buf: data to be written (dma-safe memory), or NULL</span>
<span class="cm"> * @rx_buf: data to be read (dma-safe memory), or NULL</span>
<span class="cm"> * @tx_dma: DMA address of tx_buf, if @spi_message.is_dma_mapped</span>
<span class="cm"> * @rx_dma: DMA address of rx_buf, if @spi_message.is_dma_mapped</span>
<span class="cm"> * @len: size of rx and tx buffers (in bytes)</span>
<span class="cm"> * @speed_hz: Select a speed other than the device default for this</span>
<span class="cm"> *      transfer. If 0 the default (from @spi_device) is used.</span>
<span class="cm"> * @bits_per_word: select a bits_per_word other than the device default</span>
<span class="cm"> *      for this transfer. If 0 the default (from @spi_device) is used.</span>
<span class="cm"> * @cs_change: affects chipselect after this transfer completes</span>
<span class="cm"> * @delay_usecs: microseconds to delay after this transfer before</span>
<span class="cm"> *	(optionally) changing the chipselect status, then starting</span>
<span class="cm"> *	the next transfer or completing this @spi_message.</span>
<span class="cm"> * @transfer_list: transfers are sequenced through @spi_message.transfers</span>
<span class="cm"> *</span>
<span class="cm"> * SPI transfers always write the same number of bytes as they read.</span>
<span class="cm"> * Protocol drivers should always provide @rx_buf and/or @tx_buf.</span>
<span class="cm"> * In some cases, they may also want to provide DMA addresses for</span>
<span class="cm"> * the data being transferred; that may reduce overhead, when the</span>
<span class="cm"> * underlying driver uses dma.</span>
<span class="cm"> *</span>
<span class="cm"> * If the transmit buffer is null, zeroes will be shifted out</span>
<span class="cm"> * while filling @rx_buf.  If the receive buffer is null, the data</span>
<span class="cm"> * shifted in will be discarded.  Only &quot;len&quot; bytes shift out (or in).</span>
<span class="cm"> * It&#39;s an error to try to shift out a partial word.  (For example, by</span>
<span class="cm"> * shifting out three bytes with word size of sixteen or twenty bits;</span>
<span class="cm"> * the former uses two bytes per word, the latter uses four bytes.)</span>
<span class="cm"> *</span>
<span class="cm"> * In-memory data values are always in native CPU byte order, translated</span>
<span class="cm"> * from the wire byte order (big-endian except with SPI_LSB_FIRST).  So</span>
<span class="cm"> * for example when bits_per_word is sixteen, buffers are 2N bytes long</span>
<span class="cm"> * (@len = 2N) and hold N sixteen bit words in CPU byte order.</span>
<span class="cm"> *</span>
<span class="cm"> * When the word size of the SPI transfer is not a power-of-two multiple</span>
<span class="cm"> * of eight bits, those in-memory words include extra bits.  In-memory</span>
<span class="cm"> * words are always seen by protocol drivers as right-justified, so the</span>
<span class="cm"> * undefined (rx) or unused (tx) bits are always the most significant bits.</span>
<span class="cm"> *</span>
<span class="cm"> * All SPI transfers start with the relevant chipselect active.  Normally</span>
<span class="cm"> * it stays selected until after the last transfer in a message.  Drivers</span>
<span class="cm"> * can affect the chipselect signal using cs_change.</span>
<span class="cm"> *</span>
<span class="cm"> * (i) If the transfer isn&#39;t the last one in the message, this flag is</span>
<span class="cm"> * used to make the chipselect briefly go inactive in the middle of the</span>
<span class="cm"> * message.  Toggling chipselect in this way may be needed to terminate</span>
<span class="cm"> * a chip command, letting a single spi_message perform all of group of</span>
<span class="cm"> * chip transactions together.</span>
<span class="cm"> *</span>
<span class="cm"> * (ii) When the transfer is the last one in the message, the chip may</span>
<span class="cm"> * stay selected until the next transfer.  On multi-device SPI busses</span>
<span class="cm"> * with nothing blocking messages going to other devices, this is just</span>
<span class="cm"> * a performance hint; starting a message to another device deselects</span>
<span class="cm"> * this one.  But in other cases, this can be used to ensure correctness.</span>
<span class="cm"> * Some devices need protocol transactions to be built from a series of</span>
<span class="cm"> * spi_message submissions, where the content of one message is determined</span>
<span class="cm"> * by the results of previous messages and where the whole transaction</span>
<span class="cm"> * ends when the chipselect goes intactive.</span>
<span class="cm"> *</span>
<span class="cm"> * The code that submits an spi_message (and its spi_transfers)</span>
<span class="cm"> * to the lower layers is responsible for managing its memory.</span>
<span class="cm"> * Zero-initialize every field you don&#39;t set up explicitly, to</span>
<span class="cm"> * insulate against future API updates.  After you submit a message</span>
<span class="cm"> * and its transfers, ignore them until its completion callback.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="p">{</span>
	<span class="cm">/* it&#39;s ok if tx_buf == rx_buf (right?)</span>
<span class="cm">	 * for MicroWire, one buffer must be null</span>
<span class="cm">	 * buffers must work with dma_*map_single() calls, unless</span>
<span class="cm">	 *   spi_message.is_dma_mapped reports a pre-existing mapping</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">void</span>	<span class="o">*</span><span class="n">tx_buf</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">rx_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">len</span><span class="p">;</span>

	<span class="n">dma_addr_t</span>	<span class="n">tx_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">rx_dma</span><span class="p">;</span>

	<span class="kt">unsigned</span>	<span class="n">cs_change</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">bits_per_word</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">delay_usecs</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">speed_hz</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">transfer_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct spi_message - one multi-segment SPI transaction</span>
<span class="cm"> * @transfers: list of transfer segments in this transaction</span>
<span class="cm"> * @spi: SPI device to which the transaction is queued</span>
<span class="cm"> * @is_dma_mapped: if true, the caller provided both dma and cpu virtual</span>
<span class="cm"> *	addresses for each transfer buffer</span>
<span class="cm"> * @complete: called to report transaction completions</span>
<span class="cm"> * @context: the argument to complete() when it&#39;s called</span>
<span class="cm"> * @actual_length: the total number of bytes that were transferred in all</span>
<span class="cm"> *	successful segments</span>
<span class="cm"> * @status: zero for success, else negative errno</span>
<span class="cm"> * @queue: for use by whichever driver currently owns the message</span>
<span class="cm"> * @state: for use by whichever driver currently owns the message</span>
<span class="cm"> *</span>
<span class="cm"> * A @spi_message is used to execute an atomic sequence of data transfers,</span>
<span class="cm"> * each represented by a struct spi_transfer.  The sequence is &quot;atomic&quot;</span>
<span class="cm"> * in the sense that no other spi_message may use that SPI bus until that</span>
<span class="cm"> * sequence completes.  On some systems, many such sequences can execute as</span>
<span class="cm"> * as single programmed DMA transfer.  On all systems, these messages are</span>
<span class="cm"> * queued, and might complete after transactions to other devices.  Messages</span>
<span class="cm"> * sent to a given spi_device are alway executed in FIFO order.</span>
<span class="cm"> *</span>
<span class="cm"> * The code that submits an spi_message (and its spi_transfers)</span>
<span class="cm"> * to the lower layers is responsible for managing its memory.</span>
<span class="cm"> * Zero-initialize every field you don&#39;t set up explicitly, to</span>
<span class="cm"> * insulate against future API updates.  After you submit a message</span>
<span class="cm"> * and its transfers, ignore them until its completion callback.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_message</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">transfers</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">spi_device</span>	<span class="o">*</span><span class="n">spi</span><span class="p">;</span>

	<span class="kt">unsigned</span>		<span class="n">is_dma_mapped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* REVISIT:  we might want a flag affecting the behavior of the</span>
<span class="cm">	 * last transfer ... allowing things like &quot;read 16 bit length L&quot;</span>
<span class="cm">	 * immediately followed by &quot;read L bytes&quot;.  Basically imposing</span>
<span class="cm">	 * a specific message scheduling algorithm.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some controller drivers (message-at-a-time queue processing)</span>
<span class="cm">	 * could provide that as their default scheduling algorithm.  But</span>
<span class="cm">	 * others (with multi-message pipelines) could need a flag to</span>
<span class="cm">	 * tell them about such special cases.</span>
<span class="cm">	 */</span>

	<span class="cm">/* completion is reported through a callback */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">complete</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">actual_length</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="cm">/* for optional use by whatever driver currently owns the</span>
<span class="cm">	 * spi_message ...  between calls to spi_async and then later</span>
<span class="cm">	 * complete(), that&#39;s the spi_master controller driver.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">queue</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">state</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spi_message_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">spi_message_add_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">spi_transfer_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">transfer_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* It&#39;s fine to embed message and transaction structures in other data</span>
<span class="cm"> * structures so long as you don&#39;t free them while they&#39;re in use.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="nf">spi_message_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ntrans</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_message</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">ntrans</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_transfer</span><span class="p">),</span>
			<span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">spi_transfer</span> <span class="o">*</span><span class="p">)(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">transfers</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ntrans</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
			<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">spi_message_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_async_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>

<span class="cm">/*---------------------------------------------------------------------------*/</span>

<span class="cm">/* All these synchronous SPI transfer routines are utilities layered</span>
<span class="cm"> * over the core async transfer primitive.  Here, &quot;synchronous&quot; means</span>
<span class="cm"> * they will sleep uninterruptibly until the async transfer completes.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_sync_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_message</span> <span class="o">*</span><span class="n">message</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_bus_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_bus_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_write - SPI synchronous write</span>
<span class="cm"> * @spi: device to which data will be written</span>
<span class="cm"> * @buf: data buffer</span>
<span class="cm"> * @len: data buffer size</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This writes the buffer and returns zero or a negative error code.</span>
<span class="cm"> * Callable only from contexts that can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">spi_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="n">t</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">tx_buf</span>		<span class="o">=</span> <span class="n">buf</span><span class="p">,</span>
			<span class="p">.</span><span class="n">len</span>		<span class="o">=</span> <span class="n">len</span><span class="p">,</span>
		<span class="p">};</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="n">m</span><span class="p">;</span>

	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">spi_sync</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_read - SPI synchronous read</span>
<span class="cm"> * @spi: device from which data will be read</span>
<span class="cm"> * @buf: data buffer</span>
<span class="cm"> * @len: data buffer size</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This reads the buffer and returns zero or a negative error code.</span>
<span class="cm"> * Callable only from contexts that can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">spi_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span>	<span class="n">t</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">rx_buf</span>		<span class="o">=</span> <span class="n">buf</span><span class="p">,</span>
			<span class="p">.</span><span class="n">len</span>		<span class="o">=</span> <span class="n">len</span><span class="p">,</span>
		<span class="p">};</span>
	<span class="k">struct</span> <span class="n">spi_message</span>	<span class="n">m</span><span class="p">;</span>

	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">spi_sync</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* this copies txbuf and rxbuf data; for small transfers only! */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">spi_write_then_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">txbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n_tx</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">rxbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n_rx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * spi_w8r8 - SPI synchronous 8 bit write followed by 8 bit read</span>
<span class="cm"> * @spi: device with which data will be exchanged</span>
<span class="cm"> * @cmd: command to be written before data is read back</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This returns the (unsigned) eight bit number returned by the</span>
<span class="cm"> * device, or else a negative error code.  Callable only from</span>
<span class="cm"> * contexts that can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">spi_w8r8</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">result</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_write_then_read</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* return negative errno or unsigned value */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * spi_w8r16 - SPI synchronous 8 bit write followed by 16 bit read</span>
<span class="cm"> * @spi: device with which data will be exchanged</span>
<span class="cm"> * @cmd: command to be written before data is read back</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This returns the (unsigned) sixteen bit number returned by the</span>
<span class="cm"> * device, or else a negative error code.  Callable only from</span>
<span class="cm"> * contexts that can sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The number is returned in wire-order, which is at least sometimes</span>
<span class="cm"> * big-endian.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">spi_w8r16</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">result</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">spi_write_then_read</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* return negative errno or unsigned value */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*---------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * INTERFACE between board init code and SPI infrastructure.</span>
<span class="cm"> *</span>
<span class="cm"> * No SPI driver ever sees these SPI device table segments, but</span>
<span class="cm"> * it&#39;s how the SPI core (or adapters that get hotplugged) grows</span>
<span class="cm"> * the driver model tree.</span>
<span class="cm"> *</span>
<span class="cm"> * As a rule, SPI devices can&#39;t be probed.  Instead, board init code</span>
<span class="cm"> * provides a table listing the devices which are present, with enough</span>
<span class="cm"> * information to bind and set up the device&#39;s driver.  There&#39;s basic</span>
<span class="cm"> * support for nonstatic configurations too; enough to handle adding</span>
<span class="cm"> * parport adapters, or microcontrollers acting as USB-to-SPI bridges.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct spi_board_info - board-specific template for a SPI device</span>
<span class="cm"> * @modalias: Initializes spi_device.modalias; identifies the driver.</span>
<span class="cm"> * @platform_data: Initializes spi_device.platform_data; the particular</span>
<span class="cm"> *	data stored there is driver-specific.</span>
<span class="cm"> * @controller_data: Initializes spi_device.controller_data; some</span>
<span class="cm"> *	controllers need hints about hardware setup, e.g. for DMA.</span>
<span class="cm"> * @irq: Initializes spi_device.irq; depends on how the board is wired.</span>
<span class="cm"> * @max_speed_hz: Initializes spi_device.max_speed_hz; based on limits</span>
<span class="cm"> *	from the chip datasheet and board-specific signal quality issues.</span>
<span class="cm"> * @bus_num: Identifies which spi_master parents the spi_device; unused</span>
<span class="cm"> *	by spi_new_device(), and otherwise depends on board wiring.</span>
<span class="cm"> * @chip_select: Initializes spi_device.chip_select; depends on how</span>
<span class="cm"> *	the board is wired.</span>
<span class="cm"> * @mode: Initializes spi_device.mode; based on the chip datasheet, board</span>
<span class="cm"> *	wiring (some devices support both 3WIRE and standard modes), and</span>
<span class="cm"> *	possibly presence of an inverter in the chipselect path.</span>
<span class="cm"> *</span>
<span class="cm"> * When adding new SPI devices to the device tree, these structures serve</span>
<span class="cm"> * as a partial device template.  They hold information which can&#39;t always</span>
<span class="cm"> * be determined by drivers.  Information that probe() can establish (such</span>
<span class="cm"> * as the default transfer wordsize) is not included here.</span>
<span class="cm"> *</span>
<span class="cm"> * These structures are used in two places.  Their primary role is to</span>
<span class="cm"> * be stored in tables of board-specific device descriptors, which are</span>
<span class="cm"> * declared early in board initialization and then used (much later) to</span>
<span class="cm"> * populate a controller&#39;s device tree after the that controller&#39;s driver</span>
<span class="cm"> * initializes.  A secondary (and atypical) role is as a parameter to</span>
<span class="cm"> * spi_new_device() call, which happens after those controller drivers</span>
<span class="cm"> * are active in some dynamic board configuration models.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">spi_board_info</span> <span class="p">{</span>
	<span class="cm">/* the device name and module name are coupled, like platform_bus;</span>
<span class="cm">	 * &quot;modalias&quot; is normally the driver name.</span>
<span class="cm">	 *</span>
<span class="cm">	 * platform_data goes to spi_device.dev.platform_data,</span>
<span class="cm">	 * controller_data goes to spi_device.controller_data,</span>
<span class="cm">	 * irq is copied too</span>
<span class="cm">	 */</span>
	<span class="kt">char</span>		<span class="n">modalias</span><span class="p">[</span><span class="n">SPI_NAME_SIZE</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">void</span>	<span class="o">*</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">controller_data</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* slower signaling on noisy or low voltage boards */</span>
	<span class="n">u32</span>		<span class="n">max_speed_hz</span><span class="p">;</span>


	<span class="cm">/* bus_num is board specific and matches the bus_num of some</span>
<span class="cm">	 * spi_master that will probably be registered later.</span>
<span class="cm">	 *</span>
<span class="cm">	 * chip_select reflects how this chip is wired to that master;</span>
<span class="cm">	 * it&#39;s less than num_chipselect.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span>		<span class="n">bus_num</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">chip_select</span><span class="p">;</span>

	<span class="cm">/* mode becomes spi_device.mode, and is essential for chips</span>
<span class="cm">	 * where the default of SPI_CS_HIGH = 0 is wrong.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span>		<span class="n">mode</span><span class="p">;</span>

	<span class="cm">/* ... may need additional spi_device chip config data here.</span>
<span class="cm">	 * avoid stuff protocol drivers can set; but include stuff</span>
<span class="cm">	 * needed to behave without being bound to a driver:</span>
<span class="cm">	 *  - quirks like clock rate mattering when not selected</span>
<span class="cm">	 */</span>
<span class="p">};</span>

<span class="cp">#ifdef	CONFIG_SPI</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">spi_register_board_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_board_info</span> <span class="k">const</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cm">/* board init code may ignore whether SPI is configured or not */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">spi_register_board_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_board_info</span> <span class="k">const</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/* If you&#39;re hotplugging an adapter with devices (parport, usb, etc)</span>
<span class="cm"> * use spi_new_device() to describe each device.  You can also call</span>
<span class="cm"> * spi_unregister_device() to start making that device vanish, but</span>
<span class="cm"> * normally that would be handled by spi_unregister_master().</span>
<span class="cm"> *</span>
<span class="cm"> * You can also use spi_alloc_device() and spi_add_device() to use a two</span>
<span class="cm"> * stage registration sequence for each spi_device.  This gives the caller</span>
<span class="cm"> * some more control over the spi_device structure before it is registered,</span>
<span class="cm"> * but requires that caller to initialize fields that would otherwise</span>
<span class="cm"> * be defined using the board info.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span>
<span class="n">spi_alloc_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="n">master</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">spi_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span>
<span class="n">spi_new_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_master</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spi_board_info</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">spi_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spi</span><span class="p">)</span>
		<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device_id</span> <span class="o">*</span>
<span class="n">spi_get_device_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_SPI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
