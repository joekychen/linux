<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › vgaarb.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vgaarb.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * The VGA aribiter manages VGA space routing and VGA resource decode to</span>
<span class="cm"> * allow multiple VGA devices to be used in a system in a safe way.</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2005 Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;</span>
<span class="cm"> * (C) Copyright 2007 Paulo R. Zanoni &lt;przanoni@gmail.com&gt;</span>
<span class="cm"> * (C) Copyright 2007, 2009 Tiago Vignatti &lt;vignatti@freedesktop.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="cm"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="cm"> * to deal in the Software without restriction, including without limitation</span>
<span class="cm"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="cm"> * and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="cm"> * Software is furnished to do so, subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice (including the next</span>
<span class="cm"> * paragraph) shall be included in all copies or substantial portions of the</span>
<span class="cm"> * Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="cm"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span>
<span class="cm"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="cm"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="cm"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="cm"> * DEALINGS</span>
<span class="cm"> * IN THE SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef LINUX_VGA_H</span>
<span class="cp">#define LINUX_VGA_H</span>

<span class="cp">#include &lt;video/vga.h&gt;</span>

<span class="cm">/* Legacy VGA regions */</span>
<span class="cp">#define VGA_RSRC_NONE	       0x00</span>
<span class="cp">#define VGA_RSRC_LEGACY_IO     0x01</span>
<span class="cp">#define VGA_RSRC_LEGACY_MEM    0x02</span>
<span class="cp">#define VGA_RSRC_LEGACY_MASK   (VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM)</span>
<span class="cm">/* Non-legacy access */</span>
<span class="cp">#define VGA_RSRC_NORMAL_IO     0x04</span>
<span class="cp">#define VGA_RSRC_NORMAL_MEM    0x08</span>

<span class="cm">/* Passing that instead of a pci_dev to use the system &quot;default&quot;</span>
<span class="cm"> * device, that is the one used by vgacon. Archs will probably</span>
<span class="cm"> * have to provide their own vga_default_device();</span>
<span class="cm"> */</span>
<span class="cp">#define VGA_DEFAULT_DEVICE     (NULL)</span>

<span class="k">struct</span> <span class="n">pci_dev</span><span class="p">;</span>

<span class="cm">/* For use by clients */</span>

<span class="cm">/**</span>
<span class="cm"> *     vga_set_legacy_decoding</span>
<span class="cm"> *</span>
<span class="cm"> *     @pdev: pci device of the VGA card</span>
<span class="cm"> *     @decodes: bit mask of what legacy regions the card decodes</span>
<span class="cm"> *</span>
<span class="cm"> *     Indicates to the arbiter if the card decodes legacy VGA IOs,</span>
<span class="cm"> *     legacy VGA Memory, both, or none. All cards default to both,</span>
<span class="cm"> *     the card driver (fbdev for example) should tell the arbiter</span>
<span class="cm"> *     if it has disabled legacy decoding, so the card can be left</span>
<span class="cm"> *     out of the arbitration process (and can be safe to take</span>
<span class="cm"> *     interrupts at any time.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">vga_set_legacy_decoding</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">decodes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *     vga_get         - acquire &amp; locks VGA resources</span>
<span class="cm"> *</span>
<span class="cm"> *     @pdev: pci device of the VGA card or NULL for the system default</span>
<span class="cm"> *     @rsrc: bit mask of resources to acquire and lock</span>
<span class="cm"> *     @interruptible: blocking should be interruptible by signals ?</span>
<span class="cm"> *</span>
<span class="cm"> *     This function acquires VGA resources for the given</span>
<span class="cm"> *     card and mark those resources locked. If the resource requested</span>
<span class="cm"> *     are &quot;normal&quot; (and not legacy) resources, the arbiter will first check</span>
<span class="cm"> *     wether the card is doing legacy decoding for that type of resource. If</span>
<span class="cm"> *     yes, the lock is &quot;converted&quot; into a legacy resource lock.</span>
<span class="cm"> *     The arbiter will first look for all VGA cards that might conflict</span>
<span class="cm"> *     and disable their IOs and/or Memory access, including VGA forwarding</span>
<span class="cm"> *     on P2P bridges if necessary, so that the requested resources can</span>
<span class="cm"> *     be used. Then, the card is marked as locking these resources and</span>
<span class="cm"> *     the IO and/or Memory accesse are enabled on the card (including</span>
<span class="cm"> *     VGA forwarding on parent P2P bridges if any).</span>
<span class="cm"> *     This function will block if some conflicting card is already locking</span>
<span class="cm"> *     one of the required resources (or any resource on a different bus</span>
<span class="cm"> *     segment, since P2P bridges don&#39;t differenciate VGA memory and IO</span>
<span class="cm"> *     afaik). You can indicate wether this blocking should be interruptible</span>
<span class="cm"> *     by a signal (for userland interface) or not.</span>
<span class="cm"> *     Must not be called at interrupt time or in atomic context.</span>
<span class="cm"> *     If the card already owns the resources, the function succeeds.</span>
<span class="cm"> *     Nested calls are supported (a per-resource counter is maintained)</span>
<span class="cm"> */</span>

<span class="cp">#if defined(CONFIG_VGA_ARB)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vga_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interruptible</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vga_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">interruptible</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *     vga_get_interruptible</span>
<span class="cm"> *</span>
<span class="cm"> *     Shortcut to vga_get</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vga_get_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="n">vga_get</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rsrc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *     vga_get_uninterruptible</span>
<span class="cm"> *</span>
<span class="cm"> *     Shortcut to vga_get</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vga_get_uninterruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="n">vga_get</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rsrc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *     vga_tryget      - try to acquire &amp; lock legacy VGA resources</span>
<span class="cm"> *</span>
<span class="cm"> *     @pdev: pci devivce of VGA card or NULL for system default</span>
<span class="cm"> *     @rsrc: bit mask of resources to acquire and lock</span>
<span class="cm"> *</span>
<span class="cm"> *     This function performs the same operation as vga_get(), but</span>
<span class="cm"> *     will return an error (-EBUSY) instead of blocking if the resources</span>
<span class="cm"> *     are already locked by another card. It can be called in any context</span>
<span class="cm"> */</span>

<span class="cp">#if defined(CONFIG_VGA_ARB)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vga_tryget</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vga_tryget</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *     vga_put         - release lock on legacy VGA resources</span>
<span class="cm"> *</span>
<span class="cm"> *     @pdev: pci device of VGA card or NULL for system default</span>
<span class="cm"> *     @rsrc: but mask of resource to release</span>
<span class="cm"> *</span>
<span class="cm"> *     This function releases resources previously locked by vga_get()</span>
<span class="cm"> *     or vga_tryget(). The resources aren&#39;t disabled right away, so</span>
<span class="cm"> *     that a subsequence vga_get() on the same card will succeed</span>
<span class="cm"> *     immediately. Resources have a counter, so locks are only</span>
<span class="cm"> *     released if the counter reaches 0.</span>
<span class="cm"> */</span>

<span class="cp">#if defined(CONFIG_VGA_ARB)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">vga_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsrc</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define vga_put(pdev, rsrc)</span>
<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> *     vga_default_device</span>
<span class="cm"> *</span>
<span class="cm"> *     This can be defined by the platform. The default implementation</span>
<span class="cm"> *     is rather dumb and will probably only work properly on single</span>
<span class="cm"> *     vga card setups and/or x86 platforms.</span>
<span class="cm"> *</span>
<span class="cm"> *     If your VGA default device is not PCI, you&#39;ll have to return</span>
<span class="cm"> *     NULL here. In this case, I assume it will not conflict with</span>
<span class="cm"> *     any PCI card. If this is not true, I&#39;ll have to define two archs</span>
<span class="cm"> *     hooks for enabling/disabling the VGA default device if that is</span>
<span class="cm"> *     possible. This may be a problem with real _ISA_ VGA cards, in</span>
<span class="cm"> *     addition to a PCI one. I don&#39;t know at this point how to deal</span>
<span class="cm"> *     with that card. Can theirs IOs be disabled at all ? If not, then</span>
<span class="cm"> *     I suppose it&#39;s a matter of having the proper arch hook telling</span>
<span class="cm"> *     us about it, so we basically never allow anybody to succeed a</span>
<span class="cm"> *     vga_get()...</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE</span>
<span class="cp">#ifdef CONFIG_VGA_ARB</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">vga_default_device</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">vga_set_default_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">vga_default_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">};</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vga_set_default_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span> <span class="p">};</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *     vga_conflicts</span>
<span class="cm"> *</span>
<span class="cm"> *     Architectures should define this if they have several</span>
<span class="cm"> *     independent PCI domains that can afford concurrent VGA</span>
<span class="cm"> *     decoding</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __ARCH_HAS_VGA_CONFLICT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vga_conflicts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	vga_client_register</span>
<span class="cm"> *</span>
<span class="cm"> *	@pdev: pci device of the VGA client</span>
<span class="cm"> *	@cookie: client cookie to be used in callbacks</span>
<span class="cm"> *	@irq_set_state: irq state change callback</span>
<span class="cm"> *	@set_vga_decode: vga decode change callback</span>
<span class="cm"> *</span>
<span class="cm"> * 	return value: 0 on success, -1 on failure</span>
<span class="cm"> * 	Register a client with the VGA arbitration logic</span>
<span class="cm"> *</span>
<span class="cm"> *	Clients have two callback mechanisms they can use.</span>
<span class="cm"> *	irq enable/disable callback -</span>
<span class="cm"> *		If a client can&#39;t disable its GPUs VGA resources, then we</span>
<span class="cm"> *		need to be able to ask it to turn off its irqs when we</span>
<span class="cm"> *		turn off its mem and io decoding.</span>
<span class="cm"> *	set_vga_decode</span>
<span class="cm"> *		If a client can disable its GPU VGA resource, it will</span>
<span class="cm"> *		get a callback from this to set the encode/decode state</span>
<span class="cm"> *</span>
<span class="cm"> * Rationale: we cannot disable VGA decode resources unconditionally</span>
<span class="cm"> * some single GPU laptops seem to require ACPI or BIOS access to the</span>
<span class="cm"> * VGA registers to control things like backlights etc.</span>
<span class="cm"> * Hopefully newer multi-GPU laptops do something saner, and desktops</span>
<span class="cm"> * won&#39;t have any special ACPI for this.</span>
<span class="cm"> * They driver will get a callback when VGA arbitration is first used</span>
<span class="cm"> * by userspace since we some older X servers have issues.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_VGA_ARB)</span>
<span class="kt">int</span> <span class="n">vga_client_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_set_state</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">),</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_vga_decode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">));</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vga_client_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_set_state</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">),</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_vga_decode</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* LINUX_VGA_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
