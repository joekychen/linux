<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › pci.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pci.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	pci.h</span>
<span class="cm"> *</span>
<span class="cm"> *	PCI defines and function prototypes</span>
<span class="cm"> *	Copyright 1994, Drew Eckhardt</span>
<span class="cm"> *	Copyright 1997--1999 Martin Mares &lt;mj@ucw.cz&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	For more information, please consult the following manuals (look at</span>
<span class="cm"> *	http://www.pcisig.com/ for how to get them):</span>
<span class="cm"> *</span>
<span class="cm"> *	PCI BIOS Specification</span>
<span class="cm"> *	PCI Local Bus Specification</span>
<span class="cm"> *	PCI to PCI Bridge Specification</span>
<span class="cm"> *	PCI System Design Guide</span>
<span class="cm"> */</span>

<span class="cp">#ifndef LINUX_PCI_H</span>
<span class="cp">#define LINUX_PCI_H</span>

<span class="cp">#include &lt;linux/pci_regs.h&gt;	</span><span class="cm">/* The pci register defines */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The PCI interface treats multi-function devices as independent</span>
<span class="cm"> * devices.  The slot/function address of each device is encoded</span>
<span class="cm"> * in a single byte as follows:</span>
<span class="cm"> *</span>
<span class="cm"> *	7:3 = slot</span>
<span class="cm"> *	2:0 = function</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_DEVFN(slot, func)	((((slot) &amp; 0x1f) &lt;&lt; 3) | ((func) &amp; 0x07))</span>
<span class="cp">#define PCI_SLOT(devfn)		(((devfn) &gt;&gt; 3) &amp; 0x1f)</span>
<span class="cp">#define PCI_FUNC(devfn)		((devfn) &amp; 0x07)</span>

<span class="cm">/* Ioctls for /proc/bus/pci/X/Y nodes. */</span>
<span class="cp">#define PCIIOC_BASE		(&#39;P&#39; &lt;&lt; 24 | &#39;C&#39; &lt;&lt; 16 | &#39;I&#39; &lt;&lt; 8)</span>
<span class="cp">#define PCIIOC_CONTROLLER	(PCIIOC_BASE | 0x00)	</span><span class="cm">/* Get controller for PCI device. */</span><span class="cp"></span>
<span class="cp">#define PCIIOC_MMAP_IS_IO	(PCIIOC_BASE | 0x01)	</span><span class="cm">/* Set mmap state to I/O space. */</span><span class="cp"></span>
<span class="cp">#define PCIIOC_MMAP_IS_MEM	(PCIIOC_BASE | 0x02)	</span><span class="cm">/* Set mmap state to MEM space. */</span><span class="cp"></span>
<span class="cp">#define PCIIOC_WRITE_COMBINE	(PCIIOC_BASE | 0x03)	</span><span class="cm">/* Enable/disable write-combining. */</span><span class="cp"></span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/irqreturn.h&gt;</span>

<span class="cm">/* Include the ID list */</span>
<span class="cp">#include &lt;linux/pci_ids.h&gt;</span>

<span class="cm">/* pci_slot represents a physical slot */</span>
<span class="k">struct</span> <span class="n">pci_slot</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>		<span class="cm">/* The bus this slot is on */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>		<span class="cm">/* node in list of slots on this bus */</span>
	<span class="k">struct</span> <span class="n">hotplug_slot</span> <span class="o">*</span><span class="n">hotplug</span><span class="p">;</span>	<span class="cm">/* Hotplug info (migrate over time) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">number</span><span class="p">;</span>		<span class="cm">/* PCI_SLOT(pci_dev-&gt;devfn) */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">pci_slot_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kobject_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* File state for mmap()s on /proc/bus/pci/X/Y */</span>
<span class="k">enum</span> <span class="n">pci_mmap_state</span> <span class="p">{</span>
	<span class="n">pci_mmap_io</span><span class="p">,</span>
	<span class="n">pci_mmap_mem</span>
<span class="p">};</span>

<span class="cm">/* This defines the direction arg to the DMA mapping routines. */</span>
<span class="cp">#define PCI_DMA_BIDIRECTIONAL	0</span>
<span class="cp">#define PCI_DMA_TODEVICE	1</span>
<span class="cp">#define PCI_DMA_FROMDEVICE	2</span>
<span class="cp">#define PCI_DMA_NONE		3</span>

<span class="cm">/*</span>
<span class="cm"> *  For PCI devices, the region numbers are assigned this way:</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* #0-5: standard PCI resources */</span>
	<span class="n">PCI_STD_RESOURCES</span><span class="p">,</span>
	<span class="n">PCI_STD_RESOURCE_END</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

	<span class="cm">/* #6: expansion ROM resource */</span>
	<span class="n">PCI_ROM_RESOURCE</span><span class="p">,</span>

	<span class="cm">/* device specific resources */</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="n">PCI_IOV_RESOURCES</span><span class="p">,</span>
	<span class="n">PCI_IOV_RESOURCE_END</span> <span class="o">=</span> <span class="n">PCI_IOV_RESOURCES</span> <span class="o">+</span> <span class="n">PCI_SRIOV_NUM_BARS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="cp">#endif</span>

	<span class="cm">/* resources assigned to buses behind the bridge */</span>
<span class="cp">#define PCI_BRIDGE_RESOURCE_NUM 4</span>

	<span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">,</span>
	<span class="n">PCI_BRIDGE_RESOURCE_END</span> <span class="o">=</span> <span class="n">PCI_BRIDGE_RESOURCES</span> <span class="o">+</span>
				  <span class="n">PCI_BRIDGE_RESOURCE_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* total resources associated with a PCI device */</span>
	<span class="n">PCI_NUM_RESOURCES</span><span class="p">,</span>

	<span class="cm">/* preserve this for compatibility */</span>
	<span class="n">DEVICE_COUNT_RESOURCE</span> <span class="o">=</span> <span class="n">PCI_NUM_RESOURCES</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">pci_power_t</span><span class="p">;</span>

<span class="cp">#define PCI_D0		((pci_power_t __force) 0)</span>
<span class="cp">#define PCI_D1		((pci_power_t __force) 1)</span>
<span class="cp">#define PCI_D2		((pci_power_t __force) 2)</span>
<span class="cp">#define PCI_D3hot	((pci_power_t __force) 3)</span>
<span class="cp">#define PCI_D3cold	((pci_power_t __force) 4)</span>
<span class="cp">#define PCI_UNKNOWN	((pci_power_t __force) 5)</span>
<span class="cp">#define PCI_POWER_ERROR	((pci_power_t __force) -1)</span>

<span class="cm">/* Remember to update this when the list above changes! */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pci_power_names</span><span class="p">[];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">pci_power_name</span><span class="p">(</span><span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_power_names</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">state</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#define PCI_PM_D2_DELAY	200</span>
<span class="cp">#define PCI_PM_D3_WAIT	10</span>
<span class="cp">#define PCI_PM_BUS_WAIT	50</span>

<span class="cm">/** The pci_channel state describes connectivity between the CPU and</span>
<span class="cm"> *  the pci device.  If some PCI bus between here and the pci device</span>
<span class="cm"> *  has crashed or locked up, this info is reflected here.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">pci_channel_state_t</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">pci_channel_state</span> <span class="p">{</span>
	<span class="cm">/* I/O channel is in normal state */</span>
	<span class="n">pci_channel_io_normal</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_channel_state_t</span><span class="p">)</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* I/O to channel is blocked */</span>
	<span class="n">pci_channel_io_frozen</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_channel_state_t</span><span class="p">)</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/* PCI card is dead */</span>
	<span class="n">pci_channel_io_perm_failure</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_channel_state_t</span><span class="p">)</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">pcie_reset_state_t</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">pcie_reset_state</span> <span class="p">{</span>
	<span class="cm">/* Reset is NOT asserted (Use to deassert reset) */</span>
	<span class="n">pcie_deassert_reset</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pcie_reset_state_t</span><span class="p">)</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* Use #PERST to reset PCI-E device */</span>
	<span class="n">pcie_warm_reset</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pcie_reset_state_t</span><span class="p">)</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/* Use PCI-E Hot Reset to reset device */</span>
	<span class="n">pcie_hot_reset</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pcie_reset_state_t</span><span class="p">)</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__bitwise</span> <span class="n">pci_dev_flags_t</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">pci_dev_flags</span> <span class="p">{</span>
	<span class="cm">/* INTX_DISABLE in PCI_COMMAND register disables MSI</span>
<span class="cm">	 * generation too.</span>
<span class="cm">	 */</span>
	<span class="n">PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_dev_flags_t</span><span class="p">)</span> <span class="mi">1</span><span class="p">,</span>
	<span class="cm">/* Device configuration is irrevocably lost if disabled into D3 */</span>
	<span class="n">PCI_DEV_FLAGS_NO_D3</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_dev_flags_t</span><span class="p">)</span> <span class="mi">2</span><span class="p">,</span>
	<span class="cm">/* Provide indication device is assigned by a Virtual Machine Manager */</span>
	<span class="n">PCI_DEV_FLAGS_ASSIGNED</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_dev_flags_t</span><span class="p">)</span> <span class="mi">4</span><span class="p">,</span>
	<span class="cm">/* Device causes system crash if in D3 during S3 sleep */</span>
	<span class="n">PCI_DEV_FLAGS_NO_D3_DURING_SLEEP</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_dev_flags_t</span><span class="p">)</span> <span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">pci_irq_reroute_variant</span> <span class="p">{</span>
	<span class="n">INTEL_IRQ_REROUTE_VARIANT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">MAX_IRQ_REROUTE_VARIANTS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__bitwise</span> <span class="n">pci_bus_flags_t</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">pci_bus_flags</span> <span class="p">{</span>
	<span class="n">PCI_BUS_FLAGS_NO_MSI</span>   <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_bus_flags_t</span><span class="p">)</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PCI_BUS_FLAGS_NO_MMRBC</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_bus_flags_t</span><span class="p">)</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Based on the PCI Hotplug Spec, but some values are made up by us */</span>
<span class="k">enum</span> <span class="n">pci_bus_speed</span> <span class="p">{</span>
	<span class="n">PCI_SPEED_33MHz</span>			<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">PCI_SPEED_66MHz</span>			<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">PCI_SPEED_66MHz_PCIX</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">PCI_SPEED_100MHz_PCIX</span>		<span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="n">PCI_SPEED_133MHz_PCIX</span>		<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">PCI_SPEED_66MHz_PCIX_ECC</span>	<span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
	<span class="n">PCI_SPEED_100MHz_PCIX_ECC</span>	<span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
	<span class="n">PCI_SPEED_133MHz_PCIX_ECC</span>	<span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
	<span class="n">PCI_SPEED_66MHz_PCIX_266</span>	<span class="o">=</span> <span class="mh">0x09</span><span class="p">,</span>
	<span class="n">PCI_SPEED_100MHz_PCIX_266</span>	<span class="o">=</span> <span class="mh">0x0a</span><span class="p">,</span>
	<span class="n">PCI_SPEED_133MHz_PCIX_266</span>	<span class="o">=</span> <span class="mh">0x0b</span><span class="p">,</span>
	<span class="n">AGP_UNKNOWN</span>			<span class="o">=</span> <span class="mh">0x0c</span><span class="p">,</span>
	<span class="n">AGP_1X</span>				<span class="o">=</span> <span class="mh">0x0d</span><span class="p">,</span>
	<span class="n">AGP_2X</span>				<span class="o">=</span> <span class="mh">0x0e</span><span class="p">,</span>
	<span class="n">AGP_4X</span>				<span class="o">=</span> <span class="mh">0x0f</span><span class="p">,</span>
	<span class="n">AGP_8X</span>				<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">PCI_SPEED_66MHz_PCIX_533</span>	<span class="o">=</span> <span class="mh">0x11</span><span class="p">,</span>
	<span class="n">PCI_SPEED_100MHz_PCIX_533</span>	<span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>
	<span class="n">PCI_SPEED_133MHz_PCIX_533</span>	<span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
	<span class="n">PCIE_SPEED_2_5GT</span>		<span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="n">PCIE_SPEED_5_0GT</span>		<span class="o">=</span> <span class="mh">0x15</span><span class="p">,</span>
	<span class="n">PCIE_SPEED_8_0GT</span>		<span class="o">=</span> <span class="mh">0x16</span><span class="p">,</span>
	<span class="n">PCI_SPEED_UNKNOWN</span>		<span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pci_cap_saved_data</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">cap_nr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pci_cap_saved_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_cap_saved_data</span> <span class="n">cap</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pcie_link_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_vpd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_sriov</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_ats</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The pci_dev structure is used to describe PCI devices.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bus_list</span><span class="p">;</span>	<span class="cm">/* node in per-bus list */</span>
	<span class="k">struct</span> <span class="n">pci_bus</span>	<span class="o">*</span><span class="n">bus</span><span class="p">;</span>		<span class="cm">/* bus this device is on */</span>
	<span class="k">struct</span> <span class="n">pci_bus</span>	<span class="o">*</span><span class="n">subordinate</span><span class="p">;</span>	<span class="cm">/* bus this device bridges to */</span>

	<span class="kt">void</span>		<span class="o">*</span><span class="n">sysdata</span><span class="p">;</span>	<span class="cm">/* hook for sys-specific extension */</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">procent</span><span class="p">;</span>	<span class="cm">/* device entry in /proc/bus/pci */</span>
	<span class="k">struct</span> <span class="n">pci_slot</span>	<span class="o">*</span><span class="n">slot</span><span class="p">;</span>		<span class="cm">/* Physical slot this device is in */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">devfn</span><span class="p">;</span>		<span class="cm">/* encoded device &amp; function index */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">vendor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">subsystem_vendor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">subsystem_device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">class</span><span class="p">;</span>		<span class="cm">/* 3 bytes: (base,sub,prog-if) */</span>
	<span class="n">u8</span>		<span class="n">revision</span><span class="p">;</span>	<span class="cm">/* PCI revision, low byte of class word */</span>
	<span class="n">u8</span>		<span class="n">hdr_type</span><span class="p">;</span>	<span class="cm">/* PCI header type (`multi&#39; flag masked out) */</span>
	<span class="n">u8</span>		<span class="n">pcie_cap</span><span class="p">;</span>	<span class="cm">/* PCI-E capability offset */</span>
	<span class="n">u8</span>		<span class="n">pcie_type</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>	<span class="cm">/* PCI-E device/port type */</span>
	<span class="n">u8</span>		<span class="n">pcie_mpss</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>	<span class="cm">/* PCI-E Max Payload Size Supported */</span>
	<span class="n">u8</span>		<span class="n">rom_base_reg</span><span class="p">;</span>	<span class="cm">/* which config register controls the ROM */</span>
	<span class="n">u8</span>		<span class="n">pin</span><span class="p">;</span>  		<span class="cm">/* which interrupt pin this device uses */</span>

	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>	<span class="cm">/* which driver has allocated this device */</span>
	<span class="n">u64</span>		<span class="n">dma_mask</span><span class="p">;</span>	<span class="cm">/* Mask of the bits of bus address this</span>
<span class="cm">					   device implements.  Normally this is</span>
<span class="cm">					   0xffffffff.  You only need to change</span>
<span class="cm">					   this if your device has broken DMA</span>
<span class="cm">					   or supports 64-bit transfers.  */</span>

	<span class="k">struct</span> <span class="n">device_dma_parameters</span> <span class="n">dma_parms</span><span class="p">;</span>

	<span class="n">pci_power_t</span>     <span class="n">current_state</span><span class="p">;</span>  <span class="cm">/* Current operating state. In ACPI-speak,</span>
<span class="cm">					   this is D0-D3, D0 being fully functional,</span>
<span class="cm">					   and D3 being off. */</span>
	<span class="kt">int</span>		<span class="n">pm_cap</span><span class="p">;</span>		<span class="cm">/* PM capability offset in the</span>
<span class="cm">					   configuration space */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">pme_support</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>	<span class="cm">/* Bitmask of states from which PME#</span>
<span class="cm">					   can be generated */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">pme_interrupt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">pme_poll</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Poll device&#39;s PME status bit */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">d1_support</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Low power state D1 is supported */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">d2_support</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Low power state D2 is supported */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">no_d1d2</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Only allow D0 and D3 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">mmio_always_on</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* disallow turning off io/mem</span>
<span class="cm">						   decoding during bar sizing */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">wakeup_prepared</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">d3_delay</span><span class="p">;</span>	<span class="cm">/* D3-&gt;D0 transition time in ms */</span>

<span class="cp">#ifdef CONFIG_PCIEASPM</span>
	<span class="k">struct</span> <span class="n">pcie_link_state</span>	<span class="o">*</span><span class="n">link_state</span><span class="p">;</span>	<span class="cm">/* ASPM link state. */</span>
<span class="cp">#endif</span>

	<span class="n">pci_channel_state_t</span> <span class="n">error_state</span><span class="p">;</span>	<span class="cm">/* current connectivity state */</span>
	<span class="k">struct</span>	<span class="n">device</span>	<span class="n">dev</span><span class="p">;</span>		<span class="cm">/* Generic device interface */</span>

	<span class="kt">int</span>		<span class="n">cfg_size</span><span class="p">;</span>	<span class="cm">/* Size of configuration space */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Instead of touching interrupt line and base address registers</span>
<span class="cm">	 * directly, use the values stored here. They might be different!</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">resource</span><span class="p">[</span><span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">];</span> <span class="cm">/* I/O and memory regions + expansion ROMs */</span>

	<span class="cm">/* These fields are used by common fixups */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">transparent</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Transparent PCI bridge */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">multifunction</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span><span class="cm">/* Part of multi-function device */</span>
	<span class="cm">/* keep track of device state */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">is_added</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">is_busmaster</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* device is busmaster */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">no_msi</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* device may not use msi */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">block_cfg_access</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* config space access is blocked */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">broken_parity_status</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Device generates false positive parity */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">irq_reroute_variant</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* device needs IRQ rerouting variant */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> 	<span class="n">msi_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">msix_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">ari_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* ARI forwarding */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">is_managed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">is_pcie</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Obsolete. Will be removed.</span>
<span class="cm">					   Use pci_is_pcie() instead */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">needs_freset</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Dev requires fundamental reset */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">state_saved</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">is_physfn</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">is_virtfn</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">reset_fn</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">is_hotplug_bridge</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">__aer_firmware_first_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">__aer_firmware_first</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">pci_dev_flags_t</span> <span class="n">dev_flags</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">enable_cnt</span><span class="p">;</span>	<span class="cm">/* pci_enable_device has been called */</span>

	<span class="n">u32</span>		<span class="n">saved_config_space</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="cm">/* config space saved at suspend time */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">saved_cap_space</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">rom_attr</span><span class="p">;</span> <span class="cm">/* attribute descriptor for sysfs ROM entry */</span>
	<span class="kt">int</span> <span class="n">rom_attr_enabled</span><span class="p">;</span>		<span class="cm">/* has display of the rom attribute been enabled? */</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">res_attr</span><span class="p">[</span><span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">];</span> <span class="cm">/* sysfs file for resources */</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">res_attr_wc</span><span class="p">[</span><span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">];</span> <span class="cm">/* sysfs file for WC mapping of resources */</span>
<span class="cp">#ifdef CONFIG_PCI_MSI</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">msi_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">msi_kset</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">pci_vpd</span> <span class="o">*</span><span class="n">vpd</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI_ATS</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_sriov</span> <span class="o">*</span><span class="n">sriov</span><span class="p">;</span>	<span class="cm">/* SR-IOV capability related */</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">physfn</span><span class="p">;</span>	<span class="cm">/* the PF this VF is associated with */</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">pci_ats</span>	<span class="o">*</span><span class="n">ats</span><span class="p">;</span>	<span class="cm">/* Address Translation Service */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">pci_physfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI_IOV</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">is_virtfn</span><span class="p">)</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">physfn</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">alloc_pci_dev</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define pci_dev_b(n) list_entry(n, struct pci_dev, bus_list)</span>
<span class="cp">#define	to_pci_dev(n) container_of(n, struct pci_dev, dev)</span>
<span class="cp">#define for_each_pci_dev(d) while ((d = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, d)) != NULL)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_channel_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">error_state</span> <span class="o">!=</span> <span class="n">pci_channel_io_normal</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pci_host_bridge_window</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>		<span class="cm">/* host bridge aperture (CPU address) */</span>
	<span class="n">resource_size_t</span> <span class="n">offset</span><span class="p">;</span>		<span class="cm">/* bus address + offset = CPU address */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pci_host_bridge</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>		<span class="cm">/* root bus */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">windows</span><span class="p">;</span>	<span class="cm">/* pci_host_bridge_windows */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_host_bridge</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">release_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	to_pci_host_bridge(n) container_of(n, struct pci_host_bridge, dev)</span>
<span class="kt">void</span> <span class="n">pci_set_host_bridge_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_host_bridge</span> <span class="o">*</span><span class="n">bridge</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_host_bridge</span> <span class="o">*</span><span class="p">),</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">release_data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The first PCI_BRIDGE_RESOURCE_NUM PCI bus resources (those that correspond</span>
<span class="cm"> * to P2P or CardBus bridge windows) go in a table.  Additional ones (for</span>
<span class="cm"> * buses below host bridges or subtractive decode bridges) go in the list.</span>
<span class="cm"> * Use pci_bus_for_each_resource() to iterate through all the resources.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * PCI_SUBTRACTIVE_DECODE means the bridge forwards the window implicitly</span>
<span class="cm"> * and there&#39;s no way to program the bridge with the details of the window.</span>
<span class="cm"> * This does not apply to ACPI _CRS windows, even with the _DEC subtractive-</span>
<span class="cm"> * decode bit set, because they are explicit and can be programmed with _SRS.</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_SUBTRACTIVE_DECODE	0x1</span>

<span class="k">struct</span> <span class="n">pci_bus_resource</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PCI_REGION_FLAG_MASK	0x0fU	</span><span class="cm">/* These bits of resource flags tell us the PCI region flags */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">pci_bus</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>		<span class="cm">/* node in list of buses */</span>
	<span class="k">struct</span> <span class="n">pci_bus</span>	<span class="o">*</span><span class="n">parent</span><span class="p">;</span>	<span class="cm">/* parent bus this bridge is on */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>	<span class="cm">/* list of child buses */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">devices</span><span class="p">;</span>	<span class="cm">/* list of devices on this bus */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">self</span><span class="p">;</span>		<span class="cm">/* bridge device as seen by parent */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">slots</span><span class="p">;</span>		<span class="cm">/* list of slots on this bus */</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">resource</span><span class="p">[</span><span class="n">PCI_BRIDGE_RESOURCE_NUM</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">resources</span><span class="p">;</span>	<span class="cm">/* address space routed to this bus */</span>

	<span class="k">struct</span> <span class="n">pci_ops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>		<span class="cm">/* configuration access functions */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">sysdata</span><span class="p">;</span>	<span class="cm">/* hook for sys-specific extension */</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">procdir</span><span class="p">;</span>	<span class="cm">/* directory entry in /proc/bus/pci */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">number</span><span class="p">;</span>		<span class="cm">/* bus number */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">primary</span><span class="p">;</span>	<span class="cm">/* number of primary bridge */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">secondary</span><span class="p">;</span>	<span class="cm">/* number of secondary bridge */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">subordinate</span><span class="p">;</span>	<span class="cm">/* max number of subordinate buses */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">max_bus_speed</span><span class="p">;</span>	<span class="cm">/* enum pci_bus_speed */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">cur_bus_speed</span><span class="p">;</span>	<span class="cm">/* enum pci_bus_speed */</span>

	<span class="kt">char</span>		<span class="n">name</span><span class="p">[</span><span class="mi">48</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">bridge_ctl</span><span class="p">;</span>	<span class="cm">/* manage NO_ISA/FBB/et al behaviors */</span>
	<span class="n">pci_bus_flags_t</span> <span class="n">bus_flags</span><span class="p">;</span>	<span class="cm">/* Inherited by child busses */</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">bridge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span>	<span class="o">*</span><span class="n">legacy_io</span><span class="p">;</span> <span class="cm">/* legacy I/O for this bus */</span>
	<span class="k">struct</span> <span class="n">bin_attribute</span>	<span class="o">*</span><span class="n">legacy_mem</span><span class="p">;</span> <span class="cm">/* legacy mem */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">is_added</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define pci_bus_b(n)	list_entry(n, struct pci_bus, node)</span>
<span class="cp">#define to_pci_bus(n)	container_of(n, struct pci_bus, dev)</span>

<span class="cm">/*</span>
<span class="cm"> * Returns true if the pci bus is root (behind host-pci bridge),</span>
<span class="cm"> * false otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pci_is_root_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pbus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">pbus</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI_MSI</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pci_dev_msi_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">msi_enabled</span> <span class="o">||</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">msix_enabled</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pci_dev_msi_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Error values that may be returned by PCI functions.</span>
<span class="cm"> */</span>
<span class="cp">#define PCIBIOS_SUCCESSFUL		0x00</span>
<span class="cp">#define PCIBIOS_FUNC_NOT_SUPPORTED	0x81</span>
<span class="cp">#define PCIBIOS_BAD_VENDOR_ID		0x83</span>
<span class="cp">#define PCIBIOS_DEVICE_NOT_FOUND	0x86</span>
<span class="cp">#define PCIBIOS_BAD_REGISTER_NUMBER	0x87</span>
<span class="cp">#define PCIBIOS_SET_FAILED		0x88</span>
<span class="cp">#define PCIBIOS_BUFFER_TOO_SMALL	0x89</span>

<span class="cm">/* Low-level architecture-dependent routines */</span>

<span class="k">struct</span> <span class="n">pci_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ACPI needs to be able to access PCI config space before we&#39;ve done a</span>
<span class="cm"> * PCI bus scan and created pci_bus structures.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">raw_pci_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">raw_pci_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pci_bus_region</span> <span class="p">{</span>
	<span class="n">resource_size_t</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">end</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pci_dynids</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>            <span class="cm">/* protects list, index */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>      <span class="cm">/* for IDs added at runtime */</span>
<span class="p">};</span>

<span class="cm">/* ---------------------------------------------------------------- */</span>
<span class="cm">/** PCI Error Recovery System (PCI-ERS).  If a PCI device driver provides</span>
<span class="cm"> *  a set of callbacks in struct pci_error_handlers, then that device driver</span>
<span class="cm"> *  will be notified of PCI bus errors, and will be driven to recovery</span>
<span class="cm"> *  when an error occurs.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">pci_ers_result_t</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">pci_ers_result</span> <span class="p">{</span>
	<span class="cm">/* no result/none/not supported in device driver */</span>
	<span class="n">PCI_ERS_RESULT_NONE</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_ers_result_t</span><span class="p">)</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* Device driver can recover without slot reset */</span>
	<span class="n">PCI_ERS_RESULT_CAN_RECOVER</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_ers_result_t</span><span class="p">)</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/* Device driver wants slot to be reset. */</span>
	<span class="n">PCI_ERS_RESULT_NEED_RESET</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_ers_result_t</span><span class="p">)</span> <span class="mi">3</span><span class="p">,</span>

	<span class="cm">/* Device has completely failed, is unrecoverable */</span>
	<span class="n">PCI_ERS_RESULT_DISCONNECT</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_ers_result_t</span><span class="p">)</span> <span class="mi">4</span><span class="p">,</span>

	<span class="cm">/* Device driver is fully recovered and operational */</span>
	<span class="n">PCI_ERS_RESULT_RECOVERED</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">pci_ers_result_t</span><span class="p">)</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* PCI bus error event callbacks */</span>
<span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="p">{</span>
	<span class="cm">/* PCI bus error detected on this device */</span>
	<span class="n">pci_ers_result_t</span> <span class="p">(</span><span class="o">*</span><span class="n">error_detected</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="k">enum</span> <span class="n">pci_channel_state</span> <span class="n">error</span><span class="p">);</span>

	<span class="cm">/* MMIO has been re-enabled, but not DMA */</span>
	<span class="n">pci_ers_result_t</span> <span class="p">(</span><span class="o">*</span><span class="n">mmio_enabled</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* PCI Express link has been reset */</span>
	<span class="n">pci_ers_result_t</span> <span class="p">(</span><span class="o">*</span><span class="n">link_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* PCI slot has been reset */</span>
	<span class="n">pci_ers_result_t</span> <span class="p">(</span><span class="o">*</span><span class="n">slot_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Device driver may resume normal operations */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* ---------------------------------------------------------------- */</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pci_driver</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>	<span class="cm">/* must be non-NULL for probe to be called */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>	<span class="cm">/* New device inserted */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Device removed (NULL if not a hot-plug capable driver) */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>	<span class="cm">/* Device suspended */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">suspend_late</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">resume_early</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>	                <span class="cm">/* Device woken up */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="o">*</span><span class="n">err_handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_driver</span>	<span class="n">driver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dynids</span> <span class="n">dynids</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	to_pci_driver(drv) container_of(drv, struct pci_driver, driver)</span>

<span class="cm">/**</span>
<span class="cm"> * DEFINE_PCI_DEVICE_TABLE - macro used to describe a pci device table</span>
<span class="cm"> * @_table: device table name</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct pci_device_id array (a device table)</span>
<span class="cm"> * in a generic manner.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFINE_PCI_DEVICE_TABLE(_table) \</span>
<span class="cp">	const struct pci_device_id _table[] __devinitconst</span>

<span class="cm">/**</span>
<span class="cm"> * PCI_DEVICE - macro used to describe a specific pci device</span>
<span class="cm"> * @vend: the 16 bit PCI Vendor ID</span>
<span class="cm"> * @dev: the 16 bit PCI Device ID</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct pci_device_id that matches a</span>
<span class="cm"> * specific device.  The subvendor and subdevice fields will be set to</span>
<span class="cm"> * PCI_ANY_ID.</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_DEVICE(vend,dev) \</span>
<span class="cp">	.vendor = (vend), .device = (dev), \</span>
<span class="cp">	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID</span>

<span class="cm">/**</span>
<span class="cm"> * PCI_DEVICE_CLASS - macro used to describe a specific pci device class</span>
<span class="cm"> * @dev_class: the class, subclass, prog-if triple for this device</span>
<span class="cm"> * @dev_class_mask: the class mask for this device</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct pci_device_id that matches a</span>
<span class="cm"> * specific PCI class.  The vendor, device, subvendor, and subdevice</span>
<span class="cm"> * fields will be set to PCI_ANY_ID.</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_DEVICE_CLASS(dev_class,dev_class_mask) \</span>
<span class="cp">	.class = (dev_class), .class_mask = (dev_class_mask), \</span>
<span class="cp">	.vendor = PCI_ANY_ID, .device = PCI_ANY_ID, \</span>
<span class="cp">	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID</span>

<span class="cm">/**</span>
<span class="cm"> * PCI_VDEVICE - macro used to describe a specific pci device in short form</span>
<span class="cm"> * @vendor: the vendor name</span>
<span class="cm"> * @device: the 16 bit PCI Device ID</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct pci_device_id that matches a</span>
<span class="cm"> * specific PCI device.  The subvendor, and subdevice fields will be set</span>
<span class="cm"> * to PCI_ANY_ID. The macro allows the next field to follow as the device</span>
<span class="cm"> * private data.</span>
<span class="cm"> */</span>

<span class="cp">#define PCI_VDEVICE(vendor, device)		\</span>
<span class="cp">	PCI_VENDOR_ID_##vendor, (device),	\</span>
<span class="cp">	PCI_ANY_ID, PCI_ANY_ID, 0, 0</span>

<span class="cm">/* these external functions are only available when PCI support is enabled */</span>
<span class="cp">#ifdef CONFIG_PCI</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pcie_bus_configure_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">u8</span> <span class="n">smpss</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">pcie_bus_config_types</span> <span class="p">{</span>
	<span class="n">PCIE_BUS_TUNE_OFF</span><span class="p">,</span>
	<span class="n">PCIE_BUS_SAFE</span><span class="p">,</span>
	<span class="n">PCIE_BUS_PERFORMANCE</span><span class="p">,</span>
	<span class="n">PCIE_BUS_PEER2PEER</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">enum</span> <span class="n">pcie_bus_config_types</span> <span class="n">pcie_bus_config</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">pci_bus_type</span><span class="p">;</span>

<span class="cm">/* Do NOT directly access these two variables, unless you are arch specific pci</span>
<span class="cm"> * code, or pci core code. */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">pci_root_buses</span><span class="p">;</span>	<span class="cm">/* list of all known PCI buses */</span>
<span class="cm">/* Some device drivers need know if pci is initiated */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">no_pci_devices</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">pcibios_fixup_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pcibios_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">pcibios_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>

<span class="cm">/* Used only when drivers/pci/setup.c is used */</span>
<span class="n">resource_size_t</span> <span class="n">pcibios_align_resource</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="p">,</span>
				<span class="n">resource_size_t</span><span class="p">,</span>
				<span class="n">resource_size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcibios_update_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>

<span class="cm">/* Weak but can be overriden by arch */</span>
<span class="kt">void</span> <span class="n">pci_fixup_cardbus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Generic PCI functions used internally */</span>

<span class="kt">void</span> <span class="n">pcibios_resource_to_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_bus_region</span> <span class="o">*</span><span class="n">region</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcibios_bus_to_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">pci_bus_region</span> <span class="o">*</span><span class="n">region</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcibios_scan_specific_bus</span><span class="p">(</span><span class="kt">int</span> <span class="n">busn</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pci_find_bus</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">busnr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_bus_add_devices</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pci_scan_bus_parented</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sysdata</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pci_scan_bus</span><span class="p">(</span><span class="kt">int</span> <span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sysdata</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pci_create_root_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sysdata</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">resources</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span> <span class="n">__devinit</span> <span class="n">pci_scan_root_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sysdata</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">resources</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pci_add_new_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">busnr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcie_update_link_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="n">u16</span> <span class="n">link_status</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_slot</span> <span class="o">*</span><span class="n">pci_create_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_nr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">hotplug_slot</span> <span class="o">*</span><span class="n">hotplug</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_destroy_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_renumber_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot_nr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_scan_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_scan_single_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_scan_child_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_bus_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_read_bridge_bases</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">pci_find_parent_resource</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">pci_swizzle_interrupt_pin</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pin</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_get_interrupt_pin</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">**</span><span class="n">bridge</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">pci_common_swizzle</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pinp</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_dev_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_remove_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__pci_remove_bus_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_stop_and_remove_bus_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_stop_bus_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_setup_cardbus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_sort_breadthfirst</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#define dev_is_pci(d) ((d)-&gt;bus == &amp;pci_bus_type)</span>
<span class="cp">#define dev_is_pf(d) ((dev_is_pci(d) ? to_pci_dev(d)-&gt;is_physfn : false))</span>
<span class="cp">#define dev_num_vf(d) ((dev_is_pci(d) ? pci_num_vf(to_pci_dev(d)) : 0))</span>

<span class="cm">/* Generic PCI functions exported to card drivers */</span>

<span class="k">enum</span> <span class="n">pci_lost_interrupt_reason</span> <span class="p">{</span>
	<span class="n">PCI_LOST_IRQ_NO_INFORMATION</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PCI_LOST_IRQ_DISABLE_MSI</span><span class="p">,</span>
	<span class="n">PCI_LOST_IRQ_DISABLE_MSIX</span><span class="p">,</span>
	<span class="n">PCI_LOST_IRQ_DISABLE_ACPI</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="n">pci_lost_interrupt_reason</span> <span class="n">pci_lost_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_find_next_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_bus_find_ext_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ht_cap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_find_next_ht_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ht_cap</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pci_find_next_bus</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_device</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vendor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_subsys</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vendor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ss_vendor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ss_device</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_domain_bus_and_slot</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">pci_get_bus_and_slot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
						   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_get_domain_bus_and_slot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bus</span><span class="p">,</span> <span class="n">devfn</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_class</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_dev_present</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ids</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pci_bus_read_config_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_bus_read_config_word</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_bus_read_config_dword</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_bus_write_config_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_bus_write_config_word</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_bus_write_config_dword</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">pci_bus_set_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_read_config_byte</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_bus_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_read_config_word</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_bus_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_read_config_dword</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
					<span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_bus_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_write_config_byte</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_bus_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_write_config_word</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_bus_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_write_config_dword</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">where</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_bus_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_enable_device_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_reenable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pcim_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcim_pin_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_is_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">enable_cnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_is_managed</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">is_managed</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">pci_disable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcibios_max_latency</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">pci_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_clear_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pci_set_pcie_reset_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pcie_reset_state</span> <span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_set_cacheline_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#define HAVE_PCI_SET_MWI</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_set_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_try_set_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_clear_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_intx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pci_intx_mask_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pci_check_and_mask_intx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pci_check_and_unmask_intx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_msi_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_set_dma_max_seg_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_set_dma_seg_boundary</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcix_get_max_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcix_get_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcix_set_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mmrbc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcie_get_readrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcie_set_readrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcie_get_mps</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcie_set_mps</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mps</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__pci_reset_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__pci_reset_function_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_reset_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_update_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resno</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_assign_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_reassign_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">add_size</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">align</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_select_bars</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* ROM control related routines */</span>
<span class="kt">int</span> <span class="n">pci_enable_rom</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_disable_rom</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__iomem</span> <span class="n">__must_check</span> <span class="o">*</span><span class="n">pci_map_rom</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_unmap_rom</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rom</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">pci_get_rom_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">rom</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* Power management related routines */</span>
<span class="kt">int</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_restore_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="o">*</span><span class="n">pci_store_saved_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_load_saved_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_load_and_free_saved_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">pci_saved_state</span> <span class="o">**</span><span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__pci_complete_power_transition</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">);</span>
<span class="n">pci_power_t</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pci_pme_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_pme_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__pci_enable_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
<span class="n">pci_power_t</span> <span class="n">pci_target_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_prepare_to_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_back_from_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pci_dev_run_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pci_check_pme_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_pme_wakeup_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_enable_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">,</span>
				  <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pci_enable_wake</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define PCI_EXP_IDO_REQUEST	(1&lt;&lt;0)</span>
<span class="cp">#define PCI_EXP_IDO_COMPLETION	(1&lt;&lt;1)</span>
<span class="kt">void</span> <span class="n">pci_enable_ido</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_disable_ido</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">pci_obff_signal_type</span> <span class="p">{</span>
	<span class="n">PCI_EXP_OBFF_SIGNAL_L0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PCI_EXP_OBFF_SIGNAL_ALWAYS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">pci_enable_obff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pci_obff_signal_type</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_disable_obff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="n">bool</span> <span class="n">pci_ltr_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_enable_ltr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_disable_ltr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_set_ltr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">snoop_lat_ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nosnoop_lat_ns</span><span class="p">);</span>

<span class="cm">/* For use by arch with custom probe code */</span>
<span class="kt">void</span> <span class="n">set_pcie_port_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_pcie_hotplug_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="cm">/* Functions for PCI Hotplug drivers to use */</span>
<span class="kt">int</span> <span class="n">pci_bus_find_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HOTPLUG</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_rescan_bus_bridge_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pci_rescan_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Vital product data routines */</span>
<span class="kt">ssize_t</span> <span class="n">pci_read_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">pci_write_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_vpd_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* Helper functions for low-level code (drivers/pci/setup-[bus,res].c) */</span>
<span class="n">resource_size_t</span> <span class="n">pcibios_retrieve_fw_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_bus_assign_resources</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_bus_size_bridges</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_claim_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_assign_unassigned_resources</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_assign_unassigned_bridge_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">bridge</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pdev_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_enable_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_fixup_irqs</span><span class="p">(</span><span class="n">u8</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">),</span>
		    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">));</span>
<span class="cp">#define HAVE_PCI_REQ_REGIONS	2</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_request_regions_exclusive</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_release_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_request_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_request_region_exclusive</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_release_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_request_selected_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_request_selected_regions_exclusive</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* drivers/pci/bus.c */</span>
<span class="kt">void</span> <span class="n">pci_add_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">resources</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_add_resource_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">resources</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			     <span class="n">resource_size_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_free_resource_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">resources</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_bus_add_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">pci_bus_resource_n</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_bus_remove_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cp">#define pci_bus_for_each_resource(bus, res, i)				\</span>
<span class="cp">	for (i = 0;							\</span>
<span class="cp">	    (res = pci_bus_resource_n(bus, i)) || i &lt; PCI_BRIDGE_RESOURCE_NUM; \</span>
<span class="cp">	     i++)</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">pci_bus_alloc_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">size</span><span class="p">,</span>
			<span class="n">resource_size_t</span> <span class="n">align</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="n">min</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type_mask</span><span class="p">,</span>
			<span class="n">resource_size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">alignf</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
						  <span class="k">const</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="p">,</span>
						  <span class="n">resource_size_t</span><span class="p">,</span>
						  <span class="n">resource_size_t</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">alignf_data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_enable_bridges</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cm">/* Proper probing supporting hot-pluggable devices */</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">__pci_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * pci_register_driver must be a macro so that KBUILD_MODNAME can be expanded</span>
<span class="cm"> */</span>
<span class="cp">#define pci_register_driver(driver)		\</span>
<span class="cp">	__pci_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span>

<span class="kt">void</span> <span class="n">pci_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * module_pci_driver() - Helper macro for registering a PCI driver</span>
<span class="cm"> * @__pci_driver: pci_driver struct</span>
<span class="cm"> *</span>
<span class="cm"> * Helper macro for PCI drivers which do not do anything special in module</span>
<span class="cm"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span>
<span class="cm"> * use this macro once, and calling it replaces module_init() and module_exit()</span>
<span class="cm"> */</span>
<span class="cp">#define module_pci_driver(__pci_driver) \</span>
<span class="cp">	module_driver(__pci_driver, pci_register_driver, \</span>
<span class="cp">		       pci_unregister_driver)</span>

<span class="kt">void</span> <span class="n">pci_stop_and_remove_behind_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">pci_dev_driver</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_add_dynid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vendor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subvendor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevice</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class_mask</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">driver_data</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">pci_match_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ids</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_scan_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">pass</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">pci_walk_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">top</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
		  <span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_cfg_space_size_ext</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pci_cfg_space_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pci_bus_max_busnr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pci_setup_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cp">#define PCI_VGA_STATE_CHANGE_BRIDGE (1 &lt;&lt; 0)</span>
<span class="cp">#define PCI_VGA_STATE_CHANGE_DECODES (1 &lt;&lt; 1)</span>

<span class="kt">int</span> <span class="n">pci_set_vga_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">decode</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command_bits</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>
<span class="cm">/* kmem_cache style wrapper around pci_alloc_consistent() */</span>

<span class="cp">#include &lt;linux/pci-dma.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>

<span class="cp">#define	pci_pool dma_pool</span>
<span class="cp">#define pci_pool_create(name, pdev, size, align, allocation) \</span>
<span class="cp">		dma_pool_create(name, &amp;pdev-&gt;dev, size, align, allocation)</span>
<span class="cp">#define	pci_pool_destroy(pool) dma_pool_destroy(pool)</span>
<span class="cp">#define	pci_pool_alloc(pool, flags, handle) dma_pool_alloc(pool, flags, handle)</span>
<span class="cp">#define	pci_pool_free(pool, vaddr, addr) dma_pool_free(pool, vaddr, addr)</span>

<span class="k">enum</span> <span class="n">pci_dma_burst_strategy</span> <span class="p">{</span>
	<span class="n">PCI_DMA_BURST_INFINITY</span><span class="p">,</span>	<span class="cm">/* make bursts as large as possible,</span>
<span class="cm">				   strategy_parameter is N/A */</span>
	<span class="n">PCI_DMA_BURST_BOUNDARY</span><span class="p">,</span> <span class="cm">/* disconnect at every strategy_parameter</span>
<span class="cm">				   byte boundaries */</span>
	<span class="n">PCI_DMA_BURST_MULTIPLE</span><span class="p">,</span> <span class="cm">/* disconnect at some multiple of</span>
<span class="cm">				   strategy_parameter byte boundaries */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">msix_entry</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">vector</span><span class="p">;</span>	<span class="cm">/* kernel uses to write allocated vector */</span>
	<span class="n">u16</span>	<span class="n">entry</span><span class="p">;</span>	<span class="cm">/* driver uses to specify entry, OS writes */</span>
<span class="p">};</span>


<span class="cp">#ifndef CONFIG_PCI_MSI</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_enable_msi_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_msi_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_disable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_msix_table_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_enable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_msix_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_disable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">msi_remove_pci_irq_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_restore_msi_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_msi_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_enable_msi_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nvec</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_msi_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_disable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_msix_table_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nvec</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_msix_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_disable_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">msi_remove_pci_irq_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_restore_msi_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_msi_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PCIEPORTBUS</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">pcie_ports_disabled</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">pcie_ports_auto</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define pcie_ports_disabled	true</span>
<span class="cp">#define pcie_ports_auto		false</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_PCIEASPM</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pcie_aspm_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pcie_aspm_support_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pcie_aspm_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">pcie_aspm_support_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PCIEAER</span>
<span class="kt">void</span> <span class="n">pci_no_aer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">pci_aer_available</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_no_aer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pci_aer_available</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_PCIE_ECRC</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pcie_set_ecrc_checking</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pcie_ecrc_get_policy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{};</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pcie_set_ecrc_checking</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pcie_ecrc_get_policy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#define pci_enable_msi(pdev)	pci_enable_msi_block(pdev, 1)</span>

<span class="cp">#ifdef CONFIG_HT_IRQ</span>
<span class="cm">/* The functions a driver should call */</span>
<span class="kt">int</span>  <span class="n">ht_create_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ht_destroy_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HT_IRQ */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_cfg_access_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">pci_cfg_access_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_cfg_access_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * PCI domain support.  Sometimes called PCI segment (eg by ACPI),</span>
<span class="cm"> * a PCI domain is defined to be a set of PCI busses which share</span>
<span class="cm"> * configuration space.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PCI_DOMAINS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_domains_supported</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">pci_domains_supported</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_domain_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_proc_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_DOMAINS */</span><span class="cp"></span>

<span class="cm">/* some architectures require additional setup to direct VGA traffic */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arch_set_vga_state_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">decode</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command_bits</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_register_set_vga_state</span><span class="p">(</span><span class="n">arch_set_vga_state_t</span> <span class="n">func</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_PCI is not enabled */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  If the system does not have PCI, clearly these return errors.  Define</span>
<span class="cm"> *  these as simple inline functions to avoid hair in drivers.</span>
<span class="cm"> */</span>

<span class="cp">#define _PCI_NOP(o, s, t) \</span>
<span class="cp">	static inline int pci_##o##_config_##s(struct pci_dev *dev, \</span>
<span class="cp">						int where, t val) \</span>
<span class="cp">		{ return PCIBIOS_FUNC_NOT_SUPPORTED; }</span>

<span class="cp">#define _PCI_NOP_ALL(o, x)	_PCI_NOP(o, byte, u8 x) \</span>
<span class="cp">				_PCI_NOP(o, word, u16 x) \</span>
<span class="cp">				_PCI_NOP(o, dword, u32 x)</span>
<span class="n">_PCI_NOP_ALL</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
<span class="n">_PCI_NOP_ALL</span><span class="p">(</span><span class="n">write</span><span class="p">,)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_device</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vendor</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_subsys</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vendor</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ss_vendor</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ss_device</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_class</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define pci_dev_present(ids)	(0)</span>
<span class="cp">#define no_pci_devices()	(1)</span>
<span class="cp">#define pci_dev_put(dev)	do { } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_disable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_set_dma_max_seg_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_set_dma_seg_boundary</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_assign_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__pci_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_find_next_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">post</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_find_ext_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Power management related routines */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_restore_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pci_power_t</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">PCI_D0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_enable_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_power_t</span> <span class="n">state</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_enable_ido</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_disable_ido</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_enable_obff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_disable_obff</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_release_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="cp">#define pci_dma_burst_advice(pdev, strat, strategy_parameter) do { } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_block_cfg_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_block_cfg_access_in_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_unblock_cfg_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">pci_find_next_bus</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_get_bus_and_slot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devfn</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">pci_domain_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="cp">#define dev_is_pci(d) (false)</span>
<span class="cp">#define dev_is_pf(d) (false)</span>
<span class="cp">#define dev_num_vf(d) (0)</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cm">/* Include architecture-dependent settings and functions */</span>

<span class="cp">#include &lt;asm/pci.h&gt;</span>

<span class="cp">#ifndef PCIBIOS_MAX_MEM_32</span>
<span class="cp">#define PCIBIOS_MAX_MEM_32 (-1)</span>
<span class="cp">#endif</span>

<span class="cm">/* these helpers provide future and backwards compatibility</span>
<span class="cm"> * for accessing popular PCI BAR info */</span>
<span class="cp">#define pci_resource_start(dev, bar)	((dev)-&gt;resource[(bar)].start)</span>
<span class="cp">#define pci_resource_end(dev, bar)	((dev)-&gt;resource[(bar)].end)</span>
<span class="cp">#define pci_resource_flags(dev, bar)	((dev)-&gt;resource[(bar)].flags)</span>
<span class="cp">#define pci_resource_len(dev,bar) \</span>
<span class="cp">	((pci_resource_start((dev), (bar)) == 0 &amp;&amp;	\</span>
<span class="cp">	  pci_resource_end((dev), (bar)) ==		\</span>
<span class="cp">	  pci_resource_start((dev), (bar))) ? 0 :	\</span>
<span class="cp">							\</span>
<span class="cp">	 (pci_resource_end((dev), (bar)) -		\</span>
<span class="cp">	  pci_resource_start((dev), (bar)) + 1))</span>

<span class="cm">/* Similar to the helpers above, these manipulate per-pci_dev</span>
<span class="cm"> * driver-specific data.  They are really just a wrapper around</span>
<span class="cm"> * the generic device structure functions of these calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pci_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If you want to know what to call your pci_dev, ask this function.</span>
<span class="cm"> * Again, it&#39;s a wrapper around the generic device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pci_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Some archs don&#39;t want to expose struct resource to userland as-is</span>
<span class="cm"> * in sysfs and /proc</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HAVE_ARCH_PCI_RESOURCE_TO_USER</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">pci_resource_to_user</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">rsrc</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
		<span class="n">resource_size_t</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_ARCH_PCI_RESOURCE_TO_USER */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> *  The world is not perfect and supplies us with broken PCI devices.</span>
<span class="cm"> *  For at least a part of these bugs we need a work-around, so both</span>
<span class="cm"> *  generic (drivers/pci/quirks.c) and per-architecture code can define</span>
<span class="cm"> *  fixup hooks to be called for particular buggy devices.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">pci_fixup</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">vendor</span><span class="p">;</span>		<span class="cm">/* You can use PCI_ANY_ID here of course */</span>
	<span class="n">u16</span> <span class="n">device</span><span class="p">;</span>		<span class="cm">/* You can use PCI_ANY_ID here of course */</span>
	<span class="n">u32</span> <span class="n">class</span><span class="p">;</span>		<span class="cm">/* You can use PCI_ANY_ID here too */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class_shift</span><span class="p">;</span>	<span class="cm">/* should be 0, 8, 16 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">pci_fixup_pass</span> <span class="p">{</span>
	<span class="n">pci_fixup_early</span><span class="p">,</span>	<span class="cm">/* Before probing BARs */</span>
	<span class="n">pci_fixup_header</span><span class="p">,</span>	<span class="cm">/* After reading configuration header */</span>
	<span class="n">pci_fixup_final</span><span class="p">,</span>	<span class="cm">/* Final phase of device fixups */</span>
	<span class="n">pci_fixup_enable</span><span class="p">,</span>	<span class="cm">/* pci_enable_device() time */</span>
	<span class="n">pci_fixup_resume</span><span class="p">,</span>	<span class="cm">/* pci_device_resume() */</span>
	<span class="n">pci_fixup_suspend</span><span class="p">,</span>	<span class="cm">/* pci_device_suspend */</span>
	<span class="n">pci_fixup_resume_early</span><span class="p">,</span> <span class="cm">/* pci_device_resume_early() */</span>
<span class="p">};</span>

<span class="cm">/* Anonymous variables would be nice... */</span>
<span class="cp">#define DECLARE_PCI_FIXUP_SECTION(section, name, vendor, device, class,	\</span>
<span class="cp">				  class_shift, hook)			\</span>
<span class="cp">	static const struct pci_fixup const __pci_fixup_##name __used	\</span>
<span class="cp">	__attribute__((__section__(#section), aligned((sizeof(void *)))))    \</span>
<span class="cp">		= { vendor, device, class, class_shift, hook };</span>

<span class="cp">#define DECLARE_PCI_FIXUP_CLASS_EARLY(vendor, device, class,		\</span>
<span class="cp">					 class_shift, hook)		\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_early,			\</span>
<span class="cp">		vendor##device##hook, vendor, device, class, class_shift, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_CLASS_HEADER(vendor, device, class,		\</span>
<span class="cp">					 class_shift, hook)		\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_header,			\</span>
<span class="cp">		vendor##device##hook, vendor, device, class, class_shift, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_CLASS_FINAL(vendor, device, class,		\</span>
<span class="cp">					 class_shift, hook)		\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_final,			\</span>
<span class="cp">		vendor##device##hook, vendor, device, class, class_shift, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_CLASS_ENABLE(vendor, device, class,		\</span>
<span class="cp">					 class_shift, hook)		\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_enable,			\</span>
<span class="cp">		vendor##device##hook, vendor, device, class, class_shift, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_CLASS_RESUME(vendor, device, class,		\</span>
<span class="cp">					 class_shift, hook)		\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_resume,			\</span>
<span class="cp">		resume##vendor##device##hook, vendor, device, class,	\</span>
<span class="cp">		class_shift, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_CLASS_RESUME_EARLY(vendor, device, class,	\</span>
<span class="cp">					 class_shift, hook)		\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_resume_early,		\</span>
<span class="cp">		resume_early##vendor##device##hook, vendor, device,	\</span>
<span class="cp">		class, class_shift, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_CLASS_SUSPEND(vendor, device, class,		\</span>
<span class="cp">					 class_shift, hook)		\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_suspend,			\</span>
<span class="cp">		suspend##vendor##device##hook, vendor, device, class,	\</span>
<span class="cp">		class_shift, hook)</span>

<span class="cp">#define DECLARE_PCI_FIXUP_EARLY(vendor, device, hook)			\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_early,			\</span>
<span class="cp">		vendor##device##hook, vendor, device, PCI_ANY_ID, 0, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_HEADER(vendor, device, hook)			\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_header,			\</span>
<span class="cp">		vendor##device##hook, vendor, device, PCI_ANY_ID, 0, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_FINAL(vendor, device, hook)			\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_final,			\</span>
<span class="cp">		vendor##device##hook, vendor, device, PCI_ANY_ID, 0, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_ENABLE(vendor, device, hook)			\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_enable,			\</span>
<span class="cp">		vendor##device##hook, vendor, device, PCI_ANY_ID, 0, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_RESUME(vendor, device, hook)			\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_resume,			\</span>
<span class="cp">		resume##vendor##device##hook, vendor, device,		\</span>
<span class="cp">		PCI_ANY_ID, 0, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_RESUME_EARLY(vendor, device, hook)		\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_resume_early,		\</span>
<span class="cp">		resume_early##vendor##device##hook, vendor, device,	\</span>
<span class="cp">		PCI_ANY_ID, 0, hook)</span>
<span class="cp">#define DECLARE_PCI_FIXUP_SUSPEND(vendor, device, hook)			\</span>
<span class="cp">	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_suspend,			\</span>
<span class="cp">		suspend##vendor##device##hook, vendor, device,		\</span>
<span class="cp">		PCI_ANY_ID, 0, hook)</span>

<span class="cp">#ifdef CONFIG_PCI_QUIRKS</span>
<span class="kt">void</span> <span class="n">pci_fixup_device</span><span class="p">(</span><span class="k">enum</span> <span class="n">pci_fixup_pass</span> <span class="n">pass</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_fixup_device</span><span class="p">(</span><span class="k">enum</span> <span class="n">pci_fixup_pass</span> <span class="n">pass</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pcim_iomap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxlen</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcim_iounmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">pcim_iomap_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcim_iomap_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcim_iomap_regions_request_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcim_iounmap_regions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_pci_problems</span><span class="p">;</span>
<span class="cp">#define PCIPCI_FAIL		1	</span><span class="cm">/* No PCI PCI DMA */</span><span class="cp"></span>
<span class="cp">#define PCIPCI_TRITON		2</span>
<span class="cp">#define PCIPCI_NATOMA		4</span>
<span class="cp">#define PCIPCI_VIAETBF		8</span>
<span class="cp">#define PCIPCI_VSFX		16</span>
<span class="cp">#define PCIPCI_ALIMAGIK		32	</span><span class="cm">/* Need low latency setting */</span><span class="cp"></span>
<span class="cp">#define PCIAGP_FAIL		64	</span><span class="cm">/* No PCI to AGP DMA */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_cardbus_io_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_cardbus_mem_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">__devinitdata</span> <span class="n">pci_dfl_cache_line_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">pci_cache_line_size</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_hotplug_io_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_hotplug_mem_size</span><span class="p">;</span>

<span class="cm">/* Architecture specific versions may override these (weak) */</span>
<span class="kt">int</span> <span class="n">pcibios_add_platform_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcibios_disable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcibios_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcibios_set_pcie_reset_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">pcie_reset_state</span> <span class="n">state</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI_MMCONFIG</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">pci_mmcfg_early_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">pci_mmcfg_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_mmcfg_early_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_mmcfg_late_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">pci_ext_cfg_avail</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI_IOV</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_enable_sriov</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_virtfn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_disable_sriov</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">pci_sriov_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_num_vf</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_enable_sriov</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_virtfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_disable_sriov</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">irqreturn_t</span> <span class="nf">pci_sriov_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_num_vf</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_HOTPLUG_PCI) || defined(CONFIG_HOTPLUG_PCI_MODULE)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_hp_create_module_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_slot</span> <span class="o">*</span><span class="n">pci_slot</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_hp_remove_module_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_slot</span> <span class="o">*</span><span class="n">pci_slot</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * pci_pcie_cap - get the saved PCIe capability offset</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * PCIe capability offset is calculated at PCI device initialization</span>
<span class="cm"> * time and saved in the data structure. This function returns saved</span>
<span class="cm"> * PCIe capability offset. Using this instead of pci_find_capability()</span>
<span class="cm"> * reduces unnecessary search in the PCI configuration space. If you</span>
<span class="cm"> * need to calculate PCIe capability offset from raw device for some</span>
<span class="cm"> * reasons, please use pci_find_capability() instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_pcie_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_cap</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_is_pcie - check if the PCI device is PCI Express capable</span>
<span class="cm"> * @dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Retrun true if the PCI device is PCI Express capable, false otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pci_is_pcie</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">pci_request_acs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="cp">#define PCI_VPD_LRDT			0x80	</span><span class="cm">/* Large Resource Data Type */</span><span class="cp"></span>
<span class="cp">#define PCI_VPD_LRDT_ID(x)		(x | PCI_VPD_LRDT)</span>

<span class="cm">/* Large Resource Data Type Tag Item Names */</span>
<span class="cp">#define PCI_VPD_LTIN_ID_STRING		0x02	</span><span class="cm">/* Identifier String */</span><span class="cp"></span>
<span class="cp">#define PCI_VPD_LTIN_RO_DATA		0x10	</span><span class="cm">/* Read-Only Data */</span><span class="cp"></span>
<span class="cp">#define PCI_VPD_LTIN_RW_DATA		0x11	</span><span class="cm">/* Read-Write Data */</span><span class="cp"></span>

<span class="cp">#define PCI_VPD_LRDT_ID_STRING		PCI_VPD_LRDT_ID(PCI_VPD_LTIN_ID_STRING)</span>
<span class="cp">#define PCI_VPD_LRDT_RO_DATA		PCI_VPD_LRDT_ID(PCI_VPD_LTIN_RO_DATA)</span>
<span class="cp">#define PCI_VPD_LRDT_RW_DATA		PCI_VPD_LRDT_ID(PCI_VPD_LTIN_RW_DATA)</span>

<span class="cm">/* Small Resource Data Type Tag Item Names */</span>
<span class="cp">#define PCI_VPD_STIN_END		0x78	</span><span class="cm">/* End */</span><span class="cp"></span>

<span class="cp">#define PCI_VPD_SRDT_END		PCI_VPD_STIN_END</span>

<span class="cp">#define PCI_VPD_SRDT_TIN_MASK		0x78</span>
<span class="cp">#define PCI_VPD_SRDT_LEN_MASK		0x07</span>

<span class="cp">#define PCI_VPD_LRDT_TAG_SIZE		3</span>
<span class="cp">#define PCI_VPD_SRDT_TAG_SIZE		1</span>

<span class="cp">#define PCI_VPD_INFO_FLD_HDR_SIZE	3</span>

<span class="cp">#define PCI_VPD_RO_KEYWORD_PARTNO	&quot;PN&quot;</span>
<span class="cp">#define PCI_VPD_RO_KEYWORD_MFR_ID	&quot;MN&quot;</span>
<span class="cp">#define PCI_VPD_RO_KEYWORD_VENDOR0	&quot;V0&quot;</span>
<span class="cp">#define PCI_VPD_RO_KEYWORD_CHKSUM	&quot;RV&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * pci_vpd_lrdt_size - Extracts the Large Resource Data Type length</span>
<span class="cm"> * @lrdt: Pointer to the beginning of the Large Resource Data Type tag</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the extracted Large Resource Data Type length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">pci_vpd_lrdt_size</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">lrdt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">lrdt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">u16</span><span class="p">)</span><span class="n">lrdt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_vpd_srdt_size - Extracts the Small Resource Data Type length</span>
<span class="cm"> * @lrdt: Pointer to the beginning of the Small Resource Data Type tag</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the extracted Small Resource Data Type length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">pci_vpd_srdt_size</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">srdt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">srdt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PCI_VPD_SRDT_LEN_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_vpd_info_field_size - Extracts the information field length</span>
<span class="cm"> * @lrdt: Pointer to the beginning of an information field header</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the extracted information field length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">pci_vpd_info_field_size</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">info_field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">info_field</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_vpd_find_tag - Locates the Resource Data Type tag provided</span>
<span class="cm"> * @buf: Pointer to buffered vpd data</span>
<span class="cm"> * @off: The offset into the buffer at which to begin the search</span>
<span class="cm"> * @len: The length of the vpd buffer</span>
<span class="cm"> * @rdt: The Resource Data Type to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the index where the Resource Data Type was found or</span>
<span class="cm"> * -ENOENT otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">pci_vpd_find_tag</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u8</span> <span class="n">rdt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_vpd_find_info_keyword - Locates an information field keyword in the VPD</span>
<span class="cm"> * @buf: Pointer to buffered vpd data</span>
<span class="cm"> * @off: The offset into the buffer at which to begin the search</span>
<span class="cm"> * @len: The length of the buffer area, relative to off, in which to search</span>
<span class="cm"> * @kw: The keyword to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the index where the information field keyword was found or</span>
<span class="cm"> * -ENOENT otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">pci_vpd_find_info_keyword</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kw</span><span class="p">);</span>

<span class="cm">/* PCI &lt;-&gt; OF binding helpers */</span>
<span class="cp">#ifdef CONFIG_OF</span>
<span class="k">struct</span> <span class="n">device_node</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_set_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_release_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_set_bus_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pci_release_bus_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="cm">/* Arch may override this (weak) */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span> <span class="n">__weak</span> <span class="n">pcibios_get_phb_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span>
<span class="nf">pci_device_to_OF_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdev</span> <span class="o">?</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">pci_bus_to_OF_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bus</span> <span class="o">?</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_OF */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_set_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_release_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_set_bus_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_release_bus_of_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif  </span><span class="cm">/* CONFIG_OF */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_EEH</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">eeh_dev</span> <span class="o">*</span><span class="nf">pci_dev_to_eeh_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span><span class="p">.</span><span class="n">edev</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * pci_find_upstream_pcie_bridge - find upstream PCIe-to-PCI bridge of a device</span>
<span class="cm"> * @pdev: the PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * if the device is PCIE, return NULL</span>
<span class="cm"> * if the device isn&#39;t connected to a PCIe bridge (that is its parent is a</span>
<span class="cm"> * legacy PCI bridge and the bridge is directly connected to bus 0), return its</span>
<span class="cm"> * parent</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_find_upstream_pcie_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* LINUX_PCI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
