<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › libata.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>libata.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright 2003-2005 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> *  Copyright 2003-2005 Jeff Garzik</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *  any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; see the file COPYING.  If not, write to</span>
<span class="cm"> *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  libata documentation is available via &#39;make {ps|pdf}docs&#39;,</span>
<span class="cm"> *  as Documentation/DocBook/libata.*</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_LIBATA_H__</span>
<span class="cp">#define __LINUX_LIBATA_H__</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/ata.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Define if arch has non-standard setup.  This is a _PCI_ standard</span>
<span class="cm"> * not a legacy or ISA standard.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_ATA_NONSTANDARD</span>
<span class="cp">#include &lt;asm/libata-portmap.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;asm-generic/libata-portmap.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * compile-time options: to be removed as soon as all the drivers are</span>
<span class="cm"> * converted to the new debugging mechanism</span>
<span class="cm"> */</span>
<span class="cp">#undef ATA_DEBUG		</span><span class="cm">/* debugging output */</span><span class="cp"></span>
<span class="cp">#undef ATA_VERBOSE_DEBUG	</span><span class="cm">/* yet more debugging output */</span><span class="cp"></span>
<span class="cp">#undef ATA_IRQ_TRAP		</span><span class="cm">/* define to ack screaming irqs */</span><span class="cp"></span>
<span class="cp">#undef ATA_NDEBUG		</span><span class="cm">/* define to disable quick runtime checks */</span><span class="cp"></span>


<span class="cm">/* note: prints function name for you */</span>
<span class="cp">#ifdef ATA_DEBUG</span>
<span class="cp">#define DPRINTK(fmt, args...) printk(KERN_ERR &quot;%s: &quot; fmt, __func__, ## args)</span>
<span class="cp">#ifdef ATA_VERBOSE_DEBUG</span>
<span class="cp">#define VPRINTK(fmt, args...) printk(KERN_ERR &quot;%s: &quot; fmt, __func__, ## args)</span>
<span class="cp">#else</span>
<span class="cp">#define VPRINTK(fmt, args...)</span>
<span class="cp">#endif	</span><span class="cm">/* ATA_VERBOSE_DEBUG */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define DPRINTK(fmt, args...)</span>
<span class="cp">#define VPRINTK(fmt, args...)</span>
<span class="cp">#endif	</span><span class="cm">/* ATA_DEBUG */</span><span class="cp"></span>

<span class="cp">#define BPRINTK(fmt, args...) if (ap-&gt;flags &amp; ATA_FLAG_DEBUGMSG) printk(KERN_ERR &quot;%s: &quot; fmt, __func__, ## args)</span>

<span class="cp">#define ata_print_version_once(dev, version)			\</span>
<span class="cp">({								\</span>
<span class="cp">	static bool __print_once;				\</span>
<span class="cp">								\</span>
<span class="cp">	if (!__print_once) {					\</span>
<span class="cp">		__print_once = true;				\</span>
<span class="cp">		ata_print_version(dev, version);		\</span>
<span class="cp">	}							\</span>
<span class="cp">})</span>

<span class="cm">/* NEW: debug levels */</span>
<span class="cp">#define HAVE_LIBATA_MSG 1</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ATA_MSG_DRV</span>	<span class="o">=</span> <span class="mh">0x0001</span><span class="p">,</span>
	<span class="n">ATA_MSG_INFO</span>	<span class="o">=</span> <span class="mh">0x0002</span><span class="p">,</span>
	<span class="n">ATA_MSG_PROBE</span>	<span class="o">=</span> <span class="mh">0x0004</span><span class="p">,</span>
	<span class="n">ATA_MSG_WARN</span>	<span class="o">=</span> <span class="mh">0x0008</span><span class="p">,</span>
	<span class="n">ATA_MSG_MALLOC</span>	<span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>
	<span class="n">ATA_MSG_CTL</span>	<span class="o">=</span> <span class="mh">0x0020</span><span class="p">,</span>
	<span class="n">ATA_MSG_INTR</span>	<span class="o">=</span> <span class="mh">0x0040</span><span class="p">,</span>
	<span class="n">ATA_MSG_ERR</span>	<span class="o">=</span> <span class="mh">0x0080</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define ata_msg_drv(p)    ((p)-&gt;msg_enable &amp; ATA_MSG_DRV)</span>
<span class="cp">#define ata_msg_info(p)   ((p)-&gt;msg_enable &amp; ATA_MSG_INFO)</span>
<span class="cp">#define ata_msg_probe(p)  ((p)-&gt;msg_enable &amp; ATA_MSG_PROBE)</span>
<span class="cp">#define ata_msg_warn(p)   ((p)-&gt;msg_enable &amp; ATA_MSG_WARN)</span>
<span class="cp">#define ata_msg_malloc(p) ((p)-&gt;msg_enable &amp; ATA_MSG_MALLOC)</span>
<span class="cp">#define ata_msg_ctl(p)    ((p)-&gt;msg_enable &amp; ATA_MSG_CTL)</span>
<span class="cp">#define ata_msg_intr(p)   ((p)-&gt;msg_enable &amp; ATA_MSG_INTR)</span>
<span class="cp">#define ata_msg_err(p)    ((p)-&gt;msg_enable &amp; ATA_MSG_ERR)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ata_msg_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">dval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">default_msg_enable_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dval</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dval</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">default_msg_enable_bits</span><span class="p">;</span> <span class="cm">/* should be 0x1 - only driver info msgs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dval</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">dval</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* defines only for the constants which don&#39;t work well as enums */</span>
<span class="cp">#define ATA_TAG_POISON		0xfafbfcfdU</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* various global constants */</span>
	<span class="n">LIBATA_MAX_PRD</span>		<span class="o">=</span> <span class="n">ATA_MAX_PRD</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">LIBATA_DUMB_MAX_PRD</span>	<span class="o">=</span> <span class="n">ATA_MAX_PRD</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* Worst case */</span>
	<span class="n">ATA_DEF_QUEUE</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="cm">/* tag ATA_MAX_QUEUE - 1 is reserved for internal commands */</span>
	<span class="n">ATA_MAX_QUEUE</span>		<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="n">ATA_TAG_INTERNAL</span>	<span class="o">=</span> <span class="n">ATA_MAX_QUEUE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ATA_SHORT_PAUSE</span>		<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>

	<span class="n">ATAPI_MAX_DRAIN</span>		<span class="o">=</span> <span class="mi">16</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">,</span>

	<span class="n">ATA_ALL_DEVICES</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_MAX_DEVICES</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>

	<span class="n">ATA_SHT_EMULATED</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ATA_SHT_CMD_PER_LUN</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ATA_SHT_THIS_ID</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">ATA_SHT_USE_CLUSTERING</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* struct ata_device stuff */</span>
	<span class="n">ATA_DFLAG_LBA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* device supports LBA */</span>
	<span class="n">ATA_DFLAG_LBA48</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* device supports LBA48 */</span>
	<span class="n">ATA_DFLAG_CDB_INTR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="cm">/* device asserts INTRQ when ready for CDB */</span>
	<span class="n">ATA_DFLAG_NCQ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span> <span class="cm">/* device supports NCQ */</span>
	<span class="n">ATA_DFLAG_FLUSH_EXT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="cm">/* do FLUSH_EXT instead of FLUSH */</span>
	<span class="n">ATA_DFLAG_ACPI_PENDING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="cm">/* ACPI resume action pending */</span>
	<span class="n">ATA_DFLAG_ACPI_FAILED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="cm">/* ACPI on devcfg has failed */</span>
	<span class="n">ATA_DFLAG_AN</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="cm">/* AN configured */</span>
	<span class="n">ATA_DFLAG_DMADIR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span> <span class="cm">/* device requires DMADIR */</span>
	<span class="n">ATA_DFLAG_CFG_MASK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>

	<span class="n">ATA_DFLAG_PIO</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span> <span class="cm">/* device limited to PIO mode */</span>
	<span class="n">ATA_DFLAG_NCQ_OFF</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span> <span class="cm">/* device limited to non-NCQ mode */</span>
	<span class="n">ATA_DFLAG_SLEEPING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span> <span class="cm">/* device is sleeping */</span>
	<span class="n">ATA_DFLAG_DUBIOUS_XFER</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span> <span class="cm">/* data transfer not verified */</span>
	<span class="n">ATA_DFLAG_NO_UNLOAD</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span> <span class="cm">/* device doesn&#39;t support unload */</span>
	<span class="n">ATA_DFLAG_UNLOCK_HPA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span> <span class="cm">/* unlock HPA */</span>
	<span class="n">ATA_DFLAG_INIT_MASK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>

	<span class="n">ATA_DFLAG_DETACH</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
	<span class="n">ATA_DFLAG_DETACHED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">),</span>

	<span class="n">ATA_DEV_UNKNOWN</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* unknown device */</span>
	<span class="n">ATA_DEV_ATA</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* ATA device */</span>
	<span class="n">ATA_DEV_ATA_UNSUP</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* ATA device (unsupported) */</span>
	<span class="n">ATA_DEV_ATAPI</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* ATAPI device */</span>
	<span class="n">ATA_DEV_ATAPI_UNSUP</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* ATAPI device (unsupported) */</span>
	<span class="n">ATA_DEV_PMP</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* SATA port multiplier */</span>
	<span class="n">ATA_DEV_PMP_UNSUP</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* SATA port multiplier (unsupported) */</span>
	<span class="n">ATA_DEV_SEMB</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* SEMB */</span>
	<span class="n">ATA_DEV_SEMB_UNSUP</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>	<span class="cm">/* SEMB (unsupported) */</span>
	<span class="n">ATA_DEV_NONE</span>		<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>	<span class="cm">/* no device */</span>

	<span class="cm">/* struct ata_link flags */</span>
	<span class="n">ATA_LFLAG_NO_HRST</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* avoid hardreset */</span>
	<span class="n">ATA_LFLAG_NO_SRST</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="cm">/* avoid softreset */</span>
	<span class="n">ATA_LFLAG_ASSUME_ATA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span> <span class="cm">/* assume ATA class */</span>
	<span class="n">ATA_LFLAG_ASSUME_SEMB</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="cm">/* assume SEMB class */</span>
	<span class="n">ATA_LFLAG_ASSUME_CLASS</span>	<span class="o">=</span> <span class="n">ATA_LFLAG_ASSUME_ATA</span> <span class="o">|</span> <span class="n">ATA_LFLAG_ASSUME_SEMB</span><span class="p">,</span>
	<span class="n">ATA_LFLAG_NO_RETRY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="cm">/* don&#39;t retry this link */</span>
	<span class="n">ATA_LFLAG_DISABLED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="cm">/* link is disabled */</span>
	<span class="n">ATA_LFLAG_SW_ACTIVITY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="cm">/* keep activity stats */</span>
	<span class="n">ATA_LFLAG_NO_LPM</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="cm">/* disable LPM on this link */</span>

	<span class="cm">/* struct ata_port flags */</span>
	<span class="n">ATA_FLAG_SLAVE_POSS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* host supports slave dev */</span>
					    <span class="cm">/* (doesn&#39;t imply presence) */</span>
	<span class="n">ATA_FLAG_SATA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">ATA_FLAG_NO_ATAPI</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="cm">/* No ATAPI support */</span>
	<span class="n">ATA_FLAG_PIO_DMA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="cm">/* PIO cmds via DMA */</span>
	<span class="n">ATA_FLAG_PIO_LBA48</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="cm">/* Host DMA engine is LBA28 only */</span>
	<span class="n">ATA_FLAG_PIO_POLLING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span> <span class="cm">/* use polling PIO if LLD</span>
<span class="cm">					     * doesn&#39;t handle PIO interrupts */</span>
	<span class="n">ATA_FLAG_NCQ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span> <span class="cm">/* host supports NCQ */</span>
	<span class="n">ATA_FLAG_NO_POWEROFF_SPINDOWN</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span> <span class="cm">/* don&#39;t spindown before poweroff */</span>
	<span class="n">ATA_FLAG_NO_HIBERNATE_SPINDOWN</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span> <span class="cm">/* don&#39;t spindown before hibernation */</span>
	<span class="n">ATA_FLAG_DEBUGMSG</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>
	<span class="n">ATA_FLAG_FPDMA_AA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span> <span class="cm">/* driver supports Auto-Activate */</span>
	<span class="n">ATA_FLAG_IGN_SIMPLEX</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span> <span class="cm">/* ignore SIMPLEX */</span>
	<span class="n">ATA_FLAG_NO_IORDY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span> <span class="cm">/* controller lacks iordy */</span>
	<span class="n">ATA_FLAG_ACPI_SATA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span> <span class="cm">/* need native SATA ACPI layout */</span>
	<span class="n">ATA_FLAG_AN</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span> <span class="cm">/* controller supports AN */</span>
	<span class="n">ATA_FLAG_PMP</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span> <span class="cm">/* controller supports PMP */</span>
	<span class="n">ATA_FLAG_EM</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span> <span class="cm">/* driver supports enclosure</span>
<span class="cm">					      * management */</span>
	<span class="n">ATA_FLAG_SW_ACTIVITY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">),</span> <span class="cm">/* driver supports sw activity</span>
<span class="cm">					      * led */</span>
	<span class="n">ATA_FLAG_NO_DIPM</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">),</span> <span class="cm">/* host not happy with DIPM */</span>

	<span class="cm">/* bits 24:31 of ap-&gt;flags are reserved for LLD specific flags */</span>


	<span class="cm">/* struct ata_port pflags */</span>
	<span class="n">ATA_PFLAG_EH_PENDING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* EH pending */</span>
	<span class="n">ATA_PFLAG_EH_IN_PROGRESS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* EH in progress */</span>
	<span class="n">ATA_PFLAG_FROZEN</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="cm">/* port is frozen */</span>
	<span class="n">ATA_PFLAG_RECOVERED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span> <span class="cm">/* recovery action performed */</span>
	<span class="n">ATA_PFLAG_LOADING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="cm">/* boot/loading probe */</span>
	<span class="n">ATA_PFLAG_SCSI_HOTPLUG</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="cm">/* SCSI hotplug scheduled */</span>
	<span class="n">ATA_PFLAG_INITIALIZING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="cm">/* being initialized, don&#39;t touch */</span>
	<span class="n">ATA_PFLAG_RESETTING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="cm">/* reset in progress */</span>
	<span class="n">ATA_PFLAG_UNLOADING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span> <span class="cm">/* driver is being unloaded */</span>
	<span class="n">ATA_PFLAG_UNLOADED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span> <span class="cm">/* driver is unloaded */</span>

	<span class="n">ATA_PFLAG_SUSPENDED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span> <span class="cm">/* port is suspended (power) */</span>
	<span class="n">ATA_PFLAG_PM_PENDING</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span> <span class="cm">/* PM operation pending */</span>
	<span class="n">ATA_PFLAG_INIT_GTM_VALID</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span> <span class="cm">/* initial gtm data valid */</span>

	<span class="n">ATA_PFLAG_PIO32</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">),</span>  <span class="cm">/* 32bit PIO */</span>
	<span class="n">ATA_PFLAG_PIO32CHANGE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span>  <span class="cm">/* 32bit PIO can be turned on/off */</span>

	<span class="cm">/* struct ata_queued_cmd flags */</span>
	<span class="n">ATA_QCFLAG_ACTIVE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* cmd not yet ack&#39;d to scsi lyer */</span>
	<span class="n">ATA_QCFLAG_DMAMAP</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* SG table is DMA mapped */</span>
	<span class="n">ATA_QCFLAG_IO</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span> <span class="cm">/* standard IO command */</span>
	<span class="n">ATA_QCFLAG_RESULT_TF</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="cm">/* result TF requested */</span>
	<span class="n">ATA_QCFLAG_CLEAR_EXCL</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="cm">/* clear excl_link on completion */</span>
	<span class="n">ATA_QCFLAG_QUIET</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="cm">/* don&#39;t report device error */</span>
	<span class="n">ATA_QCFLAG_RETRY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="cm">/* retry after failure */</span>

	<span class="n">ATA_QCFLAG_FAILED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span> <span class="cm">/* cmd failed and is owned by EH */</span>
	<span class="n">ATA_QCFLAG_SENSE_VALID</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span> <span class="cm">/* sense data valid */</span>
	<span class="n">ATA_QCFLAG_EH_SCHEDULED</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span> <span class="cm">/* EH scheduled (obsolete) */</span>

	<span class="cm">/* host set flags */</span>
	<span class="n">ATA_HOST_SIMPLEX</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* Host is simplex, one DMA channel per host only */</span>
	<span class="n">ATA_HOST_STARTED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* Host started */</span>
	<span class="n">ATA_HOST_PARALLEL_SCAN</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* Ports on this host can be scanned in parallel */</span>
	<span class="n">ATA_HOST_IGNORE_ATA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>	<span class="cm">/* Ignore ATA devices on this host. */</span>

	<span class="cm">/* bits 24:31 of host-&gt;flags are reserved for LLD specific flags */</span>

	<span class="cm">/* various lengths of time */</span>
	<span class="n">ATA_TMOUT_BOOT</span>		<span class="o">=</span> <span class="mi">30000</span><span class="p">,</span>	<span class="cm">/* heuristic */</span>
	<span class="n">ATA_TMOUT_BOOT_QUICK</span>	<span class="o">=</span>  <span class="mi">7000</span><span class="p">,</span>	<span class="cm">/* heuristic */</span>
	<span class="n">ATA_TMOUT_INTERNAL_QUICK</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
	<span class="n">ATA_TMOUT_MAX_PARK</span>	<span class="o">=</span> <span class="mi">30000</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * GoVault needs 2s and iVDR disk HHD424020F7SV00 800ms.  2s</span>
<span class="cm">	 * is too much without parallel probing.  Use 2s if parallel</span>
<span class="cm">	 * probing is available, 800ms otherwise.</span>
<span class="cm">	 */</span>
	<span class="n">ATA_TMOUT_FF_WAIT_LONG</span>	<span class="o">=</span>  <span class="mi">2000</span><span class="p">,</span>
	<span class="n">ATA_TMOUT_FF_WAIT</span>	<span class="o">=</span>   <span class="mi">800</span><span class="p">,</span>

	<span class="cm">/* Spec mandates to wait for &quot;&gt;= 2ms&quot; before checking status</span>
<span class="cm">	 * after reset.  We wait 150ms, because that was the magic</span>
<span class="cm">	 * delay used for ATAPI devices in Hale Landis&#39;s ATADRVR, for</span>
<span class="cm">	 * the period of time between when the ATA command register is</span>
<span class="cm">	 * written, and then status is checked.  Because waiting for</span>
<span class="cm">	 * &quot;a while&quot; before checking status is fine, post SRST, we</span>
<span class="cm">	 * perform this magic delay here as well.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Old drivers/ide uses the 2mS rule and then waits for ready.</span>
<span class="cm">	 */</span>
	<span class="n">ATA_WAIT_AFTER_RESET</span>	<span class="o">=</span>  <span class="mi">150</span><span class="p">,</span>

	<span class="cm">/* If PMP is supported, we have to do follow-up SRST.  As some</span>
<span class="cm">	 * PMPs don&#39;t send D2H Reg FIS after hardreset, LLDs are</span>
<span class="cm">	 * advised to wait only for the following duration before</span>
<span class="cm">	 * doing SRST.</span>
<span class="cm">	 */</span>
	<span class="n">ATA_TMOUT_PMP_SRST_WAIT</span>	<span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>

	<span class="cm">/* ATA bus states */</span>
	<span class="n">BUS_UNKNOWN</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">BUS_DMA</span>			<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">BUS_IDLE</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">BUS_NOINTR</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">BUS_NODATA</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">BUS_TIMER</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">BUS_PIO</span>			<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">BUS_EDD</span>			<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">BUS_IDENTIFY</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">BUS_PACKET</span>		<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>

	<span class="cm">/* SATA port states */</span>
	<span class="n">PORT_UNKNOWN</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PORT_ENABLED</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PORT_DISABLED</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/* encoding various smaller bitmaps into a single</span>
<span class="cm">	 * unsigned long bitmap</span>
<span class="cm">	 */</span>
	<span class="n">ATA_NR_PIO_MODES</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">ATA_NR_MWDMA_MODES</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">ATA_NR_UDMA_MODES</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

	<span class="n">ATA_SHIFT_PIO</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ATA_SHIFT_MWDMA</span>		<span class="o">=</span> <span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="n">ATA_NR_PIO_MODES</span><span class="p">,</span>
	<span class="n">ATA_SHIFT_UDMA</span>		<span class="o">=</span> <span class="n">ATA_SHIFT_MWDMA</span> <span class="o">+</span> <span class="n">ATA_NR_MWDMA_MODES</span><span class="p">,</span>

	<span class="cm">/* size of buffer to pad xfers ending on unaligned boundaries */</span>
	<span class="n">ATA_DMA_PAD_SZ</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

	<span class="cm">/* ering size */</span>
	<span class="n">ATA_ERING_SIZE</span>		<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>

	<span class="cm">/* return values for -&gt;qc_defer */</span>
	<span class="n">ATA_DEFER_LINK</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ATA_DEFER_PORT</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/* desc_len for ata_eh_info and context */</span>
	<span class="n">ATA_EH_DESC_LEN</span>		<span class="o">=</span> <span class="mi">80</span><span class="p">,</span>

	<span class="cm">/* reset / recovery action types */</span>
	<span class="n">ATA_EH_REVALIDATE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">ATA_EH_SOFTRESET</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* meaningful only in -&gt;prereset */</span>
	<span class="n">ATA_EH_HARDRESET</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="cm">/* meaningful only in -&gt;prereset */</span>
	<span class="n">ATA_EH_RESET</span>		<span class="o">=</span> <span class="n">ATA_EH_SOFTRESET</span> <span class="o">|</span> <span class="n">ATA_EH_HARDRESET</span><span class="p">,</span>
	<span class="n">ATA_EH_ENABLE_LINK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">ATA_EH_PARK</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="cm">/* unload heads and stop I/O */</span>

	<span class="n">ATA_EH_PERDEV_MASK</span>	<span class="o">=</span> <span class="n">ATA_EH_REVALIDATE</span> <span class="o">|</span> <span class="n">ATA_EH_PARK</span><span class="p">,</span>
	<span class="n">ATA_EH_ALL_ACTIONS</span>	<span class="o">=</span> <span class="n">ATA_EH_REVALIDATE</span> <span class="o">|</span> <span class="n">ATA_EH_RESET</span> <span class="o">|</span>
				  <span class="n">ATA_EH_ENABLE_LINK</span><span class="p">,</span>

	<span class="cm">/* ata_eh_info-&gt;flags */</span>
	<span class="n">ATA_EHI_HOTPLUGGED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>  <span class="cm">/* could have been hotplugged */</span>
	<span class="n">ATA_EHI_NO_AUTOPSY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>  <span class="cm">/* no autopsy */</span>
	<span class="n">ATA_EHI_QUIET</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>  <span class="cm">/* be quiet */</span>
	<span class="n">ATA_EHI_NO_RECOVERY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>  <span class="cm">/* no recovery */</span>

	<span class="n">ATA_EHI_DID_SOFTRESET</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span> <span class="cm">/* already soft-reset this port */</span>
	<span class="n">ATA_EHI_DID_HARDRESET</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span> <span class="cm">/* already soft-reset this port */</span>
	<span class="n">ATA_EHI_PRINTINFO</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span> <span class="cm">/* print configuration info */</span>
	<span class="n">ATA_EHI_SETMODE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span> <span class="cm">/* configure transfer mode */</span>
	<span class="n">ATA_EHI_POST_SETMODE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">),</span> <span class="cm">/* revalidating after setmode */</span>

	<span class="n">ATA_EHI_DID_RESET</span>	<span class="o">=</span> <span class="n">ATA_EHI_DID_SOFTRESET</span> <span class="o">|</span> <span class="n">ATA_EHI_DID_HARDRESET</span><span class="p">,</span>

	<span class="cm">/* mask of flags to transfer *to* the slave link */</span>
	<span class="n">ATA_EHI_TO_SLAVE_MASK</span>	<span class="o">=</span> <span class="n">ATA_EHI_NO_AUTOPSY</span> <span class="o">|</span> <span class="n">ATA_EHI_QUIET</span><span class="p">,</span>

	<span class="cm">/* max tries if error condition is still set after -&gt;error_handler */</span>
	<span class="n">ATA_EH_MAX_TRIES</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

	<span class="cm">/* sometimes resuming a link requires several retries */</span>
	<span class="n">ATA_LINK_RESUME_TRIES</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

	<span class="cm">/* how hard are we gonna try to probe/recover devices */</span>
	<span class="n">ATA_PROBE_MAX_TRIES</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">ATA_EH_DEV_TRIES</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">ATA_EH_PMP_TRIES</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">ATA_EH_PMP_LINK_TRIES</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">SATA_PMP_RW_TIMEOUT</span>	<span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>		<span class="cm">/* PMP read/write timeout */</span>

	<span class="cm">/* This should match the actual table size of</span>
<span class="cm">	 * ata_eh_cmd_timeout_table in libata-eh.c.</span>
<span class="cm">	 */</span>
	<span class="n">ATA_EH_CMD_TIMEOUT_TABLE_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>

	<span class="cm">/* Horkage types. May be set by libata or controller on drives</span>
<span class="cm">	   (some horkage may be drive/controller pair dependent */</span>

	<span class="n">ATA_HORKAGE_DIAGNOSTIC</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* Failed boot diag */</span>
	<span class="n">ATA_HORKAGE_NODMA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* DMA problems */</span>
	<span class="n">ATA_HORKAGE_NONCQ</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* Don&#39;t use NCQ */</span>
	<span class="n">ATA_HORKAGE_MAX_SEC_128</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>	<span class="cm">/* Limit max sects to 128 */</span>
	<span class="n">ATA_HORKAGE_BROKEN_HPA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* Broken HPA */</span>
	<span class="n">ATA_HORKAGE_DISABLE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>	<span class="cm">/* Disable it */</span>
	<span class="n">ATA_HORKAGE_HPA_SIZE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>	<span class="cm">/* native size off by one */</span>
	<span class="n">ATA_HORKAGE_IVB</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* cbl det validity bit bugs */</span>
	<span class="n">ATA_HORKAGE_STUCK_ERR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>	<span class="cm">/* stuck ERR on next PACKET */</span>
	<span class="n">ATA_HORKAGE_BRIDGE_OK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>	<span class="cm">/* no bridge limits */</span>
	<span class="n">ATA_HORKAGE_ATAPI_MOD16_DMA</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span> <span class="cm">/* use ATAPI DMA for commands</span>
<span class="cm">						    not multiple of 16 bytes */</span>
	<span class="n">ATA_HORKAGE_FIRMWARE_WARN</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>	<span class="cm">/* firmware update warning */</span>
	<span class="n">ATA_HORKAGE_1_5_GBPS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>	<span class="cm">/* force 1.5 Gbps */</span>
	<span class="n">ATA_HORKAGE_NOSETXFER</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span>	<span class="cm">/* skip SETXFER, SATA only */</span>
	<span class="n">ATA_HORKAGE_BROKEN_FPDMA_AA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>	<span class="cm">/* skip AA */</span>
	<span class="n">ATA_HORKAGE_DUMP_ID</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>	<span class="cm">/* dump IDENTIFY data */</span>

	 <span class="cm">/* DMA mask for user DMA control: User visible values; DO NOT</span>
<span class="cm">	    renumber */</span>
	<span class="n">ATA_DMA_MASK_ATA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* DMA on ATA Disk */</span>
	<span class="n">ATA_DMA_MASK_ATAPI</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* DMA on ATAPI */</span>
	<span class="n">ATA_DMA_MASK_CFA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* DMA on CF Card */</span>

	<span class="cm">/* ATAPI command types */</span>
	<span class="n">ATAPI_READ</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* READs */</span>
	<span class="n">ATAPI_WRITE</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* WRITEs */</span>
	<span class="n">ATAPI_READ_CD</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>		<span class="cm">/* READ CD [MSF] */</span>
	<span class="n">ATAPI_PASS_THRU</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>		<span class="cm">/* SAT pass-thru */</span>
	<span class="n">ATAPI_MISC</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>		<span class="cm">/* the rest */</span>

	<span class="cm">/* Timing constants */</span>
	<span class="n">ATA_TIMING_SETUP</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">ATA_TIMING_ACT8B</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">ATA_TIMING_REC8B</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">ATA_TIMING_CYC8B</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">ATA_TIMING_8BIT</span>		<span class="o">=</span> <span class="n">ATA_TIMING_ACT8B</span> <span class="o">|</span> <span class="n">ATA_TIMING_REC8B</span> <span class="o">|</span>
				  <span class="n">ATA_TIMING_CYC8B</span><span class="p">,</span>
	<span class="n">ATA_TIMING_ACTIVE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="n">ATA_TIMING_RECOVER</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="n">ATA_TIMING_DMACK_HOLD</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
	<span class="n">ATA_TIMING_CYCLE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
	<span class="n">ATA_TIMING_UDMA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	<span class="n">ATA_TIMING_ALL</span>		<span class="o">=</span> <span class="n">ATA_TIMING_SETUP</span> <span class="o">|</span> <span class="n">ATA_TIMING_ACT8B</span> <span class="o">|</span>
				  <span class="n">ATA_TIMING_REC8B</span> <span class="o">|</span> <span class="n">ATA_TIMING_CYC8B</span> <span class="o">|</span>
				  <span class="n">ATA_TIMING_ACTIVE</span> <span class="o">|</span> <span class="n">ATA_TIMING_RECOVER</span> <span class="o">|</span>
				  <span class="n">ATA_TIMING_DMACK_HOLD</span> <span class="o">|</span> <span class="n">ATA_TIMING_CYCLE</span> <span class="o">|</span>
				  <span class="n">ATA_TIMING_UDMA</span><span class="p">,</span>

	<span class="cm">/* ACPI constants */</span>
	<span class="n">ATA_ACPI_FILTER_SETXFER</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ATA_ACPI_FILTER_LOCK</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ATA_ACPI_FILTER_DIPM</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">ATA_ACPI_FILTER_FPDMA_OFFSET</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* FPDMA non-zero offset */</span>
	<span class="n">ATA_ACPI_FILTER_FPDMA_AA</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* FPDMA auto activate */</span>

	<span class="n">ATA_ACPI_FILTER_DEFAULT</span>	<span class="o">=</span> <span class="n">ATA_ACPI_FILTER_SETXFER</span> <span class="o">|</span>
				  <span class="n">ATA_ACPI_FILTER_LOCK</span> <span class="o">|</span>
				  <span class="n">ATA_ACPI_FILTER_DIPM</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ata_xfer_mask</span> <span class="p">{</span>
	<span class="n">ATA_MASK_PIO</span>		<span class="o">=</span> <span class="p">((</span><span class="mi">1LU</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_NR_PIO_MODES</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">,</span>
	<span class="n">ATA_MASK_MWDMA</span>		<span class="o">=</span> <span class="p">((</span><span class="mi">1LU</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_NR_MWDMA_MODES</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_MWDMA</span><span class="p">,</span>
	<span class="n">ATA_MASK_UDMA</span>		<span class="o">=</span> <span class="p">((</span><span class="mi">1LU</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_NR_UDMA_MODES</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_UDMA</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">hsm_task_states</span> <span class="p">{</span>
	<span class="n">HSM_ST_IDLE</span><span class="p">,</span>		<span class="cm">/* no command on going */</span>
	<span class="n">HSM_ST_FIRST</span><span class="p">,</span>		<span class="cm">/* (waiting the device to)</span>
<span class="cm">				   write CDB or first data block */</span>
	<span class="n">HSM_ST</span><span class="p">,</span>			<span class="cm">/* (waiting the device to) transfer data */</span>
	<span class="n">HSM_ST_LAST</span><span class="p">,</span>		<span class="cm">/* (waiting the device to) complete command */</span>
	<span class="n">HSM_ST_ERR</span><span class="p">,</span>		<span class="cm">/* error */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ata_completion_errors</span> <span class="p">{</span>
	<span class="n">AC_ERR_DEV</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* device reported error */</span>
	<span class="n">AC_ERR_HSM</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* host state machine violation */</span>
	<span class="n">AC_ERR_TIMEOUT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="cm">/* timeout */</span>
	<span class="n">AC_ERR_MEDIA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span> <span class="cm">/* media error */</span>
	<span class="n">AC_ERR_ATA_BUS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="cm">/* ATA bus error */</span>
	<span class="n">AC_ERR_HOST_BUS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="cm">/* host bus error */</span>
	<span class="n">AC_ERR_SYSTEM</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="cm">/* system error */</span>
	<span class="n">AC_ERR_INVALID</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="cm">/* invalid argument */</span>
	<span class="n">AC_ERR_OTHER</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="cm">/* unknown */</span>
	<span class="n">AC_ERR_NODEV_HINT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span> <span class="cm">/* polling device detection hint */</span>
	<span class="n">AC_ERR_NCQ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span> <span class="cm">/* marker for offending NCQ qc */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Link power management policy: If you alter this, you also need to</span>
<span class="cm"> * alter libata-scsi.c (for the ascii descriptions)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ata_lpm_policy</span> <span class="p">{</span>
	<span class="n">ATA_LPM_UNKNOWN</span><span class="p">,</span>
	<span class="n">ATA_LPM_MAX_POWER</span><span class="p">,</span>
	<span class="n">ATA_LPM_MED_POWER</span><span class="p">,</span>
	<span class="n">ATA_LPM_MIN_POWER</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ata_lpm_hints</span> <span class="p">{</span>
	<span class="n">ATA_LPM_EMPTY</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* port empty/probing */</span>
	<span class="n">ATA_LPM_HIPM</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* may use HIPM */</span>
<span class="p">};</span>

<span class="cm">/* forward declarations */</span>
<span class="k">struct</span> <span class="n">scsi_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ata_port_operations</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ata_port</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ata_link</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ata_queued_cmd</span><span class="p">;</span>

<span class="cm">/* typedefs */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ata_qc_cb_t</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ata_prereset_fn_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ata_reset_fn_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ata_postreset_fn_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_link_power_management_policy</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_unload_heads</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_em_message_type</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_em_message</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_attr_sw_activity</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">sw_activity</span> <span class="p">{</span>
	<span class="n">OFF</span><span class="p">,</span>
	<span class="n">BLINK_ON</span><span class="p">,</span>
	<span class="n">BLINK_OFF</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_ATA_SFF</span>
<span class="k">struct</span> <span class="n">ata_ioports</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">cmd_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">data_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">error_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">feature_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">nsect_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">lbal_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">lbam_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">lbah_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">device_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">status_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">command_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">altstatus_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">ctl_addr</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ATA_BMDMA</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">bmdma_addr</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_BMDMA */</span><span class="cp"></span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">scr_addr</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_SFF */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ata_host</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> 		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="k">const</span>	<span class="o">*</span><span class="n">iomap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">n_ports</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">eh_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">eh_owner</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ATA_ACPI</span>
	<span class="n">acpi_handle</span>		<span class="n">acpi_handle</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">ata_port</span>		<span class="o">*</span><span class="n">simplex_claimed</span><span class="p">;</span>	<span class="cm">/* channel owning the DMA */</span>
	<span class="k">struct</span> <span class="n">ata_port</span>		<span class="o">*</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span>		<span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">scsidone</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">ata_taskfile</span>	<span class="n">tf</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">cdb</span><span class="p">[</span><span class="n">ATAPI_CDB_LEN</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* ATA_QCFLAG_xxx */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">tag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">n_elem</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">orig_n_elem</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">dma_dir</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sect_size</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nbytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">extrabytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">curbytes</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="n">sgent</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">cursg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cursg_ofs</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">err_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span>	<span class="n">result_tf</span><span class="p">;</span>
	<span class="n">ata_qc_cb_t</span>		<span class="n">complete_fn</span><span class="p">;</span>

	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">lldd_task</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_port_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">unhandled_irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">idle_irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">rw_reqbuf</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_ering_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">eflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">err_mask</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">timestamp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_ering</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">cursor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_ering_entry</span>	<span class="n">ring</span><span class="p">[</span><span class="n">ATA_ERING_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span>		<span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">devno</span><span class="p">;</span>		<span class="cm">/* 0 or 1 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">horkage</span><span class="p">;</span>	<span class="cm">/* List of broken features */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* ATA_DFLAG_xxx */</span>
	<span class="k">struct</span> <span class="n">scsi_device</span>	<span class="o">*</span><span class="n">sdev</span><span class="p">;</span>		<span class="cm">/* attached SCSI device */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ATA_ACPI</span>
	<span class="n">acpi_handle</span>		<span class="n">acpi_handle</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">acpi_object</span>	<span class="o">*</span><span class="n">gtf_cache</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">gtf_filter</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">tdev</span><span class="p">;</span>
	<span class="cm">/* n_sector is CLEAR_BEGIN, read comment above CLEAR_BEGIN */</span>
	<span class="n">u64</span>			<span class="n">n_sectors</span><span class="p">;</span>	<span class="cm">/* size of device, if ATA */</span>
	<span class="n">u64</span>			<span class="n">n_native_sectors</span><span class="p">;</span> <span class="cm">/* native size, if ATA */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">class</span><span class="p">;</span>		<span class="cm">/* ATA_DEV_xxx */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">unpark_deadline</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">pio_mode</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">dma_mode</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">xfer_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">xfer_shift</span><span class="p">;</span>	<span class="cm">/* ATA_SHIFT_xxx */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">multi_count</span><span class="p">;</span>	<span class="cm">/* sectors count for</span>
<span class="cm">						   READ/WRITE MULTIPLE */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_sectors</span><span class="p">;</span>	<span class="cm">/* per-device max sectors */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cdb_len</span><span class="p">;</span>

	<span class="cm">/* per-dev xfer mask */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pio_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mwdma_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">udma_mask</span><span class="p">;</span>

	<span class="cm">/* for CHS addressing */</span>
	<span class="n">u16</span>			<span class="n">cylinders</span><span class="p">;</span>	<span class="cm">/* Number of cylinders */</span>
	<span class="n">u16</span>			<span class="n">heads</span><span class="p">;</span>		<span class="cm">/* Number of heads */</span>
	<span class="n">u16</span>			<span class="n">sectors</span><span class="p">;</span>	<span class="cm">/* Number of sectors per track */</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u16</span>		<span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_WORDS</span><span class="p">];</span> <span class="cm">/* IDENTIFY xxx DEVICE data */</span>
		<span class="n">u32</span>		<span class="n">gscr</span><span class="p">[</span><span class="n">SATA_PMP_GSCR_DWORDS</span><span class="p">];</span> <span class="cm">/* PMP GSCR block */</span>
	<span class="p">};</span>

	<span class="cm">/* error history */</span>
	<span class="kt">int</span>			<span class="n">spdn_cnt</span><span class="p">;</span>
	<span class="cm">/* ering is CLEAR_END, read comment above CLEAR_END */</span>
	<span class="k">struct</span> <span class="n">ata_ering</span>	<span class="n">ering</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Fields between ATA_DEVICE_CLEAR_BEGIN and ATA_DEVICE_CLEAR_END are</span>
<span class="cm"> * cleared to zero on ata_dev_init().</span>
<span class="cm"> */</span>
<span class="cp">#define ATA_DEVICE_CLEAR_BEGIN		offsetof(struct ata_device, n_sectors)</span>
<span class="cp">#define ATA_DEVICE_CLEAR_END		offsetof(struct ata_device, ering)</span>

<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* offending device */</span>
	<span class="n">u32</span>			<span class="n">serror</span><span class="p">;</span>		<span class="cm">/* SError from LLDD */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">err_mask</span><span class="p">;</span>	<span class="cm">/* port-wide err_mask */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">action</span><span class="p">;</span>		<span class="cm">/* ATA_EH_* action mask */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">dev_action</span><span class="p">[</span><span class="n">ATA_MAX_DEVICES</span><span class="p">];</span> <span class="cm">/* dev EH action */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* ATA_EHI_* flags */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">probe_mask</span><span class="p">;</span>

	<span class="kt">char</span>			<span class="n">desc</span><span class="p">[</span><span class="n">ATA_EH_DESC_LEN</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">desc_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span>	<span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">tries</span><span class="p">[</span><span class="n">ATA_MAX_DEVICES</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">cmd_timeout_idx</span><span class="p">[</span><span class="n">ATA_MAX_DEVICES</span><span class="p">]</span>
					       <span class="p">[</span><span class="n">ATA_EH_CMD_TIMEOUT_TABLE_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">classes</span><span class="p">[</span><span class="n">ATA_MAX_DEVICES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">did_probe_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">unloaded_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">saved_ncq_enabled</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">saved_xfer_mode</span><span class="p">[</span><span class="n">ATA_MAX_DEVICES</span><span class="p">];</span>
	<span class="cm">/* timestamp for the last reset attempt or success */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_reset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_acpi_drive</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dma</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_acpi_drive</span> <span class="n">drive</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ata_link</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span>		<span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pmp</span><span class="p">;</span>		<span class="cm">/* port multiplier port # */</span>

	<span class="k">struct</span> <span class="n">device</span>		<span class="n">tdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">active_tag</span><span class="p">;</span>	<span class="cm">/* active tag on this link */</span>
	<span class="n">u32</span>			<span class="n">sactive</span><span class="p">;</span>	<span class="cm">/* active NCQ commands */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* ATA_LFLAG_xxx */</span>

	<span class="n">u32</span>			<span class="n">saved_scontrol</span><span class="p">;</span>	<span class="cm">/* SControl on probe */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">hw_sata_spd_limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sata_spd_limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sata_spd</span><span class="p">;</span>	<span class="cm">/* current SATA PHY speed */</span>
	<span class="k">enum</span> <span class="n">ata_lpm_policy</span>	<span class="n">lpm_policy</span><span class="p">;</span>

	<span class="cm">/* record runtime error info, protected by host_set lock */</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span>	<span class="n">eh_info</span><span class="p">;</span>
	<span class="cm">/* EH context */</span>
	<span class="k">struct</span> <span class="n">ata_eh_context</span>	<span class="n">eh_context</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ata_device</span>	<span class="n">device</span><span class="p">[</span><span class="n">ATA_MAX_DEVICES</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)</span>
<span class="cp">#define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])</span>

<span class="k">struct</span> <span class="n">ata_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>	<span class="o">*</span><span class="n">scsi_host</span><span class="p">;</span> <span class="cm">/* our co-allocated scsi host */</span>
	<span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="cm">/* Flags owned by the EH context. Only EH should touch these once the</span>
<span class="cm">	   port is active */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>	<span class="cm">/* ATA_FLAG_xxx */</span>
	<span class="cm">/* Flags that change dynamically, protected by ap-&gt;lock */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pflags</span><span class="p">;</span> <span class="cm">/* ATA_PFLAG_xxx */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">print_id</span><span class="p">;</span> <span class="cm">/* user visible unique port ID */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">port_no</span><span class="p">;</span> <span class="cm">/* 0 based port no. inside the host */</span>

<span class="cp">#ifdef CONFIG_ATA_SFF</span>
	<span class="k">struct</span> <span class="n">ata_ioports</span>	<span class="n">ioaddr</span><span class="p">;</span>	<span class="cm">/* ATA cmd/ctl/dma register blocks */</span>
	<span class="n">u8</span>			<span class="n">ctl</span><span class="p">;</span>	<span class="cm">/* cache of ATA control register */</span>
	<span class="n">u8</span>			<span class="n">last_ctl</span><span class="p">;</span>	<span class="cm">/* Cache last written value */</span>
	<span class="k">struct</span> <span class="n">ata_link</span><span class="o">*</span>	<span class="n">sff_pio_task_link</span><span class="p">;</span> <span class="cm">/* link currently used */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">sff_pio_task</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ATA_BMDMA</span>
	<span class="k">struct</span> <span class="n">ata_bmdma_prd</span>	<span class="o">*</span><span class="n">bmdma_prd</span><span class="p">;</span>	<span class="cm">/* BMDMA SG list */</span>
	<span class="n">dma_addr_t</span>		<span class="n">bmdma_prd_dma</span><span class="p">;</span>	<span class="cm">/* and its DMA mapping */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_BMDMA */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_SFF */</span><span class="cp"></span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">pio_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">mwdma_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">udma_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cbl</span><span class="p">;</span>	<span class="cm">/* cable type; ATA_CBL_xxx */</span>

	<span class="k">struct</span> <span class="n">ata_queued_cmd</span>	<span class="n">qcmd</span><span class="p">[</span><span class="n">ATA_MAX_QUEUE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">qc_allocated</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">qc_active</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nr_active_links</span><span class="p">;</span> <span class="cm">/* #links with active qcs */</span>

	<span class="k">struct</span> <span class="n">ata_link</span>		<span class="n">link</span><span class="p">;</span>		<span class="cm">/* host default link */</span>
	<span class="k">struct</span> <span class="n">ata_link</span>		<span class="o">*</span><span class="n">slave_link</span><span class="p">;</span>	<span class="cm">/* see ata_slave_link_init() */</span>

	<span class="kt">int</span>			<span class="n">nr_pmp_links</span><span class="p">;</span>	<span class="cm">/* nr of available PMP links */</span>
	<span class="k">struct</span> <span class="n">ata_link</span>		<span class="o">*</span><span class="n">pmp_link</span><span class="p">;</span>	<span class="cm">/* array of PMP links */</span>
	<span class="k">struct</span> <span class="n">ata_link</span>		<span class="o">*</span><span class="n">excl_link</span><span class="p">;</span>	<span class="cm">/* for PMP qc exclusion */</span>

	<span class="k">struct</span> <span class="n">ata_port_stats</span>	<span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span>		<span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> 		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">tdev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">scsi_scan_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">hotplug_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">scsi_rescan_task</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">hsm_task_state</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">msg_enable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">eh_done_q</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">eh_wait_q</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">eh_tries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">park_req_pending</span><span class="p">;</span>

	<span class="n">pm_message_t</span>		<span class="n">pm_mesg</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">pm_result</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ata_lpm_policy</span>	<span class="n">target_lpm_policy</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">fastdrain_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">fastdrain_cnt</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">em_message_type</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ATA_ACPI</span>
	<span class="n">acpi_handle</span>		<span class="n">acpi_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_acpi_gtm</span>	<span class="n">__acpi_init_gtm</span><span class="p">;</span> <span class="cm">/* use ata_acpi_init_gtm() */</span>
<span class="cp">#endif</span>
	<span class="cm">/* owned by EH */</span>
	<span class="n">u8</span>			<span class="n">sector_buf</span><span class="p">[</span><span class="n">ATA_SECT_SIZE</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The following initializer overrides a method to NULL whether one of</span>
<span class="cm"> * its parent has the method defined or not.  This is equivalent to</span>
<span class="cm"> * ERR_PTR(-ENOENT).  Unfortunately, ERR_PTR doesn&#39;t render a constant</span>
<span class="cm"> * expression and thus can&#39;t be used as an initializer.</span>
<span class="cm"> */</span>
<span class="cp">#define ATA_OP_NULL		(void *)(unsigned long)(-ENOENT)</span>

<span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Command execution</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">qc_defer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">check_atapi_dma</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">qc_prep</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">qc_issue</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">qc_fill_rtf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configuration and exception handling</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">cable_detect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">mode_filter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_piomode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_dmamode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">set_mode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">**</span><span class="n">r_failed_dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_id</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dev_config</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freeze</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">thaw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">ata_prereset_fn_t</span>	<span class="n">prereset</span><span class="p">;</span>
	<span class="n">ata_reset_fn_t</span>		<span class="n">softreset</span><span class="p">;</span>
	<span class="n">ata_reset_fn_t</span>		<span class="n">hardreset</span><span class="p">;</span>
	<span class="n">ata_postreset_fn_t</span>	<span class="n">postreset</span><span class="p">;</span>
	<span class="n">ata_prereset_fn_t</span>	<span class="n">pmp_prereset</span><span class="p">;</span>
	<span class="n">ata_reset_fn_t</span>		<span class="n">pmp_softreset</span><span class="p">;</span>
	<span class="n">ata_reset_fn_t</span>		<span class="n">pmp_hardreset</span><span class="p">;</span>
	<span class="n">ata_postreset_fn_t</span>	<span class="n">pmp_postreset</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">error_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lost_interrupt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">post_internal_cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optional features</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">scr_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">scr_write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pmp_attach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pmp_detach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">set_lpm</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ata_lpm_policy</span> <span class="n">policy</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">hints</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start, stop, suspend and resume</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">port_suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">port_resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">port_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">port_stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">host_stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ATA_SFF</span>
	<span class="cm">/*</span>
<span class="cm">	 * SFF / taskfile oriented ops</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_dev_select</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_set_devctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ctl</span><span class="p">);</span>
	<span class="n">u8</span>   <span class="p">(</span><span class="o">*</span><span class="n">sff_check_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">u8</span>   <span class="p">(</span><span class="o">*</span><span class="n">sff_check_altstatus</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_tf_load</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_tf_read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_exec_command</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_data_xfer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_irq_on</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_irq_check</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_irq_clear</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sff_drain_fifo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ATA_BMDMA</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bmdma_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bmdma_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bmdma_stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
	<span class="n">u8</span>   <span class="p">(</span><span class="o">*</span><span class="n">bmdma_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_BMDMA */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_SFF */</span><span class="cp"></span>

	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">em_show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">em_store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">sw_activity_show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">sw_activity_store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">sw_activity</span> <span class="n">val</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Obsolete</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">phy_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">eng_timeout</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * -&gt;inherits must be the last field and all the preceding</span>
<span class="cm">	 * fields must be pointers.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span>	<span class="o">*</span><span class="n">inherits</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_port_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">link_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">pio_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mwdma_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">udma_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="o">*</span><span class="n">port_ops</span><span class="p">;</span>
	<span class="kt">void</span> 			<span class="o">*</span><span class="n">private_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_timing</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mode</span><span class="p">;</span>		<span class="cm">/* ATA mode */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">setup</span><span class="p">;</span>		<span class="cm">/* t1 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">act8b</span><span class="p">;</span>		<span class="cm">/* t2 for 8-bit I/O */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">rec8b</span><span class="p">;</span>		<span class="cm">/* t2i for 8-bit I/O */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cyc8b</span><span class="p">;</span>		<span class="cm">/* t0 for 8-bit I/O */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">active</span><span class="p">;</span>		<span class="cm">/* t2 or tD */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">recover</span><span class="p">;</span>		<span class="cm">/* t2i or tK */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dmack_hold</span><span class="p">;</span>	<span class="cm">/* tj */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cycle</span><span class="p">;</span>		<span class="cm">/* t0 */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">udma</span><span class="p">;</span>		<span class="cm">/* t2CYCTYP/2 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Core layer - drivers/ata/libata-core.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sata_deb_timing_normal</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sata_deb_timing_hotplug</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sata_deb_timing_long</span><span class="p">[];</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_dummy_port_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="n">ata_dummy_port_info</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span>
<span class="nf">sata_ehc_deb_timing</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="o">*</span><span class="n">ehc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_EHI_HOTPLUGGED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sata_deb_timing_hotplug</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">sata_deb_timing_normal</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_port_is_dummy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ata_dummy_port_ops</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_set_spd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_std_prereset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_wait_after_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_link_debounce</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_link_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_link_scr_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ata_lpm_policy</span> <span class="n">policy</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">spm_wakeup</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_link_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">,</span>
			<span class="n">bool</span> <span class="o">*</span><span class="n">online</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_std_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_std_postreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">ata_host_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_ports</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">ata_host_alloc_pinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ppi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_ports</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_slave_link_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_host_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_host_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_host_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
			     <span class="n">irq_handler_t</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_host_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_host_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_scsi_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_scsi_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_scsi_queuecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sas_scsi_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sas_port_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ata_sas_port_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sas_async_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sas_sync_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sas_port_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sas_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sas_port_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sas_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sas_queuecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_scr_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_scr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_scr_write_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">ata_link_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">ata_link_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_host_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_host_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_ratelimit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_msleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">ata_wait_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">atapi_cmd_type</span><span class="p">(</span><span class="n">u8</span> <span class="n">opcode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_tf_to_fis</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="n">pmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">fis</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_tf_from_fis</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">fis</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pio_mask</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mwdma_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">udma_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_unpack_xfermask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pio_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mwdma_mask</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">udma_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">ata_xfer_mask2mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ata_xfer_mode2mask</span><span class="p">(</span><span class="n">u8</span> <span class="n">xfer_mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_xfer_mode2shift</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ata_mode_string</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ata_id_xfermask</span><span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_std_qc_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_noop_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sg_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_elem</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_dev_classify</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_dev_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_id_string</span><span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_id_c_string</span><span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_do_dev_read_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_qc_complete_multiple</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">qc_active</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_scsi_simulate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_std_bios_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			      <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">geom</span><span class="p">[]);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_scsi_unlock_native_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_scsi_slave_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_scsi_slave_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_scsi_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">queue_depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ata_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">queue_depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">ata_dev_pair</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_do_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">**</span><span class="n">r_failed_dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_scsi_port_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_scsi_cmd_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">eh_q</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_cable_40wire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_cable_80wire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_cable_sata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_cable_ignore</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_cable_unknown</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>

<span class="cm">/* Timing helpers */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_pio_need_iordy</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">ata_timing_find_mode</span><span class="p">(</span><span class="n">u8</span> <span class="n">xfer_mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_timing_compute</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_timing_merge</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">ata_timing_cycle2mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xfer_shift</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cycle</span><span class="p">);</span>

<span class="cm">/* PCI */</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">struct</span> <span class="n">pci_dev</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pci_bits</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">reg</span><span class="p">;</span>	<span class="cm">/* PCI config register to read */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">width</span><span class="p">;</span>	<span class="cm">/* 1 (8 bit), 2 (16 bit), 4 (32 bit) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pci_test_config_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_bits</span> <span class="o">*</span><span class="n">bits</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_pci_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_pci_device_do_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="n">ata_pci_device_do_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_device_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_device_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ACPI - drivers/ata/libata-acpi.c</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_ATA_ACPI</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="nf">ata_acpi_init_gtm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_INIT_GTM_VALID</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">__acpi_init_gtm</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">ata_acpi_stm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="n">stm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ata_acpi_gtm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="n">stm</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ata_acpi_gtm_xfermask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="n">gtm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ata_acpi_cbl_80wire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="n">gtm</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="nf">ata_acpi_init_gtm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_acpi_stm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="n">stm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_acpi_gtm</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="n">stm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_acpi_gtm_xfermask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="n">gtm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_acpi_cbl_80wire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_acpi_gtm</span> <span class="o">*</span><span class="n">gtm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * EH - drivers/ata/libata-eh.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_port_wait_eh</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_link_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_port_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_port_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_async_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_eh_freeze_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_eh_thaw_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_eh_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_eh_qc_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_eh_analyze_ncq_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_do_eh</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">ata_prereset_fn_t</span> <span class="n">prereset</span><span class="p">,</span>
		      <span class="n">ata_reset_fn_t</span> <span class="n">softreset</span><span class="p">,</span> <span class="n">ata_reset_fn_t</span> <span class="n">hardreset</span><span class="p">,</span>
		      <span class="n">ata_postreset_fn_t</span> <span class="n">postreset</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_std_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_link_nr_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Base operations to inherit from and initializers for sht</span>
<span class="cm"> *</span>
<span class="cm"> * Operations</span>
<span class="cm"> *</span>
<span class="cm"> * base  : Common to all libata drivers.</span>
<span class="cm"> * sata  : SATA controllers w/ native interface.</span>
<span class="cm"> * pmp   : SATA controllers w/ PMP support.</span>
<span class="cm"> * sff   : SFF ATA controllers w/o BMDMA support.</span>
<span class="cm"> * bmdma : SFF ATA controllers w/ BMDMA support.</span>
<span class="cm"> *</span>
<span class="cm"> * sht initializers</span>
<span class="cm"> *</span>
<span class="cm"> * BASE  : Common to all libata drivers.  The user must set</span>
<span class="cm"> *	   sg_tablesize and dma_boundary.</span>
<span class="cm"> * PIO   : SFF ATA controllers w/ only PIO support.</span>
<span class="cm"> * BMDMA : SFF ATA controllers w/ BMDMA support.  sg_tablesize and</span>
<span class="cm"> *	   dma_boundary are set to BMDMA limits.</span>
<span class="cm"> * NCQ   : SATA controllers supporting NCQ.  The user must set</span>
<span class="cm"> *	   sg_tablesize, dma_boundary and can_queue.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_base_port_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">sata_port_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">ata_common_sdev_attrs</span><span class="p">[];</span>

<span class="cp">#define ATA_BASE_SHT(drv_name)					\</span>
<span class="cp">	.module			= THIS_MODULE,			\</span>
<span class="cp">	.name			= drv_name,			\</span>
<span class="cp">	.ioctl			= ata_scsi_ioctl,		\</span>
<span class="cp">	.queuecommand		= ata_scsi_queuecmd,		\</span>
<span class="cp">	.can_queue		= ATA_DEF_QUEUE,		\</span>
<span class="cp">	.this_id		= ATA_SHT_THIS_ID,		\</span>
<span class="cp">	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,		\</span>
<span class="cp">	.emulated		= ATA_SHT_EMULATED,		\</span>
<span class="cp">	.use_clustering		= ATA_SHT_USE_CLUSTERING,	\</span>
<span class="cp">	.proc_name		= drv_name,			\</span>
<span class="cp">	.slave_configure	= ata_scsi_slave_config,	\</span>
<span class="cp">	.slave_destroy		= ata_scsi_slave_destroy,	\</span>
<span class="cp">	.bios_param		= ata_std_bios_param,		\</span>
<span class="cp">	.unlock_native_capacity	= ata_scsi_unlock_native_capacity, \</span>
<span class="cp">	.sdev_attrs		= ata_common_sdev_attrs</span>

<span class="cp">#define ATA_NCQ_SHT(drv_name)					\</span>
<span class="cp">	ATA_BASE_SHT(drv_name),					\</span>
<span class="cp">	.change_queue_depth	= ata_scsi_change_queue_depth</span>

<span class="cm">/*</span>
<span class="cm"> * PMP helpers</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SATA_PMP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sata_pmp_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PMP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sata_pmp_attached</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_pmp_links</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_is_host_link</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">link</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">||</span> <span class="n">link</span> <span class="o">==</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_SATA_PMP */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sata_pmp_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">sata_pmp_attached</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_is_host_link</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SATA_PMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sata_srst_pmp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sata_pmp_supported</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">SATA_PMP_CTRL_PORT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * printk helpers</span>
<span class="cm"> */</span>
<span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">ata_port_printk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">ata_link_printk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">ata_dev_printk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="cp">#define ata_port_err(ap, fmt, ...)				\</span>
<span class="cp">	ata_port_printk(ap, KERN_ERR, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_port_warn(ap, fmt, ...)				\</span>
<span class="cp">	ata_port_printk(ap, KERN_WARNING, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_port_notice(ap, fmt, ...)				\</span>
<span class="cp">	ata_port_printk(ap, KERN_NOTICE, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_port_info(ap, fmt, ...)				\</span>
<span class="cp">	ata_port_printk(ap, KERN_INFO, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_port_dbg(ap, fmt, ...)				\</span>
<span class="cp">	ata_port_printk(ap, KERN_DEBUG, fmt, ##__VA_ARGS__)</span>

<span class="cp">#define ata_link_err(link, fmt, ...)				\</span>
<span class="cp">	ata_link_printk(link, KERN_ERR, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_link_warn(link, fmt, ...)				\</span>
<span class="cp">	ata_link_printk(link, KERN_WARNING, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_link_notice(link, fmt, ...)				\</span>
<span class="cp">	ata_link_printk(link, KERN_NOTICE, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_link_info(link, fmt, ...)				\</span>
<span class="cp">	ata_link_printk(link, KERN_INFO, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_link_dbg(link, fmt, ...)				\</span>
<span class="cp">	ata_link_printk(link, KERN_DEBUG, fmt, ##__VA_ARGS__)</span>

<span class="cp">#define ata_dev_err(dev, fmt, ...)				\</span>
<span class="cp">	ata_dev_printk(dev, KERN_ERR, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_dev_warn(dev, fmt, ...)				\</span>
<span class="cp">	ata_dev_printk(dev, KERN_WARNING, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_dev_notice(dev, fmt, ...)				\</span>
<span class="cp">	ata_dev_printk(dev, KERN_NOTICE, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_dev_info(dev, fmt, ...)				\</span>
<span class="cp">	ata_dev_printk(dev, KERN_INFO, fmt, ##__VA_ARGS__)</span>
<span class="cp">#define ata_dev_dbg(dev, fmt, ...)				\</span>
<span class="cp">	ata_dev_printk(dev, KERN_DEBUG, fmt, ##__VA_ARGS__)</span>

<span class="kt">void</span> <span class="n">ata_print_version</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ata_eh_info helpers</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">__ata_ehi_push_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_ehi_clear_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_ehi_hotplugged</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">probe_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_MAX_DEVICES</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_EHI_HOTPLUGGED</span><span class="p">;</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span> <span class="o">|</span> <span class="n">ATA_EH_ENABLE_LINK</span><span class="p">;</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_ATA_BUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * port description helpers</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ata_port_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_port_pbar_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">offset</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_tag_valid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&lt;</span> <span class="n">ATA_MAX_QUEUE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_tag_internal</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">ATA_TAG_INTERNAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * device helpers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_class_enabled</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA</span> <span class="o">||</span> <span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI</span> <span class="o">||</span>
		<span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_PMP</span> <span class="o">||</span> <span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_SEMB</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_class_disabled</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA_UNSUP</span> <span class="o">||</span> <span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI_UNSUP</span> <span class="o">||</span>
		<span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_PMP_UNSUP</span> <span class="o">||</span> <span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_SEMB_UNSUP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_class_absent</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">ata_class_enabled</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ata_class_disabled</span><span class="p">(</span><span class="n">class</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_dev_enabled</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_class_enabled</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_dev_disabled</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_class_disabled</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_dev_absent</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_class_absent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * link helpers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_link_max_devices</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SLAVE_POSS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_link_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_tag_valid</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span><span class="p">)</span> <span class="o">||</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Iterators</span>
<span class="cm"> *</span>
<span class="cm"> * ATA_LITER_* constants are used to select link iteration mode and</span>
<span class="cm"> * ATA_DITER_* device iteration mode.</span>
<span class="cm"> *</span>
<span class="cm"> * For a custom iteration directly using ata_{link|dev}_next(), if</span>
<span class="cm"> * @link or @dev, respectively, is NULL, the first element is</span>
<span class="cm"> * returned.  @dev and @link can be any valid device or link and the</span>
<span class="cm"> * next element according to the iteration mode will be returned.</span>
<span class="cm"> * After the last element, NULL is returned.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ata_link_iter_mode</span> <span class="p">{</span>
	<span class="n">ATA_LITER_EDGE</span><span class="p">,</span>		<span class="cm">/* if present, PMP links only; otherwise,</span>
<span class="cm">				 * host link.  no slave link */</span>
	<span class="n">ATA_LITER_HOST_FIRST</span><span class="p">,</span>	<span class="cm">/* host link followed by PMP or slave links */</span>
	<span class="n">ATA_LITER_PMP_FIRST</span><span class="p">,</span>	<span class="cm">/* PMP links followed by host link,</span>
<span class="cm">				 * slave link still comes after host link */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ata_dev_iter_mode</span> <span class="p">{</span>
	<span class="n">ATA_DITER_ENABLED</span><span class="p">,</span>
	<span class="n">ATA_DITER_ENABLED_REVERSE</span><span class="p">,</span>
	<span class="n">ATA_DITER_ALL</span><span class="p">,</span>
	<span class="n">ATA_DITER_ALL_REVERSE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">ata_link_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">ata_link_iter_mode</span> <span class="n">mode</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">ata_dev_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">ata_dev_iter_mode</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Shortcut notation for iterations</span>
<span class="cm"> *</span>
<span class="cm"> * ata_for_each_link() iterates over each link of @ap according to</span>
<span class="cm"> * @mode.  @link points to the current link in the loop.  @link is</span>
<span class="cm"> * NULL after loop termination.  ata_for_each_dev() works the same way</span>
<span class="cm"> * except that it iterates over each device of @link.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the mode prefixes ATA_{L|D}ITER_ shouldn&#39;t need to be</span>
<span class="cm"> * specified when using the following shorthand notations.  Only the</span>
<span class="cm"> * mode itself (EDGE, HOST_FIRST, ENABLED, etc...) should be</span>
<span class="cm"> * specified.  This not only increases brevity but also makes it</span>
<span class="cm"> * impossible to use ATA_LITER_* for device iteration or vice-versa.</span>
<span class="cm"> */</span>
<span class="cp">#define ata_for_each_link(link, ap, mode) \</span>
<span class="cp">	for ((link) = ata_link_next(NULL, (ap), ATA_LITER_##mode); (link); \</span>
<span class="cp">	     (link) = ata_link_next((link), (ap), ATA_LITER_##mode))</span>

<span class="cp">#define ata_for_each_dev(dev, link, mode) \</span>
<span class="cp">	for ((dev) = ata_dev_next(NULL, (link), ATA_DITER_##mode); (dev); \</span>
<span class="cp">	     (dev) = ata_dev_next((dev), (link), ATA_DITER_##mode))</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_ncq_enabled - Test whether NCQ is enabled</span>
<span class="cm"> *	@dev: ATA device to test for</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	1 if NCQ is enabled for @dev, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_ncq_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_DFLAG_PIO</span> <span class="o">|</span> <span class="n">ATA_DFLAG_NCQ_OFF</span> <span class="o">|</span>
			      <span class="n">ATA_DFLAG_NCQ</span><span class="p">))</span> <span class="o">==</span> <span class="n">ATA_DFLAG_NCQ</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_qc_set_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">ctl</span> <span class="o">|=</span> <span class="n">ATA_NIEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="nf">__ata_qc_from_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
						       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ata_tag_valid</span><span class="p">(</span><span class="n">tag</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">qcmd</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="nf">ata_qc_from_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span> <span class="o">=</span> <span class="n">__ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">qc</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">qc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_QCFLAG_ACTIVE</span> <span class="o">|</span>
			  <span class="n">ATA_QCFLAG_FAILED</span><span class="p">))</span> <span class="o">==</span> <span class="n">ATA_QCFLAG_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">qc</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_qc_raw_nbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="n">min</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">extrabytes</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_tf_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tf</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_ATA_SFF</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">=</span> <span class="n">ATA_DEVCTL_OBS</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">ATA_DEVICE_OBS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">ATA_DEVICE_OBS</span> <span class="o">|</span> <span class="n">ATA_DEV1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_qc_reinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span> <span class="o">=</span> <span class="n">DMA_NONE</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">extrabytes</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">curbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span> <span class="o">=</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>

	<span class="n">ata_tf_init</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>

	<span class="cm">/* init result_tf such that it indicates normal completion */</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_DRDY</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_try_flush_cache</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_id_wcache_enabled</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">ata_id_has_flush</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">ata_id_has_flush_ext</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ac_err_mask</span><span class="p">(</span><span class="n">u8</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_BUSY</span> <span class="o">|</span> <span class="n">ATA_DRQ</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">AC_ERR_HSM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DF</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">AC_ERR_DEV</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__ac_err_mask</span><span class="p">(</span><span class="n">u8</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ac_err_mask</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AC_ERR_OTHER</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="nf">ata_shost_to_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_check_ready</span><span class="p">(</span><span class="n">u8</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* 0xff indicates either no device or device not ready */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ata_deadline</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from_jiffies</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout_msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">from_jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout_msecs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Don&#39;t open code these in drivers as there are traps. Firstly the range may</span>
<span class="cm">   change in future hardware and specs, secondly 0xFF means &#39;no DMA&#39; but is</span>
<span class="cm">   &gt; UDMA_0. Dyma ddreigiau */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_using_mwdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">&gt;=</span> <span class="n">XFER_MW_DMA_0</span> <span class="o">&amp;&amp;</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">&lt;=</span> <span class="n">XFER_MW_DMA_4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_using_udma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">&gt;=</span> <span class="n">XFER_UDMA_0</span> <span class="o">&amp;&amp;</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">&lt;=</span> <span class="n">XFER_UDMA_7</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_dma_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">==</span> <span class="mh">0xFF</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> * PMP - drivers/ata/libata-pmp.c</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SATA_PMP</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">sata_pmp_port_ops</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_pmp_qc_defer_cmd_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sata_pmp_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_SATA_PMP */</span><span class="cp"></span>

<span class="cp">#define sata_pmp_port_ops		sata_port_ops</span>
<span class="cp">#define sata_pmp_qc_defer_cmd_switch	ata_std_qc_defer</span>
<span class="cp">#define sata_pmp_error_handler		ata_std_error_handler</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SATA_PMP */</span><span class="cp"></span>


<span class="cm">/**************************************************************************</span>
<span class="cm"> * SFF - drivers/ata/libata-sff.c</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_ATA_SFF</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_sff_port_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_bmdma32_port_ops</span><span class="p">;</span>

<span class="cm">/* PIO only, sg_tablesize and dma_boundary limits can be removed */</span>
<span class="cp">#define ATA_PIO_SHT(drv_name)					\</span>
<span class="cp">	ATA_BASE_SHT(drv_name),					\</span>
<span class="cp">	.sg_tablesize		= LIBATA_MAX_PRD,		\</span>
<span class="cp">	.dma_boundary		= ATA_DMA_BOUNDARY</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_dev_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">ata_sff_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_dma_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sff_busy_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout_pat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sff_wait_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_tf_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_tf_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_exec_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_sff_data_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_sff_data_xfer32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_sff_data_xfer_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_irq_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_irq_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sff_hsm_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="n">status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_wq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_queue_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_queue_pio_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_sff_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">ata_sff_qc_fill_rtf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_sff_port_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">ata_sff_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_lost_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sff_prereset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_sff_dev_classify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">present</span><span class="p">,</span>
					  <span class="n">u8</span> <span class="o">*</span><span class="n">r_err</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sff_wait_after_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devmask</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_sff_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sata_sff_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_postreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_drain_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_sff_std_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_sff_init_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_sff_prepare_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ppi</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ata_host</span> <span class="o">**</span><span class="n">r_host</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_sff_activate_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
				     <span class="n">irq_handler_t</span> <span class="n">irq_handler</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_sff_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ppi</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">host_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hflags</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_ATA_BMDMA</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_bmdma_port_ops</span><span class="p">;</span>

<span class="cp">#define ATA_BMDMA_SHT(drv_name)					\</span>
<span class="cp">	ATA_BASE_SHT(drv_name),					\</span>
<span class="cp">	.sg_tablesize		= LIBATA_MAX_PRD,		\</span>
<span class="cp">	.dma_boundary		= ATA_DMA_BOUNDARY</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_bmdma_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_bmdma_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_bmdma_dumb_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_bmdma_port_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">ata_bmdma_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_bmdma_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_bmdma_post_internal_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_bmdma_irq_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_bmdma_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_bmdma_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_bmdma_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">ata_bmdma_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_bmdma_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_bmdma_port_start32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_bmdma_clear_simplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ata_pci_bmdma_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_bmdma_prepare_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ppi</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ata_host</span> <span class="o">**</span><span class="n">r_host</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ata_pci_bmdma_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ppi</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">host_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hflags</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_BMDMA */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_busy_wait - Wait for a port status register</span>
<span class="cm"> *	@ap: Port to wait for.</span>
<span class="cm"> *	@bits: bits that must be clear</span>
<span class="cm"> *	@max: number of 10uS waits to perform</span>
<span class="cm"> *</span>
<span class="cm"> *	Waits up to max*10 microseconds for the selected bits in the port&#39;s</span>
<span class="cm"> *	status register to be cleared.</span>
<span class="cm"> *	Returns final value of status register.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ata_sff_busy_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">max</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_wait_idle - Wait for a port to be idle.</span>
<span class="cm"> *	@ap: Port to wait for.</span>
<span class="cm"> *</span>
<span class="cm"> *	Waits up to 10ms for port&#39;s BUSY and DRQ signals to clear.</span>
<span class="cm"> *	Returns final value of status register.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ata_wait_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ata_sff_busy_wait</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_BUSY</span> <span class="o">|</span> <span class="n">ATA_DRQ</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>

<span class="cp">#ifdef ATA_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_BUSY</span> <span class="o">|</span> <span class="n">ATA_DRQ</span><span class="p">)))</span>
		<span class="n">ata_port_printk</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;abnormal Status 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_SFF */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_LIBATA_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
