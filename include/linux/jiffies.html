<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › jiffies.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jiffies.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_JIFFIES_H</span>
<span class="cp">#define _LINUX_JIFFIES_H</span>

<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;asm/param.h&gt;			</span><span class="cm">/* for HZ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The following defines establish the engineering parameters of the PLL</span>
<span class="cm"> * model. The HZ variable establishes the timer interrupt frequency, 100 Hz</span>
<span class="cm"> * for the SunOS kernel, 256 Hz for the Ultrix kernel and 1024 Hz for the</span>
<span class="cm"> * OSF/1 kernel. The SHIFT_HZ define expresses the same value as the</span>
<span class="cm"> * nearest power of two in order to avoid hardware multiply operations.</span>
<span class="cm"> */</span>
<span class="cp">#if HZ &gt;= 12 &amp;&amp; HZ &lt; 24</span>
<span class="cp"># define SHIFT_HZ	4</span>
<span class="cp">#elif HZ &gt;= 24 &amp;&amp; HZ &lt; 48</span>
<span class="cp"># define SHIFT_HZ	5</span>
<span class="cp">#elif HZ &gt;= 48 &amp;&amp; HZ &lt; 96</span>
<span class="cp"># define SHIFT_HZ	6</span>
<span class="cp">#elif HZ &gt;= 96 &amp;&amp; HZ &lt; 192</span>
<span class="cp"># define SHIFT_HZ	7</span>
<span class="cp">#elif HZ &gt;= 192 &amp;&amp; HZ &lt; 384</span>
<span class="cp"># define SHIFT_HZ	8</span>
<span class="cp">#elif HZ &gt;= 384 &amp;&amp; HZ &lt; 768</span>
<span class="cp"># define SHIFT_HZ	9</span>
<span class="cp">#elif HZ &gt;= 768 &amp;&amp; HZ &lt; 1536</span>
<span class="cp"># define SHIFT_HZ	10</span>
<span class="cp">#elif HZ &gt;= 1536 &amp;&amp; HZ &lt; 3072</span>
<span class="cp"># define SHIFT_HZ	11</span>
<span class="cp">#elif HZ &gt;= 3072 &amp;&amp; HZ &lt; 6144</span>
<span class="cp"># define SHIFT_HZ	12</span>
<span class="cp">#elif HZ &gt;= 6144 &amp;&amp; HZ &lt; 12288</span>
<span class="cp"># define SHIFT_HZ	13</span>
<span class="cp">#else</span>
<span class="cp"># error Invalid value of HZ.</span>
<span class="cp">#endif</span>

<span class="cm">/* LATCH is used in the interval timer and ftape setup. */</span>
<span class="cp">#define LATCH  ((CLOCK_TICK_RATE + HZ/2) / HZ)	</span><span class="cm">/* For divider */</span><span class="cp"></span>

<span class="cm">/* Suppose we want to divide two numbers NOM and DEN: NOM/DEN, then we can</span>
<span class="cm"> * improve accuracy by shifting LSH bits, hence calculating:</span>
<span class="cm"> *     (NOM &lt;&lt; LSH) / DEN</span>
<span class="cm"> * This however means trouble for large NOM, because (NOM &lt;&lt; LSH) may no</span>
<span class="cm"> * longer fit in 32 bits. The following way of calculating this gives us</span>
<span class="cm"> * some slack, under the following conditions:</span>
<span class="cm"> *   - (NOM / DEN) fits in (32 - LSH) bits.</span>
<span class="cm"> *   - (NOM % DEN) fits in (32 - LSH) bits.</span>
<span class="cm"> */</span>
<span class="cp">#define SH_DIV(NOM,DEN,LSH) (   (((NOM) / (DEN)) &lt;&lt; (LSH))              \</span>
<span class="cp">                             + ((((NOM) % (DEN)) &lt;&lt; (LSH)) + (DEN) / 2) / (DEN))</span>

<span class="cm">/* HZ is the requested value. ACTHZ is actual HZ (&quot;&lt;&lt; 8&quot; is for accuracy) */</span>
<span class="cp">#define ACTHZ (SH_DIV (CLOCK_TICK_RATE, LATCH, 8))</span>

<span class="cm">/* TICK_NSEC is the time between ticks in nsec assuming real ACTHZ */</span>
<span class="cp">#define TICK_NSEC (SH_DIV (1000000UL * 1000, ACTHZ, 8))</span>

<span class="cm">/* TICK_USEC is the time between ticks in usec assuming fake USER_HZ */</span>
<span class="cp">#define TICK_USEC ((1000000UL + USER_HZ/2) / USER_HZ)</span>

<span class="cm">/* TICK_USEC_TO_NSEC is the time between ticks in nsec assuming real ACTHZ and	*/</span>
<span class="cm">/* a value TUSEC for TICK_USEC (can be set bij adjtimex)		*/</span>
<span class="cp">#define TICK_USEC_TO_NSEC(TUSEC) (SH_DIV (TUSEC * USER_HZ * 1000, ACTHZ, 8))</span>

<span class="cm">/* some arch&#39;s have a small-data section that can be accessed register-relative</span>
<span class="cm"> * but that can only take up to, say, 4-byte variables. jiffies being part of</span>
<span class="cm"> * an 8-byte variable may not be correctly accessed unless we force the issue</span>
<span class="cm"> */</span>
<span class="cp">#define __jiffy_data  __attribute__((section(&quot;.data&quot;)))</span>

<span class="cm">/*</span>
<span class="cm"> * The 64-bit value is not atomic - you MUST NOT read it</span>
<span class="cm"> * without sampling the sequence number in xtime_lock.</span>
<span class="cm"> * get_jiffies_64() will do this for you as appropriate.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">__jiffy_data</span> <span class="n">jiffies_64</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">volatile</span> <span class="n">__jiffy_data</span> <span class="n">jiffies</span><span class="p">;</span>

<span class="cp">#if (BITS_PER_LONG &lt; 64)</span>
<span class="n">u64</span> <span class="n">get_jiffies_64</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">get_jiffies_64</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	These inlines deal with timer wrapping correctly. You are </span>
<span class="cm"> *	strongly encouraged to use them</span>
<span class="cm"> *	1. Because people otherwise forget</span>
<span class="cm"> *	2. Because if the timer wrap changes in future you won&#39;t have to</span>
<span class="cm"> *	   alter your driver code.</span>
<span class="cm"> *</span>
<span class="cm"> * time_after(a,b) returns true if the time a is after time b.</span>
<span class="cm"> *</span>
<span class="cm"> * Do this with &quot;&lt;0&quot; and &quot;&gt;=0&quot; to only test the sign of the result. A</span>
<span class="cm"> * good compiler would generate better code (and a really good compiler</span>
<span class="cm"> * wouldn&#39;t care). Gcc is currently neither.</span>
<span class="cm"> */</span>
<span class="cp">#define time_after(a,b)		\</span>
<span class="cp">	(typecheck(unsigned long, a) &amp;&amp; \</span>
<span class="cp">	 typecheck(unsigned long, b) &amp;&amp; \</span>
<span class="cp">	 ((long)(b) - (long)(a) &lt; 0))</span>
<span class="cp">#define time_before(a,b)	time_after(b,a)</span>

<span class="cp">#define time_after_eq(a,b)	\</span>
<span class="cp">	(typecheck(unsigned long, a) &amp;&amp; \</span>
<span class="cp">	 typecheck(unsigned long, b) &amp;&amp; \</span>
<span class="cp">	 ((long)(a) - (long)(b) &gt;= 0))</span>
<span class="cp">#define time_before_eq(a,b)	time_after_eq(b,a)</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate whether a is in the range of [b, c].</span>
<span class="cm"> */</span>
<span class="cp">#define time_in_range(a,b,c) \</span>
<span class="cp">	(time_after_eq(a,b) &amp;&amp; \</span>
<span class="cp">	 time_before_eq(a,c))</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate whether a is in the range of [b, c).</span>
<span class="cm"> */</span>
<span class="cp">#define time_in_range_open(a,b,c) \</span>
<span class="cp">	(time_after_eq(a,b) &amp;&amp; \</span>
<span class="cp">	 time_before(a,c))</span>

<span class="cm">/* Same as above, but does so with platform independent 64bit types.</span>
<span class="cm"> * These must be used when utilizing jiffies_64 (i.e. return value of</span>
<span class="cm"> * get_jiffies_64() */</span>
<span class="cp">#define time_after64(a,b)	\</span>
<span class="cp">	(typecheck(__u64, a) &amp;&amp;	\</span>
<span class="cp">	 typecheck(__u64, b) &amp;&amp; \</span>
<span class="cp">	 ((__s64)(b) - (__s64)(a) &lt; 0))</span>
<span class="cp">#define time_before64(a,b)	time_after64(b,a)</span>

<span class="cp">#define time_after_eq64(a,b)	\</span>
<span class="cp">	(typecheck(__u64, a) &amp;&amp; \</span>
<span class="cp">	 typecheck(__u64, b) &amp;&amp; \</span>
<span class="cp">	 ((__s64)(a) - (__s64)(b) &gt;= 0))</span>
<span class="cp">#define time_before_eq64(a,b)	time_after_eq64(b,a)</span>

<span class="cm">/*</span>
<span class="cm"> * These four macros compare jiffies and &#39;a&#39; for convenience.</span>
<span class="cm"> */</span>

<span class="cm">/* time_is_before_jiffies(a) return true if a is before jiffies */</span>
<span class="cp">#define time_is_before_jiffies(a) time_after(jiffies, a)</span>

<span class="cm">/* time_is_after_jiffies(a) return true if a is after jiffies */</span>
<span class="cp">#define time_is_after_jiffies(a) time_before(jiffies, a)</span>

<span class="cm">/* time_is_before_eq_jiffies(a) return true if a is before or equal to jiffies*/</span>
<span class="cp">#define time_is_before_eq_jiffies(a) time_after_eq(jiffies, a)</span>

<span class="cm">/* time_is_after_eq_jiffies(a) return true if a is after or equal to jiffies*/</span>
<span class="cp">#define time_is_after_eq_jiffies(a) time_before_eq(jiffies, a)</span>

<span class="cm">/*</span>
<span class="cm"> * Have the 32 bit jiffies value wrap 5 minutes after boot</span>
<span class="cm"> * so jiffies wrap bugs show up earlier.</span>
<span class="cm"> */</span>
<span class="cp">#define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))</span>

<span class="cm">/*</span>
<span class="cm"> * Change timeval to jiffies, trying to avoid the</span>
<span class="cm"> * most obvious overflows..</span>
<span class="cm"> *</span>
<span class="cm"> * And some not so obvious.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we don&#39;t want to return LONG_MAX, because</span>
<span class="cm"> * for various timeout reasons we often end up having</span>
<span class="cm"> * to wait &quot;jiffies+1&quot; in order to guarantee that we wait</span>
<span class="cm"> * at _least_ &quot;jiffies&quot; - so &quot;jiffies+1&quot; had better still</span>
<span class="cm"> * be positive.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_JIFFY_OFFSET ((LONG_MAX &gt;&gt; 1)-1)</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">preset_lpj</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We want to do realistic conversions of time so we need to use the same</span>
<span class="cm"> * values the update wall clock code uses as the jiffies size.  This value</span>
<span class="cm"> * is: TICK_NSEC (which is defined in timex.h).  This</span>
<span class="cm"> * is a constant and is in nanoseconds.  We will use scaled math</span>
<span class="cm"> * with a set of scales defined here as SEC_JIFFIE_SC,  USEC_JIFFIE_SC and</span>
<span class="cm"> * NSEC_JIFFIE_SC.  Note that these defines contain nothing but</span>
<span class="cm"> * constants and so are computed at compile time.  SHIFT_HZ (computed in</span>
<span class="cm"> * timex.h) adjusts the scaling for different HZ values.</span>

<span class="cm"> * Scaled math???  What is that?</span>
<span class="cm"> *</span>
<span class="cm"> * Scaled math is a way to do integer math on values that would,</span>
<span class="cm"> * otherwise, either overflow, underflow, or cause undesired div</span>
<span class="cm"> * instructions to appear in the execution path.  In short, we &quot;scale&quot;</span>
<span class="cm"> * up the operands so they take more bits (more precision, less</span>
<span class="cm"> * underflow), do the desired operation and then &quot;scale&quot; the result back</span>
<span class="cm"> * by the same amount.  If we do the scaling by shifting we avoid the</span>
<span class="cm"> * costly mpy and the dastardly div instructions.</span>

<span class="cm"> * Suppose, for example, we want to convert from seconds to jiffies</span>
<span class="cm"> * where jiffies is defined in nanoseconds as NSEC_PER_JIFFIE.  The</span>
<span class="cm"> * simple math is: jiff = (sec * NSEC_PER_SEC) / NSEC_PER_JIFFIE; We</span>
<span class="cm"> * observe that (NSEC_PER_SEC / NSEC_PER_JIFFIE) is a constant which we</span>
<span class="cm"> * might calculate at compile time, however, the result will only have</span>
<span class="cm"> * about 3-4 bits of precision (less for smaller values of HZ).</span>
<span class="cm"> *</span>
<span class="cm"> * So, we scale as follows:</span>
<span class="cm"> * jiff = (sec) * (NSEC_PER_SEC / NSEC_PER_JIFFIE);</span>
<span class="cm"> * jiff = ((sec) * ((NSEC_PER_SEC * SCALE)/ NSEC_PER_JIFFIE)) / SCALE;</span>
<span class="cm"> * Then we make SCALE a power of two so:</span>
<span class="cm"> * jiff = ((sec) * ((NSEC_PER_SEC &lt;&lt; SCALE)/ NSEC_PER_JIFFIE)) &gt;&gt; SCALE;</span>
<span class="cm"> * Now we define:</span>
<span class="cm"> * #define SEC_CONV = ((NSEC_PER_SEC &lt;&lt; SCALE)/ NSEC_PER_JIFFIE))</span>
<span class="cm"> * jiff = (sec * SEC_CONV) &gt;&gt; SCALE;</span>
<span class="cm"> *</span>
<span class="cm"> * Often the math we use will expand beyond 32-bits so we tell C how to</span>
<span class="cm"> * do this and pass the 64-bit result of the mpy through the &quot;&gt;&gt; SCALE&quot;</span>
<span class="cm"> * which should take the result back to 32-bits.  We want this expansion</span>
<span class="cm"> * to capture as much precision as possible.  At the same time we don&#39;t</span>
<span class="cm"> * want to overflow so we pick the SCALE to avoid this.  In this file,</span>
<span class="cm"> * that means using a different scale for each range of HZ values (as</span>
<span class="cm"> * defined in timex.h).</span>
<span class="cm"> *</span>
<span class="cm"> * For those who want to know, gcc will give a 64-bit result from a &quot;*&quot;</span>
<span class="cm"> * operator if the result is a long long AND at least one of the</span>
<span class="cm"> * operands is cast to long long (usually just prior to the &quot;*&quot; so as</span>
<span class="cm"> * not to confuse it into thinking it really has a 64-bit operand,</span>
<span class="cm"> * which, buy the way, it can do, but it takes more code and at least 2</span>
<span class="cm"> * mpys).</span>

<span class="cm"> * We also need to be aware that one second in nanoseconds is only a</span>
<span class="cm"> * couple of bits away from overflowing a 32-bit word, so we MUST use</span>
<span class="cm"> * 64-bits to get the full range time in nanoseconds.</span>

<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Here are the scales we will use.  One for seconds, nanoseconds and</span>
<span class="cm"> * microseconds.</span>
<span class="cm"> *</span>
<span class="cm"> * Within the limits of cpp we do a rough cut at the SEC_JIFFIE_SC and</span>
<span class="cm"> * check if the sign bit is set.  If not, we bump the shift count by 1.</span>
<span class="cm"> * (Gets an extra bit of precision where we can use it.)</span>
<span class="cm"> * We know it is set for HZ = 1024 and HZ = 100 not for 1000.</span>
<span class="cm"> * Haven&#39;t tested others.</span>

<span class="cm"> * Limits of cpp (for #if expressions) only long (no long long), but</span>
<span class="cm"> * then we only need the most signicant bit.</span>
<span class="cm"> */</span>

<span class="cp">#define SEC_JIFFIE_SC (31 - SHIFT_HZ)</span>
<span class="cp">#if !((((NSEC_PER_SEC &lt;&lt; 2) / TICK_NSEC) &lt;&lt; (SEC_JIFFIE_SC - 2)) &amp; 0x80000000)</span>
<span class="cp">#undef SEC_JIFFIE_SC</span>
<span class="cp">#define SEC_JIFFIE_SC (32 - SHIFT_HZ)</span>
<span class="cp">#endif</span>
<span class="cp">#define NSEC_JIFFIE_SC (SEC_JIFFIE_SC + 29)</span>
<span class="cp">#define USEC_JIFFIE_SC (SEC_JIFFIE_SC + 19)</span>
<span class="cp">#define SEC_CONVERSION ((unsigned long)((((u64)NSEC_PER_SEC &lt;&lt; SEC_JIFFIE_SC) +\</span>
<span class="cp">                                TICK_NSEC -1) / (u64)TICK_NSEC))</span>

<span class="cp">#define NSEC_CONVERSION ((unsigned long)((((u64)1 &lt;&lt; NSEC_JIFFIE_SC) +\</span>
<span class="cp">                                        TICK_NSEC -1) / (u64)TICK_NSEC))</span>
<span class="cp">#define USEC_CONVERSION  \</span>
<span class="cp">                    ((unsigned long)((((u64)NSEC_PER_USEC &lt;&lt; USEC_JIFFIE_SC) +\</span>
<span class="cp">                                        TICK_NSEC -1) / (u64)TICK_NSEC))</span>
<span class="cm">/*</span>
<span class="cm"> * USEC_ROUND is used in the timeval to jiffie conversion.  See there</span>
<span class="cm"> * for more details.  It is the scaled resolution rounding value.  Note</span>
<span class="cm"> * that it is a 64-bit value.  Since, when it is applied, we are already</span>
<span class="cm"> * in jiffies (albit scaled), it is nothing but the bits we will shift</span>
<span class="cm"> * off.</span>
<span class="cm"> */</span>
<span class="cp">#define USEC_ROUND (u64)(((u64)1 &lt;&lt; USEC_JIFFIE_SC) - 1)</span>
<span class="cm">/*</span>
<span class="cm"> * The maximum jiffie value is (MAX_INT &gt;&gt; 1).  Here we translate that</span>
<span class="cm"> * into seconds.  The 64-bit case will overflow if we are not careful,</span>
<span class="cm"> * so use the messy SH_DIV macro to do it.  Still all constants.</span>
<span class="cm"> */</span>
<span class="cp">#if BITS_PER_LONG &lt; 64</span>
<span class="cp"># define MAX_SEC_IN_JIFFIES \</span>
<span class="cp">	(long)((u64)((u64)MAX_JIFFY_OFFSET * TICK_NSEC) / NSEC_PER_SEC)</span>
<span class="cp">#else	</span><span class="cm">/* take care of overflow on 64 bits machines */</span><span class="cp"></span>
<span class="cp"># define MAX_SEC_IN_JIFFIES \</span>
<span class="cp">	(SH_DIV((MAX_JIFFY_OFFSET &gt;&gt; SEC_JIFFIE_SC) * TICK_NSEC, NSEC_PER_SEC, 1) - 1)</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Convert various time units to each other:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">usecs_to_jiffies</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timespec_to_jiffies</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jiffies_to_timespec</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeval_to_jiffies</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">jiffies_to_timeval</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">clock_t</span> <span class="n">jiffies_to_clock_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clock_t_to_jiffies</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">jiffies_64_to_clock_t</span><span class="p">(</span><span class="n">u64</span> <span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">nsec_to_clock_t</span><span class="p">(</span><span class="n">u64</span> <span class="n">x</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">nsecs_to_jiffies64</span><span class="p">(</span><span class="n">u64</span> <span class="n">n</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nsecs_to_jiffies</span><span class="p">(</span><span class="n">u64</span> <span class="n">n</span><span class="p">);</span>

<span class="cp">#define TIMESTAMP_SIZE	30</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
