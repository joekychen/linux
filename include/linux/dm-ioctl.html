<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › dm-ioctl.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dm-ioctl.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001 - 2003 Sistina Software (UK) Limited.</span>
<span class="cm"> * Copyright (C) 2004 - 2009 Red Hat, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the LGPL.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_DM_IOCTL_V4_H</span>
<span class="cp">#define _LINUX_DM_IOCTL_V4_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#define DM_DIR &quot;mapper&quot;		</span><span class="cm">/* Slashes not supported */</span><span class="cp"></span>
<span class="cp">#define DM_CONTROL_NODE &quot;control&quot;</span>
<span class="cp">#define DM_MAX_TYPE_NAME 16</span>
<span class="cp">#define DM_NAME_LEN 128</span>
<span class="cp">#define DM_UUID_LEN 129</span>

<span class="cm">/*</span>
<span class="cm"> * A traditional ioctl interface for the device mapper.</span>
<span class="cm"> *</span>
<span class="cm"> * Each device can have two tables associated with it, an</span>
<span class="cm"> * &#39;active&#39; table which is the one currently used by io passing</span>
<span class="cm"> * through the device, and an &#39;inactive&#39; one which is a table</span>
<span class="cm"> * that is being prepared as a replacement for the &#39;active&#39; one.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_VERSION:</span>
<span class="cm"> * Just get the version information for the ioctl interface.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_REMOVE_ALL:</span>
<span class="cm"> * Remove all dm devices, destroy all tables.  Only really used</span>
<span class="cm"> * for debug.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_LIST_DEVICES:</span>
<span class="cm"> * Get a list of all the dm device names.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_DEV_CREATE:</span>
<span class="cm"> * Create a new device, neither the &#39;active&#39; or &#39;inactive&#39; table</span>
<span class="cm"> * slots will be filled.  The device will be in suspended state</span>
<span class="cm"> * after creation, however any io to the device will get errored</span>
<span class="cm"> * since it will be out-of-bounds.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_DEV_REMOVE:</span>
<span class="cm"> * Remove a device, destroy any tables.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_DEV_RENAME:</span>
<span class="cm"> * Rename a device or set its uuid if none was previously supplied.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_SUSPEND:</span>
<span class="cm"> * This performs both suspend and resume, depending which flag is</span>
<span class="cm"> * passed in.</span>
<span class="cm"> * Suspend: This command will not return until all pending io to</span>
<span class="cm"> * the device has completed.  Further io will be deferred until</span>
<span class="cm"> * the device is resumed.</span>
<span class="cm"> * Resume: It is no longer an error to issue this command on an</span>
<span class="cm"> * unsuspended device.  If a table is present in the &#39;inactive&#39;</span>
<span class="cm"> * slot, it will be moved to the active slot, then the old table</span>
<span class="cm"> * from the active slot will be _destroyed_.  Finally the device</span>
<span class="cm"> * is resumed.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_DEV_STATUS:</span>
<span class="cm"> * Retrieves the status for the table in the &#39;active&#39; slot.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_DEV_WAIT:</span>
<span class="cm"> * Wait for a significant event to occur to the device.  This</span>
<span class="cm"> * could either be caused by an event triggered by one of the</span>
<span class="cm"> * targets of the table in the &#39;active&#39; slot, or a table change.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_TABLE_LOAD:</span>
<span class="cm"> * Load a table into the &#39;inactive&#39; slot for the device.  The</span>
<span class="cm"> * device does _not_ need to be suspended prior to this command.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_TABLE_CLEAR:</span>
<span class="cm"> * Destroy any table in the &#39;inactive&#39; slot (ie. abort).</span>
<span class="cm"> *</span>
<span class="cm"> * DM_TABLE_DEPS:</span>
<span class="cm"> * Return a set of device dependencies for the &#39;active&#39; table.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_TABLE_STATUS:</span>
<span class="cm"> * Return the targets status for the &#39;active&#39; table.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_TARGET_MSG:</span>
<span class="cm"> * Pass a message string to the target at a specific offset of a device.</span>
<span class="cm"> *</span>
<span class="cm"> * DM_DEV_SET_GEOMETRY:</span>
<span class="cm"> * Set the geometry of a device by passing in a string in this format:</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;cylinders heads sectors_per_track start_sector&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * Beware that CHS geometry is nearly obsolete and only provided</span>
<span class="cm"> * for compatibility with dm devices that can be booted by a PC</span>
<span class="cm"> * BIOS.  See struct hd_geometry for range limits.  Also note that</span>
<span class="cm"> * the geometry is erased if the device size changes.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * All ioctl arguments consist of a single chunk of memory, with</span>
<span class="cm"> * this structure at the start.  If a uuid is specified any</span>
<span class="cm"> * lookup (eg. for a DM_INFO) will be done on that, *not* the</span>
<span class="cm"> * name.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_ioctl</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The version number is made up of three parts:</span>
<span class="cm">	 * major - no backward or forward compatibility,</span>
<span class="cm">	 * minor - only backwards compatible,</span>
<span class="cm">	 * patch - both backwards and forwards compatible.</span>
<span class="cm">	 *</span>
<span class="cm">	 * All clients of the ioctl interface should fill in the</span>
<span class="cm">	 * version number of the interface that they were</span>
<span class="cm">	 * compiled with.</span>
<span class="cm">	 *</span>
<span class="cm">	 * All recognised ioctl commands (ie. those that don&#39;t</span>
<span class="cm">	 * return -ENOTTY) fill out this field, even if the</span>
<span class="cm">	 * command failed.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">version</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* in/out */</span>
	<span class="n">__u32</span> <span class="n">data_size</span><span class="p">;</span>	<span class="cm">/* total size of data passed in</span>
<span class="cm">				 * including this struct */</span>

	<span class="n">__u32</span> <span class="n">data_start</span><span class="p">;</span>	<span class="cm">/* offset to start of data</span>
<span class="cm">				 * relative to start of this struct */</span>

	<span class="n">__u32</span> <span class="n">target_count</span><span class="p">;</span>	<span class="cm">/* in/out */</span>
	<span class="n">__s32</span> <span class="n">open_count</span><span class="p">;</span>	<span class="cm">/* out */</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* in/out */</span>

	<span class="cm">/*</span>
<span class="cm">	 * event_nr holds either the event number (input and output) or the</span>
<span class="cm">	 * udev cookie value (input only).</span>
<span class="cm">	 * The DM_DEV_WAIT ioctl takes an event number as input.</span>
<span class="cm">	 * The DM_SUSPEND, DM_DEV_REMOVE and DM_DEV_RENAME ioctls</span>
<span class="cm">	 * use the field as a cookie to return in the DM_COOKIE</span>
<span class="cm">	 * variable with the uevents they issue.</span>
<span class="cm">	 * For output, the ioctls return the event number, not the cookie.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">event_nr</span><span class="p">;</span>      	<span class="cm">/* in/out */</span>
	<span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>

	<span class="n">__u64</span> <span class="n">dev</span><span class="p">;</span>		<span class="cm">/* in/out */</span>

	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DM_NAME_LEN</span><span class="p">];</span>	<span class="cm">/* device name */</span>
	<span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="n">DM_UUID_LEN</span><span class="p">];</span>	<span class="cm">/* unique identifier for</span>
<span class="cm">				 * the block device */</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>		<span class="cm">/* padding or data */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Used to specify tables.  These structures appear after the</span>
<span class="cm"> * dm_ioctl.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_target_spec</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">sector_start</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">status</span><span class="p">;</span>		<span class="cm">/* used when reading from kernel only */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Location of the next dm_target_spec.</span>
<span class="cm">	 * - When specifying targets on a DM_TABLE_LOAD command, this value is</span>
<span class="cm">	 *   the number of bytes from the start of the &quot;current&quot; dm_target_spec</span>
<span class="cm">	 *   to the start of the &quot;next&quot; dm_target_spec.</span>
<span class="cm">	 * - When retrieving targets on a DM_TABLE_STATUS command, this value</span>
<span class="cm">	 *   is the number of bytes from the start of the first dm_target_spec</span>
<span class="cm">	 *   (that follows the dm_ioctl struct) to the start of the &quot;next&quot;</span>
<span class="cm">	 *   dm_target_spec.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">next</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">target_type</span><span class="p">[</span><span class="n">DM_MAX_TYPE_NAME</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Parameter string starts immediately after this object.</span>
<span class="cm">	 * Be careful to add padding after string to ensure correct</span>
<span class="cm">	 * alignment of subsequent dm_target_spec.</span>
<span class="cm">	 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Used to retrieve the target dependencies.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_target_deps</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">count</span><span class="p">;</span>	<span class="cm">/* Array size */</span>
	<span class="n">__u32</span> <span class="n">padding</span><span class="p">;</span>	<span class="cm">/* unused */</span>
	<span class="n">__u64</span> <span class="n">dev</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* out */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Used to get a list of all dm devices.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_name_list</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">next</span><span class="p">;</span>		<span class="cm">/* offset to the next record from</span>
<span class="cm">				   the _start_ of this */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Used to retrieve the target versions</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_target_versions</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">version</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

        <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Used to pass message to a target</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dm_target_msg</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">sector</span><span class="p">;</span>	<span class="cm">/* Device sector */</span>

	<span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * If you change this make sure you make the corresponding change</span>
<span class="cm"> * to dm-ioctl.c:lookup_ioctl()</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Top level cmds */</span>
	<span class="n">DM_VERSION_CMD</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DM_REMOVE_ALL_CMD</span><span class="p">,</span>
	<span class="n">DM_LIST_DEVICES_CMD</span><span class="p">,</span>

	<span class="cm">/* device level cmds */</span>
	<span class="n">DM_DEV_CREATE_CMD</span><span class="p">,</span>
	<span class="n">DM_DEV_REMOVE_CMD</span><span class="p">,</span>
	<span class="n">DM_DEV_RENAME_CMD</span><span class="p">,</span>
	<span class="n">DM_DEV_SUSPEND_CMD</span><span class="p">,</span>
	<span class="n">DM_DEV_STATUS_CMD</span><span class="p">,</span>
	<span class="n">DM_DEV_WAIT_CMD</span><span class="p">,</span>

	<span class="cm">/* Table level cmds */</span>
	<span class="n">DM_TABLE_LOAD_CMD</span><span class="p">,</span>
	<span class="n">DM_TABLE_CLEAR_CMD</span><span class="p">,</span>
	<span class="n">DM_TABLE_DEPS_CMD</span><span class="p">,</span>
	<span class="n">DM_TABLE_STATUS_CMD</span><span class="p">,</span>

	<span class="cm">/* Added later */</span>
	<span class="n">DM_LIST_VERSIONS_CMD</span><span class="p">,</span>
	<span class="n">DM_TARGET_MSG_CMD</span><span class="p">,</span>
	<span class="n">DM_DEV_SET_GEOMETRY_CMD</span>
<span class="p">};</span>

<span class="cp">#define DM_IOCTL 0xfd</span>

<span class="cp">#define DM_VERSION       _IOWR(DM_IOCTL, DM_VERSION_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_REMOVE_ALL    _IOWR(DM_IOCTL, DM_REMOVE_ALL_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_LIST_DEVICES  _IOWR(DM_IOCTL, DM_LIST_DEVICES_CMD, struct dm_ioctl)</span>

<span class="cp">#define DM_DEV_CREATE    _IOWR(DM_IOCTL, DM_DEV_CREATE_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_DEV_REMOVE    _IOWR(DM_IOCTL, DM_DEV_REMOVE_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_DEV_RENAME    _IOWR(DM_IOCTL, DM_DEV_RENAME_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_DEV_SUSPEND   _IOWR(DM_IOCTL, DM_DEV_SUSPEND_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_DEV_STATUS    _IOWR(DM_IOCTL, DM_DEV_STATUS_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_DEV_WAIT      _IOWR(DM_IOCTL, DM_DEV_WAIT_CMD, struct dm_ioctl)</span>

<span class="cp">#define DM_TABLE_LOAD    _IOWR(DM_IOCTL, DM_TABLE_LOAD_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_TABLE_CLEAR   _IOWR(DM_IOCTL, DM_TABLE_CLEAR_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_TABLE_DEPS    _IOWR(DM_IOCTL, DM_TABLE_DEPS_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_TABLE_STATUS  _IOWR(DM_IOCTL, DM_TABLE_STATUS_CMD, struct dm_ioctl)</span>

<span class="cp">#define DM_LIST_VERSIONS _IOWR(DM_IOCTL, DM_LIST_VERSIONS_CMD, struct dm_ioctl)</span>

<span class="cp">#define DM_TARGET_MSG	 _IOWR(DM_IOCTL, DM_TARGET_MSG_CMD, struct dm_ioctl)</span>
<span class="cp">#define DM_DEV_SET_GEOMETRY	_IOWR(DM_IOCTL, DM_DEV_SET_GEOMETRY_CMD, struct dm_ioctl)</span>

<span class="cp">#define DM_VERSION_MAJOR	4</span>
<span class="cp">#define DM_VERSION_MINOR	22</span>
<span class="cp">#define DM_VERSION_PATCHLEVEL	0</span>
<span class="cp">#define DM_VERSION_EXTRA	&quot;-ioctl (2011-10-19)&quot;</span>

<span class="cm">/* Status bits */</span>
<span class="cp">#define DM_READONLY_FLAG	(1 &lt;&lt; 0) </span><span class="cm">/* In/Out */</span><span class="cp"></span>
<span class="cp">#define DM_SUSPEND_FLAG		(1 &lt;&lt; 1) </span><span class="cm">/* In/Out */</span><span class="cp"></span>
<span class="cp">#define DM_PERSISTENT_DEV_FLAG	(1 &lt;&lt; 3) </span><span class="cm">/* In */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Flag passed into ioctl STATUS command to get table information</span>
<span class="cm"> * rather than current status.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_STATUS_TABLE_FLAG	(1 &lt;&lt; 4) </span><span class="cm">/* In */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Flags that indicate whether a table is present in either of</span>
<span class="cm"> * the two table slots that a device has.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_ACTIVE_PRESENT_FLAG   (1 &lt;&lt; 5) </span><span class="cm">/* Out */</span><span class="cp"></span>
<span class="cp">#define DM_INACTIVE_PRESENT_FLAG (1 &lt;&lt; 6) </span><span class="cm">/* Out */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Indicates that the buffer passed in wasn&#39;t big enough for the</span>
<span class="cm"> * results.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_BUFFER_FULL_FLAG	(1 &lt;&lt; 8) </span><span class="cm">/* Out */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This flag is now ignored.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_SKIP_BDGET_FLAG	(1 &lt;&lt; 9) </span><span class="cm">/* In */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Set this to avoid attempting to freeze any filesystem when suspending.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_SKIP_LOCKFS_FLAG	(1 &lt;&lt; 10) </span><span class="cm">/* In */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Set this to suspend without flushing queued ios.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_NOFLUSH_FLAG		(1 &lt;&lt; 11) </span><span class="cm">/* In */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * If set, any table information returned will relate to the inactive</span>
<span class="cm"> * table instead of the live one.  Always check DM_INACTIVE_PRESENT_FLAG</span>
<span class="cm"> * is set before using the data returned.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_QUERY_INACTIVE_TABLE_FLAG	(1 &lt;&lt; 12) </span><span class="cm">/* In */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * If set, a uevent was generated for which the caller may need to wait.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_UEVENT_GENERATED_FLAG	(1 &lt;&lt; 13) </span><span class="cm">/* Out */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * If set, rename changes the uuid not the name.  Only permitted</span>
<span class="cm"> * if no uuid was previously supplied: an existing uuid cannot be changed.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_UUID_FLAG			(1 &lt;&lt; 14) </span><span class="cm">/* In */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * If set, all buffers are wiped after use. Use when sending</span>
<span class="cm"> * or requesting sensitive data such as an encryption key.</span>
<span class="cm"> */</span>
<span class="cp">#define DM_SECURE_DATA_FLAG		(1 &lt;&lt; 15) </span><span class="cm">/* In */</span><span class="cp"></span>

<span class="cp">#endif				</span><span class="cm">/* _LINUX_DM_IOCTL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
