<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › kexec.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>kexec.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef LINUX_KEXEC_H</span>
<span class="cp">#define LINUX_KEXEC_H</span>

<span class="cm">/* kexec system call -  It loads the new kernel to boot into.</span>
<span class="cm"> * kexec does not sync, or unmount filesystems so if you need</span>
<span class="cm"> * that to happen you need to do that yourself.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/* kexec flags for different usage scenarios */</span>
<span class="cp">#define KEXEC_ON_CRASH		0x00000001</span>
<span class="cp">#define KEXEC_PRESERVE_CONTEXT	0x00000002</span>
<span class="cp">#define KEXEC_ARCH_MASK		0xffff0000</span>

<span class="cm">/* These values match the ELF architecture values.</span>
<span class="cm"> * Unless there is a good reason that should continue to be the case.</span>
<span class="cm"> */</span>
<span class="cp">#define KEXEC_ARCH_DEFAULT ( 0 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_386     ( 3 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_X86_64  (62 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_PPC     (20 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_PPC64   (21 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_IA_64   (50 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_ARM     (40 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_S390    (22 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_SH      (42 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_MIPS_LE (10 &lt;&lt; 16)</span>
<span class="cp">#define KEXEC_ARCH_MIPS    ( 8 &lt;&lt; 16)</span>

<span class="cm">/* The artificial cap on the number of segments passed to kexec_load. */</span>
<span class="cp">#define KEXEC_SEGMENT_MAX 16</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> * This structure is used to hold the arguments that are used when</span>
<span class="cm"> * loading  kernel binaries.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bufsz</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">memsz</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Load a new kernel image as described by the kexec_segment array</span>
<span class="cm"> * consisting of passed number of segments at the entry-point address.</span>
<span class="cm"> * The flags allow different useage types.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kexec_load</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kexec_segment</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifdef CONFIG_KEXEC</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/elfcore.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;asm/kexec.h&gt;</span>

<span class="cm">/* Verify architecture specific macros are defined */</span>

<span class="cp">#ifndef KEXEC_SOURCE_MEMORY_LIMIT</span>
<span class="cp">#error KEXEC_SOURCE_MEMORY_LIMIT not defined</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef KEXEC_DESTINATION_MEMORY_LIMIT</span>
<span class="cp">#error KEXEC_DESTINATION_MEMORY_LIMIT not defined</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef KEXEC_CONTROL_MEMORY_LIMIT</span>
<span class="cp">#error KEXEC_CONTROL_MEMORY_LIMIT not defined</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef KEXEC_CONTROL_PAGE_SIZE</span>
<span class="cp">#error KEXEC_CONTROL_PAGE_SIZE not defined</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef KEXEC_ARCH</span>
<span class="cp">#error KEXEC_ARCH not defined</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef KEXEC_CRASH_CONTROL_MEMORY_LIMIT</span>
<span class="cp">#define KEXEC_CRASH_CONTROL_MEMORY_LIMIT KEXEC_CONTROL_MEMORY_LIMIT</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef KEXEC_CRASH_MEM_ALIGN</span>
<span class="cp">#define KEXEC_CRASH_MEM_ALIGN PAGE_SIZE</span>
<span class="cp">#endif</span>

<span class="cp">#define KEXEC_NOTE_HEAD_BYTES ALIGN(sizeof(struct elf_note), 4)</span>
<span class="cp">#define KEXEC_CORE_NOTE_NAME &quot;CORE&quot;</span>
<span class="cp">#define KEXEC_CORE_NOTE_NAME_BYTES ALIGN(sizeof(KEXEC_CORE_NOTE_NAME), 4)</span>
<span class="cp">#define KEXEC_CORE_NOTE_DESC_BYTES ALIGN(sizeof(struct elf_prstatus), 4)</span>
<span class="cm">/*</span>
<span class="cm"> * The per-cpu notes area is a list of notes terminated by a &quot;NULL&quot;</span>
<span class="cm"> * note header.  For kdump, the code in vmcore.c runs in the context</span>
<span class="cm"> * of the second kernel to combine them into one note.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef KEXEC_NOTE_BYTES</span>
<span class="cp">#define KEXEC_NOTE_BYTES ( (KEXEC_NOTE_HEAD_BYTES * 2) +		\</span>
<span class="cp">			    KEXEC_CORE_NOTE_NAME_BYTES +		\</span>
<span class="cp">			    KEXEC_CORE_NOTE_DESC_BYTES )</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is used to hold the arguments that are used when loading</span>
<span class="cm"> * kernel binaries.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kimage_entry_t</span><span class="p">;</span>
<span class="cp">#define IND_DESTINATION  0x1</span>
<span class="cp">#define IND_INDIRECTION  0x2</span>
<span class="cp">#define IND_DONE         0x4</span>
<span class="cp">#define IND_SOURCE       0x8</span>

<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bufsz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mem</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">memsz</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">struct</span> <span class="n">compat_kexec_segment</span> <span class="p">{</span>
	<span class="n">compat_uptr_t</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">compat_size_t</span> <span class="n">bufsz</span><span class="p">;</span>
	<span class="n">compat_ulong_t</span> <span class="n">mem</span><span class="p">;</span>	<span class="cm">/* User space sees this as a (void *) ... */</span>
	<span class="n">compat_size_t</span> <span class="n">memsz</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">kimage</span> <span class="p">{</span>
	<span class="n">kimage_entry_t</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">kimage_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">kimage_entry_t</span> <span class="o">*</span><span class="n">last_entry</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">destination</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">control_code_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">swap_page</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segments</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="n">segment</span><span class="p">[</span><span class="n">KEXEC_SEGMENT_MAX</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">control_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dest_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">unuseable_pages</span><span class="p">;</span>

	<span class="cm">/* Address of next control page to allocate for crash kernels. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">control_page</span><span class="p">;</span>

	<span class="cm">/* Flags to indicate special processing */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#define KEXEC_TYPE_DEFAULT 0</span>
<span class="cp">#define KEXEC_TYPE_CRASH   1</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">preserve_context</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef ARCH_HAS_KIMAGE_ARCH</span>
	<span class="k">struct</span> <span class="n">kimage_arch</span> <span class="n">arch</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>



<span class="cm">/* kexec interface functions */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">machine_kexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">machine_kexec_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">machine_kexec_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">sys_kexec_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segments</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kexec_segment</span> <span class="n">__user</span> <span class="o">*</span><span class="n">segments</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kernel_kexec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">compat_sys_kexec_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segments</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">compat_kexec_segment</span> <span class="n">__user</span> <span class="o">*</span><span class="n">segments</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">kimage_alloc_control_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">crash_kexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">kexec_should_crash</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">crash_save_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">crash_save_vmcoreinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">crash_map_reserved_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">crash_unmap_reserved_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">arch_crash_save_vmcoreinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">__printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">vmcoreinfo_append_str</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">paddr_vmcoreinfo_note</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define VMCOREINFO_OSRELEASE(value) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;OSRELEASE=%s\n&quot;, value)</span>
<span class="cp">#define VMCOREINFO_PAGESIZE(value) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;PAGESIZE=%ld\n&quot;, value)</span>
<span class="cp">#define VMCOREINFO_SYMBOL(name) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;SYMBOL(%s)=%lx\n&quot;, #name, (unsigned long)&amp;name)</span>
<span class="cp">#define VMCOREINFO_SIZE(name) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;SIZE(%s)=%lu\n&quot;, #name, \</span>
<span class="cp">			      (unsigned long)sizeof(name))</span>
<span class="cp">#define VMCOREINFO_STRUCT_SIZE(name) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;SIZE(%s)=%lu\n&quot;, #name, \</span>
<span class="cp">			      (unsigned long)sizeof(struct name))</span>
<span class="cp">#define VMCOREINFO_OFFSET(name, field) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;OFFSET(%s.%s)=%lu\n&quot;, #name, #field, \</span>
<span class="cp">			      (unsigned long)offsetof(struct name, field))</span>
<span class="cp">#define VMCOREINFO_LENGTH(name, value) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;LENGTH(%s)=%lu\n&quot;, #name, (unsigned long)value)</span>
<span class="cp">#define VMCOREINFO_NUMBER(name) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;NUMBER(%s)=%ld\n&quot;, #name, (long)name)</span>
<span class="cp">#define VMCOREINFO_CONFIG(name) \</span>
<span class="cp">	vmcoreinfo_append_str(&quot;CONFIG_%s=y\n&quot;, #name)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">kexec_image</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kimage</span> <span class="o">*</span><span class="n">kexec_crash_image</span><span class="p">;</span>

<span class="cp">#ifndef kexec_flush_icache_page</span>
<span class="cp">#define kexec_flush_icache_page(page)</span>
<span class="cp">#endif</span>

<span class="cm">/* List of defined/legal kexec flags */</span>
<span class="cp">#ifndef CONFIG_KEXEC_JUMP</span>
<span class="cp">#define KEXEC_FLAGS    KEXEC_ON_CRASH</span>
<span class="cp">#else</span>
<span class="cp">#define KEXEC_FLAGS    (KEXEC_ON_CRASH | KEXEC_PRESERVE_CONTEXT)</span>
<span class="cp">#endif</span>

<span class="cp">#define VMCOREINFO_BYTES           (4096)</span>
<span class="cp">#define VMCOREINFO_NOTE_NAME       &quot;VMCOREINFO&quot;</span>
<span class="cp">#define VMCOREINFO_NOTE_NAME_BYTES ALIGN(sizeof(VMCOREINFO_NOTE_NAME), 4)</span>
<span class="cp">#define VMCOREINFO_NOTE_SIZE       (KEXEC_NOTE_HEAD_BYTES*2 + VMCOREINFO_BYTES \</span>
<span class="cp">				    + VMCOREINFO_NOTE_NAME_BYTES)</span>

<span class="cm">/* Location of a reserved region to hold the crash kernel.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">crashk_res</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">u32</span> <span class="n">note_buf_t</span><span class="p">[</span><span class="n">KEXEC_NOTE_BYTES</span><span class="o">/</span><span class="mi">4</span><span class="p">];</span>
<span class="k">extern</span> <span class="n">note_buf_t</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">crash_notes</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">vmcoreinfo_note</span><span class="p">[</span><span class="n">VMCOREINFO_NOTE_SIZE</span><span class="o">/</span><span class="mi">4</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">vmcoreinfo_size</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">vmcoreinfo_max_size</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="n">parse_crashkernel</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmdline</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">system_ram</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crash_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">crash_base</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">crash_shrink_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_size</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">crash_get_memory_size</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">crash_free_reserved_phys_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_KEXEC */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">pt_regs</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">crash_kexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kexec_should_crash</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KEXEC */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* LINUX_KEXEC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
