<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › dlm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dlm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">**</span>
<span class="cm">**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.</span>
<span class="cm">**  Copyright (C) 2004-2011 Red Hat, Inc.  All rights reserved.</span>
<span class="cm">**</span>
<span class="cm">**  This copyrighted material is made available to anyone wishing to use,</span>
<span class="cm">**  modify, copy, or redistribute it subject to the terms and conditions</span>
<span class="cm">**  of the GNU General Public License v.2.</span>
<span class="cm">**</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">******************************************************************************/</span>

<span class="cp">#ifndef __DLM_DOT_H__</span>
<span class="cp">#define __DLM_DOT_H__</span>

<span class="cm">/*</span>
<span class="cm"> * Interface to Distributed Lock Manager (DLM)</span>
<span class="cm"> * routines and structures to use DLM lockspaces</span>
<span class="cm"> */</span>

<span class="cm">/* Lock levels and flags are here */</span>
<span class="cp">#include &lt;linux/dlmconstants.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="n">dlm_lockspace_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Lock status block</span>
<span class="cm"> *</span>
<span class="cm"> * Use this structure to specify the contents of the lock value block.  For a</span>
<span class="cm"> * conversion request, this structure is used to specify the lock ID of the</span>
<span class="cm"> * lock.  DLM writes the status of the lock request and the lock ID assigned</span>
<span class="cm"> * to the request in the lock status block.</span>
<span class="cm"> *</span>
<span class="cm"> * sb_lkid: the returned lock ID.  It is set on new (non-conversion) requests.</span>
<span class="cm"> * It is available when dlm_lock returns.</span>
<span class="cm"> *</span>
<span class="cm"> * sb_lvbptr: saves or returns the contents of the lock&#39;s LVB according to rules</span>
<span class="cm"> * shown for the DLM_LKF_VALBLK flag.</span>
<span class="cm"> *</span>
<span class="cm"> * sb_flags: DLM_SBF_DEMOTED is returned if in the process of promoting a lock,</span>
<span class="cm"> * it was first demoted to NL to avoid conversion deadlock.</span>
<span class="cm"> * DLM_SBF_VALNOTVALID is returned if the resource&#39;s LVB is marked invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * sb_status: the returned status of the lock request set prior to AST</span>
<span class="cm"> * execution.  Possible return values:</span>
<span class="cm"> *</span>
<span class="cm"> * 0 if lock request was successful</span>
<span class="cm"> * -EAGAIN if request would block and is flagged DLM_LKF_NOQUEUE</span>
<span class="cm"> * -DLM_EUNLOCK if unlock request was successful</span>
<span class="cm"> * -DLM_ECANCEL if a cancel completed successfully</span>
<span class="cm"> * -EDEADLK if a deadlock was detected</span>
<span class="cm"> * -ETIMEDOUT if the lock request was canceled due to a timeout</span>
<span class="cm"> */</span>

<span class="cp">#define DLM_SBF_DEMOTED		0x01</span>
<span class="cp">#define DLM_SBF_VALNOTVALID	0x02</span>
<span class="cp">#define DLM_SBF_ALTMODE		0x04</span>

<span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="p">{</span>
	<span class="kt">int</span> 	 <span class="n">sb_status</span><span class="p">;</span>
	<span class="n">__u32</span>	 <span class="n">sb_lkid</span><span class="p">;</span>
	<span class="kt">char</span> 	 <span class="n">sb_flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span>	 <span class="n">sb_lvbptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* dlm_new_lockspace() flags */</span>

<span class="cp">#define DLM_LSFL_TIMEWARN	0x00000002</span>
<span class="cp">#define DLM_LSFL_FS     	0x00000004</span>
<span class="cp">#define DLM_LSFL_NEWEXCL     	0x00000008</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="k">struct</span> <span class="n">dlm_slot</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nodeid</span><span class="p">;</span> <span class="cm">/* 1 to MAX_INT */</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>   <span class="cm">/* 1 to MAX_INT */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * recover_prep: called before the dlm begins lock recovery.</span>
<span class="cm"> *   Notfies lockspace user that locks from failed members will be granted.</span>
<span class="cm"> * recover_slot: called after recover_prep and before recover_done.</span>
<span class="cm"> *   Identifies a failed lockspace member.</span>
<span class="cm"> * recover_done: called after the dlm completes lock recovery.</span>
<span class="cm"> *   Identifies lockspace members and lockspace generation number.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">dlm_lockspace_ops</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">recover_prep</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ops_arg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">recover_slot</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ops_arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">recover_done</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ops_arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">slots</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">num_slots</span><span class="p">,</span> <span class="kt">int</span> <span class="n">our_slot</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">generation</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * dlm_new_lockspace</span>
<span class="cm"> *</span>
<span class="cm"> * Create/join a lockspace.</span>
<span class="cm"> *</span>
<span class="cm"> * name: lockspace name, null terminated, up to DLM_LOCKSPACE_LEN (not</span>
<span class="cm"> *   including terminating null).</span>
<span class="cm"> *</span>
<span class="cm"> * cluster: cluster name, null terminated, up to DLM_LOCKSPACE_LEN (not</span>
<span class="cm"> *   including terminating null).  Optional.  When cluster is null, it</span>
<span class="cm"> *   is not used.  When set, dlm_new_lockspace() returns -EBADR if cluster</span>
<span class="cm"> *   is not equal to the dlm cluster name.</span>
<span class="cm"> *</span>
<span class="cm"> * flags:</span>
<span class="cm"> * DLM_LSFL_NODIR</span>
<span class="cm"> *   The dlm should not use a resource directory, but statically assign</span>
<span class="cm"> *   resource mastery to nodes based on the name hash that is otherwise</span>
<span class="cm"> *   used to select the directory node.  Must be the same on all nodes.</span>
<span class="cm"> * DLM_LSFL_TIMEWARN</span>
<span class="cm"> *   The dlm should emit netlink messages if locks have been waiting</span>
<span class="cm"> *   for a configurable amount of time.  (Unused.)</span>
<span class="cm"> * DLM_LSFL_FS</span>
<span class="cm"> *   The lockspace user is in the kernel (i.e. filesystem).  Enables</span>
<span class="cm"> *   direct bast/cast callbacks.</span>
<span class="cm"> * DLM_LSFL_NEWEXCL</span>
<span class="cm"> *   dlm_new_lockspace() should return -EEXIST if the lockspace exists.</span>
<span class="cm"> *</span>
<span class="cm"> * lvblen: length of lvb in bytes.  Must be multiple of 8.</span>
<span class="cm"> *   dlm_new_lockspace() returns an error if this does not match</span>
<span class="cm"> *   what other nodes are using.</span>
<span class="cm"> *</span>
<span class="cm"> * ops: callbacks that indicate lockspace recovery points so the</span>
<span class="cm"> *   caller can coordinate its recovery and know lockspace members.</span>
<span class="cm"> *   This is only used by the initial dlm_new_lockspace() call.</span>
<span class="cm"> *   Optional.</span>
<span class="cm"> *</span>
<span class="cm"> * ops_arg: arg for ops callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * ops_result: tells caller if the ops callbacks (if provided) will</span>
<span class="cm"> *   be used or not.  0: will be used, -EXXX will not be used.</span>
<span class="cm"> *   -EOPNOTSUPP: the dlm does not have recovery_callbacks enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * lockspace: handle for dlm functions</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">dlm_new_lockspace</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cluster</span><span class="p">,</span>
		      <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lvblen</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">dlm_lockspace_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ops_arg</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="o">*</span><span class="n">ops_result</span><span class="p">,</span> <span class="n">dlm_lockspace_t</span> <span class="o">**</span><span class="n">lockspace</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * dlm_release_lockspace</span>
<span class="cm"> *</span>
<span class="cm"> * Stop a lockspace.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">dlm_release_lockspace</span><span class="p">(</span><span class="n">dlm_lockspace_t</span> <span class="o">*</span><span class="n">lockspace</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * dlm_lock</span>
<span class="cm"> *</span>
<span class="cm"> * Make an asyncronous request to acquire or convert a lock on a named</span>
<span class="cm"> * resource.</span>
<span class="cm"> *</span>
<span class="cm"> * lockspace: context for the request</span>
<span class="cm"> * mode: the requested mode of the lock (DLM_LOCK_)</span>
<span class="cm"> * lksb: lock status block for input and async return values</span>
<span class="cm"> * flags: input flags (DLM_LKF_)</span>
<span class="cm"> * name: name of the resource to lock, can be binary</span>
<span class="cm"> * namelen: the length in bytes of the resource name (MAX_RESNAME_LEN)</span>
<span class="cm"> * parent: the lock ID of a parent lock or 0 if none</span>
<span class="cm"> * lockast: function DLM executes when it completes processing the request</span>
<span class="cm"> * astarg: argument passed to lockast and bast functions</span>
<span class="cm"> * bast: function DLM executes when this lock later blocks another request</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * 0 if request is successfully queued for processing</span>
<span class="cm"> * -EINVAL if any input parameters are invalid</span>
<span class="cm"> * -EAGAIN if request would block and is flagged DLM_LKF_NOQUEUE</span>
<span class="cm"> * -ENOMEM if there is no memory to process request</span>
<span class="cm"> * -ENOTCONN if there is a communication error</span>
<span class="cm"> *</span>
<span class="cm"> * If the call to dlm_lock returns an error then the operation has failed and</span>
<span class="cm"> * the AST routine will not be called.  If dlm_lock returns 0 it is still</span>
<span class="cm"> * possible that the lock operation will fail. The AST routine will be called</span>
<span class="cm"> * when the locking is complete and the status is returned in the lksb.</span>
<span class="cm"> *</span>
<span class="cm"> * If the AST routines or parameter are passed to a conversion operation then</span>
<span class="cm"> * they will overwrite those values that were passed to a previous dlm_lock</span>
<span class="cm"> * call.</span>
<span class="cm"> *</span>
<span class="cm"> * AST routines should not block (at least not for long), but may make</span>
<span class="cm"> * any locking calls they please.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">dlm_lock</span><span class="p">(</span><span class="n">dlm_lockspace_t</span> <span class="o">*</span><span class="n">lockspace</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
	     <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
	     <span class="kt">uint32_t</span> <span class="n">parent_lkid</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lockast</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">),</span>
	     <span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bast</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * dlm_unlock</span>
<span class="cm"> *</span>
<span class="cm"> * Asynchronously release a lock on a resource.  The AST routine is called</span>
<span class="cm"> * when the resource is successfully unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * lockspace: context for the request</span>
<span class="cm"> * lkid: the lock ID as returned in the lksb</span>
<span class="cm"> * flags: input flags (DLM_LKF_)</span>
<span class="cm"> * lksb: if NULL the lksb parameter passed to last lock request is used</span>
<span class="cm"> * astarg: the arg used with the completion ast for the unlock</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * 0 if request is successfully queued for processing</span>
<span class="cm"> * -EINVAL if any input parameters are invalid</span>
<span class="cm"> * -ENOTEMPTY if the lock still has sublocks</span>
<span class="cm"> * -EBUSY if the lock is waiting for a remote lock operation</span>
<span class="cm"> * -ENOTCONN if there is a communication error</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">dlm_unlock</span><span class="p">(</span><span class="n">dlm_lockspace_t</span> <span class="o">*</span><span class="n">lockspace</span><span class="p">,</span>
	       <span class="kt">uint32_t</span> <span class="n">lkid</span><span class="p">,</span>
	       <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
	       <span class="kt">void</span> <span class="o">*</span><span class="n">astarg</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif				</span><span class="cm">/* __DLM_DOT_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
