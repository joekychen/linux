<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › page-flags.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>page-flags.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Macros for manipulating and testing page-&gt;flags</span>
<span class="cm"> */</span>

<span class="cp">#ifndef PAGE_FLAGS_H</span>
<span class="cp">#define PAGE_FLAGS_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#ifndef __GENERATING_BOUNDS_H</span>
<span class="cp">#include &lt;linux/mm_types.h&gt;</span>
<span class="cp">#include &lt;generated/bounds.h&gt;</span>
<span class="cp">#endif </span><span class="cm">/* !__GENERATING_BOUNDS_H */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Various page-&gt;flags bits:</span>
<span class="cm"> *</span>
<span class="cm"> * PG_reserved is set for special pages, which can never be swapped out. Some</span>
<span class="cm"> * of them might not even exist (eg empty_bad_page)...</span>
<span class="cm"> *</span>
<span class="cm"> * The PG_private bitflag is set on pagecache pages if they contain filesystem</span>
<span class="cm"> * specific data (which is normally at page-&gt;private). It can be used by</span>
<span class="cm"> * private allocations for its own usage.</span>
<span class="cm"> *</span>
<span class="cm"> * During initiation of disk I/O, PG_locked is set. This bit is set before I/O</span>
<span class="cm"> * and cleared when writeback _starts_ or when read _completes_. PG_writeback</span>
<span class="cm"> * is set before writeback starts and cleared when it finishes.</span>
<span class="cm"> *</span>
<span class="cm"> * PG_locked also pins a page in pagecache, and blocks truncation of the file</span>
<span class="cm"> * while it is held.</span>
<span class="cm"> *</span>
<span class="cm"> * page_waitqueue(page) is a wait queue of all tasks waiting for the page</span>
<span class="cm"> * to become unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * PG_uptodate tells whether the page&#39;s contents is valid.  When a read</span>
<span class="cm"> * completes, the page becomes uptodate, unless a disk I/O error happened.</span>
<span class="cm"> *</span>
<span class="cm"> * PG_referenced, PG_reclaim are used for page reclaim for anonymous and</span>
<span class="cm"> * file-backed pagecache (see mm/vmscan.c).</span>
<span class="cm"> *</span>
<span class="cm"> * PG_error is set to indicate that an I/O error occurred on this page.</span>
<span class="cm"> *</span>
<span class="cm"> * PG_arch_1 is an architecture specific page state bit.  The generic code</span>
<span class="cm"> * guarantees that this bit is cleared for a page when it first is entered into</span>
<span class="cm"> * the page cache.</span>
<span class="cm"> *</span>
<span class="cm"> * PG_highmem pages are not permanently mapped into the kernel virtual address</span>
<span class="cm"> * space, they need to be kmapped separately for doing IO on the pages.  The</span>
<span class="cm"> * struct page (these bits with information) are always mapped into kernel</span>
<span class="cm"> * address space...</span>
<span class="cm"> *</span>
<span class="cm"> * PG_hwpoison indicates that a page got corrupted in hardware and contains</span>
<span class="cm"> * data with incorrect ECC bits that triggered a machine check. Accessing is</span>
<span class="cm"> * not safe since it may cause another machine check. Don&#39;t touch!</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Don&#39;t use the *_dontuse flags.  Use the macros.  Otherwise you&#39;ll break</span>
<span class="cm"> * locked- and dirty-page accounting.</span>
<span class="cm"> *</span>
<span class="cm"> * The page flags field is split into two parts, the main flags area</span>
<span class="cm"> * which extends from the low bits upwards, and the fields area which</span>
<span class="cm"> * extends from the high bits downwards.</span>
<span class="cm"> *</span>
<span class="cm"> *  | FIELD | ... | FLAGS |</span>
<span class="cm"> *  N-1           ^       0</span>
<span class="cm"> *               (NR_PAGEFLAGS)</span>
<span class="cm"> *</span>
<span class="cm"> * The fields area is reserved for fields mapping zone, node (for NUMA) and</span>
<span class="cm"> * SPARSEMEM section (for variants of SPARSEMEM that require section ids like</span>
<span class="cm"> * SPARSEMEM_EXTREME with !SPARSEMEM_VMEMMAP).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">pageflags</span> <span class="p">{</span>
	<span class="n">PG_locked</span><span class="p">,</span>		<span class="cm">/* Page is locked. Don&#39;t touch. */</span>
	<span class="n">PG_error</span><span class="p">,</span>
	<span class="n">PG_referenced</span><span class="p">,</span>
	<span class="n">PG_uptodate</span><span class="p">,</span>
	<span class="n">PG_dirty</span><span class="p">,</span>
	<span class="n">PG_lru</span><span class="p">,</span>
	<span class="n">PG_active</span><span class="p">,</span>
	<span class="n">PG_slab</span><span class="p">,</span>
	<span class="n">PG_owner_priv_1</span><span class="p">,</span>	<span class="cm">/* Owner use. If pagecache, fs may use*/</span>
	<span class="n">PG_arch_1</span><span class="p">,</span>
	<span class="n">PG_reserved</span><span class="p">,</span>
	<span class="n">PG_private</span><span class="p">,</span>		<span class="cm">/* If pagecache, has fs-private data */</span>
	<span class="n">PG_private_2</span><span class="p">,</span>		<span class="cm">/* If pagecache, has fs aux data */</span>
	<span class="n">PG_writeback</span><span class="p">,</span>		<span class="cm">/* Page is under writeback */</span>
<span class="cp">#ifdef CONFIG_PAGEFLAGS_EXTENDED</span>
	<span class="n">PG_head</span><span class="p">,</span>		<span class="cm">/* A head page */</span>
	<span class="n">PG_tail</span><span class="p">,</span>		<span class="cm">/* A tail page */</span>
<span class="cp">#else</span>
	<span class="n">PG_compound</span><span class="p">,</span>		<span class="cm">/* A compound page */</span>
<span class="cp">#endif</span>
	<span class="n">PG_swapcache</span><span class="p">,</span>		<span class="cm">/* Swap page: swp_entry_t in private */</span>
	<span class="n">PG_mappedtodisk</span><span class="p">,</span>	<span class="cm">/* Has blocks allocated on-disk */</span>
	<span class="n">PG_reclaim</span><span class="p">,</span>		<span class="cm">/* To be reclaimed asap */</span>
	<span class="n">PG_swapbacked</span><span class="p">,</span>		<span class="cm">/* Page is backed by RAM/swap */</span>
	<span class="n">PG_unevictable</span><span class="p">,</span>		<span class="cm">/* Page is &quot;unevictable&quot;  */</span>
<span class="cp">#ifdef CONFIG_MMU</span>
	<span class="n">PG_mlocked</span><span class="p">,</span>		<span class="cm">/* Page is vma mlocked */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ARCH_USES_PG_UNCACHED</span>
	<span class="n">PG_uncached</span><span class="p">,</span>		<span class="cm">/* Page has been mapped as uncached */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MEMORY_FAILURE</span>
	<span class="n">PG_hwpoison</span><span class="p">,</span>		<span class="cm">/* hardware poisoned page. Don&#39;t touch */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">PG_compound_lock</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="n">__NR_PAGEFLAGS</span><span class="p">,</span>

	<span class="cm">/* Filesystems */</span>
	<span class="n">PG_checked</span> <span class="o">=</span> <span class="n">PG_owner_priv_1</span><span class="p">,</span>

	<span class="cm">/* Two page bits are conscripted by FS-Cache to maintain local caching</span>
<span class="cm">	 * state.  These bits are set on pages belonging to the netfs&#39;s inodes</span>
<span class="cm">	 * when those inodes are being locally cached.</span>
<span class="cm">	 */</span>
	<span class="n">PG_fscache</span> <span class="o">=</span> <span class="n">PG_private_2</span><span class="p">,</span>	<span class="cm">/* page backed by cache */</span>

	<span class="cm">/* XEN */</span>
	<span class="n">PG_pinned</span> <span class="o">=</span> <span class="n">PG_owner_priv_1</span><span class="p">,</span>
	<span class="n">PG_savepinned</span> <span class="o">=</span> <span class="n">PG_dirty</span><span class="p">,</span>

	<span class="cm">/* SLOB */</span>
	<span class="n">PG_slob_free</span> <span class="o">=</span> <span class="n">PG_private</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifndef __GENERATING_BOUNDS_H</span>

<span class="cm">/*</span>
<span class="cm"> * Macros to create function definitions for page flags</span>
<span class="cm"> */</span>
<span class="cp">#define TESTPAGEFLAG(uname, lname)					\</span>
<span class="cp">static inline int Page##uname(const struct page *page)			\</span>
<span class="cp">			{ return test_bit(PG_##lname, &amp;page-&gt;flags); }</span>

<span class="cp">#define SETPAGEFLAG(uname, lname)					\</span>
<span class="cp">static inline void SetPage##uname(struct page *page)			\</span>
<span class="cp">			{ set_bit(PG_##lname, &amp;page-&gt;flags); }</span>

<span class="cp">#define CLEARPAGEFLAG(uname, lname)					\</span>
<span class="cp">static inline void ClearPage##uname(struct page *page)			\</span>
<span class="cp">			{ clear_bit(PG_##lname, &amp;page-&gt;flags); }</span>

<span class="cp">#define __SETPAGEFLAG(uname, lname)					\</span>
<span class="cp">static inline void __SetPage##uname(struct page *page)			\</span>
<span class="cp">			{ __set_bit(PG_##lname, &amp;page-&gt;flags); }</span>

<span class="cp">#define __CLEARPAGEFLAG(uname, lname)					\</span>
<span class="cp">static inline void __ClearPage##uname(struct page *page)		\</span>
<span class="cp">			{ __clear_bit(PG_##lname, &amp;page-&gt;flags); }</span>

<span class="cp">#define TESTSETFLAG(uname, lname)					\</span>
<span class="cp">static inline int TestSetPage##uname(struct page *page)			\</span>
<span class="cp">		{ return test_and_set_bit(PG_##lname, &amp;page-&gt;flags); }</span>

<span class="cp">#define TESTCLEARFLAG(uname, lname)					\</span>
<span class="cp">static inline int TestClearPage##uname(struct page *page)		\</span>
<span class="cp">		{ return test_and_clear_bit(PG_##lname, &amp;page-&gt;flags); }</span>

<span class="cp">#define __TESTCLEARFLAG(uname, lname)					\</span>
<span class="cp">static inline int __TestClearPage##uname(struct page *page)		\</span>
<span class="cp">		{ return __test_and_clear_bit(PG_##lname, &amp;page-&gt;flags); }</span>

<span class="cp">#define PAGEFLAG(uname, lname) TESTPAGEFLAG(uname, lname)		\</span>
<span class="cp">	SETPAGEFLAG(uname, lname) CLEARPAGEFLAG(uname, lname)</span>

<span class="cp">#define __PAGEFLAG(uname, lname) TESTPAGEFLAG(uname, lname)		\</span>
<span class="cp">	__SETPAGEFLAG(uname, lname)  __CLEARPAGEFLAG(uname, lname)</span>

<span class="cp">#define PAGEFLAG_FALSE(uname) 						\</span>
<span class="cp">static inline int Page##uname(const struct page *page)			\</span>
<span class="cp">			{ return 0; }</span>

<span class="cp">#define TESTSCFLAG(uname, lname)					\</span>
<span class="cp">	TESTSETFLAG(uname, lname) TESTCLEARFLAG(uname, lname)</span>

<span class="cp">#define SETPAGEFLAG_NOOP(uname)						\</span>
<span class="cp">static inline void SetPage##uname(struct page *page) {  }</span>

<span class="cp">#define CLEARPAGEFLAG_NOOP(uname)					\</span>
<span class="cp">static inline void ClearPage##uname(struct page *page) {  }</span>

<span class="cp">#define __CLEARPAGEFLAG_NOOP(uname)					\</span>
<span class="cp">static inline void __ClearPage##uname(struct page *page) {  }</span>

<span class="cp">#define TESTCLEARFLAG_FALSE(uname)					\</span>
<span class="cp">static inline int TestClearPage##uname(struct page *page) { return 0; }</span>

<span class="cp">#define __TESTCLEARFLAG_FALSE(uname)					\</span>
<span class="cp">static inline int __TestClearPage##uname(struct page *page) { return 0; }</span>

<span class="k">struct</span> <span class="n">page</span><span class="p">;</span>	<span class="cm">/* forward declaration */</span>

<span class="n">TESTPAGEFLAG</span><span class="p">(</span><span class="n">Locked</span><span class="p">,</span> <span class="n">locked</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Error</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="n">TESTCLEARFLAG</span><span class="p">(</span><span class="n">Error</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Referenced</span><span class="p">,</span> <span class="n">referenced</span><span class="p">)</span> <span class="n">TESTCLEARFLAG</span><span class="p">(</span><span class="n">Referenced</span><span class="p">,</span> <span class="n">referenced</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Dirty</span><span class="p">,</span> <span class="n">dirty</span><span class="p">)</span> <span class="n">TESTSCFLAG</span><span class="p">(</span><span class="n">Dirty</span><span class="p">,</span> <span class="n">dirty</span><span class="p">)</span> <span class="n">__CLEARPAGEFLAG</span><span class="p">(</span><span class="n">Dirty</span><span class="p">,</span> <span class="n">dirty</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">LRU</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="n">__CLEARPAGEFLAG</span><span class="p">(</span><span class="n">LRU</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Active</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span> <span class="n">__CLEARPAGEFLAG</span><span class="p">(</span><span class="n">Active</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>
	<span class="n">TESTCLEARFLAG</span><span class="p">(</span><span class="n">Active</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>
<span class="n">__PAGEFLAG</span><span class="p">(</span><span class="n">Slab</span><span class="p">,</span> <span class="n">slab</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Checked</span><span class="p">,</span> <span class="n">checked</span><span class="p">)</span>		<span class="cm">/* Used by some filesystems */</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Pinned</span><span class="p">,</span> <span class="n">pinned</span><span class="p">)</span> <span class="n">TESTSCFLAG</span><span class="p">(</span><span class="n">Pinned</span><span class="p">,</span> <span class="n">pinned</span><span class="p">)</span>	<span class="cm">/* Xen */</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">SavePinned</span><span class="p">,</span> <span class="n">savepinned</span><span class="p">);</span>			<span class="cm">/* Xen */</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Reserved</span><span class="p">,</span> <span class="n">reserved</span><span class="p">)</span> <span class="n">__CLEARPAGEFLAG</span><span class="p">(</span><span class="n">Reserved</span><span class="p">,</span> <span class="n">reserved</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">SwapBacked</span><span class="p">,</span> <span class="n">swapbacked</span><span class="p">)</span> <span class="n">__CLEARPAGEFLAG</span><span class="p">(</span><span class="n">SwapBacked</span><span class="p">,</span> <span class="n">swapbacked</span><span class="p">)</span>

<span class="n">__PAGEFLAG</span><span class="p">(</span><span class="n">SlobFree</span><span class="p">,</span> <span class="n">slob_free</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * Private page markings that may be used by the filesystem that owns the page</span>
<span class="cm"> * for its own purposes.</span>
<span class="cm"> * - PG_private and PG_private_2 cause releasepage() and co to be invoked</span>
<span class="cm"> */</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Private</span><span class="p">,</span> <span class="n">private</span><span class="p">)</span> <span class="n">__SETPAGEFLAG</span><span class="p">(</span><span class="n">Private</span><span class="p">,</span> <span class="n">private</span><span class="p">)</span>
	<span class="n">__CLEARPAGEFLAG</span><span class="p">(</span><span class="n">Private</span><span class="p">,</span> <span class="n">private</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Private2</span><span class="p">,</span> <span class="n">private_2</span><span class="p">)</span> <span class="n">TESTSCFLAG</span><span class="p">(</span><span class="n">Private2</span><span class="p">,</span> <span class="n">private_2</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">OwnerPriv1</span><span class="p">,</span> <span class="n">owner_priv_1</span><span class="p">)</span> <span class="n">TESTCLEARFLAG</span><span class="p">(</span><span class="n">OwnerPriv1</span><span class="p">,</span> <span class="n">owner_priv_1</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * Only test-and-set exist for PG_writeback.  The unconditional operators are</span>
<span class="cm"> * risky: they bypass page accounting.</span>
<span class="cm"> */</span>
<span class="n">TESTPAGEFLAG</span><span class="p">(</span><span class="n">Writeback</span><span class="p">,</span> <span class="n">writeback</span><span class="p">)</span> <span class="n">TESTSCFLAG</span><span class="p">(</span><span class="n">Writeback</span><span class="p">,</span> <span class="n">writeback</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">MappedToDisk</span><span class="p">,</span> <span class="n">mappedtodisk</span><span class="p">)</span>

<span class="cm">/* PG_readahead is only used for file reads; PG_reclaim is only for writes */</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Reclaim</span><span class="p">,</span> <span class="n">reclaim</span><span class="p">)</span> <span class="n">TESTCLEARFLAG</span><span class="p">(</span><span class="n">Reclaim</span><span class="p">,</span> <span class="n">reclaim</span><span class="p">)</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Readahead</span><span class="p">,</span> <span class="n">reclaim</span><span class="p">)</span>		<span class="cm">/* Reminder to do async read-ahead */</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="cm">/*</span>
<span class="cm"> * Must use a macro here due to header dependency issues. page_zone() is not</span>
<span class="cm"> * available at this point.</span>
<span class="cm"> */</span>
<span class="cp">#define PageHighMem(__p) is_highmem(page_zone(__p))</span>
<span class="cp">#else</span>
<span class="n">PAGEFLAG_FALSE</span><span class="p">(</span><span class="n">HighMem</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SWAP</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">SwapCache</span><span class="p">,</span> <span class="n">swapcache</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="n">PAGEFLAG_FALSE</span><span class="p">(</span><span class="n">SwapCache</span><span class="p">)</span>
	<span class="n">SETPAGEFLAG_NOOP</span><span class="p">(</span><span class="n">SwapCache</span><span class="p">)</span> <span class="n">CLEARPAGEFLAG_NOOP</span><span class="p">(</span><span class="n">SwapCache</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Unevictable</span><span class="p">,</span> <span class="n">unevictable</span><span class="p">)</span> <span class="n">__CLEARPAGEFLAG</span><span class="p">(</span><span class="n">Unevictable</span><span class="p">,</span> <span class="n">unevictable</span><span class="p">)</span>
	<span class="n">TESTCLEARFLAG</span><span class="p">(</span><span class="n">Unevictable</span><span class="p">,</span> <span class="n">unevictable</span><span class="p">)</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Mlocked</span><span class="p">,</span> <span class="n">mlocked</span><span class="p">)</span> <span class="n">__CLEARPAGEFLAG</span><span class="p">(</span><span class="n">Mlocked</span><span class="p">,</span> <span class="n">mlocked</span><span class="p">)</span>
	<span class="n">TESTSCFLAG</span><span class="p">(</span><span class="n">Mlocked</span><span class="p">,</span> <span class="n">mlocked</span><span class="p">)</span> <span class="n">__TESTCLEARFLAG</span><span class="p">(</span><span class="n">Mlocked</span><span class="p">,</span> <span class="n">mlocked</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="n">PAGEFLAG_FALSE</span><span class="p">(</span><span class="n">Mlocked</span><span class="p">)</span> <span class="n">SETPAGEFLAG_NOOP</span><span class="p">(</span><span class="n">Mlocked</span><span class="p">)</span>
	<span class="n">TESTCLEARFLAG_FALSE</span><span class="p">(</span><span class="n">Mlocked</span><span class="p">)</span> <span class="n">__TESTCLEARFLAG_FALSE</span><span class="p">(</span><span class="n">Mlocked</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ARCH_USES_PG_UNCACHED</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">Uncached</span><span class="p">,</span> <span class="n">uncached</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="n">PAGEFLAG_FALSE</span><span class="p">(</span><span class="n">Uncached</span><span class="p">)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MEMORY_FAILURE</span>
<span class="n">PAGEFLAG</span><span class="p">(</span><span class="n">HWPoison</span><span class="p">,</span> <span class="n">hwpoison</span><span class="p">)</span>
<span class="n">TESTSCFLAG</span><span class="p">(</span><span class="n">HWPoison</span><span class="p">,</span> <span class="n">hwpoison</span><span class="p">)</span>
<span class="cp">#define __PG_HWPOISON (1UL &lt;&lt; PG_hwpoison)</span>
<span class="cp">#else</span>
<span class="n">PAGEFLAG_FALSE</span><span class="p">(</span><span class="n">HWPoison</span><span class="p">)</span>
<span class="cp">#define __PG_HWPOISON 0</span>
<span class="cp">#endif</span>

<span class="n">u64</span> <span class="n">stable_page_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">PageUptodate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">PG_uptodate</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must ensure that the data we read out of the page is loaded</span>
<span class="cm">	 * _after_ we&#39;ve loaded page-&gt;flags to check for PageUptodate.</span>
<span class="cm">	 * We can skip the barrier if the page is not uptodate, because</span>
<span class="cm">	 * we wouldn&#39;t be reading anything from it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See SetPageUptodate() for the other side of the story.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__SetPageUptodate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">PG_uptodate</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">SetPageUptodate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_S390</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">PG_uptodate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">page_set_storage_key</span><span class="p">(</span><span class="n">page_to_phys</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">PAGE_DEFAULT_KEY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="cm">/*</span>
<span class="cm">	 * Memory barrier must be issued before setting the PG_uptodate bit,</span>
<span class="cm">	 * so that all previous stores issued in order to bring the page</span>
<span class="cm">	 * uptodate are actually visible before PageUptodate becomes true.</span>
<span class="cm">	 *</span>
<span class="cm">	 * s390 doesn&#39;t need an explicit smp_wmb here because the test and</span>
<span class="cm">	 * set bit already provides full barriers.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">PG_uptodate</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">CLEARPAGEFLAG</span><span class="p">(</span><span class="n">Uptodate</span><span class="p">,</span> <span class="n">uptodate</span><span class="p">)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">cancel_dirty_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">account_size</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">test_clear_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">test_set_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">test_set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PAGEFLAGS_EXTENDED</span>
<span class="cm">/*</span>
<span class="cm"> * System with lots of page flags available. This allows separate</span>
<span class="cm"> * flags for PageHead() and PageTail() checks of compound pages so that bit</span>
<span class="cm"> * tests can be used in performance sensitive paths. PageCompound is</span>
<span class="cm"> * generally not used in hot code paths.</span>
<span class="cm"> */</span>
<span class="n">__PAGEFLAG</span><span class="p">(</span><span class="n">Head</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="n">CLEARPAGEFLAG</span><span class="p">(</span><span class="n">Head</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
<span class="n">__PAGEFLAG</span><span class="p">(</span><span class="n">Tail</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">PageCompound</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">PG_head</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">PG_tail</span><span class="p">));</span>

<span class="p">}</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">ClearPageCompound</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">ClearPageHead</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * Reduce page flag use as much as possible by overlapping</span>
<span class="cm"> * compound page flags with the flags used for page cache pages. Possible</span>
<span class="cm"> * because PageCompound is always set for compound pages and not for</span>
<span class="cm"> * pages on the LRU and/or pagecache.</span>
<span class="cm"> */</span>
<span class="n">TESTPAGEFLAG</span><span class="p">(</span><span class="n">Compound</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span>
<span class="n">__PAGEFLAG</span><span class="p">(</span><span class="n">Head</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * PG_reclaim is used in combination with PG_compound to mark the</span>
<span class="cm"> * head and tail of a compound page. This saves one page flag</span>
<span class="cm"> * but makes it impossible to use compound pages for the page cache.</span>
<span class="cm"> * The PG_reclaim bit would have to be used for reclaim or readahead</span>
<span class="cm"> * if compound pages enter the page cache.</span>
<span class="cm"> *</span>
<span class="cm"> * PG_compound &amp; PG_reclaim	=&gt; Tail page</span>
<span class="cm"> * PG_compound &amp; ~PG_reclaim	=&gt; Head page</span>
<span class="cm"> */</span>
<span class="cp">#define PG_head_tail_mask ((1L &lt;&lt; PG_compound) | (1L &lt;&lt; PG_reclaim))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">PageTail</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PG_head_tail_mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">PG_head_tail_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__SetPageTail</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PG_head_tail_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__ClearPageTail</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PG_head_tail_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">ClearPageCompound</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PG_head_tail_mask</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_compound</span><span class="p">));</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">PG_compound</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* !PAGEFLAGS_EXTENDED */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="cm">/*</span>
<span class="cm"> * PageHuge() only returns true for hugetlbfs pages, but not for</span>
<span class="cm"> * normal or transparent huge pages.</span>
<span class="cm"> *</span>
<span class="cm"> * PageTransHuge() returns true for both transparent huge and</span>
<span class="cm"> * hugetlbfs pages, but not normal pages. PageTransHuge() can only be</span>
<span class="cm"> * called only in the core VM paths where hugetlbfs pages can&#39;t exist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">PageTransHuge</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageTail</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PageTransCompound returns true for both transparent huge pages</span>
<span class="cm"> * and hugetlbfs pages, so it should only be called when it&#39;s known</span>
<span class="cm"> * that hugetlbfs pages aren&#39;t involved.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">PageTransCompound</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PageTransTail returns true for both transparent huge pages</span>
<span class="cm"> * and hugetlbfs pages, so it should only be called when it&#39;s known</span>
<span class="cm"> * that hugetlbfs pages aren&#39;t involved.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">PageTransTail</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">PageTail</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">PageTransHuge</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">PageTransCompound</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">PageTransTail</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="cp">#define __PG_MLOCKED		(1 &lt;&lt; PG_mlocked)</span>
<span class="cp">#else</span>
<span class="cp">#define __PG_MLOCKED		0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="cp">#define __PG_COMPOUND_LOCK		(1 &lt;&lt; PG_compound_lock)</span>
<span class="cp">#else</span>
<span class="cp">#define __PG_COMPOUND_LOCK		0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Flags checked when a page is freed.  Pages being freed should not have</span>
<span class="cm"> * these flags set.  It they are, there is a problem.</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_FLAGS_CHECK_AT_FREE \</span>
<span class="cp">	(1 &lt;&lt; PG_lru	 | 1 &lt;&lt; PG_locked    | \</span>
<span class="cp">	 1 &lt;&lt; PG_private | 1 &lt;&lt; PG_private_2 | \</span>
<span class="cp">	 1 &lt;&lt; PG_writeback | 1 &lt;&lt; PG_reserved | \</span>
<span class="cp">	 1 &lt;&lt; PG_slab	 | 1 &lt;&lt; PG_swapcache | 1 &lt;&lt; PG_active | \</span>
<span class="cp">	 1 &lt;&lt; PG_unevictable | __PG_MLOCKED | __PG_HWPOISON | \</span>
<span class="cp">	 __PG_COMPOUND_LOCK)</span>

<span class="cm">/*</span>
<span class="cm"> * Flags checked when a page is prepped for return by the page allocator.</span>
<span class="cm"> * Pages being prepped should not have any flags set.  It they are set,</span>
<span class="cm"> * there has been a kernel bug or struct page corruption.</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_FLAGS_CHECK_AT_PREP	((1 &lt;&lt; NR_PAGEFLAGS) - 1)</span>

<span class="cp">#define PAGE_FLAGS_PRIVATE				\</span>
<span class="cp">	(1 &lt;&lt; PG_private | 1 &lt;&lt; PG_private_2)</span>
<span class="cm">/**</span>
<span class="cm"> * page_has_private - Determine if page has private stuff</span>
<span class="cm"> * @page: The page to be checked</span>
<span class="cm"> *</span>
<span class="cm"> * Determine if a page has private stuff, indicating that release routines</span>
<span class="cm"> * should be invoked upon it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">page_has_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PAGE_FLAGS_PRIVATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !__GENERATING_BOUNDS_H */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* PAGE_FLAGS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
