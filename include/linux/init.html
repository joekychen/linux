<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › init.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>init.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_INIT_H</span>
<span class="cp">#define _LINUX_INIT_H</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/* These macros are used to mark some functions or </span>
<span class="cm"> * initialized data (doesn&#39;t apply to uninitialized data)</span>
<span class="cm"> * as `initialization&#39; functions. The kernel can take this</span>
<span class="cm"> * as hint that the function is used only during the initialization</span>
<span class="cm"> * phase and free up used memory resources after</span>
<span class="cm"> *</span>
<span class="cm"> * Usage:</span>
<span class="cm"> * For functions:</span>
<span class="cm"> * </span>
<span class="cm"> * You should add __init immediately before the function name, like:</span>
<span class="cm"> *</span>
<span class="cm"> * static void __init initme(int x, int y)</span>
<span class="cm"> * {</span>
<span class="cm"> *    extern int z; z = x * y;</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * If the function has a prototype somewhere, you can also add</span>
<span class="cm"> * __init between closing brace of the prototype and semicolon:</span>
<span class="cm"> *</span>
<span class="cm"> * extern int initialize_foobar_device(int, int, int) __init;</span>
<span class="cm"> *</span>
<span class="cm"> * For initialized data:</span>
<span class="cm"> * You should insert __initdata between the variable name and equal</span>
<span class="cm"> * sign followed by value, e.g.:</span>
<span class="cm"> *</span>
<span class="cm"> * static int init_variable __initdata = 0;</span>
<span class="cm"> * static const char linux_logo[] __initconst = { 0x32, 0x36, ... };</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t forget to initialize data not at file scope, i.e. within a function,</span>
<span class="cm"> * as gcc otherwise puts the data into the bss section and not into the init</span>
<span class="cm"> * section.</span>
<span class="cm"> * </span>
<span class="cm"> * Also note, that this data cannot be &quot;const&quot;.</span>
<span class="cm"> */</span>

<span class="cm">/* These are for everybody (although not all archs will actually</span>
<span class="cm">   discard it in modules) */</span>
<span class="cp">#define __init		__section(.init.text) __cold notrace</span>
<span class="cp">#define __initdata	__section(.init.data)</span>
<span class="cp">#define __initconst	__section(.init.rodata)</span>
<span class="cp">#define __exitdata	__section(.exit.data)</span>
<span class="cp">#define __exit_call	__used __section(.exitcall.exit)</span>

<span class="cm">/*</span>
<span class="cm"> * modpost check for section mismatches during the kernel build.</span>
<span class="cm"> * A section mismatch happens when there are references from a</span>
<span class="cm"> * code or data section to an init section (both code or data).</span>
<span class="cm"> * The init sections are (for most archs) discarded by the kernel</span>
<span class="cm"> * when early init has completed so all such references are potential bugs.</span>
<span class="cm"> * For exit sections the same issue exists.</span>
<span class="cm"> *</span>
<span class="cm"> * The following markers are used for the cases where the reference to</span>
<span class="cm"> * the *init / *exit section (code or data) is valid and will teach</span>
<span class="cm"> * modpost not to issue a warning.  Intended semantics is that a code or</span>
<span class="cm"> * data tagged __ref* can reference code or data from init section without</span>
<span class="cm"> * producing a warning (of course, no warning does not mean code is</span>
<span class="cm"> * correct, so optimally document why the __ref is needed and why it&#39;s OK).</span>
<span class="cm"> *</span>
<span class="cm"> * The markers follow same syntax rules as __init / __initdata.</span>
<span class="cm"> */</span>
<span class="cp">#define __ref            __section(.ref.text) noinline</span>
<span class="cp">#define __refdata        __section(.ref.data)</span>
<span class="cp">#define __refconst       __section(.ref.rodata)</span>

<span class="cm">/* compatibility defines */</span>
<span class="cp">#define __init_refok     __ref</span>
<span class="cp">#define __initdata_refok __refdata</span>
<span class="cp">#define __exit_refok     __ref</span>


<span class="cp">#ifdef MODULE</span>
<span class="cp">#define __exitused</span>
<span class="cp">#else</span>
<span class="cp">#define __exitused  __used</span>
<span class="cp">#endif</span>

<span class="cp">#define __exit          __section(.exit.text) __exitused __cold notrace</span>

<span class="cm">/* Used for HOTPLUG */</span>
<span class="cp">#define __devinit        __section(.devinit.text) __cold notrace</span>
<span class="cp">#define __devinitdata    __section(.devinit.data)</span>
<span class="cp">#define __devinitconst   __section(.devinit.rodata)</span>
<span class="cp">#define __devexit        __section(.devexit.text) __exitused __cold notrace</span>
<span class="cp">#define __devexitdata    __section(.devexit.data)</span>
<span class="cp">#define __devexitconst   __section(.devexit.rodata)</span>

<span class="cm">/* Used for HOTPLUG_CPU */</span>
<span class="cp">#define __cpuinit        __section(.cpuinit.text) __cold notrace</span>
<span class="cp">#define __cpuinitdata    __section(.cpuinit.data)</span>
<span class="cp">#define __cpuinitconst   __section(.cpuinit.rodata)</span>
<span class="cp">#define __cpuexit        __section(.cpuexit.text) __exitused __cold notrace</span>
<span class="cp">#define __cpuexitdata    __section(.cpuexit.data)</span>
<span class="cp">#define __cpuexitconst   __section(.cpuexit.rodata)</span>

<span class="cm">/* Used for MEMORY_HOTPLUG */</span>
<span class="cp">#define __meminit        __section(.meminit.text) __cold notrace</span>
<span class="cp">#define __meminitdata    __section(.meminit.data)</span>
<span class="cp">#define __meminitconst   __section(.meminit.rodata)</span>
<span class="cp">#define __memexit        __section(.memexit.text) __exitused __cold notrace</span>
<span class="cp">#define __memexitdata    __section(.memexit.data)</span>
<span class="cp">#define __memexitconst   __section(.memexit.rodata)</span>

<span class="cm">/* For assembly routines */</span>
<span class="cp">#define __HEAD		.section	&quot;.head.text&quot;,&quot;ax&quot;</span>
<span class="cp">#define __INIT		.section	&quot;.init.text&quot;,&quot;ax&quot;</span>
<span class="cp">#define __FINIT		.previous</span>

<span class="cp">#define __INITDATA	.section	&quot;.init.data&quot;,&quot;aw&quot;,%progbits</span>
<span class="cp">#define __INITRODATA	.section	&quot;.init.rodata&quot;,&quot;a&quot;,%progbits</span>
<span class="cp">#define __FINITDATA	.previous</span>

<span class="cp">#define __DEVINIT        .section	&quot;.devinit.text&quot;, &quot;ax&quot;</span>
<span class="cp">#define __DEVINITDATA    .section	&quot;.devinit.data&quot;, &quot;aw&quot;</span>
<span class="cp">#define __DEVINITRODATA  .section	&quot;.devinit.rodata&quot;, &quot;a&quot;</span>

<span class="cp">#define __CPUINIT        .section	&quot;.cpuinit.text&quot;, &quot;ax&quot;</span>
<span class="cp">#define __CPUINITDATA    .section	&quot;.cpuinit.data&quot;, &quot;aw&quot;</span>
<span class="cp">#define __CPUINITRODATA  .section	&quot;.cpuinit.rodata&quot;, &quot;a&quot;</span>

<span class="cp">#define __MEMINIT        .section	&quot;.meminit.text&quot;, &quot;ax&quot;</span>
<span class="cp">#define __MEMINITDATA    .section	&quot;.meminit.data&quot;, &quot;aw&quot;</span>
<span class="cp">#define __MEMINITRODATA  .section	&quot;.meminit.rodata&quot;, &quot;a&quot;</span>

<span class="cm">/* silence warnings when references are OK */</span>
<span class="cp">#define __REF            .section       &quot;.ref.text&quot;, &quot;ax&quot;</span>
<span class="cp">#define __REFDATA        .section       &quot;.ref.data&quot;, &quot;aw&quot;</span>
<span class="cp">#define __REFCONST       .section       &quot;.ref.rodata&quot;, &quot;a&quot;</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cm">/*</span>
<span class="cm"> * Used for initialization calls..</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">initcall_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exitcall_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__con_initcall_start</span><span class="p">[],</span> <span class="n">__con_initcall_end</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">initcall_t</span> <span class="n">__security_initcall_start</span><span class="p">[],</span> <span class="n">__security_initcall_end</span><span class="p">[];</span>

<span class="cm">/* Used for contructor calls. */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor_fn_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Defined in init/main.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_one_initcall</span><span class="p">(</span><span class="n">initcall_t</span> <span class="n">fn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">__initdata</span> <span class="n">boot_command_line</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">saved_command_line</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reset_devices</span><span class="p">;</span>

<span class="cm">/* used by init/main.c */</span>
<span class="kt">void</span> <span class="n">setup_arch</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">prepare_namespace</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">late_time_init</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">initcall_debug</span><span class="p">;</span>

<span class="cp">#endif</span>
  
<span class="cp">#ifndef MODULE</span>

<span class="cp">#ifndef __ASSEMBLY__</span>

<span class="cm">/* initcalls are now grouped by functionality into separate </span>
<span class="cm"> * subsections. Ordering inside the subsections is determined</span>
<span class="cm"> * by link order. </span>
<span class="cm"> * For backwards compatibility, initcall() puts the call in </span>
<span class="cm"> * the device init subsection.</span>
<span class="cm"> *</span>
<span class="cm"> * The `id&#39; arg to __define_initcall() is needed so that multiple initcalls</span>
<span class="cm"> * can point at the same handler without causing duplicate-symbol build errors.</span>
<span class="cm"> */</span>

<span class="cp">#define __define_initcall(level,fn,id) \</span>
<span class="cp">	static initcall_t __initcall_##fn##id __used \</span>
<span class="cp">	__attribute__((__section__(&quot;.initcall&quot; level &quot;.init&quot;))) = fn</span>

<span class="cm">/*</span>
<span class="cm"> * Early initcalls run before initializing SMP.</span>
<span class="cm"> *</span>
<span class="cm"> * Only for built-in code, not modules.</span>
<span class="cm"> */</span>
<span class="cp">#define early_initcall(fn)		__define_initcall(&quot;early&quot;,fn,early)</span>

<span class="cm">/*</span>
<span class="cm"> * A &quot;pure&quot; initcall has no dependencies on anything else, and purely</span>
<span class="cm"> * initializes variables that couldn&#39;t be statically initialized.</span>
<span class="cm"> *</span>
<span class="cm"> * This only exists for built-in code, not for modules.</span>
<span class="cm"> */</span>
<span class="cp">#define pure_initcall(fn)		__define_initcall(&quot;0&quot;,fn,0)</span>

<span class="cp">#define core_initcall(fn)		__define_initcall(&quot;1&quot;,fn,1)</span>
<span class="cp">#define core_initcall_sync(fn)		__define_initcall(&quot;1s&quot;,fn,1s)</span>
<span class="cp">#define postcore_initcall(fn)		__define_initcall(&quot;2&quot;,fn,2)</span>
<span class="cp">#define postcore_initcall_sync(fn)	__define_initcall(&quot;2s&quot;,fn,2s)</span>
<span class="cp">#define arch_initcall(fn)		__define_initcall(&quot;3&quot;,fn,3)</span>
<span class="cp">#define arch_initcall_sync(fn)		__define_initcall(&quot;3s&quot;,fn,3s)</span>
<span class="cp">#define subsys_initcall(fn)		__define_initcall(&quot;4&quot;,fn,4)</span>
<span class="cp">#define subsys_initcall_sync(fn)	__define_initcall(&quot;4s&quot;,fn,4s)</span>
<span class="cp">#define fs_initcall(fn)			__define_initcall(&quot;5&quot;,fn,5)</span>
<span class="cp">#define fs_initcall_sync(fn)		__define_initcall(&quot;5s&quot;,fn,5s)</span>
<span class="cp">#define rootfs_initcall(fn)		__define_initcall(&quot;rootfs&quot;,fn,rootfs)</span>
<span class="cp">#define device_initcall(fn)		__define_initcall(&quot;6&quot;,fn,6)</span>
<span class="cp">#define device_initcall_sync(fn)	__define_initcall(&quot;6s&quot;,fn,6s)</span>
<span class="cp">#define late_initcall(fn)		__define_initcall(&quot;7&quot;,fn,7)</span>
<span class="cp">#define late_initcall_sync(fn)		__define_initcall(&quot;7s&quot;,fn,7s)</span>

<span class="cp">#define __initcall(fn) device_initcall(fn)</span>

<span class="cp">#define __exitcall(fn) \</span>
<span class="cp">	static exitcall_t __exitcall_##fn __exit_call = fn</span>

<span class="cp">#define console_initcall(fn) \</span>
<span class="cp">	static initcall_t __initcall_##fn \</span>
<span class="cp">	__used __section(.con_initcall.init) = fn</span>

<span class="cp">#define security_initcall(fn) \</span>
<span class="cp">	static initcall_t __initcall_##fn \</span>
<span class="cp">	__used __section(.security_initcall.init) = fn</span>

<span class="k">struct</span> <span class="n">obs_kernel_param</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_func</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">early</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Only for really core code.  See moduleparam.h for the normal way.</span>
<span class="cm"> *</span>
<span class="cm"> * Force the alignment so the compiler doesn&#39;t space elements of the</span>
<span class="cm"> * obs_kernel_param &quot;array&quot; too far apart in .init.setup.</span>
<span class="cm"> */</span>
<span class="cp">#define __setup_param(str, unique_id, fn, early)			\</span>
<span class="cp">	static const char __setup_str_##unique_id[] __initconst	\</span>
<span class="cp">		__aligned(1) = str; \</span>
<span class="cp">	static struct obs_kernel_param __setup_##unique_id	\</span>
<span class="cp">		__used __section(.init.setup)			\</span>
<span class="cp">		__attribute__((aligned((sizeof(long)))))	\</span>
<span class="cp">		= { __setup_str_##unique_id, fn, early }</span>

<span class="cp">#define __setup(str, fn)					\</span>
<span class="cp">	__setup_param(str, fn, fn, 0)</span>

<span class="cm">/* NOTE: fn is as per module_param, not __setup!  Emits warning if fn</span>
<span class="cm"> * returns non-zero. */</span>
<span class="cp">#define early_param(str, fn)					\</span>
<span class="cp">	__setup_param(str, fn, fn, 1)</span>

<span class="cm">/* Relies on boot_command_line being set */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="n">parse_early_param</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="n">parse_early_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmdline</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __ASSEMBLY__ */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * module_init() - driver initialization entry point</span>
<span class="cm"> * @x: function to be run at kernel boot time or module insertion</span>
<span class="cm"> * </span>
<span class="cm"> * module_init() will either be called during do_initcalls() (if</span>
<span class="cm"> * builtin) or at module insertion time (if a module).  There can only</span>
<span class="cm"> * be one per module.</span>
<span class="cm"> */</span>
<span class="cp">#define module_init(x)	__initcall(x);</span>

<span class="cm">/**</span>
<span class="cm"> * module_exit() - driver exit entry point</span>
<span class="cm"> * @x: function to be run when driver is removed</span>
<span class="cm"> * </span>
<span class="cm"> * module_exit() will wrap the driver clean-up code</span>
<span class="cm"> * with cleanup_module() when used with rmmod when</span>
<span class="cm"> * the driver is a module.  If the driver is statically</span>
<span class="cm"> * compiled into the kernel, module_exit() has no effect.</span>
<span class="cm"> * There can only be one per module.</span>
<span class="cm"> */</span>
<span class="cp">#define module_exit(x)	__exitcall(x);</span>

<span class="cp">#else </span><span class="cm">/* MODULE */</span><span class="cp"></span>

<span class="cm">/* Don&#39;t use these in modules, but some people do... */</span>
<span class="cp">#define early_initcall(fn)		module_init(fn)</span>
<span class="cp">#define core_initcall(fn)		module_init(fn)</span>
<span class="cp">#define postcore_initcall(fn)		module_init(fn)</span>
<span class="cp">#define arch_initcall(fn)		module_init(fn)</span>
<span class="cp">#define subsys_initcall(fn)		module_init(fn)</span>
<span class="cp">#define fs_initcall(fn)			module_init(fn)</span>
<span class="cp">#define device_initcall(fn)		module_init(fn)</span>
<span class="cp">#define late_initcall(fn)		module_init(fn)</span>

<span class="cp">#define security_initcall(fn)		module_init(fn)</span>

<span class="cm">/* Each module must use one module_init(). */</span>
<span class="cp">#define module_init(initfn)					\</span>
<span class="cp">	static inline initcall_t __inittest(void)		\</span>
<span class="cp">	{ return initfn; }					\</span>
<span class="cp">	int init_module(void) __attribute__((alias(#initfn)));</span>

<span class="cm">/* This is only required if you want to be unloadable. */</span>
<span class="cp">#define module_exit(exitfn)					\</span>
<span class="cp">	static inline exitcall_t __exittest(void)		\</span>
<span class="cp">	{ return exitfn; }					\</span>
<span class="cp">	void cleanup_module(void) __attribute__((alias(#exitfn)));</span>

<span class="cp">#define __setup_param(str, unique_id, fn)	</span><span class="cm">/* nothing */</span><span class="cp"></span>
<span class="cp">#define __setup(str, func) 			</span><span class="cm">/* nothing */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/* Data marked not to be saved by software suspend */</span>
<span class="cp">#define __nosavedata __section(.data..nosave)</span>

<span class="cm">/* This means &quot;can be init if no module support, otherwise module load</span>
<span class="cm">   may call it.&quot; */</span>
<span class="cp">#ifdef CONFIG_MODULES</span>
<span class="cp">#define __init_or_module</span>
<span class="cp">#define __initdata_or_module</span>
<span class="cp">#define __initconst_or_module</span>
<span class="cp">#define __INIT_OR_MODULE	.text</span>
<span class="cp">#define __INITDATA_OR_MODULE	.data</span>
<span class="cp">#define __INITRODATA_OR_MODULE	.section &quot;.rodata&quot;,&quot;a&quot;,%progbits</span>
<span class="cp">#else</span>
<span class="cp">#define __init_or_module __init</span>
<span class="cp">#define __initdata_or_module __initdata</span>
<span class="cp">#define __initconst_or_module __initconst</span>
<span class="cp">#define __INIT_OR_MODULE __INIT</span>
<span class="cp">#define __INITDATA_OR_MODULE __INITDATA</span>
<span class="cp">#define __INITRODATA_OR_MODULE __INITRODATA</span>
<span class="cp">#endif </span><span class="cm">/*CONFIG_MODULES*/</span><span class="cp"></span>

<span class="cm">/* Functions marked as __devexit may be discarded at kernel link time, depending</span>
<span class="cm">   on config options.  Newer versions of binutils detect references from</span>
<span class="cm">   retained sections to discarded sections and flag an error.  Pointers to</span>
<span class="cm">   __devexit functions must use __devexit_p(function_name), the wrapper will</span>
<span class="cm">   insert either the function_name or NULL, depending on the config options.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(MODULE) || defined(CONFIG_HOTPLUG)</span>
<span class="cp">#define __devexit_p(x) x</span>
<span class="cp">#else</span>
<span class="cp">#define __devexit_p(x) NULL</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef MODULE</span>
<span class="cp">#define __exit_p(x) x</span>
<span class="cp">#else</span>
<span class="cp">#define __exit_p(x) NULL</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_INIT_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
