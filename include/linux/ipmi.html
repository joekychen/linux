<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ipmi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ipmi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ipmi.h</span>
<span class="cm"> *</span>
<span class="cm"> * MontaVista IPMI interface</span>
<span class="cm"> *</span>
<span class="cm"> * Author: MontaVista Software, Inc.</span>
<span class="cm"> *         Corey Minyard &lt;minyard@mvista.com&gt;</span>
<span class="cm"> *         source@mvista.com</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2002 MontaVista Software Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> *  under the terms of the GNU General Public License as published by the</span>
<span class="cm"> *  Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> *  option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<span class="cm"> *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="cm"> *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS</span>
<span class="cm"> *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm"> *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</span>
<span class="cm"> *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE</span>
<span class="cm"> *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along</span>
<span class="cm"> *  with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> *  675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_IPMI_H</span>
<span class="cp">#define __LINUX_IPMI_H</span>

<span class="cp">#include &lt;linux/ipmi_msgdefs.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This file describes an interface to an IPMI driver.  You have to</span>
<span class="cm"> * have a fairly good understanding of IPMI to use this, so go read</span>
<span class="cm"> * the specs first before actually trying to do anything.</span>
<span class="cm"> *</span>
<span class="cm"> * With that said, this driver provides a multi-user interface to the</span>
<span class="cm"> * IPMI driver, and it allows multiple IPMI physical interfaces below</span>
<span class="cm"> * the driver.  The physical interfaces bind as a lower layer on the</span>
<span class="cm"> * driver.  They appear as interfaces to the application using this</span>
<span class="cm"> * interface.</span>
<span class="cm"> *</span>
<span class="cm"> * Multi-user means that multiple applications may use the driver,</span>
<span class="cm"> * send commands, receive responses, etc.  The driver keeps track of</span>
<span class="cm"> * commands the user sends and tracks the responses.  The responses</span>
<span class="cm"> * will go back to the application that send the command.  If the</span>
<span class="cm"> * response doesn&#39;t come back in time, the driver will return a</span>
<span class="cm"> * timeout error response to the application.  Asynchronous events</span>
<span class="cm"> * from the BMC event queue will go to all users bound to the driver.</span>
<span class="cm"> * The incoming event queue in the BMC will automatically be flushed</span>
<span class="cm"> * if it becomes full and it is queried once a second to see if</span>
<span class="cm"> * anything is in it.  Incoming commands to the driver will get</span>
<span class="cm"> * delivered as commands.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver provides two main interfaces: one for in-kernel</span>
<span class="cm"> * applications and another for userland applications.  The</span>
<span class="cm"> * capabilities are basically the same for both interface, although</span>
<span class="cm"> * the interfaces are somewhat different.  The stuff in the</span>
<span class="cm"> * #ifdef __KERNEL__ below is the in-kernel interface.  The userland</span>
<span class="cm"> * interface is defined later in the file.  */</span>



<span class="cm">/*</span>
<span class="cm"> * This is an overlay for all the address types, so it&#39;s easy to</span>
<span class="cm"> * determine the actual address type.  This is kind of like addresses</span>
<span class="cm"> * work for sockets.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMI_MAX_ADDR_SIZE 32</span>
<span class="k">struct</span> <span class="n">ipmi_addr</span> <span class="p">{</span>
	 <span class="cm">/* Try to take these from the &quot;Channel Medium Type&quot; table</span>
<span class="cm">	    in section 6.5 of the IPMI 1.5 manual. */</span>
	<span class="kt">int</span>   <span class="n">addr_type</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">char</span>  <span class="n">data</span><span class="p">[</span><span class="n">IPMI_MAX_ADDR_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * When the address is not used, the type will be set to this value.</span>
<span class="cm"> * The channel is the BMC&#39;s channel number for the channel (usually</span>
<span class="cm"> * 0), or IPMC_BMC_CHANNEL if communicating directly with the BMC.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMI_SYSTEM_INTERFACE_ADDR_TYPE	0x0c</span>
<span class="k">struct</span> <span class="n">ipmi_system_interface_addr</span> <span class="p">{</span>
	<span class="kt">int</span>           <span class="n">addr_type</span><span class="p">;</span>
	<span class="kt">short</span>         <span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lun</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* An IPMB Address. */</span>
<span class="cp">#define IPMI_IPMB_ADDR_TYPE		0x01</span>
<span class="cm">/* Used for broadcast get device id as described in section 17.9 of the</span>
<span class="cm">   IPMI 1.5 manual. */</span>
<span class="cp">#define IPMI_IPMB_BROADCAST_ADDR_TYPE	0x41</span>
<span class="k">struct</span> <span class="n">ipmi_ipmb_addr</span> <span class="p">{</span>
	<span class="kt">int</span>           <span class="n">addr_type</span><span class="p">;</span>
	<span class="kt">short</span>         <span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">slave_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lun</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A LAN Address.  This is an address to/from a LAN interface bridged</span>
<span class="cm"> * by the BMC, not an address actually out on the LAN.</span>
<span class="cm"> *</span>
<span class="cm"> * A conscious decision was made here to deviate slightly from the IPMI</span>
<span class="cm"> * spec.  We do not use rqSWID and rsSWID like it shows in the</span>
<span class="cm"> * message.  Instead, we use remote_SWID and local_SWID.  This means</span>
<span class="cm"> * that any message (a request or response) from another device will</span>
<span class="cm"> * always have exactly the same address.  If you didn&#39;t do this,</span>
<span class="cm"> * requests and responses from the same device would have different</span>
<span class="cm"> * addresses, and that&#39;s not too cool.</span>
<span class="cm"> *</span>
<span class="cm"> * In this address, the remote_SWID is always the SWID the remote</span>
<span class="cm"> * message came from, or the SWID we are sending the message to.</span>
<span class="cm"> * local_SWID is always our SWID.  Note that having our SWID in the</span>
<span class="cm"> * message is a little weird, but this is required.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMI_LAN_ADDR_TYPE		0x04</span>
<span class="k">struct</span> <span class="n">ipmi_lan_addr</span> <span class="p">{</span>
	<span class="kt">int</span>           <span class="n">addr_type</span><span class="p">;</span>
	<span class="kt">short</span>         <span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">privilege</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">session_handle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">remote_SWID</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">local_SWID</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lun</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Channel for talking directly with the BMC.  When using this</span>
<span class="cm"> * channel, This is for the system interface address type only.  FIXME</span>
<span class="cm"> * - is this right, or should we use -1?</span>
<span class="cm"> */</span>
<span class="cp">#define IPMI_BMC_CHANNEL  0xf</span>
<span class="cp">#define IPMI_NUM_CHANNELS 0x10</span>

<span class="cm">/*</span>
<span class="cm"> * Used to signify an &quot;all channel&quot; bitmask.  This is more than the</span>
<span class="cm"> * actual number of channels because this is used in userland and</span>
<span class="cm"> * will cover us if the number of channels is extended.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMI_CHAN_ALL     (~0)</span>


<span class="cm">/*</span>
<span class="cm"> * A raw IPMI message without any addressing.  This covers both</span>
<span class="cm"> * commands and responses.  The completion code is always the first</span>
<span class="cm"> * byte of data in the response (as the spec shows the messages laid</span>
<span class="cm"> * out).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipmi_msg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">netfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kernel_ipmi_msg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">netfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Various defines that are useful for IPMI applications.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMI_INVALID_CMD_COMPLETION_CODE	0xC1</span>
<span class="cp">#define IPMI_TIMEOUT_COMPLETION_CODE		0xC3</span>
<span class="cp">#define IPMI_UNKNOWN_ERR_COMPLETION_CODE	0xff</span>


<span class="cm">/*</span>
<span class="cm"> * Receive types for messages coming from the receive interface.  This</span>
<span class="cm"> * is used for the receive in-kernel interface and in the receive</span>
<span class="cm"> * IOCTL.</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;IPMI_RESPONSE_RESPNOSE_TYPE&quot; is a little strange sounding, but</span>
<span class="cm"> * it allows you to get the message results when you send a response</span>
<span class="cm"> * message.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMI_RESPONSE_RECV_TYPE		1 </span><span class="cm">/* A response to a command */</span><span class="cp"></span>
<span class="cp">#define IPMI_ASYNC_EVENT_RECV_TYPE	2 </span><span class="cm">/* Something from the event queue */</span><span class="cp"></span>
<span class="cp">#define IPMI_CMD_RECV_TYPE		3 </span><span class="cm">/* A command from somewhere else */</span><span class="cp"></span>
<span class="cp">#define IPMI_RESPONSE_RESPONSE_TYPE	4 </span><span class="cm">/* The response for</span>
<span class="cm">					      a sent response, giving any</span>
<span class="cm">					      error status for sending the</span>
<span class="cm">					      response.  When you send a</span>
<span class="cm">					      response message, this will</span>
<span class="cm">					      be returned. */</span><span class="cp"></span>
<span class="cp">#define IPMI_OEM_RECV_TYPE		5 </span><span class="cm">/* The response for OEM Channels */</span><span class="cp"></span>

<span class="cm">/* Note that async events and received commands do not have a completion</span>
<span class="cm">   code as the first byte of the incoming data, unlike a response. */</span>


<span class="cm">/*</span>
<span class="cm"> * Modes for ipmi_set_maint_mode() and the userland IOCTL.  The AUTO</span>
<span class="cm"> * setting is the default and means it will be set on certain</span>
<span class="cm"> * commands.  Hard setting it on and off will override automatic</span>
<span class="cm"> * operation.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMI_MAINTENANCE_MODE_AUTO	0</span>
<span class="cp">#define IPMI_MAINTENANCE_MODE_OFF	1</span>
<span class="cp">#define IPMI_MAINTENANCE_MODE_ON	2</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * The in-kernel interface.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cm">/* Opaque type for a IPMI message user.  One of these is needed to</span>
<span class="cm">   send and receive messages. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ipmi_user</span> <span class="o">*</span><span class="n">ipmi_user_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Stuff coming from the receive interface comes as one of these.</span>
<span class="cm"> * They are allocated, the receiver must free them with</span>
<span class="cm"> * ipmi_free_recv_msg() when done with the message.  The link is not</span>
<span class="cm"> * used after the message is delivered, so the upper layer may use the</span>
<span class="cm"> * link to build a linked list, if it likes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipmi_recv_msg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>

	<span class="cm">/* The type of message as defined in the &quot;Receive Types&quot;</span>
<span class="cm">	   defines above. */</span>
	<span class="kt">int</span>              <span class="n">recv_type</span><span class="p">;</span>

	<span class="n">ipmi_user_t</span>      <span class="n">user</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipmi_addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">long</span>             <span class="n">msgid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kernel_ipmi_msg</span>  <span class="n">msg</span><span class="p">;</span>

	<span class="cm">/* The user_msg_data is the data supplied when a message was</span>
<span class="cm">	   sent, if this is a response to a sent message.  If this is</span>
<span class="cm">	   not a response to a sent message, then user_msg_data will</span>
<span class="cm">	   be NULL.  If the user above is NULL, then this will be the</span>
<span class="cm">	   intf. */</span>
	<span class="kt">void</span>             <span class="o">*</span><span class="n">user_msg_data</span><span class="p">;</span>

	<span class="cm">/* Call this when done with the message.  It will presumably free</span>
<span class="cm">	   the message and do any other necessary cleanup. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipmi_recv_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Place-holder for the data, don&#39;t make any assumptions about</span>
<span class="cm">	   the size or existence of this, since it may change. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>   <span class="n">msg_data</span><span class="p">[</span><span class="n">IPMI_MAX_MSG_LENGTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Allocate and free the receive message. */</span>
<span class="kt">void</span> <span class="n">ipmi_free_recv_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipmi_recv_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ipmi_user_hndl</span> <span class="p">{</span>
	<span class="cm">/* Routine type to call when a message needs to be routed to</span>
<span class="cm">	   the upper layer.  This will be called with some locks held,</span>
<span class="cm">	   the only IPMI routines that can be called are ipmi_request</span>
<span class="cm">	   and the alloc/free operations.  The handler_data is the</span>
<span class="cm">	   variable supplied when the receive handler was registered. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipmi_recv_hndl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipmi_recv_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			       <span class="kt">void</span>                 <span class="o">*</span><span class="n">user_msg_data</span><span class="p">);</span>

	<span class="cm">/* Called when the interface detects a watchdog pre-timeout.  If</span>
<span class="cm">	   this is NULL, it will be ignored for the user. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipmi_watchdog_pretimeout</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handler_data</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* Create a new user of the IPMI layer on the given interface number. */</span>
<span class="kt">int</span> <span class="n">ipmi_create_user</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span>          <span class="n">if_num</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ipmi_user_hndl</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span>
		     <span class="kt">void</span>                  <span class="o">*</span><span class="n">handler_data</span><span class="p">,</span>
		     <span class="n">ipmi_user_t</span>           <span class="o">*</span><span class="n">user</span><span class="p">);</span>

<span class="cm">/* Destroy the given user of the IPMI layer.  Note that after this</span>
<span class="cm">   function returns, the system is guaranteed to not call any</span>
<span class="cm">   callbacks for the user.  Thus as long as you destroy all the users</span>
<span class="cm">   before you unload a module, you will be safe.  And if you destroy</span>
<span class="cm">   the users before you destroy the callback structures, it should be</span>
<span class="cm">   safe, too. */</span>
<span class="kt">int</span> <span class="n">ipmi_destroy_user</span><span class="p">(</span><span class="n">ipmi_user_t</span> <span class="n">user</span><span class="p">);</span>

<span class="cm">/* Get the IPMI version of the BMC we are talking to. */</span>
<span class="kt">void</span> <span class="n">ipmi_get_version</span><span class="p">(</span><span class="n">ipmi_user_t</span>   <span class="n">user</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">major</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">minor</span><span class="p">);</span>

<span class="cm">/* Set and get the slave address and LUN that we will use for our</span>
<span class="cm">   source messages.  Note that this affects the interface, not just</span>
<span class="cm">   this user, so it will affect all users of this interface.  This is</span>
<span class="cm">   so some initialization code can come in and do the OEM-specific</span>
<span class="cm">   things it takes to determine your address (if not the BMC) and set</span>
<span class="cm">   it for everyone else.  Note that each channel can have its own address. */</span>
<span class="kt">int</span> <span class="n">ipmi_set_my_address</span><span class="p">(</span><span class="n">ipmi_user_t</span>   <span class="n">user</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">channel</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">address</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipmi_get_my_address</span><span class="p">(</span><span class="n">ipmi_user_t</span>   <span class="n">user</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">channel</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">address</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipmi_set_my_LUN</span><span class="p">(</span><span class="n">ipmi_user_t</span>   <span class="n">user</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">channel</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">LUN</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipmi_get_my_LUN</span><span class="p">(</span><span class="n">ipmi_user_t</span>   <span class="n">user</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">channel</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">LUN</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Like ipmi_request, but lets you specify the number of retries and</span>
<span class="cm"> * the retry time.  The retries is the number of times the message</span>
<span class="cm"> * will be resent if no reply is received.  If set to -1, the default</span>
<span class="cm"> * value will be used.  The retry time is the time in milliseconds</span>
<span class="cm"> * between retries.  If set to zero, the default value will be</span>
<span class="cm"> * used.</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t use this unless you *really* have to.  It&#39;s primarily for the</span>
<span class="cm"> * IPMI over LAN converter; since the LAN stuff does its own retries,</span>
<span class="cm"> * it makes no sense to do it here.  However, this can be used if you</span>
<span class="cm"> * have unusual requirements.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ipmi_request_settime</span><span class="p">(</span><span class="n">ipmi_user_t</span>      <span class="n">user</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ipmi_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			 <span class="kt">long</span>             <span class="n">msgid</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">kernel_ipmi_msg</span>  <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			 <span class="kt">void</span>             <span class="o">*</span><span class="n">user_msg_data</span><span class="p">,</span>
			 <span class="kt">int</span>              <span class="n">priority</span><span class="p">,</span>
			 <span class="kt">int</span>              <span class="n">max_retries</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span>     <span class="n">retry_time_ms</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Like ipmi_request, but with messages supplied.  This will not</span>
<span class="cm"> * allocate any memory, and the messages may be statically allocated</span>
<span class="cm"> * (just make sure to do the &quot;done&quot; handling on them).  Note that this</span>
<span class="cm"> * is primarily for the watchdog timer, since it should be able to</span>
<span class="cm"> * send messages even if no memory is available.  This is subject to</span>
<span class="cm"> * change as the system changes, so don&#39;t use it unless you REALLY</span>
<span class="cm"> * have to.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ipmi_request_supply_msgs</span><span class="p">(</span><span class="n">ipmi_user_t</span>          <span class="n">user</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ipmi_addr</span>     <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			     <span class="kt">long</span>                 <span class="n">msgid</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">kernel_ipmi_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			     <span class="kt">void</span>                 <span class="o">*</span><span class="n">user_msg_data</span><span class="p">,</span>
			     <span class="kt">void</span>                 <span class="o">*</span><span class="n">supplied_smi</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ipmi_recv_msg</span> <span class="o">*</span><span class="n">supplied_recv</span><span class="p">,</span>
			     <span class="kt">int</span>                  <span class="n">priority</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Poll the IPMI interface for the user.  This causes the IPMI code to</span>
<span class="cm"> * do an immediate check for information from the driver and handle</span>
<span class="cm"> * anything that is immediately pending.  This will not block in any</span>
<span class="cm"> * way.  This is useful if you need to spin waiting for something to</span>
<span class="cm"> * happen in the IPMI driver.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ipmi_poll_interface</span><span class="p">(</span><span class="n">ipmi_user_t</span> <span class="n">user</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When commands come in to the SMS, the user can register to receive</span>
<span class="cm"> * them.  Only one user can be listening on a specific netfn/cmd/chan tuple</span>
<span class="cm"> * at a time, you will get an EBUSY error if the command is already</span>
<span class="cm"> * registered.  If a command is received that does not have a user</span>
<span class="cm"> * registered, the driver will automatically return the proper</span>
<span class="cm"> * error.  Channels are specified as a bitfield, use IPMI_CHAN_ALL to</span>
<span class="cm"> * mean all channels.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ipmi_register_for_cmd</span><span class="p">(</span><span class="n">ipmi_user_t</span>   <span class="n">user</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">netfn</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">chans</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipmi_unregister_for_cmd</span><span class="p">(</span><span class="n">ipmi_user_t</span>   <span class="n">user</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">netfn</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">chans</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Go into a mode where the driver will not autonomously attempt to do</span>
<span class="cm"> * things with the interface.  It will still respond to attentions and</span>
<span class="cm"> * interrupts, and it will expect that commands will complete.  It</span>
<span class="cm"> * will not automatcially check for flags, events, or things of that</span>
<span class="cm"> * nature.</span>
<span class="cm"> *</span>
<span class="cm"> * This is primarily used for firmware upgrades.  The idea is that</span>
<span class="cm"> * when you go into firmware upgrade mode, you do this operation</span>
<span class="cm"> * and the driver will not attempt to do anything but what you tell</span>
<span class="cm"> * it or what the BMC asks for.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if you send a command that resets the BMC, the driver</span>
<span class="cm"> * will still expect a response from that command.  So the BMC should</span>
<span class="cm"> * reset itself *after* the response is sent.  Resetting before the</span>
<span class="cm"> * response is just silly.</span>
<span class="cm"> *</span>
<span class="cm"> * If in auto maintenance mode, the driver will automatically go into</span>
<span class="cm"> * maintenance mode for 30 seconds if it sees a cold reset, a warm</span>
<span class="cm"> * reset, or a firmware NetFN.  This means that code that uses only</span>
<span class="cm"> * firmware NetFN commands to do upgrades will work automatically</span>
<span class="cm"> * without change, assuming it sends a message every 30 seconds or</span>
<span class="cm"> * less.</span>
<span class="cm"> *</span>
<span class="cm"> * See the IPMI_MAINTENANCE_MODE_xxx defines for what the mode means.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ipmi_get_maintenance_mode</span><span class="p">(</span><span class="n">ipmi_user_t</span> <span class="n">user</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipmi_set_maintenance_mode</span><span class="p">(</span><span class="n">ipmi_user_t</span> <span class="n">user</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When the user is created, it will not receive IPMI events by</span>
<span class="cm"> * default.  The user must set this to TRUE to get incoming events.</span>
<span class="cm"> * The first user that sets this to TRUE will receive all events that</span>
<span class="cm"> * have been queued while no one was waiting for events.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ipmi_set_gets_events</span><span class="p">(</span><span class="n">ipmi_user_t</span> <span class="n">user</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called when a new SMI is registered.  This will also be called on</span>
<span class="cm"> * every existing interface when a new watcher is registered with</span>
<span class="cm"> * ipmi_smi_watcher_register().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipmi_smi_watcher</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>

	<span class="cm">/* You must set the owner to the current module, if you are in</span>
<span class="cm">	   a module (generally just set it to &quot;THIS_MODULE&quot;). */</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="cm">/* These two are called with read locks held for the interface</span>
<span class="cm">	   the watcher list.  So you can add and remove users from the</span>
<span class="cm">	   IPMI interface, send messages, etc., but you cannot add</span>
<span class="cm">	   or remove SMI watchers or SMI interfaces. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">new_smi</span><span class="p">)(</span><span class="kt">int</span> <span class="n">if_num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">smi_gone</span><span class="p">)(</span><span class="kt">int</span> <span class="n">if_num</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">ipmi_smi_watcher_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipmi_smi_watcher</span> <span class="o">*</span><span class="n">watcher</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipmi_smi_watcher_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipmi_smi_watcher</span> <span class="o">*</span><span class="n">watcher</span><span class="p">);</span>

<span class="cm">/* The following are various helper functions for dealing with IPMI</span>
<span class="cm">   addresses. */</span>

<span class="cm">/* Return the maximum length of an IPMI address given it&#39;s type. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ipmi_addr_length</span><span class="p">(</span><span class="kt">int</span> <span class="n">addr_type</span><span class="p">);</span>

<span class="cm">/* Validate that the given IPMI address is valid. */</span>
<span class="kt">int</span> <span class="n">ipmi_validate_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipmi_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * How did the IPMI driver find out about the device?</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ipmi_addr_src</span> <span class="p">{</span>
	<span class="n">SI_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SI_HOTMOD</span><span class="p">,</span> <span class="n">SI_HARDCODED</span><span class="p">,</span> <span class="n">SI_SPMI</span><span class="p">,</span> <span class="n">SI_ACPI</span><span class="p">,</span> <span class="n">SI_SMBIOS</span><span class="p">,</span>
	<span class="n">SI_PCI</span><span class="p">,</span>	<span class="n">SI_DEVICETREE</span><span class="p">,</span> <span class="n">SI_DEFAULT</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">ipmi_smi_info_union</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * the acpi_info element is defined for the SI_ACPI</span>
<span class="cm">	 * address type</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">acpi_handle</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">acpi_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipmi_smi_info</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ipmi_addr_src</span> <span class="n">addr_src</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Base device for the interface.  Don&#39;t forget to put this when</span>
<span class="cm">	 * you are done.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The addr_info provides more detailed info for some IPMI</span>
<span class="cm">	 * devices, depending on the addr_src.  Currently only SI_ACPI</span>
<span class="cm">	 * info is provided.</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="n">ipmi_smi_info_union</span> <span class="n">addr_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This is to get the private info of ipmi_smi_t */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ipmi_get_smi_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">if_num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipmi_smi_info</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * The userland interface</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The userland interface for the IPMI driver is a standard character</span>
<span class="cm"> * device, with each instance of an interface registered as a minor</span>
<span class="cm"> * number under the major character device.</span>
<span class="cm"> *</span>
<span class="cm"> * The read and write calls do not work, to get messages in and out</span>
<span class="cm"> * requires ioctl calls because of the complexity of the data.  select</span>
<span class="cm"> * and poll do work, so you can wait for input using the file</span>
<span class="cm"> * descriptor, you just can use read to get it.</span>
<span class="cm"> *</span>
<span class="cm"> * In general, you send a command down to the interface and receive</span>
<span class="cm"> * responses back.  You can use the msgid value to correlate commands</span>
<span class="cm"> * and responses, the driver will take care of figuring out which</span>
<span class="cm"> * incoming messages are for which command and find the proper msgid</span>
<span class="cm"> * value to report.  You will only receive reponses for commands you</span>
<span class="cm"> * send.  Asynchronous events, however, go to all open users, so you</span>
<span class="cm"> * must be ready to handle these (or ignore them if you don&#39;t care).</span>
<span class="cm"> *</span>
<span class="cm"> * The address type depends upon the channel type.  When talking</span>
<span class="cm"> * directly to the BMC (IPMC_BMC_CHANNEL), the address is ignored</span>
<span class="cm"> * (IPMI_UNUSED_ADDR_TYPE).  When talking to an IPMB channel, you must</span>
<span class="cm"> * supply a valid IPMB address with the addr_type set properly.</span>
<span class="cm"> *</span>
<span class="cm"> * When talking to normal channels, the driver takes care of the</span>
<span class="cm"> * details of formatting and sending messages on that channel.  You do</span>
<span class="cm"> * not, for instance, have to format a send command, you just send</span>
<span class="cm"> * whatever command you want to the channel, the driver will create</span>
<span class="cm"> * the send command, automatically issue receive command and get even</span>
<span class="cm"> * commands, and pass those up to the proper user.</span>
<span class="cm"> */</span>


<span class="cm">/* The magic IOCTL value for this interface. */</span>
<span class="cp">#define IPMI_IOC_MAGIC &#39;i&#39;</span>


<span class="cm">/* Messages sent to the interface are this format. */</span>
<span class="k">struct</span> <span class="n">ipmi_req</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span> <span class="cm">/* Address to send the message to. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">addr_len</span><span class="p">;</span>

	<span class="kt">long</span>    <span class="n">msgid</span><span class="p">;</span> <span class="cm">/* The sequence number for the message.  This</span>
<span class="cm">			  exact value will be reported back in the</span>
<span class="cm">			  response to this request if it is a command.</span>
<span class="cm">			  If it is a response, this will be used as</span>
<span class="cm">			  the sequence value for the response.  */</span>

	<span class="k">struct</span> <span class="n">ipmi_msg</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * Send a message to the interfaces.  error values are:</span>
<span class="cm"> *   - EFAULT - an address supplied was invalid.</span>
<span class="cm"> *   - EINVAL - The address supplied was not valid, or the command</span>
<span class="cm"> *              was not allowed.</span>
<span class="cm"> *   - EMSGSIZE - The message to was too large.</span>
<span class="cm"> *   - ENOMEM - Buffers could not be allocated for the command.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_SEND_COMMAND		_IOR(IPMI_IOC_MAGIC, 13,	\</span>
<span class="cp">					     struct ipmi_req)</span>

<span class="cm">/* Messages sent to the interface with timing parameters are this</span>
<span class="cm">   format. */</span>
<span class="k">struct</span> <span class="n">ipmi_req_settime</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipmi_req</span> <span class="n">req</span><span class="p">;</span>

	<span class="cm">/* See ipmi_request_settime() above for details on these</span>
<span class="cm">	   values. */</span>
	<span class="kt">int</span>          <span class="n">retries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retry_time_ms</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * Send a message to the interfaces with timing parameters.  error values</span>
<span class="cm"> * are:</span>
<span class="cm"> *   - EFAULT - an address supplied was invalid.</span>
<span class="cm"> *   - EINVAL - The address supplied was not valid, or the command</span>
<span class="cm"> *              was not allowed.</span>
<span class="cm"> *   - EMSGSIZE - The message to was too large.</span>
<span class="cm"> *   - ENOMEM - Buffers could not be allocated for the command.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_SEND_COMMAND_SETTIME	_IOR(IPMI_IOC_MAGIC, 21,	\</span>
<span class="cp">					     struct ipmi_req_settime)</span>

<span class="cm">/* Messages received from the interface are this format. */</span>
<span class="k">struct</span> <span class="n">ipmi_recv</span> <span class="p">{</span>
	<span class="kt">int</span>     <span class="n">recv_type</span><span class="p">;</span> <span class="cm">/* Is this a command, response or an</span>
<span class="cm">			      asyncronous event. */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>    <span class="cm">/* Address the message was from is put</span>
<span class="cm">				   here.  The caller must supply the</span>
<span class="cm">				   memory. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">addr_len</span><span class="p">;</span> <span class="cm">/* The size of the address buffer.</span>
<span class="cm">				   The caller supplies the full buffer</span>
<span class="cm">				   length, this value is updated to</span>
<span class="cm">				   the actual message length when the</span>
<span class="cm">				   message is received. */</span>

	<span class="kt">long</span>    <span class="n">msgid</span><span class="p">;</span> <span class="cm">/* The sequence number specified in the request</span>
<span class="cm">			  if this is a response.  If this is a command,</span>
<span class="cm">			  this will be the sequence number from the</span>
<span class="cm">			  command. */</span>

	<span class="k">struct</span> <span class="n">ipmi_msg</span> <span class="n">msg</span><span class="p">;</span> <span class="cm">/* The data field must point to a buffer.</span>
<span class="cm">				The data_size field must be set to the</span>
<span class="cm">				size of the message buffer.  The</span>
<span class="cm">				caller supplies the full buffer</span>
<span class="cm">				length, this value is updated to the</span>
<span class="cm">				actual message length when the message</span>
<span class="cm">				is received. */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Receive a message.  error values:</span>
<span class="cm"> *  - EAGAIN - no messages in the queue.</span>
<span class="cm"> *  - EFAULT - an address supplied was invalid.</span>
<span class="cm"> *  - EINVAL - The address supplied was not valid.</span>
<span class="cm"> *  - EMSGSIZE - The message to was too large to fit into the message buffer,</span>
<span class="cm"> *               the message will be left in the buffer. */</span>
<span class="cp">#define IPMICTL_RECEIVE_MSG		_IOWR(IPMI_IOC_MAGIC, 12,	\</span>
<span class="cp">					      struct ipmi_recv)</span>

<span class="cm">/*</span>
<span class="cm"> * Like RECEIVE_MSG, but if the message won&#39;t fit in the buffer, it</span>
<span class="cm"> * will truncate the contents instead of leaving the data in the</span>
<span class="cm"> * buffer.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_RECEIVE_MSG_TRUNC	_IOWR(IPMI_IOC_MAGIC, 11,	\</span>
<span class="cp">					      struct ipmi_recv)</span>

<span class="cm">/* Register to get commands from other entities on this interface. */</span>
<span class="k">struct</span> <span class="n">ipmi_cmdspec</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">netfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Register to receive a specific command.  error values:</span>
<span class="cm"> *   - EFAULT - an address supplied was invalid.</span>
<span class="cm"> *   - EBUSY - The netfn/cmd supplied was already in use.</span>
<span class="cm"> *   - ENOMEM - could not allocate memory for the entry.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_REGISTER_FOR_CMD	_IOR(IPMI_IOC_MAGIC, 14,	\</span>
<span class="cp">					     struct ipmi_cmdspec)</span>
<span class="cm">/*</span>
<span class="cm"> * Unregister a regsitered command.  error values:</span>
<span class="cm"> *  - EFAULT - an address supplied was invalid.</span>
<span class="cm"> *  - ENOENT - The netfn/cmd was not found registered for this user.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_UNREGISTER_FOR_CMD	_IOR(IPMI_IOC_MAGIC, 15,	\</span>
<span class="cp">					     struct ipmi_cmdspec)</span>

<span class="cm">/*</span>
<span class="cm"> * Register to get commands from other entities on specific channels.</span>
<span class="cm"> * This way, you can only listen on specific channels, or have messages</span>
<span class="cm"> * from some channels go to one place and other channels to someplace</span>
<span class="cm"> * else.  The chans field is a bitmask, (1 &lt;&lt; channel) for each channel.</span>
<span class="cm"> * It may be IPMI_CHAN_ALL for all channels.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipmi_cmdspec_chans</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">netfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chans</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Register to receive a specific command on specific channels.  error values:</span>
<span class="cm"> *   - EFAULT - an address supplied was invalid.</span>
<span class="cm"> *   - EBUSY - One of the netfn/cmd/chans supplied was already in use.</span>
<span class="cm"> *   - ENOMEM - could not allocate memory for the entry.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_REGISTER_FOR_CMD_CHANS	_IOR(IPMI_IOC_MAGIC, 28,	\</span>
<span class="cp">					     struct ipmi_cmdspec_chans)</span>
<span class="cm">/*</span>
<span class="cm"> * Unregister some netfn/cmd/chans.  error values:</span>
<span class="cm"> *  - EFAULT - an address supplied was invalid.</span>
<span class="cm"> *  - ENOENT - None of the netfn/cmd/chans were found registered for this user.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_UNREGISTER_FOR_CMD_CHANS _IOR(IPMI_IOC_MAGIC, 29,	\</span>
<span class="cp">					     struct ipmi_cmdspec_chans)</span>

<span class="cm">/*</span>
<span class="cm"> * Set whether this interface receives events.  Note that the first</span>
<span class="cm"> * user registered for events will get all pending events for the</span>
<span class="cm"> * interface.  error values:</span>
<span class="cm"> *  - EFAULT - an address supplied was invalid.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_SET_GETS_EVENTS_CMD	_IOR(IPMI_IOC_MAGIC, 16, int)</span>

<span class="cm">/*</span>
<span class="cm"> * Set and get the slave address and LUN that we will use for our</span>
<span class="cm"> * source messages.  Note that this affects the interface, not just</span>
<span class="cm"> * this user, so it will affect all users of this interface.  This is</span>
<span class="cm"> * so some initialization code can come in and do the OEM-specific</span>
<span class="cm"> * things it takes to determine your address (if not the BMC) and set</span>
<span class="cm"> * it for everyone else.  You should probably leave the LUN alone.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipmi_channel_lun_address_set</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define IPMICTL_SET_MY_CHANNEL_ADDRESS_CMD \</span>
<span class="cp">	_IOR(IPMI_IOC_MAGIC, 24, struct ipmi_channel_lun_address_set)</span>
<span class="cp">#define IPMICTL_GET_MY_CHANNEL_ADDRESS_CMD \</span>
<span class="cp">	_IOR(IPMI_IOC_MAGIC, 25, struct ipmi_channel_lun_address_set)</span>
<span class="cp">#define IPMICTL_SET_MY_CHANNEL_LUN_CMD \</span>
<span class="cp">	_IOR(IPMI_IOC_MAGIC, 26, struct ipmi_channel_lun_address_set)</span>
<span class="cp">#define IPMICTL_GET_MY_CHANNEL_LUN_CMD \</span>
<span class="cp">	_IOR(IPMI_IOC_MAGIC, 27, struct ipmi_channel_lun_address_set)</span>
<span class="cm">/* Legacy interfaces, these only set IPMB 0. */</span>
<span class="cp">#define IPMICTL_SET_MY_ADDRESS_CMD	_IOR(IPMI_IOC_MAGIC, 17, unsigned int)</span>
<span class="cp">#define IPMICTL_GET_MY_ADDRESS_CMD	_IOR(IPMI_IOC_MAGIC, 18, unsigned int)</span>
<span class="cp">#define IPMICTL_SET_MY_LUN_CMD		_IOR(IPMI_IOC_MAGIC, 19, unsigned int)</span>
<span class="cp">#define IPMICTL_GET_MY_LUN_CMD		_IOR(IPMI_IOC_MAGIC, 20, unsigned int)</span>

<span class="cm">/*</span>
<span class="cm"> * Get/set the default timing values for an interface.  You shouldn&#39;t</span>
<span class="cm"> * generally mess with these.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipmi_timing_parms</span> <span class="p">{</span>
	<span class="kt">int</span>          <span class="n">retries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retry_time_ms</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define IPMICTL_SET_TIMING_PARMS_CMD	_IOR(IPMI_IOC_MAGIC, 22, \</span>
<span class="cp">					     struct ipmi_timing_parms)</span>
<span class="cp">#define IPMICTL_GET_TIMING_PARMS_CMD	_IOR(IPMI_IOC_MAGIC, 23, \</span>
<span class="cp">					     struct ipmi_timing_parms)</span>

<span class="cm">/*</span>
<span class="cm"> * Set the maintenance mode.  See ipmi_set_maintenance_mode() above</span>
<span class="cm"> * for a description of what this does.</span>
<span class="cm"> */</span>
<span class="cp">#define IPMICTL_GET_MAINTENANCE_MODE_CMD	_IOR(IPMI_IOC_MAGIC, 30, int)</span>
<span class="cp">#define IPMICTL_SET_MAINTENANCE_MODE_CMD	_IOW(IPMI_IOC_MAGIC, 31, int)</span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_IPMI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
