<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › lockd › lockd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lockd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/include/linux/lockd/lockd.h</span>
<span class="cm"> *</span>
<span class="cm"> * General-purpose lockd include file.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef LINUX_LOCKD_LOCKD_H</span>
<span class="cp">#define LINUX_LOCKD_LOCKD_H</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/nfsd/nfsfh.h&gt;</span>
<span class="cp">#include &lt;linux/lockd/bind.h&gt;</span>
<span class="cp">#include &lt;linux/lockd/xdr.h&gt;</span>
<span class="cp">#ifdef CONFIG_LOCKD_V4</span>
<span class="cp">#include &lt;linux/lockd/xdr4.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/lockd/debug.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Version string</span>
<span class="cm"> */</span>
<span class="cp">#define LOCKD_VERSION		&quot;0.5&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Default timeout for RPC calls (seconds)</span>
<span class="cm"> */</span>
<span class="cp">#define LOCKD_DFLT_TIMEO	10</span>

<span class="cm">/*</span>
<span class="cm"> * Lockd host handle (used both by the client and server personality).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nlm_host</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">h_hash</span><span class="p">;</span>		<span class="cm">/* doubly linked list */</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">h_addr</span><span class="p">;</span>		<span class="cm">/* peer address */</span>
	<span class="kt">size_t</span>			<span class="n">h_addrlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">h_srcaddr</span><span class="p">;</span>	<span class="cm">/* our address (optional) */</span>
	<span class="kt">size_t</span>			<span class="n">h_srcaddrlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_clnt</span>		<span class="o">*</span><span class="n">h_rpcclnt</span><span class="p">;</span>	<span class="cm">/* RPC client to talk to peer */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">h_name</span><span class="p">;</span>		<span class="cm">/* remote hostname */</span>
	<span class="n">u32</span>			<span class="n">h_version</span><span class="p">;</span>	<span class="cm">/* interface version */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">h_proto</span><span class="p">;</span>	<span class="cm">/* transport proto */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">h_reclaiming</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">h_server</span>     <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* server side, not client side */</span>
				<span class="n">h_noresvport</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">h_inuse</span>      <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">h_gracewait</span><span class="p">;</span>	<span class="cm">/* wait while reclaiming */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">h_rwsem</span><span class="p">;</span>	<span class="cm">/* Reboot recovery lock */</span>
	<span class="n">u32</span>			<span class="n">h_state</span><span class="p">;</span>	<span class="cm">/* pseudo-state counter */</span>
	<span class="n">u32</span>			<span class="n">h_nsmstate</span><span class="p">;</span>	<span class="cm">/* true remote NSM state */</span>
	<span class="n">u32</span>			<span class="n">h_pidcount</span><span class="p">;</span>	<span class="cm">/* Pseudopids */</span>
	<span class="n">atomic_t</span>		<span class="n">h_count</span><span class="p">;</span>	<span class="cm">/* reference count */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">h_mutex</span><span class="p">;</span>	<span class="cm">/* mutex for pmap binding */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">h_nextrebind</span><span class="p">;</span>	<span class="cm">/* next portmap call */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">h_expires</span><span class="p">;</span>	<span class="cm">/* eligible for GC */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">h_lockowners</span><span class="p">;</span>	<span class="cm">/* Lockowners for the client */</span>
	<span class="n">spinlock_t</span>		<span class="n">h_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">h_granted</span><span class="p">;</span>	<span class="cm">/* Locks in GRANTED state */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">h_reclaim</span><span class="p">;</span>	<span class="cm">/* Locks in RECLAIM state */</span>
	<span class="k">struct</span> <span class="n">nsm_handle</span>	<span class="o">*</span><span class="n">h_nsmhandle</span><span class="p">;</span>	<span class="cm">/* NSM status handle */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">h_addrbuf</span><span class="p">;</span>	<span class="cm">/* address eyecatcher */</span>
	<span class="k">struct</span> <span class="n">net</span>		<span class="o">*</span><span class="n">net</span><span class="p">;</span>		<span class="cm">/* host net */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The largest string sm_addrbuf should hold is a full-size IPv6 address</span>
<span class="cm"> * (no &quot;::&quot; anywhere) with a scope ID.  The buffer size is computed to</span>
<span class="cm"> * hold eight groups of colon-separated four-hex-digit numbers, a</span>
<span class="cm"> * percent sign, a scope id (at most 32 bits, in decimal), and NUL.</span>
<span class="cm"> */</span>
<span class="cp">#define NSM_ADDRBUF		((8 * 4 + 7) + (1 + 10) + 1)</span>

<span class="k">struct</span> <span class="n">nsm_handle</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">sm_link</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">sm_count</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">sm_mon_name</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">sm_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span>	<span class="n">sm_addr</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">sm_addrlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sm_monitored</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">sm_sticky</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* don&#39;t unmonitor */</span>
	<span class="k">struct</span> <span class="n">nsm_private</span>	<span class="n">sm_priv</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">sm_addrbuf</span><span class="p">[</span><span class="n">NSM_ADDRBUF</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Rigorous type checking on sockaddr type conversions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="nf">nlm_addr_in</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="nf">nlm_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="nf">nlm_srcaddr_in</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">h_srcaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="nf">nlm_srcaddr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">h_srcaddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map an fl_owner_t into a unique 32-bit &quot;pid&quot;</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nlm_lockowner</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="n">fl_owner_t</span> <span class="n">owner</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nlm_wait</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Memory chunk for NLM client RPC request.</span>
<span class="cm"> */</span>
<span class="cp">#define NLMCLNT_OHSIZE		((__NEW_UTS_LEN) + 10u)</span>
<span class="k">struct</span> <span class="n">nlm_rqst</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">a_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">a_flags</span><span class="p">;</span>	<span class="cm">/* initial RPC task flags */</span>
	<span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span>	<span class="n">a_host</span><span class="p">;</span>		<span class="cm">/* host handle */</span>
	<span class="k">struct</span> <span class="n">nlm_args</span>		<span class="n">a_args</span><span class="p">;</span>		<span class="cm">/* arguments */</span>
	<span class="k">struct</span> <span class="n">nlm_res</span>		<span class="n">a_res</span><span class="p">;</span>		<span class="cm">/* result */</span>
	<span class="k">struct</span> <span class="n">nlm_block</span> <span class="o">*</span>	<span class="n">a_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">a_retries</span><span class="p">;</span>	<span class="cm">/* Retry count */</span>
	<span class="n">u8</span>			<span class="n">a_owner</span><span class="p">[</span><span class="n">NLMCLNT_OHSIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This struct describes a file held open by lockd on behalf of</span>
<span class="cm"> * an NFS client.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nlm_file</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">f_list</span><span class="p">;</span>		<span class="cm">/* linked list */</span>
	<span class="k">struct</span> <span class="n">nfs_fh</span>		<span class="n">f_handle</span><span class="p">;</span>	<span class="cm">/* NFS file handle */</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span>		<span class="n">f_file</span><span class="p">;</span>		<span class="cm">/* VFS file pointer */</span>
	<span class="k">struct</span> <span class="n">nlm_share</span> <span class="o">*</span>	<span class="n">f_shares</span><span class="p">;</span>	<span class="cm">/* DOS shares */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">f_blocks</span><span class="p">;</span>	<span class="cm">/* blocked locks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">f_locks</span><span class="p">;</span>	<span class="cm">/* guesstimate # of locks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">f_count</span><span class="p">;</span>	<span class="cm">/* reference count */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">f_mutex</span><span class="p">;</span>	<span class="cm">/* avoid concurrent access */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is a server block (i.e. a lock requested by some client which</span>
<span class="cm"> * couldn&#39;t be granted because of a conflicting lock).</span>
<span class="cm"> */</span>
<span class="cp">#define NLM_NEVER		(~(unsigned long) 0)</span>
<span class="cm">/* timeout on non-blocking call: */</span>
<span class="cp">#define NLM_TIMEOUT		(7 * HZ)</span>

<span class="k">struct</span> <span class="n">nlm_block</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">b_count</span><span class="p">;</span>	<span class="cm">/* Reference count */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">b_list</span><span class="p">;</span>		<span class="cm">/* linked list of all blocks */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">b_flist</span><span class="p">;</span>	<span class="cm">/* linked list (per file) */</span>
	<span class="k">struct</span> <span class="n">nlm_rqst</span>	<span class="o">*</span>	<span class="n">b_call</span><span class="p">;</span>		<span class="cm">/* RPC args &amp; callback info */</span>
	<span class="k">struct</span> <span class="n">svc_serv</span> <span class="o">*</span>	<span class="n">b_daemon</span><span class="p">;</span>	<span class="cm">/* NLM service */</span>
	<span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span>	<span class="n">b_host</span><span class="p">;</span>		<span class="cm">/* host handle for RPC clnt */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">b_when</span><span class="p">;</span>		<span class="cm">/* next re-xmit */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">b_id</span><span class="p">;</span>		<span class="cm">/* block id */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">b_granted</span><span class="p">;</span>	<span class="cm">/* VFS granted lock */</span>
	<span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span>	<span class="n">b_file</span><span class="p">;</span>		<span class="cm">/* file in question */</span>
	<span class="k">struct</span> <span class="n">cache_req</span> <span class="o">*</span>	<span class="n">b_cache_req</span><span class="p">;</span>	<span class="cm">/* deferred request handling */</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span>	<span class="n">b_fl</span><span class="p">;</span>		<span class="cm">/* set for GETLK */</span>
	<span class="k">struct</span> <span class="n">cache_deferred_req</span> <span class="o">*</span> <span class="n">b_deferred_req</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">b_flags</span><span class="p">;</span>	<span class="cm">/* block flags */</span>
<span class="cp">#define B_QUEUED		1	</span><span class="cm">/* lock queued */</span><span class="cp"></span>
<span class="cp">#define B_GOT_CALLBACK		2	</span><span class="cm">/* got lock or conflicting lock */</span><span class="cp"></span>
<span class="cp">#define B_TIMED_OUT		4	</span><span class="cm">/* filesystem too slow to respond */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Global variables</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_program</span>	<span class="n">nlm_program</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">svc_procedure</span>	<span class="n">nlmsvc_procedures</span><span class="p">[];</span>
<span class="cp">#ifdef CONFIG_LOCKD_V4</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">svc_procedure</span>	<span class="n">nlmsvc_procedures4</span><span class="p">[];</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span>			<span class="n">nlmsvc_grace_period</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">nlmsvc_timeout</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">bool</span>			<span class="n">nsm_use_hostnames</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">u32</span>			<span class="n">nsm_local_state</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Lockd client functions</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nlm_rqst</span> <span class="o">*</span> <span class="n">nlm_alloc_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="kt">int</span>		  <span class="n">nlm_async_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_rqst</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>		  <span class="n">nlm_async_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_rqst</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmclnt_release_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_rqst</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">nlm_wait</span> <span class="o">*</span> <span class="n">nlmclnt_prepare_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmclnt_finish_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_wait</span> <span class="o">*</span><span class="n">block</span><span class="p">);</span>
<span class="kt">int</span>		  <span class="n">nlmclnt_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_wait</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="n">__be32</span>		  <span class="n">nlmclnt_grant</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmclnt_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span>		  <span class="n">nlmclnt_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmclnt_next_cookie</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_cookie</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Host cache</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nlm_host</span>  <span class="o">*</span><span class="n">nlmclnt_lookup_host</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">size_t</span> <span class="n">salen</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">protocol</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">u32</span> <span class="n">version</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">noresvport</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmclnt_release_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">nlm_host</span>  <span class="o">*</span><span class="n">nlmsvc_lookup_host</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">size_t</span> <span class="n">hostname_len</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmsvc_release_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">rpc_clnt</span> <span class="o">*</span> <span class="n">nlm_bind_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlm_rebind_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span> <span class="n">nlm_get_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlm_shutdown_hosts</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlm_shutdown_hosts_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlm_host_rebooted</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_reboot</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Host monitoring</span>
<span class="cm"> */</span>
<span class="kt">int</span>		  <span class="n">nsm_monitor</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nsm_unmonitor</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nsm_handle</span> <span class="o">*</span><span class="n">nsm_get_handle</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">size_t</span> <span class="n">salen</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">size_t</span> <span class="n">hostname_len</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">nsm_handle</span> <span class="o">*</span><span class="n">nsm_reboot_lookup</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlm_reboot</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nsm_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsm_handle</span> <span class="o">*</span><span class="n">nsm</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is used in garbage collection and resource reclaim</span>
<span class="cm"> * A return value != 0 means destroy the lock/block/share</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span>	  <span class="p">(</span><span class="o">*</span><span class="n">nlm_host_match_fn_t</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="n">ref</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Server-side lock handling</span>
<span class="cm"> */</span>
<span class="n">__be32</span>		  <span class="n">nlmsvc_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_lock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">nlm_cookie</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">__be32</span>		  <span class="n">nlmsvc_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="n">__be32</span>		  <span class="n">nlmsvc_testlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_lock</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">nlm_lock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_cookie</span> <span class="o">*</span><span class="p">);</span>
<span class="n">__be32</span>		  <span class="n">nlmsvc_cancel_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_lock</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span>	  <span class="n">nlmsvc_retry_blocked</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmsvc_traverse_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="p">,</span>
					<span class="n">nlm_host_match_fn_t</span> <span class="n">match</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmsvc_grant_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_cookie</span> <span class="o">*</span><span class="p">,</span> <span class="n">__be32</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmsvc_release_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_rqst</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * File handling for the server personality</span>
<span class="cm"> */</span>
<span class="n">__be32</span>		  <span class="n">nlm_lookup_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">**</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlm_release_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmsvc_mark_resources</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmsvc_free_host_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_host</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>		  <span class="n">nlmsvc_invalidate_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Cluster failover support</span>
<span class="cm"> */</span>
<span class="kt">int</span>           <span class="n">nlmsvc_unlock_all_by_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span>           <span class="n">nlmsvc_unlock_all_by_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">server_addr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nlmsvc_file_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nlm_privileged_request4</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">sap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1023</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ipv4_is_loopback</span><span class="p">(</span><span class="n">sin</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nlm_privileged_request6</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">sin6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">sap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_port</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1023</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_addr_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IPV6_ADDR_MAPPED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ipv4_is_loopback</span><span class="p">(</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">.</span><span class="n">s6_addr32</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">ipv6_addr_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sin6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IPV6_ADDR_LOOPBACK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* IS_ENABLED(CONFIG_IPV6) */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__nlm_privileged_request6</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* IS_ENABLED(CONFIG_IPV6) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Ensure incoming requests are from local privileged callers.</span>
<span class="cm"> *</span>
<span class="cm"> * Return TRUE if sender is local and is connecting via a privileged port;</span>
<span class="cm"> * otherwise return FALSE.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlm_privileged_requester</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">svc_rqst</span> <span class="o">*</span><span class="n">rqstp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sap</span> <span class="o">=</span> <span class="n">svc_addr</span><span class="p">(</span><span class="n">rqstp</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="k">return</span> <span class="n">__nlm_privileged_request4</span><span class="p">(</span><span class="n">sap</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="k">return</span> <span class="n">__nlm_privileged_request6</span><span class="p">(</span><span class="n">sap</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compare two NLM locks.</span>
<span class="cm"> * When the second lock is of type F_UNLCK, this acts like a wildcard.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nlm_compare_locks</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl1</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_pid</span>   <span class="o">==</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_pid</span>
	     <span class="o">&amp;&amp;</span> <span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_owner</span> <span class="o">==</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_owner</span>
	     <span class="o">&amp;&amp;</span> <span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">==</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_start</span>
	     <span class="o">&amp;&amp;</span> <span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_end</span>   <span class="o">==</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_end</span>
	     <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_type</span>  <span class="o">==</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">||</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">lock_manager_operations</span> <span class="n">nlmsvc_lock_operations</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* LINUX_LOCKD_LOCKD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
