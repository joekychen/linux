<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ktime.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ktime.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  include/linux/ktime.h</span>
<span class="cm"> *</span>
<span class="cm"> *  ktime_t - nanosecond-resolution time format.</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright(C) 2005, Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *   Copyright(C) 2005, Red Hat, Inc., Ingo Molnar</span>
<span class="cm"> *</span>
<span class="cm"> *  data type definitions, declarations, prototypes and macros.</span>
<span class="cm"> *</span>
<span class="cm"> *  Started by: Thomas Gleixner and Ingo Molnar</span>
<span class="cm"> *</span>
<span class="cm"> *  Credits:</span>
<span class="cm"> *</span>
<span class="cm"> *  	Roman Zippel provided the ideas and primary code snippets of</span>
<span class="cm"> *  	the ktime_t union and further simplifications of the original</span>
<span class="cm"> *  	code.</span>
<span class="cm"> *</span>
<span class="cm"> *  For licencing details see kernel-base/COPYING</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_KTIME_H</span>
<span class="cp">#define _LINUX_KTIME_H</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * ktime_t:</span>
<span class="cm"> *</span>
<span class="cm"> * On 64-bit CPUs a single 64-bit variable is used to store the hrtimers</span>
<span class="cm"> * internal representation of time values in scalar nanoseconds. The</span>
<span class="cm"> * design plays out best on 64-bit CPUs, where most conversions are</span>
<span class="cm"> * NOPs and most arithmetic ktime_t operations are plain arithmetic</span>
<span class="cm"> * operations.</span>
<span class="cm"> *</span>
<span class="cm"> * On 32-bit CPUs an optimized representation of the timespec structure</span>
<span class="cm"> * is used to avoid expensive conversions from and to timespecs. The</span>
<span class="cm"> * endian-aware order of the tv struct members is chosen to allow</span>
<span class="cm"> * mathematical operations on the tv64 member of the union too, which</span>
<span class="cm"> * for certain operations produces better code.</span>
<span class="cm"> *</span>
<span class="cm"> * For architectures with efficient support for 64/32-bit conversions the</span>
<span class="cm"> * plain scalar nanosecond based representation can be selected by the</span>
<span class="cm"> * config switch CONFIG_KTIME_SCALAR.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">ktime</span> <span class="p">{</span>
	<span class="n">s64</span>	<span class="n">tv64</span><span class="p">;</span>
<span class="cp">#if BITS_PER_LONG != 64 &amp;&amp; !defined(CONFIG_KTIME_SCALAR)</span>
	<span class="k">struct</span> <span class="p">{</span>
<span class="cp"># ifdef __BIG_ENDIAN</span>
	<span class="n">s32</span>	<span class="n">sec</span><span class="p">,</span> <span class="n">nsec</span><span class="p">;</span>
<span class="cp"># else</span>
	<span class="n">s32</span>	<span class="n">nsec</span><span class="p">,</span> <span class="n">sec</span><span class="p">;</span>
<span class="cp"># endif</span>
	<span class="p">}</span> <span class="n">tv</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">ktime</span> <span class="n">ktime_t</span><span class="p">;</span>		<span class="cm">/* Kill this */</span>

<span class="cp">#define KTIME_MAX			((s64)~((u64)1 &lt;&lt; 63))</span>
<span class="cp">#if (BITS_PER_LONG == 64)</span>
<span class="cp"># define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)</span>
<span class="cp">#else</span>
<span class="cp"># define KTIME_SEC_MAX			LONG_MAX</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * ktime_t definitions when using the 64-bit scalar representation:</span>
<span class="cm"> */</span>

<span class="cp">#if (BITS_PER_LONG == 64) || defined(CONFIG_KTIME_SCALAR)</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_set - Set a ktime_t variable from a seconds/nanoseconds value</span>
<span class="cm"> * @secs:	seconds to set</span>
<span class="cm"> * @nsecs:	nanoseconds to set</span>
<span class="cm"> *</span>
<span class="cm"> * Return the ktime_t representation of the value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">ktime_set</span><span class="p">(</span><span class="k">const</span> <span class="kt">long</span> <span class="n">secs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nsecs</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if (BITS_PER_LONG == 64)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">secs</span> <span class="o">&gt;=</span> <span class="n">KTIME_SEC_MAX</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">ktime_t</span><span class="p">){</span> <span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">KTIME_MAX</span> <span class="p">};</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ktime_t</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">secs</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span> <span class="o">+</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">nsecs</span> <span class="p">};</span>
<span class="p">}</span>

<span class="cm">/* Subtract two ktime_t variables. rem = lhs -rhs: */</span>
<span class="cp">#define ktime_sub(lhs, rhs) \</span>
<span class="cp">		({ (ktime_t){ .tv64 = (lhs).tv64 - (rhs).tv64 }; })</span>

<span class="cm">/* Add two ktime_t variables. res = lhs + rhs: */</span>
<span class="cp">#define ktime_add(lhs, rhs) \</span>
<span class="cp">		({ (ktime_t){ .tv64 = (lhs).tv64 + (rhs).tv64 }; })</span>

<span class="cm">/*</span>
<span class="cm"> * Add a ktime_t variable and a scalar nanosecond value.</span>
<span class="cm"> * res = kt + nsval:</span>
<span class="cm"> */</span>
<span class="cp">#define ktime_add_ns(kt, nsval) \</span>
<span class="cp">		({ (ktime_t){ .tv64 = (kt).tv64 + (nsval) }; })</span>

<span class="cm">/*</span>
<span class="cm"> * Subtract a scalar nanosecod from a ktime_t variable</span>
<span class="cm"> * res = kt - nsval:</span>
<span class="cm"> */</span>
<span class="cp">#define ktime_sub_ns(kt, nsval) \</span>
<span class="cp">		({ (ktime_t){ .tv64 = (kt).tv64 - (nsval) }; })</span>

<span class="cm">/* convert a timespec to ktime_t format: */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">timespec_to_ktime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_set</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* convert a timeval to ktime_t format: */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">timeval_to_ktime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_set</span><span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Map the ktime_t to timespec conversion to ns_to_timespec function */</span>
<span class="cp">#define ktime_to_timespec(kt)		ns_to_timespec((kt).tv64)</span>

<span class="cm">/* Map the ktime_t to timeval conversion to ns_to_timeval function */</span>
<span class="cp">#define ktime_to_timeval(kt)		ns_to_timeval((kt).tv64)</span>

<span class="cm">/* Convert ktime_t to nanoseconds - NOP in the scalar storage format: */</span>
<span class="cp">#define ktime_to_ns(kt)			((kt).tv64)</span>

<span class="cp">#else	</span><span class="cm">/* !((BITS_PER_LONG == 64) || defined(CONFIG_KTIME_SCALAR)) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Helper macros/inlines to get the ktime_t math right in the timespec</span>
<span class="cm"> * representation. The macros are sometimes ugly - their actual use is</span>
<span class="cm"> * pretty okay-ish, given the circumstances. We do all this for</span>
<span class="cm"> * performance reasons. The pure scalar nsec_t based code was nice and</span>
<span class="cm"> * simple, but created too many 64-bit / 32-bit conversions and divisions.</span>
<span class="cm"> *</span>
<span class="cm"> * Be especially aware that negative values are represented in a way</span>
<span class="cm"> * that the tv.sec field is negative and the tv.nsec field is greater</span>
<span class="cm"> * or equal to zero but less than nanoseconds per second. This is the</span>
<span class="cm"> * same representation which is used by timespecs.</span>
<span class="cm"> *</span>
<span class="cm"> *   tv.sec &lt; 0 and 0 &gt;= tv.nsec &lt; NSEC_PER_SEC</span>
<span class="cm"> */</span>

<span class="cm">/* Set a ktime_t variable to a value in sec/nsec representation: */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">ktime_set</span><span class="p">(</span><span class="k">const</span> <span class="kt">long</span> <span class="n">secs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nsecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ktime_t</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="n">tv</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">sec</span> <span class="o">=</span> <span class="n">secs</span><span class="p">,</span> <span class="p">.</span><span class="n">nsec</span> <span class="o">=</span> <span class="n">nsecs</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_sub - subtract two ktime_t variables</span>
<span class="cm"> * @lhs:	minuend</span>
<span class="cm"> * @rhs:	subtrahend</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the remainder of the subtraction</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">ktime_sub</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">ktime_t</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">tv64</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">nsec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">res</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">nsec</span> <span class="o">+=</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_add - add two ktime_t variables</span>
<span class="cm"> * @add1:	addend1</span>
<span class="cm"> * @add2:	addend2</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the sum of @add1 and @add2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">ktime_add</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">add1</span><span class="p">,</span> <span class="k">const</span> <span class="n">ktime_t</span> <span class="n">add2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">add1</span><span class="p">.</span><span class="n">tv64</span> <span class="o">+</span> <span class="n">add2</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * performance trick: the (u32) -NSEC gives 0x00000000Fxxxxxxx</span>
<span class="cm">	 * so we subtract NSEC_PER_SEC and add 1 to the upper 32 bit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * it&#39;s equivalent to:</span>
<span class="cm">	 *   tv.nsec -= NSEC_PER_SEC</span>
<span class="cm">	 *   tv.sec ++;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">nsec</span> <span class="o">&gt;=</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span>
		<span class="n">res</span><span class="p">.</span><span class="n">tv64</span> <span class="o">+=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="n">NSEC_PER_SEC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_add_ns - Add a scalar nanoseconds value to a ktime_t variable</span>
<span class="cm"> * @kt:		addend</span>
<span class="cm"> * @nsec:	the scalar nsec value to add</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the sum of @kt and @nsec in ktime_t format</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nsec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_sub_ns - Subtract a scalar nanoseconds value from a ktime_t variable</span>
<span class="cm"> * @kt:		minuend</span>
<span class="cm"> * @nsec:	the scalar nsec value to subtract</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the subtraction of @nsec from @kt in ktime_t format</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">ktime_sub_ns</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nsec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * timespec_to_ktime - convert a timespec to ktime_t format</span>
<span class="cm"> * @ts:		the timespec variable to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a ktime_t variable with the converted timespec value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">timespec_to_ktime</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ktime_t</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="n">tv</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">sec</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
			   	   <span class="p">.</span><span class="n">nsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * timeval_to_ktime - convert a timeval to ktime_t format</span>
<span class="cm"> * @tv:		the timeval variable to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a ktime_t variable with the converted timeval value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">timeval_to_ktime</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ktime_t</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="n">tv</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">sec</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
				   <span class="p">.</span><span class="n">nsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">*</span> <span class="mi">1000</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_to_timespec - convert a ktime_t variable to timespec format</span>
<span class="cm"> * @kt:		the ktime_t variable to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the timespec representation of the ktime value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="nf">ktime_to_timespec</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">time_t</span><span class="p">)</span> <span class="n">kt</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">sec</span><span class="p">,</span>
				   <span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">kt</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">nsec</span> <span class="p">};</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_to_timeval - convert a ktime_t variable to timeval format</span>
<span class="cm"> * @kt:		the ktime_t variable to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the timeval representation of the ktime value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="nf">ktime_to_timeval</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">time_t</span><span class="p">)</span> <span class="n">kt</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">sec</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">(</span><span class="n">suseconds_t</span><span class="p">)</span> <span class="p">(</span><span class="n">kt</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">nsec</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ktime_to_ns - convert a ktime_t variable to scalar nanoseconds</span>
<span class="cm"> * @kt:		the ktime_t variable to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the scalar nanoseconds representation of @kt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">ktime_to_ns</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">kt</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">sec</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span> <span class="o">+</span> <span class="n">kt</span><span class="p">.</span><span class="n">tv</span><span class="p">.</span><span class="n">nsec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* !((BITS_PER_LONG == 64) || defined(CONFIG_KTIME_SCALAR)) */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * ktime_equal - Compares two ktime_t variables to see if they are equal</span>
<span class="cm"> * @cmp1:	comparable1</span>
<span class="cm"> * @cmp2:	comparable2</span>
<span class="cm"> *</span>
<span class="cm"> * Compare two ktime_t variables, returns 1 if equal</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ktime_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">cmp1</span><span class="p">,</span> <span class="k">const</span> <span class="n">ktime_t</span> <span class="n">cmp2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cmp1</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="n">cmp2</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">ktime_to_us</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">ktime_to_timeval</span><span class="p">(</span><span class="n">kt</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="n">USEC_PER_SEC</span> <span class="o">+</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">ktime_to_ms</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">ktime_to_timeval</span><span class="p">(</span><span class="n">kt</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="n">MSEC_PER_SEC</span> <span class="o">+</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/</span> <span class="n">USEC_PER_MSEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">ktime_us_delta</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">later</span><span class="p">,</span> <span class="k">const</span> <span class="n">ktime_t</span> <span class="n">earlier</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">later</span><span class="p">,</span> <span class="n">earlier</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">ktime_add_us</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">kt</span><span class="p">,</span> <span class="n">usec</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">ktime_sub_us</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_sub_ns</span><span class="p">(</span><span class="n">kt</span><span class="p">,</span> <span class="n">usec</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">ktime_add_safe</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">ktime_t</span> <span class="n">rhs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The resolution of the clocks. The resolution value is returned in</span>
<span class="cm"> * the clock_getres() system call to give application programmers an</span>
<span class="cm"> * idea of the (in)accuracy of timers. Timer values are rounded up to</span>
<span class="cm"> * this resolution values.</span>
<span class="cm"> */</span>
<span class="cp">#define LOW_RES_NSEC		TICK_NSEC</span>
<span class="cp">#define KTIME_LOW_RES		(ktime_t){ .tv64 = LOW_RES_NSEC }</span>

<span class="cm">/* Get the monotonic time in timespec format: */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ktime_get_ts</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>

<span class="cm">/* Get the real (wall-) time in timespec format: */</span>
<span class="cp">#define ktime_get_real_ts(ts)	getnstimeofday(ts)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">ns_to_ktime</span><span class="p">(</span><span class="n">u64</span> <span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">ktime_t</span> <span class="n">ktime_zero</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">ktime_zero</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
