<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › interrupt.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>interrupt.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* interrupt.h */</span>
<span class="cp">#ifndef _LINUX_INTERRUPT_H</span>
<span class="cp">#define _LINUX_INTERRUPT_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/irqreturn.h&gt;</span>
<span class="cp">#include &lt;linux/irqnr.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/irqflags.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * These correspond to the IORESOURCE_IRQ_* defines in</span>
<span class="cm"> * linux/ioport.h to select the interrupt line behaviour.  When</span>
<span class="cm"> * requesting an interrupt without specifying a IRQF_TRIGGER, the</span>
<span class="cm"> * setting should be assumed to be &quot;as already configured&quot;, which</span>
<span class="cm"> * may be as per machine or firmware initialisation.</span>
<span class="cm"> */</span>
<span class="cp">#define IRQF_TRIGGER_NONE	0x00000000</span>
<span class="cp">#define IRQF_TRIGGER_RISING	0x00000001</span>
<span class="cp">#define IRQF_TRIGGER_FALLING	0x00000002</span>
<span class="cp">#define IRQF_TRIGGER_HIGH	0x00000004</span>
<span class="cp">#define IRQF_TRIGGER_LOW	0x00000008</span>
<span class="cp">#define IRQF_TRIGGER_MASK	(IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \</span>
<span class="cp">				 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)</span>
<span class="cp">#define IRQF_TRIGGER_PROBE	0x00000010</span>

<span class="cm">/*</span>
<span class="cm"> * These flags used only by the kernel as part of the</span>
<span class="cm"> * irq handling routines.</span>
<span class="cm"> *</span>
<span class="cm"> * IRQF_DISABLED - keep irqs disabled when calling the action handler.</span>
<span class="cm"> *                 DEPRECATED. This flag is a NOOP and scheduled to be removed</span>
<span class="cm"> * IRQF_SAMPLE_RANDOM - irq is used to feed the random generator</span>
<span class="cm"> * IRQF_SHARED - allow sharing the irq among several devices</span>
<span class="cm"> * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur</span>
<span class="cm"> * IRQF_TIMER - Flag to mark this interrupt as timer interrupt</span>
<span class="cm"> * IRQF_PERCPU - Interrupt is per cpu</span>
<span class="cm"> * IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing</span>
<span class="cm"> * IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is</span>
<span class="cm"> *                registered first in an shared interrupt is considered for</span>
<span class="cm"> *                performance reasons)</span>
<span class="cm"> * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.</span>
<span class="cm"> *                Used by threaded interrupts which need to keep the</span>
<span class="cm"> *                irq line disabled until the threaded handler has been run.</span>
<span class="cm"> * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend</span>
<span class="cm"> * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set</span>
<span class="cm"> * IRQF_NO_THREAD - Interrupt cannot be threaded</span>
<span class="cm"> * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device</span>
<span class="cm"> *                resume time.</span>
<span class="cm"> */</span>
<span class="cp">#define IRQF_DISABLED		0x00000020</span>
<span class="cp">#define IRQF_SAMPLE_RANDOM	0x00000040</span>
<span class="cp">#define IRQF_SHARED		0x00000080</span>
<span class="cp">#define IRQF_PROBE_SHARED	0x00000100</span>
<span class="cp">#define __IRQF_TIMER		0x00000200</span>
<span class="cp">#define IRQF_PERCPU		0x00000400</span>
<span class="cp">#define IRQF_NOBALANCING	0x00000800</span>
<span class="cp">#define IRQF_IRQPOLL		0x00001000</span>
<span class="cp">#define IRQF_ONESHOT		0x00002000</span>
<span class="cp">#define IRQF_NO_SUSPEND		0x00004000</span>
<span class="cp">#define IRQF_FORCE_RESUME	0x00008000</span>
<span class="cp">#define IRQF_NO_THREAD		0x00010000</span>
<span class="cp">#define IRQF_EARLY_RESUME	0x00020000</span>

<span class="cp">#define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)</span>

<span class="cm">/*</span>
<span class="cm"> * These values can be returned by request_any_context_irq() and</span>
<span class="cm"> * describe the context the interrupt will be run in.</span>
<span class="cm"> *</span>
<span class="cm"> * IRQC_IS_HARDIRQ - interrupt runs in hardirq context</span>
<span class="cm"> * IRQC_IS_NESTED - interrupt runs in a nested threaded context</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IRQC_IS_HARDIRQ</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IRQC_IS_NESTED</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_handler_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct irqaction - per interrupt action descriptor</span>
<span class="cm"> * @handler:	interrupt handler function</span>
<span class="cm"> * @name:	name of the device</span>
<span class="cm"> * @dev_id:	cookie to identify the device</span>
<span class="cm"> * @percpu_dev_id:	cookie to identify the device</span>
<span class="cm"> * @next:	pointer to the next irqaction for shared interrupts</span>
<span class="cm"> * @irq:	interrupt number</span>
<span class="cm"> * @flags:	flags (see IRQF_* above)</span>
<span class="cm"> * @thread_fn:	interrupt handler function for threaded interrupts</span>
<span class="cm"> * @thread:	thread pointer for threaded interrupts</span>
<span class="cm"> * @thread_flags:	flags related to @thread</span>
<span class="cm"> * @thread_mask:	bitmask for keeping track of @thread activity</span>
<span class="cm"> * @dir:	pointer to the proc/irq/NN/name entry</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irqaction</span> <span class="p">{</span>
	<span class="n">irq_handler_t</span>		<span class="n">handler</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__percpu</span>		<span class="o">*</span><span class="n">percpu_dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irqaction</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">irq_handler_t</span>		<span class="n">thread_fn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">thread_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">thread_mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span>	<span class="o">*</span><span class="n">dir</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_internodealigned_in_smp</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">no_action</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_GENERIC_HARDIRQS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="n">request_threaded_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
		     <span class="n">irq_handler_t</span> <span class="n">thread_fn</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="nf">request_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
	    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="n">request_any_context_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="n">request_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">percpu_dev_id</span><span class="p">);</span>
<span class="cp">#else</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="n">request_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
	    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Special function to avoid ifdeffery in kernel/irq/devres.c which</span>
<span class="cm"> * gets magically built by GENERIC_HARDIRQS=n architectures (sparc,</span>
<span class="cm"> * m68k). I really love these $@%#!* obvious Makefile references:</span>
<span class="cm"> * ../../../kernel/irq/devres.o</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="nf">request_threaded_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
		     <span class="n">irq_handler_t</span> <span class="n">thread_fn</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="nf">request_any_context_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="nf">request_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">percpu_dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">devname</span><span class="p">,</span> <span class="n">percpu_dev_id</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="n">devm_request_threaded_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
			  <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">thread_fn</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span>
<span class="nf">devm_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">devm_request_threaded_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">irqflags</span><span class="p">,</span>
					 <span class="n">devname</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">devm_free_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * On lockdep we dont want to enable hardirqs in hardirq</span>
<span class="cm"> * context. Use local_irq_enable_in_hardirq() to annotate</span>
<span class="cm"> * kernel code that has to do this nevertheless (pretty much</span>
<span class="cm"> * the only valid case is for old/broken hardware that is</span>
<span class="cm"> * insanely slow).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: in theory this might break fragile code that relies</span>
<span class="cm"> * on hardirq delivery - in practice we dont seem to have such</span>
<span class="cm"> * places left. So the only effect should be slightly increased</span>
<span class="cm"> * irqs-off latencies.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="cp"># define local_irq_enable_in_hardirq()	do { } while (0)</span>
<span class="cp">#else</span>
<span class="cp"># define local_irq_enable_in_hardirq()	local_irq_enable()</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">disable_irq_nosync</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disable_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disable_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">enable_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">enable_percpu_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

<span class="cm">/* The following three functions are for the core kernel use only. */</span>
<span class="cp">#ifdef CONFIG_GENERIC_HARDIRQS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">suspend_device_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">resume_device_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">check_wakeup_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_wakeup_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_device_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">resume_device_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_wakeup_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_GENERIC_HARDIRQS)</span>

<span class="k">extern</span> <span class="n">cpumask_var_t</span> <span class="n">irq_default_affinity</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpumask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_can_set_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_select_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_affinity_hint</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct irq_affinity_notify - context for notification of IRQ affinity changes</span>
<span class="cm"> * @irq:		Interrupt to which notification applies</span>
<span class="cm"> * @kref:		Reference count, for internal use</span>
<span class="cm"> * @work:		Work item, for internal use</span>
<span class="cm"> * @notify:		Function to be called on change.  This will be</span>
<span class="cm"> *			called in process context.</span>
<span class="cm"> * @release:		Function to be called on release.  This will be</span>
<span class="cm"> *			called in process context.  Once registered, the</span>
<span class="cm"> *			structure must only be freed when this function is</span>
<span class="cm"> *			called or later.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">irq_affinity_notify</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify</span><span class="p">)(</span><span class="k">struct</span> <span class="n">irq_affinity_notify</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">cpumask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">irq_set_affinity_notifier</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_affinity_notify</span> <span class="o">*</span><span class="n">notify</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irq_run_affinity_notifiers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flush_scheduled_work</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irq_set_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irq_can_set_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irq_select_affinity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irq_set_affinity_hint</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP &amp;&amp; CONFIG_GENERIC_HARDIRQS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_GENERIC_HARDIRQS</span>
<span class="cm">/*</span>
<span class="cm"> * Special lockdep variants of irq disabling/enabling.</span>
<span class="cm"> * These should be used for locking constructs that</span>
<span class="cm"> * know that a particular irq context which is disabled,</span>
<span class="cm"> * and which is the only irq-context user of a lock,</span>
<span class="cm"> * that it&#39;s safe to take the lock in the irq-disabled</span>
<span class="cm"> * section without disabling hardirqs.</span>
<span class="cm"> *</span>
<span class="cm"> * On !CONFIG_LOCKDEP they are equivalent to the normal</span>
<span class="cm"> * irq disable/enable methods.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_irq_nosync_lockdep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_irq_nosync_lockdep_irqsave</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_irq_lockdep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">disable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enable_irq_lockdep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enable_irq_lockdep_irqrestore</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* IRQ wakeup (PM) control: */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">irq_set_irq_wake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">enable_irq_wake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq_set_irq_wake</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">disable_irq_wake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq_set_irq_wake</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_GENERIC_HARDIRQS */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * NOTE: non-genirq architectures, if they want to support the lock</span>
<span class="cm"> * validator need to define the methods below in their asm/irq.h</span>
<span class="cm"> * files, under an #ifdef CONFIG_LOCKDEP section.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_LOCKDEP</span>
<span class="cp">#  define disable_irq_nosync_lockdep(irq)	disable_irq_nosync(irq)</span>
<span class="cp">#  define disable_irq_nosync_lockdep_irqsave(irq, flags) \</span>
<span class="cp">						disable_irq_nosync(irq)</span>
<span class="cp">#  define disable_irq_lockdep(irq)		disable_irq(irq)</span>
<span class="cp">#  define enable_irq_lockdep(irq)		enable_irq(irq)</span>
<span class="cp">#  define enable_irq_lockdep_irqrestore(irq, flags) \</span>
<span class="cp">						enable_irq(irq)</span>
<span class="cp"># endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">enable_irq_wake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">disable_irq_wake</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_GENERIC_HARDIRQS */</span><span class="cp"></span>


<span class="cp">#ifdef CONFIG_IRQ_FORCED_THREADING</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">force_irqthreads</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define force_irqthreads	(0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __ARCH_SET_SOFTIRQ_PENDING</span>
<span class="cp">#define set_softirq_pending(x) (local_softirq_pending() = (x))</span>
<span class="cp">#define or_softirq_pending(x)  (local_softirq_pending() |= (x))</span>
<span class="cp">#endif</span>

<span class="cm">/* Some architectures might implement lazy enabling/disabling of</span>
<span class="cm"> * interrupts. In some cases, such as stop_machine, we might want</span>
<span class="cm"> * to ensure that after a local_irq_disable(), interrupts have</span>
<span class="cm"> * really been disabled in hardware. Such architectures need to</span>
<span class="cm"> * implement the following hook.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef hard_irq_disable</span>
<span class="cp">#define hard_irq_disable()	do { } while(0)</span>
<span class="cp">#endif</span>

<span class="cm">/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high</span>
<span class="cm">   frequency threaded job scheduling. For almost all the purposes</span>
<span class="cm">   tasklets are more than enough. F.e. all serial device BHs et</span>
<span class="cm">   al. should be converted to tasklets, not to softirqs.</span>
<span class="cm"> */</span>

<span class="k">enum</span>
<span class="p">{</span>
	<span class="n">HI_SOFTIRQ</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
	<span class="n">TIMER_SOFTIRQ</span><span class="p">,</span>
	<span class="n">NET_TX_SOFTIRQ</span><span class="p">,</span>
	<span class="n">NET_RX_SOFTIRQ</span><span class="p">,</span>
	<span class="n">BLOCK_SOFTIRQ</span><span class="p">,</span>
	<span class="n">BLOCK_IOPOLL_SOFTIRQ</span><span class="p">,</span>
	<span class="n">TASKLET_SOFTIRQ</span><span class="p">,</span>
	<span class="n">SCHED_SOFTIRQ</span><span class="p">,</span>
	<span class="n">HRTIMER_SOFTIRQ</span><span class="p">,</span>
	<span class="n">RCU_SOFTIRQ</span><span class="p">,</span>    <span class="cm">/* Preferable RCU should always be the last softirq */</span>

	<span class="n">NR_SOFTIRQS</span>
<span class="p">};</span>

<span class="cm">/* map softirq index to softirq name. update &#39;softirq_to_name&#39; in</span>
<span class="cm"> * kernel/softirq.c when adding a new softirq.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">softirq_to_name</span><span class="p">[</span><span class="n">NR_SOFTIRQS</span><span class="p">];</span>

<span class="cm">/* softirq mask and active fields moved to irq_cpustat_t in</span>
<span class="cm"> * asm/hardirq.h to get better cache usage.  KAO</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">softirq_action</span>
<span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">do_softirq</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__do_softirq</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">open_softirq</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">softirq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">raise_softirq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">);</span>

<span class="cm">/* This is the worklist that queues up per-cpu softirq work.</span>
<span class="cm"> *</span>
<span class="cm"> * send_remote_sendirq() adds work to these lists, and</span>
<span class="cm"> * the softirq handler itself dequeues from them.  The queues</span>
<span class="cm"> * are protected by disabling local cpu interrupts and they must</span>
<span class="cm"> * only be accessed by the local cpu that they are for.</span>
<span class="cm"> */</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="p">[</span><span class="n">NR_SOFTIRQS</span><span class="p">],</span> <span class="n">softirq_work_list</span><span class="p">);</span>

<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">ksoftirqd</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">this_cpu_ksoftirqd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">ksoftirqd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Try to send a softirq to a remote cpu.  If this cannot be done, the</span>
<span class="cm"> * work will be queued to the local cpu.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">send_remote_softirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">call_single_data</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">softirq</span><span class="p">);</span>

<span class="cm">/* Like send_remote_softirq(), but the caller must disable local cpu interrupts</span>
<span class="cm"> * and compute the current cpu, passed in as &#39;this_cpu&#39;.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__send_remote_softirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">call_single_data</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">softirq</span><span class="p">);</span>

<span class="cm">/* Tasklets --- multithreaded analogue of BHs.</span>

<span class="cm">   Main feature differing them of generic softirqs: tasklet</span>
<span class="cm">   is running only on one CPU simultaneously.</span>

<span class="cm">   Main feature differing them of BHs: different tasklets</span>
<span class="cm">   may be run simultaneously on different CPUs.</span>

<span class="cm">   Properties:</span>
<span class="cm">   * If tasklet_schedule() is called, then tasklet is guaranteed</span>
<span class="cm">     to be executed on some cpu at least once after this.</span>
<span class="cm">   * If the tasklet is already scheduled, but its execution is still not</span>
<span class="cm">     started, it will be executed only once.</span>
<span class="cm">   * If this tasklet is already running on another CPU (or schedule is called</span>
<span class="cm">     from tasklet itself), it is rescheduled for later.</span>
<span class="cm">   * Tasklet is strictly serialized wrt itself, but not</span>
<span class="cm">     wrt another tasklets. If client needs some intertask synchronization,</span>
<span class="cm">     he makes it with spinlocks.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">tasklet_struct</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DECLARE_TASKLET(name, func, data) \</span>
<span class="cp">struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }</span>

<span class="cp">#define DECLARE_TASKLET_DISABLED(name, func, data) \</span>
<span class="cp">struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }</span>


<span class="k">enum</span>
<span class="p">{</span>
	<span class="n">TASKLET_STATE_SCHED</span><span class="p">,</span>	<span class="cm">/* Tasklet is scheduled for execution */</span>
	<span class="n">TASKLET_STATE_RUN</span>	<span class="cm">/* Tasklet is running (SMP only) */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tasklet_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_RUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span> 
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_RUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_unlock_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_RUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span> <span class="n">barrier</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define tasklet_trylock(t) 1</span>
<span class="cp">#define tasklet_unlock_wait(t) do { } while (0)</span>
<span class="cp">#define tasklet_unlock(t) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__tasklet_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">__tasklet_schedule</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__tasklet_hi_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_hi_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">__tasklet_hi_schedule</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__tasklet_hi_schedule_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This version avoids touching any other tasklets. Needed for kmemcheck</span>
<span class="cm"> * in order not to take any page faults while enqueueing this tasklet;</span>
<span class="cm"> * consider VERY carefully whether you really need this or</span>
<span class="cm"> * tasklet_hi_schedule()...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_hi_schedule_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">__tasklet_hi_schedule_first</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_disable_nosync</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tasklet_disable_nosync</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">tasklet_unlock_wait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">smp_mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_mb__before_atomic_dec</span><span class="p">();</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_hi_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_mb__before_atomic_dec</span><span class="p">();</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tasklet_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tasklet_kill_immediate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tasklet_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tasklet_hrtimer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span>		<span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>	<span class="n">tasklet</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hrtimer_restart</span>	<span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span>
<span class="n">tasklet_hrtimer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_hrtimer</span> <span class="o">*</span><span class="n">ttimer</span><span class="p">,</span>
		     <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="p">),</span>
		     <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">tasklet_hrtimer_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_hrtimer</span> <span class="o">*</span><span class="n">ttimer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">time</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ttimer</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">tasklet_hrtimer_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_hrtimer</span> <span class="o">*</span><span class="n">ttimer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ttimer</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ttimer</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Autoprobing for irqs:</span>
<span class="cm"> *</span>
<span class="cm"> * probe_irq_on() and probe_irq_off() provide robust primitives</span>
<span class="cm"> * for accurate IRQ probing during kernel initialization.  They are</span>
<span class="cm"> * reasonably simple to use, are not &quot;fooled&quot; by spurious interrupts,</span>
<span class="cm"> * and, unlike other attempts at IRQ probing, they do not get hung on</span>
<span class="cm"> * stuck interrupts (such as unused PS2 mouse interfaces on ASUS boards).</span>
<span class="cm"> *</span>
<span class="cm"> * For reasonably foolproof probing, use them as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. clear and/or mask the device&#39;s internal interrupt.</span>
<span class="cm"> * 2. sti();</span>
<span class="cm"> * 3. irqs = probe_irq_on();      // &quot;take over&quot; all unassigned idle IRQs</span>
<span class="cm"> * 4. enable the device and cause it to trigger an interrupt.</span>
<span class="cm"> * 5. wait for the device to interrupt, using non-intrusive polling or a delay.</span>
<span class="cm"> * 6. irq = probe_irq_off(irqs);  // get IRQ number, 0=none, negative=multiple</span>
<span class="cm"> * 7. service the device to clear its pending interrupt.</span>
<span class="cm"> * 8. loop again if paranoia is required.</span>
<span class="cm"> *</span>
<span class="cm"> * probe_irq_on() returns a mask of allocated irq&#39;s.</span>
<span class="cm"> *</span>
<span class="cm"> * probe_irq_off() takes the mask as a parameter,</span>
<span class="cm"> * and returns the irq number which occurred,</span>
<span class="cm"> * or zero if none occurred, or a negative irq number</span>
<span class="cm"> * if more than one irq occurred.</span>
<span class="cm"> */</span>

<span class="cp">#if defined(CONFIG_GENERIC_HARDIRQS) &amp;&amp; !defined(CONFIG_GENERIC_IRQ_PROBE) </span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">probe_irq_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">probe_irq_off</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">probe_irq_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">probe_irq_on</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>	<span class="cm">/* returns 0 on failure */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">probe_irq_off</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>	<span class="cm">/* returns 0 or negative on failure */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">probe_irq_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>	<span class="cm">/* returns mask of ISA interrupts */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* Initialize /proc/irq/ */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_irq_proc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_irq_proc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">seq_file</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">show_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">arch_show_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prec</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">early_irq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">arch_probe_nr_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">arch_early_irq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
