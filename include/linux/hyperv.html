<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › hyperv.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hyperv.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2011, Microsoft Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="cm"> * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *   Haiyang Zhang &lt;haiyangz@microsoft.com&gt;</span>
<span class="cm"> *   Hank Janssen  &lt;hjanssen@microsoft.com&gt;</span>
<span class="cm"> *   K. Y. Srinivasan &lt;kys@microsoft.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _HYPERV_H</span>
<span class="cp">#define _HYPERV_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * An implementation of HyperV key value pair (KVP) functionality for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010, Novell, Inc.</span>
<span class="cm"> * Author : K. Y. Srinivasan &lt;ksrinivasan@novell.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum value size - used for both key names and value data, and includes</span>
<span class="cm"> * any applicable NULL terminators.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:  This limit is somewhat arbitrary, but falls easily within what is</span>
<span class="cm"> * supported for all native guests (back to Win 2000) and what is reasonable</span>
<span class="cm"> * for the IC KVP exchange functionality.  Note that Windows Me/98/95 are</span>
<span class="cm"> * limited to 255 character key names.</span>
<span class="cm"> *</span>
<span class="cm"> * MSDN recommends not storing data values larger than 2048 bytes in the</span>
<span class="cm"> * registry.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:  This value is used in defining the KVP exchange message - this value</span>
<span class="cm"> * cannot be modified without affecting the message size and compatibility.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * bytes, including any null terminators</span>
<span class="cm"> */</span>
<span class="cp">#define HV_KVP_EXCHANGE_MAX_VALUE_SIZE          (2048)</span>


<span class="cm">/*</span>
<span class="cm"> * Maximum key size - the registry limit for the length of an entry name</span>
<span class="cm"> * is 256 characters, including the null terminator</span>
<span class="cm"> */</span>

<span class="cp">#define HV_KVP_EXCHANGE_MAX_KEY_SIZE            (512)</span>

<span class="cm">/*</span>
<span class="cm"> * In Linux, we implement the KVP functionality in two components:</span>
<span class="cm"> * 1) The kernel component which is packaged as part of the hv_utils driver</span>
<span class="cm"> * is responsible for communicating with the host and responsible for</span>
<span class="cm"> * implementing the host/guest protocol. 2) A user level daemon that is</span>
<span class="cm"> * responsible for data gathering.</span>
<span class="cm"> *</span>
<span class="cm"> * Host/Guest Protocol: The host iterates over an index and expects the guest</span>
<span class="cm"> * to assign a key name to the index and also return the value corresponding to</span>
<span class="cm"> * the key. The host will have atmost one KVP transaction outstanding at any</span>
<span class="cm"> * given point in time. The host side iteration stops when the guest returns</span>
<span class="cm"> * an error. Microsoft has specified the following mapping of key names to</span>
<span class="cm"> * host specified index:</span>
<span class="cm"> *</span>
<span class="cm"> *	Index		Key Name</span>
<span class="cm"> *	0		FullyQualifiedDomainName</span>
<span class="cm"> *	1		IntegrationServicesVersion</span>
<span class="cm"> *	2		NetworkAddressIPv4</span>
<span class="cm"> *	3		NetworkAddressIPv6</span>
<span class="cm"> *	4		OSBuildNumber</span>
<span class="cm"> *	5		OSName</span>
<span class="cm"> *	6		OSMajorVersion</span>
<span class="cm"> *	7		OSMinorVersion</span>
<span class="cm"> *	8		OSVersion</span>
<span class="cm"> *	9		ProcessorArchitecture</span>
<span class="cm"> *</span>
<span class="cm"> * The Windows host expects the Key Name and Key Value to be encoded in utf16.</span>
<span class="cm"> *</span>
<span class="cm"> * Guest Kernel/KVP Daemon Protocol: As noted earlier, we implement all of the</span>
<span class="cm"> * data gathering functionality in a user mode daemon. The user level daemon</span>
<span class="cm"> * is also responsible for binding the key name to the index as well. The</span>
<span class="cm"> * kernel and user-level daemon communicate using a connector channel.</span>
<span class="cm"> *</span>
<span class="cm"> * The user mode component first registers with the</span>
<span class="cm"> * the kernel component. Subsequently, the kernel component requests, data</span>
<span class="cm"> * for the specified keys. In response to this message the user mode component</span>
<span class="cm"> * fills in the value corresponding to the specified key. We overload the</span>
<span class="cm"> * sequence field in the cn_msg header to define our KVP message types.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The kernel component simply acts as a conduit for communication between the</span>
<span class="cm"> * Windows host and the user-level daemon. The kernel component passes up the</span>
<span class="cm"> * index received from the Host to the user-level daemon. If the index is</span>
<span class="cm"> * valid (supported), the corresponding key as well as its</span>
<span class="cm"> * value (both are strings) is returned. If the index is invalid</span>
<span class="cm"> * (not supported), a NULL key string is returned.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Registry value types.</span>
<span class="cm"> */</span>

<span class="cp">#define REG_SZ 1</span>
<span class="cp">#define REG_U32 4</span>
<span class="cp">#define REG_U64 8</span>

<span class="k">enum</span> <span class="n">hv_kvp_exchg_op</span> <span class="p">{</span>
	<span class="n">KVP_OP_GET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">KVP_OP_SET</span><span class="p">,</span>
	<span class="n">KVP_OP_DELETE</span><span class="p">,</span>
	<span class="n">KVP_OP_ENUMERATE</span><span class="p">,</span>
	<span class="n">KVP_OP_REGISTER</span><span class="p">,</span>
	<span class="n">KVP_OP_COUNT</span> <span class="cm">/* Number of operations, must be last. */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">hv_kvp_exchg_pool</span> <span class="p">{</span>
	<span class="n">KVP_POOL_EXTERNAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">KVP_POOL_GUEST</span><span class="p">,</span>
	<span class="n">KVP_POOL_AUTO</span><span class="p">,</span>
	<span class="n">KVP_POOL_AUTO_EXTERNAL</span><span class="p">,</span>
	<span class="n">KVP_POOL_AUTO_INTERNAL</span><span class="p">,</span>
	<span class="n">KVP_POOL_COUNT</span> <span class="cm">/* Number of pools, must be last. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_kvp_hdr</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">operation</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">pool</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">pad</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">hv_kvp_exchg_msg_value</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">value_type</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">key_size</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">value_size</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">key</span><span class="p">[</span><span class="n">HV_KVP_EXCHANGE_MAX_KEY_SIZE</span><span class="p">];</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__u8</span> <span class="n">value</span><span class="p">[</span><span class="n">HV_KVP_EXCHANGE_MAX_VALUE_SIZE</span><span class="p">];</span>
		<span class="n">__u32</span> <span class="n">value_u32</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">value_u64</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">hv_kvp_msg_enumerate</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_kvp_exchg_msg_value</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">hv_kvp_msg_get</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_kvp_exchg_msg_value</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_kvp_msg_set</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_kvp_exchg_msg_value</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_kvp_msg_delete</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">key_size</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">key</span><span class="p">[</span><span class="n">HV_KVP_EXCHANGE_MAX_KEY_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_kvp_register</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">version</span><span class="p">[</span><span class="n">HV_KVP_EXCHANGE_MAX_KEY_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_kvp_hdr</span>	<span class="n">kvp_hdr</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hv_kvp_msg_get</span>		<span class="n">kvp_get</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hv_kvp_msg_set</span>		<span class="n">kvp_set</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hv_kvp_msg_delete</span>	<span class="n">kvp_delete</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hv_kvp_msg_enumerate</span>	<span class="n">kvp_enum_data</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hv_kvp_register</span>		<span class="n">kvp_register</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">body</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/uuid.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>


<span class="cp">#define MAX_PAGE_BUFFER_COUNT				19</span>
<span class="cp">#define MAX_MULTIPAGE_BUFFER_COUNT			32 </span><span class="cm">/* 128K */</span><span class="cp"></span>

<span class="cp">#pragma pack(push, 1)</span>

<span class="cm">/* Single-page buffer */</span>
<span class="k">struct</span> <span class="n">hv_page_buffer</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pfn</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Multiple-page buffer */</span>
<span class="k">struct</span> <span class="n">hv_multipage_buffer</span> <span class="p">{</span>
	<span class="cm">/* Length and Offset determines the # of pfns in the array */</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pfn_array</span><span class="p">[</span><span class="n">MAX_MULTIPAGE_BUFFER_COUNT</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* 0x18 includes the proprietary packet header */</span>
<span class="cp">#define MAX_PAGE_BUFFER_PACKET		(0x18 +			\</span>
<span class="cp">					(sizeof(struct hv_page_buffer) * \</span>
<span class="cp">					 MAX_PAGE_BUFFER_COUNT))</span>
<span class="cp">#define MAX_MULTIPAGE_BUFFER_PACKET	(0x18 +			\</span>
<span class="cp">					 sizeof(struct hv_multipage_buffer))</span>


<span class="cp">#pragma pack(pop)</span>

<span class="k">struct</span> <span class="n">hv_ring_buffer</span> <span class="p">{</span>
	<span class="cm">/* Offset in bytes from the start of ring data below */</span>
	<span class="n">u32</span> <span class="n">write_index</span><span class="p">;</span>

	<span class="cm">/* Offset in bytes from the start of ring data below */</span>
	<span class="n">u32</span> <span class="n">read_index</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">interrupt_mask</span><span class="p">;</span>

	<span class="cm">/* Pad it to PAGE_SIZE so that data starts on page boundary */</span>
	<span class="n">u8</span>	<span class="n">reserved</span><span class="p">[</span><span class="mi">4084</span><span class="p">];</span>

	<span class="cm">/* NOTE:</span>
<span class="cm">	 * The interrupt_mask field is used only for channels but since our</span>
<span class="cm">	 * vmbus connection also uses this data structure and its data starts</span>
<span class="cm">	 * here, we commented out this field.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ring data starts here + RingDataStartOffset</span>
<span class="cm">	 * !!! DO NOT place any fields below this !!!</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hv_ring_buffer_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_ring_buffer</span> <span class="o">*</span><span class="n">ring_buffer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ring_size</span><span class="p">;</span>			<span class="cm">/* Include the shared header */</span>
	<span class="n">spinlock_t</span> <span class="n">ring_lock</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">ring_datasize</span><span class="p">;</span>		<span class="cm">/* &lt; ring_size */</span>
	<span class="n">u32</span> <span class="n">ring_data_startoffset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hv_ring_buffer_debug_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">current_interrupt_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">current_read_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">current_write_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytes_avail_toread</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytes_avail_towrite</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * hv_get_ringbuffer_availbytes()</span>
<span class="cm"> *</span>
<span class="cm"> * Get number of bytes available to read and to write to</span>
<span class="cm"> * for the specified ring buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">hv_get_ringbuffer_availbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_ring_buffer_info</span> <span class="o">*</span><span class="n">rbi</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="o">*</span><span class="n">read</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">read_loc</span><span class="p">,</span> <span class="n">write_loc</span><span class="p">,</span> <span class="n">dsize</span><span class="p">;</span>

	<span class="n">smp_read_barrier_depends</span><span class="p">();</span>

	<span class="cm">/* Capture the read/write indices before they changed */</span>
	<span class="n">read_loc</span> <span class="o">=</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">ring_buffer</span><span class="o">-&gt;</span><span class="n">read_index</span><span class="p">;</span>
	<span class="n">write_loc</span> <span class="o">=</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">ring_buffer</span><span class="o">-&gt;</span><span class="n">write_index</span><span class="p">;</span>
	<span class="n">dsize</span> <span class="o">=</span> <span class="n">rbi</span><span class="o">-&gt;</span><span class="n">ring_datasize</span><span class="p">;</span>

	<span class="o">*</span><span class="n">write</span> <span class="o">=</span> <span class="n">write_loc</span> <span class="o">&gt;=</span> <span class="n">read_loc</span> <span class="o">?</span> <span class="n">dsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">write_loc</span> <span class="o">-</span> <span class="n">read_loc</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">read_loc</span> <span class="o">-</span> <span class="n">write_loc</span><span class="p">;</span>
	<span class="o">*</span><span class="n">read</span> <span class="o">=</span> <span class="n">dsize</span> <span class="o">-</span> <span class="o">*</span><span class="n">write</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * We use the same version numbering for all Hyper-V modules.</span>
<span class="cm"> *</span>
<span class="cm"> * Definition of versioning is as follows;</span>
<span class="cm"> *</span>
<span class="cm"> *	Major Number	Changes for these scenarios;</span>
<span class="cm"> *			1.	When a new version of Windows Hyper-V</span>
<span class="cm"> *				is released.</span>
<span class="cm"> *			2.	A Major change has occurred in the</span>
<span class="cm"> *				Linux IC&#39;s.</span>
<span class="cm"> *			(For example the merge for the first time</span>
<span class="cm"> *			into the kernel) Every time the Major Number</span>
<span class="cm"> *			changes, the Revision number is reset to 0.</span>
<span class="cm"> *	Minor Number	Changes when new functionality is added</span>
<span class="cm"> *			to the Linux IC&#39;s that is not a bug fix.</span>
<span class="cm"> *</span>
<span class="cm"> * 3.1 - Added completed hv_utils driver. Shutdown/Heartbeat/Timesync</span>
<span class="cm"> */</span>
<span class="cp">#define HV_DRV_VERSION           &quot;3.1&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * A revision number of vmbus that is used for ensuring both ends on a</span>
<span class="cm"> * partition are using compatible versions.</span>
<span class="cm"> */</span>
<span class="cp">#define VMBUS_REVISION_NUMBER		13</span>

<span class="cm">/* Make maximum size of pipe payload of 16K */</span>
<span class="cp">#define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)</span>

<span class="cm">/* Define PipeMode values. */</span>
<span class="cp">#define VMBUS_PIPE_TYPE_BYTE		0x00000000</span>
<span class="cp">#define VMBUS_PIPE_TYPE_MESSAGE		0x00000004</span>

<span class="cm">/* The size of the user defined data buffer for non-pipe offers. */</span>
<span class="cp">#define MAX_USER_DEFINED_BYTES		120</span>

<span class="cm">/* The size of the user defined data buffer for pipe offers. */</span>
<span class="cp">#define MAX_PIPE_USER_DEFINED_BYTES	116</span>

<span class="cm">/*</span>
<span class="cm"> * At the center of the Channel Management library is the Channel Offer. This</span>
<span class="cm"> * struct contains the fundamental information about an offer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_offer</span> <span class="p">{</span>
	<span class="n">uuid_le</span> <span class="n">if_type</span><span class="p">;</span>
	<span class="n">uuid_le</span> <span class="n">if_instance</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">int_latency</span><span class="p">;</span> <span class="cm">/* in 100ns units */</span>
	<span class="n">u32</span> <span class="n">if_revision</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">server_ctx_size</span><span class="p">;</span>	<span class="cm">/* in bytes */</span>
	<span class="n">u16</span> <span class="n">chn_flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mmio_megabytes</span><span class="p">;</span>		<span class="cm">/* in bytes * 1024 * 1024 */</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* Non-pipes: The user has MAX_USER_DEFINED_BYTES bytes. */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">user_def</span><span class="p">[</span><span class="n">MAX_USER_DEFINED_BYTES</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">std</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Pipes:</span>
<span class="cm">		 * The following sructure is an integrated pipe protocol, which</span>
<span class="cm">		 * is implemented on top of standard user-defined data. Pipe</span>
<span class="cm">		 * clients have MAX_PIPE_USER_DEFINED_BYTES left for their own</span>
<span class="cm">		 * use.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u32</span>  <span class="n">pipe_mode</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">user_def</span><span class="p">[</span><span class="n">MAX_PIPE_USER_DEFINED_BYTES</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">padding</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Server Flags */</span>
<span class="cp">#define VMBUS_CHANNEL_ENUMERATE_DEVICE_INTERFACE	1</span>
<span class="cp">#define VMBUS_CHANNEL_SERVER_SUPPORTS_TRANSFER_PAGES	2</span>
<span class="cp">#define VMBUS_CHANNEL_SERVER_SUPPORTS_GPADLS		4</span>
<span class="cp">#define VMBUS_CHANNEL_NAMED_PIPE_MODE			0x10</span>
<span class="cp">#define VMBUS_CHANNEL_LOOPBACK_OFFER			0x100</span>
<span class="cp">#define VMBUS_CHANNEL_PARENT_OFFER			0x200</span>
<span class="cp">#define VMBUS_CHANNEL_REQUEST_MONITORED_NOTIFICATION	0x400</span>

<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">offset8</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len8</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">trans_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmpacket_header</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">prev_pkt_start_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">descriptor</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmtransfer_page_range</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">byte_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">byte_offset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmtransfer_page_packet_header</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">xfer_pageset_id</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">sender_owns_set</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">range_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmtransfer_page_range</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmgpadl_packet_header</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmadd_remove_transfer_page_set</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">xfer_pageset_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This structure defines a range in guest physical space that can be made to</span>
<span class="cm"> * look virtually contiguous.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gpa_range</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">byte_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">byte_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pfn_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is the format for an Establish Gpadl packet, which contains a handle by</span>
<span class="cm"> * which this GPADL will be known and a set of GPA ranges associated with it.</span>
<span class="cm"> * This can be converted to a MDL by the guest OS.  If there are multiple GPA</span>
<span class="cm"> * ranges, then the resulting MDL will be &quot;chained,&quot; representing multiple VA</span>
<span class="cm"> * ranges.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vmestablish_gpadl</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">range_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpa_range</span> <span class="n">range</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the format for a Teardown Gpadl packet, which indicates that the</span>
<span class="cm"> * GPADL handle in the Establish Gpadl packet will never be referenced again.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vmteardown_gpadl</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>	<span class="cm">/* for alignment to a 8-byte boundary */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the format for a GPA-Direct packet, which contains a set of GPA</span>
<span class="cm"> * ranges, in addition to commands and/or data.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vmdata_gpa_direct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">range_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpa_range</span> <span class="n">range</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* This is the format for a Additional Data Packet. */</span>
<span class="k">struct</span> <span class="n">vmadditional_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">byte_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">union</span> <span class="n">vmpacket_largest_possible_header</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmpacket_descriptor</span> <span class="n">simple_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmtransfer_page_packet_header</span> <span class="n">xfer_page_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmgpadl_packet_header</span> <span class="n">gpadl_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmadd_remove_transfer_page_set</span> <span class="n">add_rm_xfer_page_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmestablish_gpadl</span> <span class="n">establish_gpadl_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmteardown_gpadl</span> <span class="n">teardown_gpadl_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmdata_gpa_direct</span> <span class="n">data_gpa_direct_hdr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define VMPACKET_DATA_START_ADDRESS(__packet)	\</span>
<span class="cp">	(void *)(((unsigned char *)__packet) +	\</span>
<span class="cp">	 ((struct vmpacket_descriptor)__packet)-&gt;offset8 * 8)</span>

<span class="cp">#define VMPACKET_DATA_LENGTH(__packet)		\</span>
<span class="cp">	((((struct vmpacket_descriptor)__packet)-&gt;len8 -	\</span>
<span class="cp">	  ((struct vmpacket_descriptor)__packet)-&gt;offset8) * 8)</span>

<span class="cp">#define VMPACKET_TRANSFER_MODE(__packet)	\</span>
<span class="cp">	(((struct IMPACT)__packet)-&gt;type)</span>

<span class="k">enum</span> <span class="n">vmbus_packet_type</span> <span class="p">{</span>
	<span class="n">VM_PKT_INVALID</span>				<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">VM_PKT_SYNCH</span>				<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">VM_PKT_ADD_XFER_PAGESET</span>			<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">VM_PKT_RM_XFER_PAGESET</span>			<span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
	<span class="n">VM_PKT_ESTABLISH_GPADL</span>			<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
	<span class="n">VM_PKT_TEARDOWN_GPADL</span>			<span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>
	<span class="n">VM_PKT_DATA_INBAND</span>			<span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span>
	<span class="n">VM_PKT_DATA_USING_XFER_PAGES</span>		<span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span>
	<span class="n">VM_PKT_DATA_USING_GPADL</span>			<span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
	<span class="n">VM_PKT_DATA_USING_GPA_DIRECT</span>		<span class="o">=</span> <span class="mh">0x9</span><span class="p">,</span>
	<span class="n">VM_PKT_CANCEL_REQUEST</span>			<span class="o">=</span> <span class="mh">0xa</span><span class="p">,</span>
	<span class="n">VM_PKT_COMP</span>				<span class="o">=</span> <span class="mh">0xb</span><span class="p">,</span>
	<span class="n">VM_PKT_DATA_USING_ADDITIONAL_PKT</span>	<span class="o">=</span> <span class="mh">0xc</span><span class="p">,</span>
	<span class="n">VM_PKT_ADDITIONAL_DATA</span>			<span class="o">=</span> <span class="mh">0xd</span>
<span class="p">};</span>

<span class="cp">#define VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED	1</span>


<span class="cm">/* Version 1 messages */</span>
<span class="k">enum</span> <span class="n">vmbus_channel_message_type</span> <span class="p">{</span>
	<span class="n">CHANNELMSG_INVALID</span>			<span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>
	<span class="n">CHANNELMSG_OFFERCHANNEL</span>		<span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>
	<span class="n">CHANNELMSG_RESCIND_CHANNELOFFER</span>	<span class="o">=</span>  <span class="mi">2</span><span class="p">,</span>
	<span class="n">CHANNELMSG_REQUESTOFFERS</span>		<span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>
	<span class="n">CHANNELMSG_ALLOFFERS_DELIVERED</span>	<span class="o">=</span>  <span class="mi">4</span><span class="p">,</span>
	<span class="n">CHANNELMSG_OPENCHANNEL</span>		<span class="o">=</span>  <span class="mi">5</span><span class="p">,</span>
	<span class="n">CHANNELMSG_OPENCHANNEL_RESULT</span>		<span class="o">=</span>  <span class="mi">6</span><span class="p">,</span>
	<span class="n">CHANNELMSG_CLOSECHANNEL</span>		<span class="o">=</span>  <span class="mi">7</span><span class="p">,</span>
	<span class="n">CHANNELMSG_GPADL_HEADER</span>		<span class="o">=</span>  <span class="mi">8</span><span class="p">,</span>
	<span class="n">CHANNELMSG_GPADL_BODY</span>			<span class="o">=</span>  <span class="mi">9</span><span class="p">,</span>
	<span class="n">CHANNELMSG_GPADL_CREATED</span>		<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">CHANNELMSG_GPADL_TEARDOWN</span>		<span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">CHANNELMSG_GPADL_TORNDOWN</span>		<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">CHANNELMSG_RELID_RELEASED</span>		<span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">CHANNELMSG_INITIATE_CONTACT</span>		<span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">CHANNELMSG_VERSION_RESPONSE</span>		<span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">CHANNELMSG_UNLOAD</span>			<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="cp">#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD</span>
	<span class="n">CHANNELMSG_VIEWRANGE_ADD</span>		<span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
	<span class="n">CHANNELMSG_VIEWRANGE_REMOVE</span>		<span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="n">CHANNELMSG_COUNT</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">vmbus_channel_message_type</span> <span class="n">msgtype</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">padding</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Query VMBus Version parameters */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_query_vmbus_version</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">version</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* VMBus Version Supported parameters */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_version_supported</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">version_supported</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Offer Channel parameters */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_offer_channel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_offer</span> <span class="n">offer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">monitorid</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">monitor_allocated</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Rescind Offer parameters */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_rescind_offer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Request Offer -- no parameters, SynIC message contains the partition ID</span>
<span class="cm"> * Set Snoop -- no parameters, SynIC message contains the partition ID</span>
<span class="cm"> * Clear Snoop -- no parameters, SynIC message contains the partition ID</span>
<span class="cm"> * All Offers Delivered -- no parameters, SynIC message contains the partition</span>
<span class="cm"> *		           ID</span>
<span class="cm"> * Flush Client -- no parameters, SynIC message contains the partition ID</span>
<span class="cm"> */</span>

<span class="cm">/* Open Channel parameters */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_open_channel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>

	<span class="cm">/* Identifies the specific VMBus channel that is being opened. */</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>

	<span class="cm">/* ID making a particular open request at a channel offer unique. */</span>
	<span class="n">u32</span> <span class="n">openid</span><span class="p">;</span>

	<span class="cm">/* GPADL for the channel&#39;s ring buffer. */</span>
	<span class="n">u32</span> <span class="n">ringbuffer_gpadlhandle</span><span class="p">;</span>

	<span class="cm">/* GPADL for the channel&#39;s server context save area. */</span>
	<span class="n">u32</span> <span class="n">server_contextarea_gpadlhandle</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	* The upstream ring buffer begins at offset zero in the memory</span>
<span class="cm">	* described by RingBufferGpadlHandle. The downstream ring buffer</span>
<span class="cm">	* follows it at this offset (in pages).</span>
<span class="cm">	*/</span>
	<span class="n">u32</span> <span class="n">downstream_ringbuffer_pageoffset</span><span class="p">;</span>

	<span class="cm">/* User-specific data to be passed along to the server endpoint. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">userdata</span><span class="p">[</span><span class="n">MAX_USER_DEFINED_BYTES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Open Channel Result parameters */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_open_result</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">openid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Close channel parameters; */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_close_channel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Channel Message GPADL */</span>
<span class="cp">#define GPADL_TYPE_RING_BUFFER		1</span>
<span class="cp">#define GPADL_TYPE_SERVER_SAVE_AREA	2</span>
<span class="cp">#define GPADL_TYPE_TRANSACTION		8</span>

<span class="cm">/*</span>
<span class="cm"> * The number of PFNs in a GPADL message is defined by the number of</span>
<span class="cm"> * pages that would be spanned by ByteCount and ByteOffset.  If the</span>
<span class="cm"> * implied number of PFNs won&#39;t fit in this packet, there will be a</span>
<span class="cm"> * follow-up packet that contains more.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_gpadl_header</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">range_buflen</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rangecount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpa_range</span> <span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* This is the followup packet that contains more PFNs. */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_gpadl_body</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msgnumber</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmbus_channel_gpadl_created</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">creation_status</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmbus_channel_gpadl_teardown</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmbus_channel_gpadl_torndown</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpadl</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD</span>
<span class="k">struct</span> <span class="n">vmbus_channel_view_range_add</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">PHYSICAL_ADDRESS</span> <span class="n">viewrange_base</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">viewrange_length</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmbus_channel_view_range_remove</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">PHYSICAL_ADDRESS</span> <span class="n">viewrange_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">vmbus_channel_relid_released</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">child_relid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmbus_channel_initiate_contact</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vmbus_version_requested</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">padding2</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">interrupt_page</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">monitor_page1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">monitor_page2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vmbus_channel_version_response</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_message_header</span> <span class="n">header</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">version_supported</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">vmbus_channel_state</span> <span class="p">{</span>
	<span class="n">CHANNEL_OFFER_STATE</span><span class="p">,</span>
	<span class="n">CHANNEL_OPENING_STATE</span><span class="p">,</span>
	<span class="n">CHANNEL_OPEN_STATE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmbus_channel_debug_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">relid</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">vmbus_channel_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">uuid_le</span> <span class="n">interfacetype</span><span class="p">;</span>
	<span class="n">uuid_le</span> <span class="n">interface_instance</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">monitorid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">servermonitor_pending</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">servermonitor_latency</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">servermonitor_connectionid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">clientmonitor_pending</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">clientmonitor_latency</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">clientmonitor_connectionid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hv_ring_buffer_debug_info</span> <span class="n">inbound</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_ring_buffer_debug_info</span> <span class="n">outbound</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Represents each channel msg on the vmbus connection This is a</span>
<span class="cm"> * variable-size data structure depending on the msg type itself</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_msginfo</span> <span class="p">{</span>
	<span class="cm">/* Bookkeeping stuff */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">msglistentry</span><span class="p">;</span>

	<span class="cm">/* So far, this is only used to handle gpadl body message */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">submsglist</span><span class="p">;</span>

	<span class="cm">/* Synchronize the request/response if needed */</span>
	<span class="k">struct</span> <span class="n">completion</span>  <span class="n">waitevent</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vmbus_channel_version_supported</span> <span class="n">version_supported</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vmbus_channel_open_result</span> <span class="n">open_result</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vmbus_channel_gpadl_torndown</span> <span class="n">gpadl_torndown</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vmbus_channel_gpadl_created</span> <span class="n">gpadl_created</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vmbus_channel_version_response</span> <span class="n">version_response</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">response</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">msgsize</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The channel message that goes out on the &quot;wire&quot;.</span>
<span class="cm">	 * It will contain at minimum the VMBUS_CHANNEL_MESSAGE_HEADER header</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmbus_close_msg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_msginfo</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmbus_channel_close_channel</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">listentry</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">device_obj</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">vmbus_channel_state</span> <span class="n">state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vmbus_channel_offer_channel</span> <span class="n">offermsg</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * These are based on the OfferMsg.MonitorId.</span>
<span class="cm">	 * Save it here for easy access.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">monitor_grp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">monitor_bit</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">ringbuffer_gpadlhandle</span><span class="p">;</span>

	<span class="cm">/* Allocated memory for ring buffer */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ringbuffer_pages</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ringbuffer_pagecount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_ring_buffer_info</span> <span class="n">outbound</span><span class="p">;</span>	<span class="cm">/* send to parent */</span>
	<span class="k">struct</span> <span class="n">hv_ring_buffer_info</span> <span class="n">inbound</span><span class="p">;</span>	<span class="cm">/* receive from parent */</span>
	<span class="n">spinlock_t</span> <span class="n">inbound_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">controlwq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vmbus_close_msg</span> <span class="n">close_msg</span><span class="p">;</span>

	<span class="cm">/* Channel callback are invoked in this workqueue context */</span>
	<span class="cm">/* HANDLE dataWorkQueue; */</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">onchannel_callback</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">channel_callback_context</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">vmbus_onmessage</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">vmbus_request_offers</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* The format must be the same as struct vmdata_gpa_direct */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_packet_page_buffer</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dataoffset8</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length8</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transactionid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rangecount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_page_buffer</span> <span class="n">range</span><span class="p">[</span><span class="n">MAX_PAGE_BUFFER_COUNT</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* The format must be the same as struct vmdata_gpa_direct */</span>
<span class="k">struct</span> <span class="n">vmbus_channel_packet_multipage_buffer</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">dataoffset8</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length8</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transactionid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rangecount</span><span class="p">;</span>		<span class="cm">/* Always 1 in this case */</span>
	<span class="k">struct</span> <span class="n">hv_multipage_buffer</span> <span class="n">range</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmbus_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">send_ringbuffersize</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">recv_ringbuffersize</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">userdata</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">userdatalen</span><span class="p">,</span>
			    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">onchannel_callback</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">),</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">vmbus_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">bufferLen</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">requestid</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">vmbus_packet_type</span> <span class="n">type</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmbus_sendpacket_pagebuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">hv_page_buffer</span> <span class="n">pagebuffers</span><span class="p">[],</span>
					    <span class="n">u32</span> <span class="n">pagecount</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					    <span class="n">u32</span> <span class="n">bufferlen</span><span class="p">,</span>
					    <span class="n">u64</span> <span class="n">requestid</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmbus_sendpacket_multipagebuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">hv_multipage_buffer</span> <span class="o">*</span><span class="n">mpb</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">bufferlen</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">requestid</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmbus_establish_gpadl</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">kbuffer</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="o">*</span><span class="n">gpadl_handle</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmbus_teardown_gpadl</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">gpadl_handle</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmbus_recvpacket</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">bufferlen</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="o">*</span><span class="n">buffer_actual_len</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="o">*</span><span class="n">requestid</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmbus_recvpacket_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">bufferlen</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="o">*</span><span class="n">buffer_actual_len</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="o">*</span><span class="n">requestid</span><span class="p">);</span>


<span class="k">extern</span> <span class="kt">void</span> <span class="n">vmbus_get_debug_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">vmbus_channel_debug_info</span> <span class="o">*</span><span class="n">debug</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">vmbus_ontimer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">hv_dev_port_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">int_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">read_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">write_idx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytes_avail_toread</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bytes_avail_towrite</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Base driver object */</span>
<span class="k">struct</span> <span class="n">hv_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* the device type supported by this driver */</span>
	<span class="n">uuid_le</span> <span class="n">dev_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hv_vmbus_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hv_vmbus_device_id</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="p">);</span>

<span class="p">};</span>

<span class="cm">/* Base device object */</span>
<span class="k">struct</span> <span class="n">hv_device</span> <span class="p">{</span>
	<span class="cm">/* the device type id of this device */</span>
	<span class="n">uuid_le</span> <span class="n">dev_type</span><span class="p">;</span>

	<span class="cm">/* the device instance id of this device */</span>
	<span class="n">uuid_le</span> <span class="n">dev_instance</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="n">device</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="nf">device_to_hv_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hv_device</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hv_driver</span> <span class="o">*</span><span class="nf">drv_to_hv_drv</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hv_driver</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hv_set_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">hv_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Vmbus interface */</span>
<span class="cp">#define vmbus_driver_register(driver)	\</span>
<span class="cp">	__vmbus_driver_register(driver, THIS_MODULE, KBUILD_MODNAME)</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">__vmbus_driver_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_driver</span> <span class="o">*</span><span class="n">hv_driver</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vmbus_driver_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_driver</span> <span class="o">*</span><span class="n">hv_driver</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * VMBUS_DEVICE - macro used to describe a specific hyperv vmbus device</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct hv_vmbus_device_id that matches a</span>
<span class="cm"> * specific device.</span>
<span class="cm"> */</span>
<span class="cp">#define VMBUS_DEVICE(g0, g1, g2, g3, g4, g5, g6, g7,	\</span>
<span class="cp">		     g8, g9, ga, gb, gc, gd, ge, gf)	\</span>
<span class="cp">	.guid = { g0, g1, g2, g3, g4, g5, g6, g7,	\</span>
<span class="cp">		  g8, g9, ga, gb, gc, gd, ge, gf },</span>

<span class="cm">/*</span>
<span class="cm"> * Common header for Hyper-V ICs</span>
<span class="cm"> */</span>

<span class="cp">#define ICMSGTYPE_NEGOTIATE		0</span>
<span class="cp">#define ICMSGTYPE_HEARTBEAT		1</span>
<span class="cp">#define ICMSGTYPE_KVPEXCHANGE		2</span>
<span class="cp">#define ICMSGTYPE_SHUTDOWN		3</span>
<span class="cp">#define ICMSGTYPE_TIMESYNC		4</span>
<span class="cp">#define ICMSGTYPE_VSS			5</span>

<span class="cp">#define ICMSGHDRFLAG_TRANSACTION	1</span>
<span class="cp">#define ICMSGHDRFLAG_REQUEST		2</span>
<span class="cp">#define ICMSGHDRFLAG_RESPONSE		4</span>

<span class="cp">#define HV_S_OK				0x00000000</span>
<span class="cp">#define HV_E_FAIL			0x80004005</span>
<span class="cp">#define HV_S_CONT			0x80070103</span>
<span class="cp">#define HV_ERROR_NOT_SUPPORTED		0x80070032</span>
<span class="cp">#define HV_ERROR_MACHINE_LOCKED		0x800704F7</span>

<span class="cm">/*</span>
<span class="cm"> * While we want to handle util services as regular devices,</span>
<span class="cm"> * there is only one instance of each of these services; so</span>
<span class="cm"> * we statically allocate the service specific state.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">hv_util_service</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">recv_buffer</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">util_cb</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">util_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hv_util_service</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">util_deinit</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vmbuspipe_hdr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msgsize</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ic_version</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">major</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">minor</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">icmsg_hdr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ic_version</span> <span class="n">icverframe</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">icmsgtype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ic_version</span> <span class="n">icvermsg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">icmsgsize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ictransaction_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">icflags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">icmsg_negotiate</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">icframe_vercnt</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">icmsg_vercnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ic_version</span> <span class="n">icversion_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* any size array */</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">shutdown_msg_data</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">reason_code</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">timeout_seconds</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">display_message</span><span class="p">[</span><span class="mi">2048</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">heartbeat_msg_data</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">seq_num</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Time Sync IC defs */</span>
<span class="cp">#define ICTIMESYNCFLAG_PROBE	0</span>
<span class="cp">#define ICTIMESYNCFLAG_SYNC	1</span>
<span class="cp">#define ICTIMESYNCFLAG_SAMPLE	2</span>

<span class="cp">#ifdef __x86_64__</span>
<span class="cp">#define WLTIMEDELTA	116444736000000000L	</span><span class="cm">/* in 100ns unit */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define WLTIMEDELTA	116444736000000000LL</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">ictimesync_data</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">parenttime</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">childtime</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">roundtriptime</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">hyperv_service_callback</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">msg_type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">log_msg</span><span class="p">;</span>
	<span class="n">uuid_le</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define MAX_SRV_VER	0x7ffffff</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">vmbus_prep_negotiate_resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">icmsg_hdr</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">icmsg_negotiate</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
					<span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">hv_kvp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_util_service</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hv_kvp_deinit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hv_kvp_onchannelcallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _HYPERV_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
