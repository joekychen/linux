<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mmc › host.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>host.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/include/linux/mmc/host.h</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *  Host driver specific definitions.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef LINUX_MMC_HOST_H</span>
<span class="cp">#define LINUX_MMC_HOST_H</span>

<span class="cp">#include &lt;linux/leds.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/fault-inject.h&gt;</span>

<span class="cp">#include &lt;linux/mmc/core.h&gt;</span>
<span class="cp">#include &lt;linux/mmc/pm.h&gt;</span>

<span class="k">struct</span> <span class="n">mmc_ios</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">clock</span><span class="p">;</span>			<span class="cm">/* clock rate */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">vdd</span><span class="p">;</span>

<span class="cm">/* vdd stores the bit number of the selected voltage range from below. */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">bus_mode</span><span class="p">;</span>		<span class="cm">/* command output mode */</span>

<span class="cp">#define MMC_BUSMODE_OPENDRAIN	1</span>
<span class="cp">#define MMC_BUSMODE_PUSHPULL	2</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">chip_select</span><span class="p">;</span>		<span class="cm">/* SPI chip select */</span>

<span class="cp">#define MMC_CS_DONTCARE		0</span>
<span class="cp">#define MMC_CS_HIGH		1</span>
<span class="cp">#define MMC_CS_LOW		2</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">power_mode</span><span class="p">;</span>		<span class="cm">/* power supply mode */</span>

<span class="cp">#define MMC_POWER_OFF		0</span>
<span class="cp">#define MMC_POWER_UP		1</span>
<span class="cp">#define MMC_POWER_ON		2</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">bus_width</span><span class="p">;</span>		<span class="cm">/* data bus width */</span>

<span class="cp">#define MMC_BUS_WIDTH_1		0</span>
<span class="cp">#define MMC_BUS_WIDTH_4		2</span>
<span class="cp">#define MMC_BUS_WIDTH_8		3</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">timing</span><span class="p">;</span>			<span class="cm">/* timing specification used */</span>

<span class="cp">#define MMC_TIMING_LEGACY	0</span>
<span class="cp">#define MMC_TIMING_MMC_HS	1</span>
<span class="cp">#define MMC_TIMING_SD_HS	2</span>
<span class="cp">#define MMC_TIMING_UHS_SDR12	MMC_TIMING_LEGACY</span>
<span class="cp">#define MMC_TIMING_UHS_SDR25	MMC_TIMING_SD_HS</span>
<span class="cp">#define MMC_TIMING_UHS_SDR50	3</span>
<span class="cp">#define MMC_TIMING_UHS_SDR104	4</span>
<span class="cp">#define MMC_TIMING_UHS_DDR50	5</span>
<span class="cp">#define MMC_TIMING_MMC_HS200	6</span>

<span class="cp">#define MMC_SDR_MODE		0</span>
<span class="cp">#define MMC_1_2V_DDR_MODE	1</span>
<span class="cp">#define MMC_1_8V_DDR_MODE	2</span>
<span class="cp">#define MMC_1_2V_SDR_MODE	3</span>
<span class="cp">#define MMC_1_8V_SDR_MODE	4</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">signal_voltage</span><span class="p">;</span>		<span class="cm">/* signalling voltage (1.8V or 3.3V) */</span>

<span class="cp">#define MMC_SIGNAL_VOLTAGE_330	0</span>
<span class="cp">#define MMC_SIGNAL_VOLTAGE_180	1</span>
<span class="cp">#define MMC_SIGNAL_VOLTAGE_120	2</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">drv_type</span><span class="p">;</span>		<span class="cm">/* driver type (A, B, C, D) */</span>

<span class="cp">#define MMC_SET_DRIVER_TYPE_B	0</span>
<span class="cp">#define MMC_SET_DRIVER_TYPE_A	1</span>
<span class="cp">#define MMC_SET_DRIVER_TYPE_C	2</span>
<span class="cp">#define MMC_SET_DRIVER_TYPE_D	3</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mmc_host_ops</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * &#39;enable&#39; is called when the host is claimed and &#39;disable&#39; is called</span>
<span class="cm">	 * when the host is released. &#39;enable&#39; and &#39;disable&#39; are deprecated.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">disable</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is optional for the host to implement pre_req and post_req in</span>
<span class="cm">	 * order to support double buffering of requests (prepare one</span>
<span class="cm">	 * request while another request is active).</span>
<span class="cm">	 * pre_req() must always be followed by a post_req().</span>
<span class="cm">	 * To undo a call made to pre_req(), call post_req() with</span>
<span class="cm">	 * a nonzero err condition.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">post_req</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">pre_req</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">is_first_req</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">request</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_request</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Avoid calling these three functions too often or in a &quot;fast path&quot;,</span>
<span class="cm">	 * since underlaying controller might implement them in an expensive</span>
<span class="cm">	 * and/or slow way.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also note that these functions might sleep, so don&#39;t call them</span>
<span class="cm">	 * in the atomic contexts!</span>
<span class="cm">	 *</span>
<span class="cm">	 * Return values for the get_ro callback should be:</span>
<span class="cm">	 *   0 for a read/write card</span>
<span class="cm">	 *   1 for a read-only card</span>
<span class="cm">	 *   -ENOSYS when not supported (equal to NULL callback)</span>
<span class="cm">	 *   or a negative errno value when something bad happened</span>
<span class="cm">	 *</span>
<span class="cm">	 * Return values for the get_cd callback should be:</span>
<span class="cm">	 *   0 for a absent card</span>
<span class="cm">	 *   1 for a present card</span>
<span class="cm">	 *   -ENOSYS when not supported (equal to NULL callback)</span>
<span class="cm">	 *   or a negative errno value when something bad happened</span>
<span class="cm">	 */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_ios</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_ios</span> <span class="o">*</span><span class="n">ios</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_ro</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_cd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>

	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">enable_sdio_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>

	<span class="cm">/* optional callback for HC quirks */</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">init_card</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">);</span>

	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">start_signal_voltage_switch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_ios</span> <span class="o">*</span><span class="n">ios</span><span class="p">);</span>

	<span class="cm">/* The tuning command opcode value is different for SD and eMMC cards */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">execute_tuning</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">u32</span> <span class="n">opcode</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">enable_preset_value</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">select_drive_strength</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_dtr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">host_drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">card_drv</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">hw_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mmc_card</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">mmc_async_req</span> <span class="p">{</span>
	<span class="cm">/* active mmc request */</span>
	<span class="k">struct</span> <span class="n">mmc_request</span>	<span class="o">*</span><span class="n">mrq</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check error status of completed mmc request.</span>
<span class="cm">	 * Returns 0 if success otherwise non zero.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">err_check</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mmc_card</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_async_req</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mmc_hotplug</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">handler_priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mmc_host</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="n">class_dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mmc_host_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">f_min</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">f_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">f_init</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ocr_avail</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ocr_avail_sdio</span><span class="p">;</span>	<span class="cm">/* SDIO-specific OCR */</span>
	<span class="n">u32</span>			<span class="n">ocr_avail_sd</span><span class="p">;</span>	<span class="cm">/* SD-specific OCR */</span>
	<span class="n">u32</span>			<span class="n">ocr_avail_mmc</span><span class="p">;</span>	<span class="cm">/* MMC-specific OCR */</span>
	<span class="k">struct</span> <span class="n">notifier_block</span>	<span class="n">pm_notify</span><span class="p">;</span>

<span class="cp">#define MMC_VDD_165_195		0x00000080	</span><span class="cm">/* VDD voltage 1.65 - 1.95 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_20_21		0x00000100	</span><span class="cm">/* VDD voltage 2.0 ~ 2.1 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_21_22		0x00000200	</span><span class="cm">/* VDD voltage 2.1 ~ 2.2 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_22_23		0x00000400	</span><span class="cm">/* VDD voltage 2.2 ~ 2.3 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_23_24		0x00000800	</span><span class="cm">/* VDD voltage 2.3 ~ 2.4 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_24_25		0x00001000	</span><span class="cm">/* VDD voltage 2.4 ~ 2.5 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_25_26		0x00002000	</span><span class="cm">/* VDD voltage 2.5 ~ 2.6 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_26_27		0x00004000	</span><span class="cm">/* VDD voltage 2.6 ~ 2.7 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_27_28		0x00008000	</span><span class="cm">/* VDD voltage 2.7 ~ 2.8 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_28_29		0x00010000	</span><span class="cm">/* VDD voltage 2.8 ~ 2.9 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_29_30		0x00020000	</span><span class="cm">/* VDD voltage 2.9 ~ 3.0 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_30_31		0x00040000	</span><span class="cm">/* VDD voltage 3.0 ~ 3.1 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_31_32		0x00080000	</span><span class="cm">/* VDD voltage 3.1 ~ 3.2 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_32_33		0x00100000	</span><span class="cm">/* VDD voltage 3.2 ~ 3.3 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_33_34		0x00200000	</span><span class="cm">/* VDD voltage 3.3 ~ 3.4 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_34_35		0x00400000	</span><span class="cm">/* VDD voltage 3.4 ~ 3.5 */</span><span class="cp"></span>
<span class="cp">#define MMC_VDD_35_36		0x00800000	</span><span class="cm">/* VDD voltage 3.5 ~ 3.6 */</span><span class="cp"></span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">caps</span><span class="p">;</span>		<span class="cm">/* Host capabilities */</span>

<span class="cp">#define MMC_CAP_4_BIT_DATA	(1 &lt;&lt; 0)	</span><span class="cm">/* Can the host do 4 bit transfers */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_MMC_HIGHSPEED	(1 &lt;&lt; 1)	</span><span class="cm">/* Can do MMC high-speed timing */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_SD_HIGHSPEED	(1 &lt;&lt; 2)	</span><span class="cm">/* Can do SD high-speed timing */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_SDIO_IRQ	(1 &lt;&lt; 3)	</span><span class="cm">/* Can signal pending SDIO IRQs */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_SPI		(1 &lt;&lt; 4)	</span><span class="cm">/* Talks only SPI protocols */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_NEEDS_POLL	(1 &lt;&lt; 5)	</span><span class="cm">/* Needs polling for card-detection */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_8_BIT_DATA	(1 &lt;&lt; 6)	</span><span class="cm">/* Can the host do 8 bit transfers */</span><span class="cp"></span>

<span class="cp">#define MMC_CAP_NONREMOVABLE	(1 &lt;&lt; 8)	</span><span class="cm">/* Nonremovable e.g. eMMC */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_WAIT_WHILE_BUSY	(1 &lt;&lt; 9)	</span><span class="cm">/* Waits while card is busy */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_ERASE		(1 &lt;&lt; 10)	</span><span class="cm">/* Allow erase/trim commands */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_1_8V_DDR	(1 &lt;&lt; 11)	</span><span class="cm">/* can support */</span><span class="cp"></span>
						<span class="cm">/* DDR mode at 1.8V */</span>
<span class="cp">#define MMC_CAP_1_2V_DDR	(1 &lt;&lt; 12)	</span><span class="cm">/* can support */</span><span class="cp"></span>
						<span class="cm">/* DDR mode at 1.2V */</span>
<span class="cp">#define MMC_CAP_POWER_OFF_CARD	(1 &lt;&lt; 13)	</span><span class="cm">/* Can power off after boot */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_BUS_WIDTH_TEST	(1 &lt;&lt; 14)	</span><span class="cm">/* CMD14/CMD19 bus width ok */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_UHS_SDR12	(1 &lt;&lt; 15)	</span><span class="cm">/* Host supports UHS SDR12 mode */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_UHS_SDR25	(1 &lt;&lt; 16)	</span><span class="cm">/* Host supports UHS SDR25 mode */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_UHS_SDR50	(1 &lt;&lt; 17)	</span><span class="cm">/* Host supports UHS SDR50 mode */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_UHS_SDR104	(1 &lt;&lt; 18)	</span><span class="cm">/* Host supports UHS SDR104 mode */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_UHS_DDR50	(1 &lt;&lt; 19)	</span><span class="cm">/* Host supports UHS DDR50 mode */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_SET_XPC_330	(1 &lt;&lt; 20)	</span><span class="cm">/* Host supports &gt;150mA current at 3.3V */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_SET_XPC_300	(1 &lt;&lt; 21)	</span><span class="cm">/* Host supports &gt;150mA current at 3.0V */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_SET_XPC_180	(1 &lt;&lt; 22)	</span><span class="cm">/* Host supports &gt;150mA current at 1.8V */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_DRIVER_TYPE_A	(1 &lt;&lt; 23)	</span><span class="cm">/* Host supports Driver Type A */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_DRIVER_TYPE_C	(1 &lt;&lt; 24)	</span><span class="cm">/* Host supports Driver Type C */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_DRIVER_TYPE_D	(1 &lt;&lt; 25)	</span><span class="cm">/* Host supports Driver Type D */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_MAX_CURRENT_200	(1 &lt;&lt; 26)	</span><span class="cm">/* Host max current limit is 200mA */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_MAX_CURRENT_400	(1 &lt;&lt; 27)	</span><span class="cm">/* Host max current limit is 400mA */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_MAX_CURRENT_600	(1 &lt;&lt; 28)	</span><span class="cm">/* Host max current limit is 600mA */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_MAX_CURRENT_800	(1 &lt;&lt; 29)	</span><span class="cm">/* Host max current limit is 800mA */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_CMD23		(1 &lt;&lt; 30)	</span><span class="cm">/* CMD23 supported. */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP_HW_RESET	(1 &lt;&lt; 31)	</span><span class="cm">/* Hardware reset */</span><span class="cp"></span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">caps2</span><span class="p">;</span>		<span class="cm">/* More host capabilities */</span>

<span class="cp">#define MMC_CAP2_BOOTPART_NOACC	(1 &lt;&lt; 0)	</span><span class="cm">/* Boot partition no access */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_CACHE_CTRL	(1 &lt;&lt; 1)	</span><span class="cm">/* Allow cache control */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_POWEROFF_NOTIFY (1 &lt;&lt; 2)	</span><span class="cm">/* Notify poweroff supported */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_NO_MULTI_READ	(1 &lt;&lt; 3)	</span><span class="cm">/* Multiblock reads don&#39;t work */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_NO_SLEEP_CMD	(1 &lt;&lt; 4)	</span><span class="cm">/* Don&#39;t allow sleep command */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_HS200_1_8V_SDR	(1 &lt;&lt; 5)        </span><span class="cm">/* can support */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_HS200_1_2V_SDR	(1 &lt;&lt; 6)        </span><span class="cm">/* can support */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \</span>
<span class="cp">				 MMC_CAP2_HS200_1_2V_SDR)</span>
<span class="cp">#define MMC_CAP2_BROKEN_VOLTAGE	(1 &lt;&lt; 7)	</span><span class="cm">/* Use the broken voltage */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_DETECT_ON_ERR	(1 &lt;&lt; 8)	</span><span class="cm">/* On I/O err check card removal */</span><span class="cp"></span>
<span class="cp">#define MMC_CAP2_HC_ERASE_SZ	(1 &lt;&lt; 9)	</span><span class="cm">/* High-capacity erase size */</span><span class="cp"></span>

	<span class="n">mmc_pm_flag_t</span>		<span class="n">pm_caps</span><span class="p">;</span>	<span class="cm">/* supported pm features */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">power_notify_type</span><span class="p">;</span>
<span class="cp">#define MMC_HOST_PW_NOTIFY_NONE		0</span>
<span class="cp">#define MMC_HOST_PW_NOTIFY_SHORT	1</span>
<span class="cp">#define MMC_HOST_PW_NOTIFY_LONG		2</span>

<span class="cp">#ifdef CONFIG_MMC_CLKGATE</span>
	<span class="kt">int</span>			<span class="n">clk_requests</span><span class="p">;</span>	<span class="cm">/* internal reference counter */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">clk_delay</span><span class="p">;</span>	<span class="cm">/* number of MCI clk hold cycles */</span>
	<span class="n">bool</span>			<span class="n">clk_gated</span><span class="p">;</span>	<span class="cm">/* clock gated */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">clk_gate_work</span><span class="p">;</span> <span class="cm">/* delayed clock gate */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">clk_old</span><span class="p">;</span>	<span class="cm">/* old clock value cache */</span>
	<span class="n">spinlock_t</span>		<span class="n">clk_lock</span><span class="p">;</span>	<span class="cm">/* lock for clk fields */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">clk_gate_mutex</span><span class="p">;</span>	<span class="cm">/* mutex for clock gating */</span>
	<span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">clkgate_delay_attr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">clkgate_delay</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* host specific block data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_seg_size</span><span class="p">;</span>	<span class="cm">/* see blk_queue_max_segment_size */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">max_segs</span><span class="p">;</span>	<span class="cm">/* see blk_queue_max_segments */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">unused</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_req_size</span><span class="p">;</span>	<span class="cm">/* maximum number of bytes in one req */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_blk_size</span><span class="p">;</span>	<span class="cm">/* maximum size of one mmc block */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_blk_count</span><span class="p">;</span>	<span class="cm">/* maximum number of blocks in one req */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">max_discard_to</span><span class="p">;</span>	<span class="cm">/* max. discard timeout in ms */</span>

	<span class="cm">/* private data */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* lock for claim and bus ops */</span>

	<span class="k">struct</span> <span class="n">mmc_ios</span>		<span class="n">ios</span><span class="p">;</span>		<span class="cm">/* current io bus settings */</span>
	<span class="n">u32</span>			<span class="n">ocr</span><span class="p">;</span>		<span class="cm">/* the current OCR setting */</span>

	<span class="cm">/* group bitfields together to minimize padding */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">use_spi_crc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">claimed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* host exclusively claimed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bus_dead</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* bus has been released */</span>
<span class="cp">#ifdef CONFIG_MMC_DEBUG</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">removed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* host is being removed */</span>
<span class="cp">#endif</span>

	<span class="kt">int</span>			<span class="n">rescan_disable</span><span class="p">;</span>	<span class="cm">/* disable card detection */</span>

	<span class="k">struct</span> <span class="n">mmc_card</span>		<span class="o">*</span><span class="n">card</span><span class="p">;</span>		<span class="cm">/* device attached to this host */</span>

	<span class="n">wait_queue_head_t</span>	<span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">claimer</span><span class="p">;</span>	<span class="cm">/* task that has host claimed */</span>
	<span class="kt">int</span>			<span class="n">claim_cnt</span><span class="p">;</span>	<span class="cm">/* &quot;claim&quot; nesting count */</span>

	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">detect</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">detect_change</span><span class="p">;</span>	<span class="cm">/* card detect flag */</span>
	<span class="k">struct</span> <span class="n">mmc_hotplug</span>	<span class="n">hotplug</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">mmc_bus_ops</span> <span class="o">*</span><span class="n">bus_ops</span><span class="p">;</span>	<span class="cm">/* current bus driver */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bus_refs</span><span class="p">;</span>	<span class="cm">/* reference counter */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sdio_irqs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">sdio_irq_thread</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">sdio_irq_pending</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">sdio_irq_thread_abort</span><span class="p">;</span>

	<span class="n">mmc_pm_flag_t</span>		<span class="n">pm_flags</span><span class="p">;</span>	<span class="cm">/* requested pm features */</span>

<span class="cp">#ifdef CONFIG_LEDS_TRIGGERS</span>
	<span class="k">struct</span> <span class="n">led_trigger</span>	<span class="o">*</span><span class="n">led</span><span class="p">;</span>		<span class="cm">/* activity led */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_REGULATOR</span>
	<span class="n">bool</span>			<span class="n">regulator_enabled</span><span class="p">;</span> <span class="cm">/* regulator state */</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">debugfs_root</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mmc_async_req</span>	<span class="o">*</span><span class="n">areq</span><span class="p">;</span>		<span class="cm">/* active async req */</span>

<span class="cp">#ifdef CONFIG_FAIL_MMC_REQUEST</span>
	<span class="k">struct</span> <span class="n">fault_attr</span>	<span class="n">fail_mmc_request</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">actual_clock</span><span class="p">;</span>	<span class="cm">/* Actual HC clock rate */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">private</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">mmc_alloc_host</span><span class="p">(</span><span class="kt">int</span> <span class="n">extra</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mmc_add_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mmc_remove_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mmc_free_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">mmc_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define mmc_host_is_spi(host)	((host)-&gt;caps &amp; MMC_CAP_SPI)</span>

<span class="cp">#define mmc_dev(x)	((x)-&gt;parent)</span>
<span class="cp">#define mmc_classdev(x)	(&amp;(x)-&gt;class_dev)</span>
<span class="cp">#define mmc_hostname(x)	(dev_name(&amp;(x)-&gt;class_dev))</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">mmc_suspend_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mmc_resume_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">mmc_power_save_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mmc_power_restore_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">mmc_detect_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mmc_request_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmc_request</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">mmc_cache_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmc_signal_sdio_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable_sdio_irq</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">sdio_irq_pending</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sdio_irq_thread</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">regulator</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_REGULATOR</span>
<span class="kt">int</span> <span class="n">mmc_regulator_get_ocrmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">supply</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mmc_regulator_set_ocr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">mmc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">supply</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vdd_bit</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmc_regulator_get_ocrmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">supply</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmc_regulator_set_ocr</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">mmc</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">supply</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vdd_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">mmc_card_awake</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mmc_card_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mmc_card_can_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">mmc_pm_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notify_block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Module parameter */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">mmc_assume_removable</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmc_card_is_removable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">MMC_CAP_NONREMOVABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mmc_assume_removable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmc_card_keep_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pm_flags</span> <span class="o">&amp;</span> <span class="n">MMC_PM_KEEP_POWER</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmc_card_wake_sdio_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">pm_flags</span> <span class="o">&amp;</span> <span class="n">MMC_PM_WAKE_SDIO_IRQ</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmc_host_cmd23</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">MMC_CAP_CMD23</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmc_boot_partition_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">caps2</span> <span class="o">&amp;</span> <span class="n">MMC_CAP2_BOOTPART_NOACC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MMC_CLKGATE</span>
<span class="kt">void</span> <span class="n">mmc_host_clk_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mmc_host_clk_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mmc_host_clk_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmc_host_clk_hold</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmc_host_clk_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mmc_host_clk_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ios</span><span class="p">.</span><span class="n">clock</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* LINUX_MMC_HOST_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
