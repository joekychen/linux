<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › uwb.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>uwb.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Ultra Wide Band</span>
<span class="cm"> * UWB API</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2006 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: doc: overview of the API, different parts and pointers</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX__UWB_H__</span>
<span class="cp">#define __LINUX__UWB_H__</span>

<span class="cp">#include &lt;linux/limits.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/uwb/spec.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="k">struct</span> <span class="n">uwb_dev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">uwb_beca_e</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">uwb_rc</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">uwb_rsv</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">uwb_dbg</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct uwb_dev - a UWB Device</span>
<span class="cm"> * @rc: UWB Radio Controller that discovered the device (kind of its</span>
<span class="cm"> *     parent).</span>
<span class="cm"> * @bce: a beacon cache entry for this device; or NULL if the device</span>
<span class="cm"> *     is a local radio controller.</span>
<span class="cm"> * @mac_addr: the EUI-48 address of this device.</span>
<span class="cm"> * @dev_addr: the current DevAddr used by this device.</span>
<span class="cm"> * @beacon_slot: the slot number the beacon is using.</span>
<span class="cm"> * @streams: bitmap of streams allocated to reservations targeted at</span>
<span class="cm"> *     this device.  For an RC, this is the streams allocated for</span>
<span class="cm"> *     reservations targeted at DevAddrs.</span>
<span class="cm"> *</span>
<span class="cm"> * A UWB device may either by a neighbor or part of a local radio</span>
<span class="cm"> * controller.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>		<span class="cm">/* radio controller */</span>
	<span class="k">struct</span> <span class="n">uwb_beca_e</span> <span class="o">*</span><span class="n">bce</span><span class="p">;</span>		<span class="cm">/* Beacon Cache Entry */</span>

	<span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="n">mac_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="n">dev_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">beacon_slot</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">streams</span><span class="p">,</span> <span class="n">UWB_NUM_STREAMS</span><span class="p">);</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">last_availability_bm</span><span class="p">,</span> <span class="n">UWB_NUM_MAS</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#define to_uwb_dev(d) container_of(d, struct uwb_dev, dev)</span>

<span class="cm">/**</span>
<span class="cm"> * UWB HWA/WHCI Radio Control {Command|Event} Block context IDs</span>
<span class="cm"> *</span>
<span class="cm"> * RC[CE]Bs have a &#39;context ID&#39; field that matches the command with</span>
<span class="cm"> * the event received to confirm it.</span>
<span class="cm"> *</span>
<span class="cm"> * Maximum number of context IDs</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">UWB_RC_CTX_MAX</span> <span class="o">=</span> <span class="mi">256</span> <span class="p">};</span>


<span class="cm">/** Notification chain head for UWB generated events to listeners */</span>
<span class="k">struct</span> <span class="n">uwb_notifs_chain</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Beacon cache list */</span>
<span class="k">struct</span> <span class="n">uwb_beca</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">entries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Event handling thread. */</span>
<span class="k">struct</span> <span class="n">uwbd</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">event_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">event_list_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct uwb_mas_bm - a bitmap of all MAS in a superframe</span>
<span class="cm"> * @bm: a bitmap of length #UWB_NUM_MAS</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="p">{</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="n">UWB_NUM_MAS</span><span class="p">);</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">unsafe_bm</span><span class="p">,</span> <span class="n">UWB_NUM_MAS</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">safe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unsafe</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * uwb_rsv_state - UWB Reservation state.</span>
<span class="cm"> *</span>
<span class="cm"> * NONE - reservation is not active (no DRP IE being transmitted).</span>
<span class="cm"> *</span>
<span class="cm"> * Owner reservation states:</span>
<span class="cm"> *</span>
<span class="cm"> * INITIATED - owner has sent an initial DRP request.</span>
<span class="cm"> * PENDING - target responded with pending Reason Code.</span>
<span class="cm"> * MODIFIED - reservation manager is modifying an established</span>
<span class="cm"> * reservation with a different MAS allocation.</span>
<span class="cm"> * ESTABLISHED - the reservation has been successfully negotiated.</span>
<span class="cm"> *</span>
<span class="cm"> * Target reservation states:</span>
<span class="cm"> *</span>
<span class="cm"> * DENIED - request is denied.</span>
<span class="cm"> * ACCEPTED - request is accepted.</span>
<span class="cm"> * PENDING - PAL has yet to make a decision to whether to accept or</span>
<span class="cm"> * deny.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: further target states TBD.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">uwb_rsv_state</span> <span class="p">{</span>
	<span class="n">UWB_RSV_STATE_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_O_INITIATED</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_O_PENDING</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_O_MODIFIED</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_O_ESTABLISHED</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_O_TO_BE_MOVED</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_O_MOVE_EXPANDING</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_O_MOVE_COMBINING</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_O_MOVE_REDUCING</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_ACCEPTED</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_DENIED</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_CONFLICT</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_PENDING</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_EXPANDING_ACCEPTED</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_EXPANDING_CONFLICT</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_EXPANDING_PENDING</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_EXPANDING_DENIED</span><span class="p">,</span>
	<span class="n">UWB_RSV_STATE_T_RESIZED</span><span class="p">,</span>

	<span class="n">UWB_RSV_STATE_LAST</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">uwb_rsv_target_type</span> <span class="p">{</span>
	<span class="n">UWB_RSV_TARGET_DEV</span><span class="p">,</span>
	<span class="n">UWB_RSV_TARGET_DEVADDR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct uwb_rsv_target - the target of a reservation.</span>
<span class="cm"> *</span>
<span class="cm"> * Reservations unicast and targeted at a single device</span>
<span class="cm"> * (UWB_RSV_TARGET_DEV); or (e.g., in the case of WUSB) targeted at a</span>
<span class="cm"> * specific (private) DevAddr (UWB_RSV_TARGET_DEVADDR).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_rsv_target</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">uwb_rsv_target_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="n">devaddr</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">uwb_rsv_move</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="n">final_mas</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_ie_drp</span> <span class="o">*</span><span class="n">companion_drp_ie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="n">companion_mas</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Number of streams reserved for reservations targeted at DevAddrs.</span>
<span class="cm"> */</span>
<span class="cp">#define UWB_NUM_GLOBAL_STREAMS 1</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">uwb_rsv_cb_f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct uwb_rsv - a DRP reservation</span>
<span class="cm"> *</span>
<span class="cm"> * Data structure management:</span>
<span class="cm"> *</span>
<span class="cm"> * @rc:             the radio controller this reservation is for</span>
<span class="cm"> *                  (as target or owner)</span>
<span class="cm"> * @rc_node:        a list node for the RC</span>
<span class="cm"> * @pal_node:       a list node for the PAL</span>
<span class="cm"> *</span>
<span class="cm"> * Owner and target parameters:</span>
<span class="cm"> *</span>
<span class="cm"> * @owner:          the UWB device owning this reservation</span>
<span class="cm"> * @target:         the target UWB device</span>
<span class="cm"> * @type:           reservation type</span>
<span class="cm"> *</span>
<span class="cm"> * Owner parameters:</span>
<span class="cm"> *</span>
<span class="cm"> * @max_mas:        maxiumum number of MAS</span>
<span class="cm"> * @min_mas:        minimum number of MAS</span>
<span class="cm"> * @sparsity:       owner selected sparsity</span>
<span class="cm"> * @is_multicast:   true iff multicast</span>
<span class="cm"> *</span>
<span class="cm"> * @callback:       callback function when the reservation completes</span>
<span class="cm"> * @pal_priv:       private data for the PAL making the reservation</span>
<span class="cm"> *</span>
<span class="cm"> * Reservation status:</span>
<span class="cm"> *</span>
<span class="cm"> * @status:         negotiation status</span>
<span class="cm"> * @stream:         stream index allocated for this reservation</span>
<span class="cm"> * @tiebreaker:     conflict tiebreaker for this reservation</span>
<span class="cm"> * @mas:            reserved MAS</span>
<span class="cm"> * @drp_ie:         the DRP IE</span>
<span class="cm"> * @ie_valid:       true iff the DRP IE matches the reservation parameters</span>
<span class="cm"> *</span>
<span class="cm"> * DRP reservations are uniquely identified by the owner, target and</span>
<span class="cm"> * stream index.  However, when using a DevAddr as a target (e.g., for</span>
<span class="cm"> * a WUSB cluster reservation) the responses may be received from</span>
<span class="cm"> * devices with different DevAddrs.  In this case, reservations are</span>
<span class="cm"> * uniquely identified by just the stream index.  A number of stream</span>
<span class="cm"> * indexes (UWB_NUM_GLOBAL_STREAMS) are reserved for this.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rc_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pal_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rsv_target</span> <span class="n">target</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">uwb_drp_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_mas</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_mas</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_interval</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_multicast</span><span class="p">;</span>

	<span class="n">uwb_rsv_cb_f</span> <span class="n">callback</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pal_priv</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">uwb_rsv_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">needs_release_companion_mas</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">stream</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tiebreaker</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="n">mas</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_ie_drp</span> <span class="o">*</span><span class="n">drp_ie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rsv_move</span> <span class="n">mv</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ie_valid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">handle_timeout_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span>
<span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="n">uwb_mas_bm_zero</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">bm</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uwb_mas_bm_copy_le</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="o">*</span><span class="n">mas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap_copy_le</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">mas</span><span class="o">-&gt;</span><span class="n">bm</span><span class="p">,</span> <span class="n">UWB_NUM_MAS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct uwb_drp_avail - a radio controller&#39;s view of MAS usage</span>
<span class="cm"> * @global:   MAS unused by neighbors (excluding reservations targeted</span>
<span class="cm"> *            or owned by the local radio controller) or the beaon period</span>
<span class="cm"> * @local:    MAS unused by local established reservations</span>
<span class="cm"> * @pending:  MAS unused by local pending reservations</span>
<span class="cm"> * @ie:       DRP Availability IE to be included in the beacon</span>
<span class="cm"> * @ie_valid: true iff @ie is valid and does not need to regenerated from</span>
<span class="cm"> *            @global and @local</span>
<span class="cm"> *</span>
<span class="cm"> * Each radio controller maintains a view of MAS usage or</span>
<span class="cm"> * availability. MAS available for a new reservation are determined</span>
<span class="cm"> * from the intersection of @global, @local, and @pending.</span>
<span class="cm"> *</span>
<span class="cm"> * The radio controller must transmit a DRP Availability IE that&#39;s the</span>
<span class="cm"> * intersection of @global and @local.</span>
<span class="cm"> *</span>
<span class="cm"> * A set bit indicates the MAS is unused and available.</span>
<span class="cm"> *</span>
<span class="cm"> * rc-&gt;rsvs_mutex should be held before accessing this data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * [ECMA-368] section 17.4.3.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_drp_avail</span> <span class="p">{</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">global</span><span class="p">,</span> <span class="n">UWB_NUM_MAS</span><span class="p">);</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="n">UWB_NUM_MAS</span><span class="p">);</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">pending</span><span class="p">,</span> <span class="n">UWB_NUM_MAS</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uwb_ie_drp_avail</span> <span class="n">ie</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ie_valid</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">uwb_drp_backoff_win</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">window</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_expired</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">can_reserve_extra_mases</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uwb_rsv_state_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">uwb_rsv_state</span> <span class="n">state</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uwb_rsv_type_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">uwb_drp_type</span> <span class="n">type</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">uwb_rsv_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">uwb_rsv_cb_f</span> <span class="n">cb</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">pal_priv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_rsv_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">uwb_rsv_establish</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_rsv_modify</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">max_mas</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_mas</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sparsity</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_rsv_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">uwb_rsv_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span> <span class="n">uwb_rsv_cb_f</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pal_priv</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">uwb_rsv_get_usable_mas</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">orig_rsv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="o">*</span><span class="n">mas</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Radio Control Interface instance</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Life cycle rules: those of the UWB Device.</span>
<span class="cm"> *</span>
<span class="cm"> * @index:    an index number for this radio controller, as used in the</span>
<span class="cm"> *            device name.</span>
<span class="cm"> * @version:  version of protocol supported by this device</span>
<span class="cm"> * @priv:     Backend implementation; rw with uwb_dev.dev.sem taken.</span>
<span class="cm"> * @cmd:      Backend implementation to execute commands; rw and call</span>
<span class="cm"> *            only  with uwb_dev.dev.sem taken.</span>
<span class="cm"> * @reset:    Hardware reset of radio controller and any PAL controllers.</span>
<span class="cm"> * @filter:   Backend implementation to manipulate data to and from device</span>
<span class="cm"> *            to be compliant to specification assumed by driver (WHCI</span>
<span class="cm"> *            0.95).</span>
<span class="cm"> *</span>
<span class="cm"> *            uwb_dev.dev.mutex is used to execute commands and update</span>
<span class="cm"> *            the corresponding structures; can&#39;t use a spinlock</span>
<span class="cm"> *            because rc-&gt;cmd() can sleep.</span>
<span class="cm"> * @ies:         This is a dynamically allocated array cacheing the</span>
<span class="cm"> *               IEs (settable by the host) that the beacon of this</span>
<span class="cm"> *               radio controller is currently sending.</span>
<span class="cm"> *</span>
<span class="cm"> *               In reality, we store here the full command we set to</span>
<span class="cm"> *               the radio controller (which is basically a command</span>
<span class="cm"> *               prefix followed by all the IEs the beacon currently</span>
<span class="cm"> *               contains). This way we don&#39;t have to realloc and</span>
<span class="cm"> *               memcpy when setting it.</span>
<span class="cm"> *</span>
<span class="cm"> *               We set this up in uwb_rc_ie_setup(), where we alloc</span>
<span class="cm"> *               this struct, call get_ie() [so we know which IEs are</span>
<span class="cm"> *               currently being sent, if any].</span>
<span class="cm"> *</span>
<span class="cm"> * @ies_capacity:Amount of space (in bytes) allocated in @ies. The</span>
<span class="cm"> *               amount used is given by sizeof(*ies) plus ies-&gt;wIELength</span>
<span class="cm"> *               (which is a little endian quantity all the time).</span>
<span class="cm"> * @ies_mutex:   protect the IE cache</span>
<span class="cm"> * @dbg:         information for the debug interface</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="n">uwb_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">version</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filter_cmd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">**</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filter_event</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">**</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">spinlock_t</span> <span class="n">neh_lock</span><span class="p">;</span>		<span class="cm">/* protects neh_* and ctx_* */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">neh_list</span><span class="p">;</span>	<span class="cm">/* Open NE handles */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctx_bm</span><span class="p">[</span><span class="n">UWB_RC_CTX_MAX</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)];</span>
	<span class="n">u8</span> <span class="n">ctx_roll</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">beaconing</span><span class="p">;</span>			<span class="cm">/* Beaconing state [channel number] */</span>
	<span class="kt">int</span> <span class="n">beaconing_forced</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scanning</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">uwb_scan_type</span> <span class="n">scan_type</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ready</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_notifs_chain</span> <span class="n">notifs_chain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_beca</span> <span class="n">uwb_beca</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uwbd</span> <span class="n">uwbd</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uwb_drp_backoff_win</span> <span class="n">bow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_drp_avail</span> <span class="n">drp_avail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">reservations</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cnflt_alien_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_mas_bm</span> <span class="n">cnflt_alien_bitmap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">rsvs_mutex</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">rsvs_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">rsv_workq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">rsv_update_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">rsv_alien_bp_work</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">set_drp_ie_pending</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ies_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc_cmd_set_ie</span> <span class="o">*</span><span class="n">ies</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ies_capacity</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pals</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">active_pals</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uwb_dbg</span> <span class="o">*</span><span class="n">dbg</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * struct uwb_pal - a UWB PAL</span>
<span class="cm"> * @name:    descriptive name for this PAL (wusbhc, wlp, etc.).</span>
<span class="cm"> * @device:  a device for the PAL.  Used to link the PAL and the radio</span>
<span class="cm"> *           controller in sysfs.</span>
<span class="cm"> * @rc:      the radio controller the PAL uses.</span>
<span class="cm"> * @channel_changed: called when the channel used by the radio changes.</span>
<span class="cm"> *           A channel of -1 means the channel has been stopped.</span>
<span class="cm"> * @new_rsv: called when a peer requests a reservation (may be NULL if</span>
<span class="cm"> *           the PAL cannot accept reservation requests).</span>
<span class="cm"> * @channel: channel being used by the PAL; 0 if the PAL isn&#39;t using</span>
<span class="cm"> *           the radio; -1 if the PAL wishes to use the radio but</span>
<span class="cm"> *           cannot.</span>
<span class="cm"> * @debugfs_dir: a debugfs directory which the PAL can use for its own</span>
<span class="cm"> *           debugfs files.</span>
<span class="cm"> *</span>
<span class="cm"> * A Protocol Adaptation Layer (PAL) is a user of the WiMedia UWB</span>
<span class="cm"> * radio platform (e.g., WUSB, WLP or Bluetooth UWB AMP).</span>
<span class="cm"> *</span>
<span class="cm"> * The PALs using a radio controller must register themselves to</span>
<span class="cm"> * permit the UWB stack to coordinate usage of the radio between the</span>
<span class="cm"> * various PALs or to allow PALs to response to certain requests from</span>
<span class="cm"> * peers.</span>
<span class="cm"> *</span>
<span class="cm"> * A struct uwb_pal should be embedded in a containing structure</span>
<span class="cm"> * belonging to the PAL and initialized with uwb_pal_init()).  Fields</span>
<span class="cm"> * should be set appropriately by the PAL before registering the PAL</span>
<span class="cm"> * with uwb_pal_register().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_pal</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">channel_changed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_pal</span> <span class="o">*</span><span class="n">pal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">new_rsv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_pal</span> <span class="o">*</span><span class="n">pal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dir</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">uwb_pal_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_pal</span> <span class="o">*</span><span class="n">pal</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_pal_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_pal</span> <span class="o">*</span><span class="n">pal</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_pal_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_pal</span> <span class="o">*</span><span class="n">pal</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">uwb_radio_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_pal</span> <span class="o">*</span><span class="n">pal</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_radio_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_pal</span> <span class="o">*</span><span class="n">pal</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * General public API</span>
<span class="cm"> *</span>
<span class="cm"> * This API can be used by UWB device drivers or by those implementing</span>
<span class="cm"> * UWB Radio Controllers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev_get_by_devaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="n">devaddr</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev_get_by_rc</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uwb_dev_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uwb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">uwb_dev_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uwb_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev_try_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="n">uwb_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Callback function for &#39;uwb_{dev,rc}_foreach()&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev:  Linux device instance</span>
<span class="cm"> *        &#39;uwb_dev = container_of(dev, struct uwb_dev, dev)&#39;</span>
<span class="cm"> * @priv: Data passed by the caller to &#39;uwb_{dev,rc}_foreach()&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * @returns: 0 to continue the iterations, any other val to stop</span>
<span class="cm"> *           iterating and return the value to the caller of</span>
<span class="cm"> *           _foreach().</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">uwb_dev_for_each_f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_dev_for_each</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="n">uwb_dev_for_each_f</span> <span class="n">func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc_get_by_dev</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc_get_by_grandpa</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_rc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">uwb_rc_cmd_cb_f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">reply</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">reply_size</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">uwb_rc_cmd_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd_name</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cmd_size</span><span class="p">,</span>
		     <span class="n">u8</span> <span class="n">expected_type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">expected_event</span><span class="p">,</span>
		     <span class="n">uwb_rc_cmd_cb_f</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">uwb_rc_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd_name</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cmd_size</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">reply</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">reply_size</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">uwb_rc_vcmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd_name</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">uwb_rccb</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cmd_size</span><span class="p">,</span>
		    <span class="n">u8</span> <span class="n">expected_type</span><span class="p">,</span> <span class="n">u16</span> <span class="n">expected_event</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">**</span><span class="n">preply</span><span class="p">);</span>

<span class="kt">size_t</span> <span class="n">__uwb_addr_print</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">uwb_rc_dev_addr_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_rc_dev_addr_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_rc_mac_addr_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_rc_mac_addr_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__uwb_mac_addr_assigned_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__uwb_dev_addr_assigned_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Print in @buf a pretty repr of @addr */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">uwb_dev_addr_print</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__uwb_addr_print</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Print in @buf a pretty repr of @addr */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">uwb_mac_addr_print</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__uwb_addr_print</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* @returns 0 if device addresses @addr2 and @addr1 are equal */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uwb_dev_addr_cmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="n">addr1</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="n">addr2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span> <span class="n">addr2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* @returns 0 if MAC addresses @addr2 and @addr1 are equal */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uwb_mac_addr_cmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="n">addr1</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="n">addr2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span> <span class="n">addr2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* @returns !0 if a MAC @addr is a broadcast address */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uwb_mac_addr_bcast</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="n">bcast</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span> <span class="p">}</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">uwb_mac_addr_cmp</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bcast</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* @returns !0 if a MAC @addr is all zeroes*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">uwb_mac_addr_unset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uwb_mac_addr</span> <span class="n">unset</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">}</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">uwb_mac_addr_cmp</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* @returns !0 if the address is in use. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">__uwb_dev_addr_assigned</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">uwb_dev_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">uwb_dev_for_each</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">__uwb_dev_addr_assigned_check</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * UWB Radio Controller API</span>
<span class="cm"> *</span>
<span class="cm"> * This API is used (in addition to the general API) to implement UWB</span>
<span class="cm"> * Radio Controllers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">uwb_rc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_rc_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">rc_priv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_rc_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_rc_neh_grok</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_rc_neh_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_rc_reset_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">uwb_rc_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_rc_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * uwb_rsv_is_owner - is the owner of this reservation the RC?</span>
<span class="cm"> * @rsv: the reservation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">uwb_rsv_is_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rsv</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">uwb_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * enum uwb_notifs - UWB events that can be passed to any listeners</span>
<span class="cm"> * @UWB_NOTIF_ONAIR: a new neighbour has joined the beacon group.</span>
<span class="cm"> * @UWB_NOTIF_OFFAIR: a neighbour has left the beacon group.</span>
<span class="cm"> *</span>
<span class="cm"> * Higher layers can register callback functions with the radio</span>
<span class="cm"> * controller using uwb_notifs_register(). The radio controller</span>
<span class="cm"> * maintains a list of all registered handlers and will notify all</span>
<span class="cm"> * nodes when an event occurs.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">uwb_notifs</span> <span class="p">{</span>
	<span class="n">UWB_NOTIF_ONAIR</span><span class="p">,</span>
	<span class="n">UWB_NOTIF_OFFAIR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Callback function registered with UWB */</span>
<span class="k">struct</span> <span class="n">uwb_notifs_handler</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cb</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">uwb_notifs</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">uwb_notifs_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_notifs_handler</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_notifs_deregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uwb_notifs_handler</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * UWB radio controller Event Size Entry (for creating entry tables)</span>
<span class="cm"> *</span>
<span class="cm"> * WUSB and WHCI define events and notifications, and they might have</span>
<span class="cm"> * fixed or variable size.</span>
<span class="cm"> *</span>
<span class="cm"> * Each event/notification has a size which is not necessarily known</span>
<span class="cm"> * in advance based on the event code. As well, vendor specific</span>
<span class="cm"> * events/notifications will have a size impossible to determine</span>
<span class="cm"> * unless we know about the device&#39;s specific details.</span>
<span class="cm"> *</span>
<span class="cm"> * It was way too smart of the spec writers not to think that it would</span>
<span class="cm"> * be impossible for a generic driver to skip over vendor specific</span>
<span class="cm"> * events/notifications if there are no LENGTH fields in the HEADER of</span>
<span class="cm"> * each message...the transaction size cannot be counted on as the</span>
<span class="cm"> * spec does not forbid to pack more than one event in a single</span>
<span class="cm"> * transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Thus, we guess sizes with tables (or for events, when you know the</span>
<span class="cm"> * size ahead of time you can use uwb_rc_neh_extra_size*()). We</span>
<span class="cm"> * register tables with the known events and their sizes, and then we</span>
<span class="cm"> * traverse those tables. For those with variable length, we provide a</span>
<span class="cm"> * way to lookup the size inside the event/notification&#39;s</span>
<span class="cm"> * payload. This allows device-specific event size tables to be</span>
<span class="cm"> * registered.</span>
<span class="cm"> *</span>
<span class="cm"> * @size:   Size of the payload</span>
<span class="cm"> *</span>
<span class="cm"> * @offset: if != 0, at offset @offset-1 starts a field with a length</span>
<span class="cm"> *          that has to be added to @size. The format of the field is</span>
<span class="cm"> *          given by @type.</span>
<span class="cm"> *</span>
<span class="cm"> * @type:   Type and length of the offset field. Most common is LE 16</span>
<span class="cm"> *          bits (that&#39;s why that is zero); others are there mostly to</span>
<span class="cm"> *          cover for bugs and weirdos.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uwb_est_entry</span> <span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">UWB_EST_16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UWB_EST_8</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">uwb_est_register</span><span class="p">(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">code_high</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">u16</span> <span class="n">product</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_est_entry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">entries</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_est_unregister</span><span class="p">(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">code_high</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">u16</span> <span class="n">product</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_est_entry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">entries</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">uwb_est_find_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_rceb</span> <span class="o">*</span><span class="n">rceb</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* -- Misc */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">EDC_MAX_ERRORS</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">EDC_ERROR_TIMEFRAME</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* error density counter */</span>
<span class="k">struct</span> <span class="n">edc</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timestart</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">errorcount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">edc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">edc</span> <span class="o">*</span><span class="n">edc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">edc</span><span class="o">-&gt;</span><span class="n">timestart</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called when an error occurred.</span>
<span class="cm"> * This is way to determine if the number of acceptable errors per time</span>
<span class="cm"> * period has been exceeded. It is not accurate as there are cases in which</span>
<span class="cm"> * this scheme will not work, for example if there are periodic occurrences</span>
<span class="cm"> * of errors that straddle updates to the start time. This scheme is</span>
<span class="cm"> * sufficient for our usage.</span>
<span class="cm"> *</span>
<span class="cm"> * @returns 1 if maximum acceptable errors per timeframe has been exceeded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">edc_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">edc</span> <span class="o">*</span><span class="n">err_hist</span><span class="p">,</span> <span class="n">u16</span> <span class="n">max_err</span><span class="p">,</span> <span class="n">u16</span> <span class="n">timeframe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">err_hist</span><span class="o">-&gt;</span><span class="n">timestart</span> <span class="o">&gt;</span> <span class="n">timeframe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_hist</span><span class="o">-&gt;</span><span class="n">errorcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err_hist</span><span class="o">-&gt;</span><span class="n">timestart</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">err_hist</span><span class="o">-&gt;</span><span class="n">errorcount</span> <span class="o">&gt;</span> <span class="n">max_err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err_hist</span><span class="o">-&gt;</span><span class="n">errorcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err_hist</span><span class="o">-&gt;</span><span class="n">timestart</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Information Element handling */</span>

<span class="k">struct</span> <span class="n">uwb_ie_hdr</span> <span class="o">*</span><span class="n">uwb_ie_next</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_rc_ie_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">uwb_ie_hdr</span> <span class="o">*</span><span class="n">ies</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">uwb_rc_ie_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">uwb_rc</span> <span class="o">*</span><span class="n">uwb_rc</span><span class="p">,</span> <span class="k">enum</span> <span class="n">uwb_ie</span> <span class="n">element_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Transmission statistics</span>
<span class="cm"> *</span>
<span class="cm"> * UWB uses LQI and RSSI (one byte values) for reporting radio signal</span>
<span class="cm"> * strength and line quality indication. We do quick and dirty</span>
<span class="cm"> * averages of those. They are signed values, btw.</span>
<span class="cm"> *</span>
<span class="cm"> * For 8 bit quantities, we keep the min, the max, an accumulator</span>
<span class="cm"> * (@sigma) and a # of samples. When @samples gets to 255, we compute</span>
<span class="cm"> * the average (@sigma / @samples), place it in @sigma and reset</span>
<span class="cm"> * @samples to 1 (so we use it as the first sample).</span>
<span class="cm"> *</span>
<span class="cm"> * Now, statistically speaking, probably I am kicking the kidneys of</span>
<span class="cm"> * some books I have in my shelves collecting dust, but I just want to</span>
<span class="cm"> * get an approx, not the Nobel.</span>
<span class="cm"> *</span>
<span class="cm"> * LOCKING: there is no locking per se, but we try to keep a lockless</span>
<span class="cm"> * schema. Only _add_samples() modifies the values--as long as you</span>
<span class="cm"> * have other locking on top that makes sure that no two calls of</span>
<span class="cm"> * _add_sample() happen at the same time, then we are fine. Now, for</span>
<span class="cm"> * resetting the values we just set @samples to 0 and that makes the</span>
<span class="cm"> * next _add_sample() to start with defaults. Reading the values in</span>
<span class="cm"> * _show() currently can race, so you need to make sure the calls are</span>
<span class="cm"> * under the same lock that protects calls to _add_sample(). FIXME:</span>
<span class="cm"> * currently unlocked (It is not ultraprecise but does the trick. Bite</span>
<span class="cm"> * me).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">stats</span> <span class="p">{</span>
	<span class="n">s8</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">sigma</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">samples</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">stats_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">samples</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">stats_add_sample</span><span class="p">(</span><span class="k">struct</span> <span class="n">stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="n">s8</span> <span class="n">sample</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s8</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">sigma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">samples</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* it was zero before, so we initialize */</span>
		<span class="n">min</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>
		<span class="n">max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="p">;</span>
		<span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span>
		<span class="n">sigma</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">sigma</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>	<span class="cm">/* compute new values */</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">sample</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sample</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">sample</span><span class="p">;</span>
	<span class="n">sigma</span> <span class="o">+=</span> <span class="n">sample</span><span class="p">;</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>	<span class="cm">/* commit */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* wrapped around! reset */</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">stats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">avg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">samples</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">max</span> <span class="o">=</span> <span class="n">avg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span>
		<span class="n">avg</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">sigma</span> <span class="o">/</span> <span class="n">samples</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">avg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">stats_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stats_init</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #ifndef __LINUX__UWB_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
