<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › sched.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sched.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_SCHED_H</span>
<span class="cp">#define _LINUX_SCHED_H</span>

<span class="cm">/*</span>
<span class="cm"> * cloning flags:</span>
<span class="cm"> */</span>
<span class="cp">#define CSIGNAL		0x000000ff	</span><span class="cm">/* signal mask to be sent at exit */</span><span class="cp"></span>
<span class="cp">#define CLONE_VM	0x00000100	</span><span class="cm">/* set if VM shared between processes */</span><span class="cp"></span>
<span class="cp">#define CLONE_FS	0x00000200	</span><span class="cm">/* set if fs info shared between processes */</span><span class="cp"></span>
<span class="cp">#define CLONE_FILES	0x00000400	</span><span class="cm">/* set if open files shared between processes */</span><span class="cp"></span>
<span class="cp">#define CLONE_SIGHAND	0x00000800	</span><span class="cm">/* set if signal handlers and blocked signals shared */</span><span class="cp"></span>
<span class="cp">#define CLONE_PTRACE	0x00002000	</span><span class="cm">/* set if we want to let tracing continue on the child too */</span><span class="cp"></span>
<span class="cp">#define CLONE_VFORK	0x00004000	</span><span class="cm">/* set if the parent wants the child to wake it up on mm_release */</span><span class="cp"></span>
<span class="cp">#define CLONE_PARENT	0x00008000	</span><span class="cm">/* set if we want to have the same parent as the cloner */</span><span class="cp"></span>
<span class="cp">#define CLONE_THREAD	0x00010000	</span><span class="cm">/* Same thread group? */</span><span class="cp"></span>
<span class="cp">#define CLONE_NEWNS	0x00020000	</span><span class="cm">/* New namespace group? */</span><span class="cp"></span>
<span class="cp">#define CLONE_SYSVSEM	0x00040000	</span><span class="cm">/* share system V SEM_UNDO semantics */</span><span class="cp"></span>
<span class="cp">#define CLONE_SETTLS	0x00080000	</span><span class="cm">/* create a new TLS for the child */</span><span class="cp"></span>
<span class="cp">#define CLONE_PARENT_SETTID	0x00100000	</span><span class="cm">/* set the TID in the parent */</span><span class="cp"></span>
<span class="cp">#define CLONE_CHILD_CLEARTID	0x00200000	</span><span class="cm">/* clear the TID in the child */</span><span class="cp"></span>
<span class="cp">#define CLONE_DETACHED		0x00400000	</span><span class="cm">/* Unused, ignored */</span><span class="cp"></span>
<span class="cp">#define CLONE_UNTRACED		0x00800000	</span><span class="cm">/* set if the tracing process can&#39;t force CLONE_PTRACE on this clone */</span><span class="cp"></span>
<span class="cp">#define CLONE_CHILD_SETTID	0x01000000	</span><span class="cm">/* set the TID in the child */</span><span class="cp"></span>
<span class="cm">/* 0x02000000 was previously the unused CLONE_STOPPED (Start in stopped state)</span>
<span class="cm">   and is now available for re-use. */</span>
<span class="cp">#define CLONE_NEWUTS		0x04000000	</span><span class="cm">/* New utsname group? */</span><span class="cp"></span>
<span class="cp">#define CLONE_NEWIPC		0x08000000	</span><span class="cm">/* New ipcs */</span><span class="cp"></span>
<span class="cp">#define CLONE_NEWUSER		0x10000000	</span><span class="cm">/* New user namespace */</span><span class="cp"></span>
<span class="cp">#define CLONE_NEWPID		0x20000000	</span><span class="cm">/* New pid namespace */</span><span class="cp"></span>
<span class="cp">#define CLONE_NEWNET		0x40000000	</span><span class="cm">/* New network namespace */</span><span class="cp"></span>
<span class="cp">#define CLONE_IO		0x80000000	</span><span class="cm">/* Clone io context */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Scheduling policies</span>
<span class="cm"> */</span>
<span class="cp">#define SCHED_NORMAL		0</span>
<span class="cp">#define SCHED_FIFO		1</span>
<span class="cp">#define SCHED_RR		2</span>
<span class="cp">#define SCHED_BATCH		3</span>
<span class="cm">/* SCHED_ISO: reserved but not implemented yet */</span>
<span class="cp">#define SCHED_IDLE		5</span>
<span class="cm">/* Can be ORed in to make sure the process is reverted back to SCHED_NORMAL on fork */</span>
<span class="cp">#define SCHED_RESET_ON_FORK     0x40000000</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="k">struct</span> <span class="n">sched_param</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">sched_priority</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include &lt;asm/param.h&gt;	</span><span class="cm">/* for HZ */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/mm_types.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>
<span class="cp">#include &lt;asm/cputime.h&gt;</span>

<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/sem.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/pid.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/topology.h&gt;</span>
<span class="cp">#include &lt;linux/proportions.h&gt;</span>
<span class="cp">#include &lt;linux/seccomp.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/rtmutex.h&gt;</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/resource.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting.h&gt;</span>
<span class="cp">#include &lt;linux/latencytop.h&gt;</span>
<span class="cp">#include &lt;linux/cred.h&gt;</span>
<span class="cp">#include &lt;linux/llist.h&gt;</span>
<span class="cp">#include &lt;linux/uidgid.h&gt;</span>

<span class="cp">#include &lt;asm/processor.h&gt;</span>

<span class="k">struct</span> <span class="n">exec_domain</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">futex_pi_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">robust_list_head</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">bio_list</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fs_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">perf_event_context</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">blk_plug</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * List of flags we want to share for kernel threads,</span>
<span class="cm"> * if only because they are not used by them anyway.</span>
<span class="cm"> */</span>
<span class="cp">#define CLONE_KERNEL	(CLONE_FS | CLONE_FILES | CLONE_SIGHAND)</span>

<span class="cm">/*</span>
<span class="cm"> * These are the constant used to fake the fixed-point load-average</span>
<span class="cm"> * counting. Some notes:</span>
<span class="cm"> *  - 11 bit fractions expand to 22 bits by the multiplies: this gives</span>
<span class="cm"> *    a load-average precision of 10 bits integer + 11 bits fractional</span>
<span class="cm"> *  - if you want to count load-averages more often, you need more</span>
<span class="cm"> *    precision, or rounding will get you. With 2-second counting freq,</span>
<span class="cm"> *    the EXP_n values would be 1981, 2034 and 2043 if still using only</span>
<span class="cm"> *    11 bit fractions.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avenrun</span><span class="p">[];</span>		<span class="cm">/* Load averages */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">get_avenrun</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">loads</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">);</span>

<span class="cp">#define FSHIFT		11		</span><span class="cm">/* nr of bits of precision */</span><span class="cp"></span>
<span class="cp">#define FIXED_1		(1&lt;&lt;FSHIFT)	</span><span class="cm">/* 1.0 as fixed-point */</span><span class="cp"></span>
<span class="cp">#define LOAD_FREQ	(5*HZ+1)	</span><span class="cm">/* 5 sec intervals */</span><span class="cp"></span>
<span class="cp">#define EXP_1		1884		</span><span class="cm">/* 1/exp(5sec/1min) as fixed-point */</span><span class="cp"></span>
<span class="cp">#define EXP_5		2014		</span><span class="cm">/* 1/exp(5sec/5min) */</span><span class="cp"></span>
<span class="cp">#define EXP_15		2037		</span><span class="cm">/* 1/exp(5sec/15min) */</span><span class="cp"></span>

<span class="cp">#define CALC_LOAD(load,exp,n) \</span>
<span class="cp">	load *= exp; \</span>
<span class="cp">	load += n*(FIXED_1-exp); \</span>
<span class="cp">	load &gt;&gt;= FSHIFT;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_forks</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nr_threads</span><span class="p">;</span>
<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">process_counts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nr_processes</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_uninterruptible</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_iowait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_iowait_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_cpu_load</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="k">extern</span> <span class="kt">void</span> <span class="n">calc_global_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">update_cpu_load_nohz</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_parent_ip</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">seq_file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cfs_rq</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">task_group</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">proc_sched_show_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">proc_sched_set_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>
<span class="n">print_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">proc_sched_show_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">proc_sched_set_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">print_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Task state bitmask. NOTE! These bits are also</span>
<span class="cm"> * encoded in fs/proc/array.c: get_task_state().</span>
<span class="cm"> *</span>
<span class="cm"> * We have two separate sets of flags: task-&gt;state</span>
<span class="cm"> * is about runnability, while task-&gt;exit_state are</span>
<span class="cm"> * about the task exiting. Confusing, but this way</span>
<span class="cm"> * modifying one set can&#39;t modify the other one by</span>
<span class="cm"> * mistake.</span>
<span class="cm"> */</span>
<span class="cp">#define TASK_RUNNING		0</span>
<span class="cp">#define TASK_INTERRUPTIBLE	1</span>
<span class="cp">#define TASK_UNINTERRUPTIBLE	2</span>
<span class="cp">#define __TASK_STOPPED		4</span>
<span class="cp">#define __TASK_TRACED		8</span>
<span class="cm">/* in tsk-&gt;exit_state */</span>
<span class="cp">#define EXIT_ZOMBIE		16</span>
<span class="cp">#define EXIT_DEAD		32</span>
<span class="cm">/* in tsk-&gt;state again */</span>
<span class="cp">#define TASK_DEAD		64</span>
<span class="cp">#define TASK_WAKEKILL		128</span>
<span class="cp">#define TASK_WAKING		256</span>
<span class="cp">#define TASK_STATE_MAX		512</span>

<span class="cp">#define TASK_STATE_TO_CHAR_STR &quot;RSDTtZXxKW&quot;</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="n">___assert_task_state</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*!!</span><span class="p">(</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">TASK_STATE_TO_CHAR_STR</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">TASK_STATE_MAX</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)];</span>

<span class="cm">/* Convenience macros for the sake of set_task_state */</span>
<span class="cp">#define TASK_KILLABLE		(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span>
<span class="cp">#define TASK_STOPPED		(TASK_WAKEKILL | __TASK_STOPPED)</span>
<span class="cp">#define TASK_TRACED		(TASK_WAKEKILL | __TASK_TRACED)</span>

<span class="cm">/* Convenience macros for the sake of wake_up */</span>
<span class="cp">#define TASK_NORMAL		(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span>
<span class="cp">#define TASK_ALL		(TASK_NORMAL | __TASK_STOPPED | __TASK_TRACED)</span>

<span class="cm">/* get_task_state() */</span>
<span class="cp">#define TASK_REPORT		(TASK_RUNNING | TASK_INTERRUPTIBLE | \</span>
<span class="cp">				 TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span>
<span class="cp">				 __TASK_TRACED)</span>

<span class="cp">#define task_is_traced(task)	((task-&gt;state &amp; __TASK_TRACED) != 0)</span>
<span class="cp">#define task_is_stopped(task)	((task-&gt;state &amp; __TASK_STOPPED) != 0)</span>
<span class="cp">#define task_is_dead(task)	((task)-&gt;exit_state != 0)</span>
<span class="cp">#define task_is_stopped_or_traced(task)	\</span>
<span class="cp">			((task-&gt;state &amp; (__TASK_STOPPED | __TASK_TRACED)) != 0)</span>
<span class="cp">#define task_contributes_to_load(task)	\</span>
<span class="cp">				((task-&gt;state &amp; TASK_UNINTERRUPTIBLE) != 0 &amp;&amp; \</span>
<span class="cp">				 (task-&gt;flags &amp; PF_FROZEN) == 0)</span>

<span class="cp">#define __set_task_state(tsk, state_value)		\</span>
<span class="cp">	do { (tsk)-&gt;state = (state_value); } while (0)</span>
<span class="cp">#define set_task_state(tsk, state_value)		\</span>
<span class="cp">	set_mb((tsk)-&gt;state, (state_value))</span>

<span class="cm">/*</span>
<span class="cm"> * set_current_state() includes a barrier so that the write of current-&gt;state</span>
<span class="cm"> * is correctly serialised wrt the caller&#39;s subsequent test of whether to</span>
<span class="cm"> * actually sleep:</span>
<span class="cm"> *</span>
<span class="cm"> *	set_current_state(TASK_UNINTERRUPTIBLE);</span>
<span class="cm"> *	if (do_i_need_to_sleep())</span>
<span class="cm"> *		schedule();</span>
<span class="cm"> *</span>
<span class="cm"> * If the caller does not need such serialisation then use __set_current_state()</span>
<span class="cm"> */</span>
<span class="cp">#define __set_current_state(state_value)			\</span>
<span class="cp">	do { current-&gt;state = (state_value); } while (0)</span>
<span class="cp">#define set_current_state(state_value)		\</span>
<span class="cp">	set_mb(current-&gt;state, (state_value))</span>

<span class="cm">/* Task command name length */</span>
<span class="cp">#define TASK_COMM_LEN 16</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This serializes &quot;schedule()&quot; and also protects</span>
<span class="cm"> * the run-queue from deletions/modifications (but</span>
<span class="cm"> * _adding_ to the beginning of the run-queue has</span>
<span class="cm"> * a separate lock).</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">rwlock_t</span> <span class="n">tasklist_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">mmlist_lock</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROVE_RCU</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lockdep_tasklist_lock_is_held</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_PROVE_RCU */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_init_smp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">schedule_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_idle_bootup_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">runqueue_is_locked</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_NO_HZ)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">select_nohz_load_balancer</span><span class="p">(</span><span class="kt">int</span> <span class="n">stop_tick</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_cpu_sd_state_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_nohz_timer_target</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">select_nohz_load_balancer</span><span class="p">(</span><span class="kt">int</span> <span class="n">stop_tick</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_cpu_sd_state_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Only dump TASK_* tasks. (0 for all tasks)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">show_state_filter</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state_filter</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">show_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">show_state_filter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">show_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * TASK is a pointer to the task whose backtrace we want to see (or NULL for current</span>
<span class="cm"> * task), SP is the stack pointer of the first frame that should be shown in the back</span>
<span class="cm"> * trace (or NULL if the entire call-chain of the task should be shown).</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">show_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">io_schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">io_schedule_timeout</span><span class="p">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">cpu_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">update_process_times</span><span class="p">(</span><span class="kt">int</span> <span class="n">user</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">scheduler_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_show_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_LOCKUP_DETECTOR</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">touch_softlockup_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">touch_softlockup_watchdog_sync</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">touch_all_softlockup_watchdogs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">proc_dowatchdog_thresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">softlockup_panic</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">lockup_detector_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">touch_softlockup_watchdog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">touch_softlockup_watchdog_sync</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">touch_all_softlockup_watchdogs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lockup_detector_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DETECT_HUNG_TASK</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">sysctl_hung_task_panic</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysctl_hung_task_check_count</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysctl_hung_task_timeout_secs</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysctl_hung_task_warnings</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">proc_dohung_task_timeout_secs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cm">/* Avoid need for ifdefs elsewhere in the code */</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">sysctl_hung_task_timeout_secs</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* Attach to any functions which should be ignored in wchan output. */</span>
<span class="cp">#define __sched		__attribute__((__section__(&quot;.sched.text&quot;)))</span>

<span class="cm">/* Linker adds these: start and end of __sched functions */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">__sched_text_start</span><span class="p">[],</span> <span class="n">__sched_text_end</span><span class="p">[];</span>

<span class="cm">/* Is this address in the __sched functions? */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">in_sched_functions</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="cp">#define	MAX_SCHEDULE_TIMEOUT	LONG_MAX</span>
<span class="k">extern</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">schedule_timeout_killable</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">schedule_preempt_disabled</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mutex_spin_on_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">owner</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nsproxy</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">user_namespace</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Default maximum number of active map areas, this limits the number of vmas</span>
<span class="cm"> * per mm struct. Users can overwrite this number by sysctl but there is a</span>
<span class="cm"> * problem.</span>
<span class="cm"> *</span>
<span class="cm"> * When a program&#39;s coredump is generated as ELF format, a section is created</span>
<span class="cm"> * per a vma. In ELF, the number of sections is represented in unsigned short.</span>
<span class="cm"> * This means the number of sections should be smaller than 65535 at coredump.</span>
<span class="cm"> * Because the kernel adds some informative sections to a image of program at</span>
<span class="cm"> * generating coredump, we need some margin. The number of extra sections is</span>
<span class="cm"> * 1-3 now and depends on arch. We use &quot;5&quot; as safe margin, here.</span>
<span class="cm"> */</span>
<span class="cp">#define MAPCOUNT_ELF_CORE_MARGIN	(5)</span>
<span class="cp">#define DEFAULT_MAX_MAP_COUNT	(USHRT_MAX - MAPCOUNT_ELF_CORE_MARGIN)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_max_map_count</span><span class="p">;</span>

<span class="cp">#include &lt;linux/aio.h&gt;</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">arch_pick_mmap_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">arch_get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">arch_get_unmapped_area_topdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">arch_unmap_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">arch_unmap_area_topdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">arch_pick_mmap_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>


<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_dumpable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_dumpable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>

<span class="cm">/* mm flags */</span>
<span class="cm">/* dumpable bits */</span>
<span class="cp">#define MMF_DUMPABLE      0  </span><span class="cm">/* core dump is permitted */</span><span class="cp"></span>
<span class="cp">#define MMF_DUMP_SECURELY 1  </span><span class="cm">/* core file is readable only by root */</span><span class="cp"></span>

<span class="cp">#define MMF_DUMPABLE_BITS 2</span>
<span class="cp">#define MMF_DUMPABLE_MASK ((1 &lt;&lt; MMF_DUMPABLE_BITS) - 1)</span>

<span class="cm">/* coredump filter bits */</span>
<span class="cp">#define MMF_DUMP_ANON_PRIVATE	2</span>
<span class="cp">#define MMF_DUMP_ANON_SHARED	3</span>
<span class="cp">#define MMF_DUMP_MAPPED_PRIVATE	4</span>
<span class="cp">#define MMF_DUMP_MAPPED_SHARED	5</span>
<span class="cp">#define MMF_DUMP_ELF_HEADERS	6</span>
<span class="cp">#define MMF_DUMP_HUGETLB_PRIVATE 7</span>
<span class="cp">#define MMF_DUMP_HUGETLB_SHARED  8</span>

<span class="cp">#define MMF_DUMP_FILTER_SHIFT	MMF_DUMPABLE_BITS</span>
<span class="cp">#define MMF_DUMP_FILTER_BITS	7</span>
<span class="cp">#define MMF_DUMP_FILTER_MASK \</span>
<span class="cp">	(((1 &lt;&lt; MMF_DUMP_FILTER_BITS) - 1) &lt;&lt; MMF_DUMP_FILTER_SHIFT)</span>
<span class="cp">#define MMF_DUMP_FILTER_DEFAULT \</span>
<span class="cp">	((1 &lt;&lt; MMF_DUMP_ANON_PRIVATE) |	(1 &lt;&lt; MMF_DUMP_ANON_SHARED) |\</span>
<span class="cp">	 (1 &lt;&lt; MMF_DUMP_HUGETLB_PRIVATE) | MMF_DUMP_MASK_DEFAULT_ELF)</span>

<span class="cp">#ifdef CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS</span>
<span class="cp"># define MMF_DUMP_MASK_DEFAULT_ELF	(1 &lt;&lt; MMF_DUMP_ELF_HEADERS)</span>
<span class="cp">#else</span>
<span class="cp"># define MMF_DUMP_MASK_DEFAULT_ELF	0</span>
<span class="cp">#endif</span>
					<span class="cm">/* leave room for more dump flags */</span>
<span class="cp">#define MMF_VM_MERGEABLE	16	</span><span class="cm">/* KSM may merge identical pages */</span><span class="cp"></span>
<span class="cp">#define MMF_VM_HUGEPAGE		17	</span><span class="cm">/* set when VM_HUGEPAGE is set on vma */</span><span class="cp"></span>
<span class="cp">#define MMF_EXE_FILE_CHANGED	18	</span><span class="cm">/* see prctl_set_mm_exe_file() */</span><span class="cp"></span>

<span class="cp">#define MMF_INIT_MASK		(MMF_DUMPABLE_MASK | MMF_DUMP_FILTER_MASK)</span>

<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">k_sigaction</span>	<span class="n">action</span><span class="p">[</span><span class="n">_NSIG</span><span class="p">];</span>
	<span class="n">spinlock_t</span>		<span class="n">siglock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">signalfd_wqh</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pacct_struct</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">ac_flag</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">ac_exitcode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ac_mem</span><span class="p">;</span>
	<span class="n">cputime_t</span>		<span class="n">ac_utime</span><span class="p">,</span> <span class="n">ac_stime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ac_minflt</span><span class="p">,</span> <span class="n">ac_majflt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cpu_itimer</span> <span class="p">{</span>
	<span class="n">cputime_t</span> <span class="n">expires</span><span class="p">;</span>
	<span class="n">cputime_t</span> <span class="n">incr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">incr_error</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct task_cputime - collected CPU time counts</span>
<span class="cm"> * @utime:		time spent in user mode, in &amp;cputime_t units</span>
<span class="cm"> * @stime:		time spent in kernel mode, in &amp;cputime_t units</span>
<span class="cm"> * @sum_exec_runtime:	total time spent on the CPU, in nanoseconds</span>
<span class="cm"> *</span>
<span class="cm"> * This structure groups together three kinds of CPU time that are</span>
<span class="cm"> * tracked for threads and thread groups.  Most things considering</span>
<span class="cm"> * CPU time want to group these counts together and treat all three</span>
<span class="cm"> * of them in parallel.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_cputime</span> <span class="p">{</span>
	<span class="n">cputime_t</span> <span class="n">utime</span><span class="p">;</span>
	<span class="n">cputime_t</span> <span class="n">stime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/* Alternate field names when used to cache expirations. */</span>
<span class="cp">#define prof_exp	stime</span>
<span class="cp">#define virt_exp	utime</span>
<span class="cp">#define sched_exp	sum_exec_runtime</span>

<span class="cp">#define INIT_CPUTIME	\</span>
<span class="cp">	(struct task_cputime) {					\</span>
<span class="cp">		.utime = 0,					\</span>
<span class="cp">		.stime = 0,					\</span>
<span class="cp">		.sum_exec_runtime = 0,				\</span>
<span class="cp">	}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable preemption until the scheduler is running.</span>
<span class="cm"> * Reset by start_kernel()-&gt;sched_init()-&gt;init_idle().</span>
<span class="cm"> *</span>
<span class="cm"> * We include PREEMPT_ACTIVE to avoid cond_resched() from working</span>
<span class="cm"> * before the scheduler is active -- see should_resched().</span>
<span class="cm"> */</span>
<span class="cp">#define INIT_PREEMPT_COUNT	(1 + PREEMPT_ACTIVE)</span>

<span class="cm">/**</span>
<span class="cm"> * struct thread_group_cputimer - thread group interval timer counts</span>
<span class="cm"> * @cputime:		thread group interval timers.</span>
<span class="cm"> * @running:		non-zero when there are timers running and</span>
<span class="cm"> * 			@cputime receives updates.</span>
<span class="cm"> * @lock:		lock for fields in this struct.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure contains the version of task_cputime, above, that is</span>
<span class="cm"> * used for thread group CPU timer calculations.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">thread_group_cputimer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">running</span><span class="p">;</span>
	<span class="n">raw_spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="k">struct</span> <span class="n">autogroup</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE! &quot;signal_struct&quot; does not have its own</span>
<span class="cm"> * locking, because a shared signal_struct always</span>
<span class="cm"> * implies a shared sighand_struct, so locking</span>
<span class="cm"> * sighand_struct is always a proper superset of</span>
<span class="cm"> * the locking of signal_struct.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">signal_struct</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">sigcnt</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">live</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nr_threads</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span>	<span class="n">wait_chldexit</span><span class="p">;</span>	<span class="cm">/* for wait4() */</span>

	<span class="cm">/* current thread group signal load-balancing target: */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">curr_target</span><span class="p">;</span>

	<span class="cm">/* shared signal handling: */</span>
	<span class="k">struct</span> <span class="n">sigpending</span>	<span class="n">shared_pending</span><span class="p">;</span>

	<span class="cm">/* thread group exit support */</span>
	<span class="kt">int</span>			<span class="n">group_exit_code</span><span class="p">;</span>
	<span class="cm">/* overloaded:</span>
<span class="cm">	 * - notify group_exit_task when -&gt;count is equal to notify_count</span>
<span class="cm">	 * - everyone except group_exit_task is stopped during signal delivery</span>
<span class="cm">	 *   of fatal signals, group_exit_task processes the signal.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">notify_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">group_exit_task</span><span class="p">;</span>

	<span class="cm">/* thread group stop support, overloads group_exit_code too */</span>
	<span class="kt">int</span>			<span class="n">group_stop_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span> <span class="cm">/* see SIGNAL_* flags below */</span>

	<span class="cm">/*</span>
<span class="cm">	 * PR_SET_CHILD_SUBREAPER marks a process, like a service</span>
<span class="cm">	 * manager, to re-parent orphan (double-forking) child processes</span>
<span class="cm">	 * to this process instead of &#39;init&#39;. The service manager is</span>
<span class="cm">	 * able to receive SIGCHLD signals and is able to investigate</span>
<span class="cm">	 * the process until it calls wait(). All children of this</span>
<span class="cm">	 * process will inherit a flag if they should look for a</span>
<span class="cm">	 * child_subreaper process at exit.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">is_child_subreaper</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">has_child_subreaper</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* POSIX.1b Interval Timers */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">posix_timers</span><span class="p">;</span>

	<span class="cm">/* ITIMER_REAL timer for the process */</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">real_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">leader_pid</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">it_real_incr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ITIMER_PROF and ITIMER_VIRTUAL timers for the process, we use</span>
<span class="cm">	 * CPUCLOCK_PROF and CPUCLOCK_VIRT for indexing array as these</span>
<span class="cm">	 * values are defined to 0 and 1 respectively</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">cpu_itimer</span> <span class="n">it</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Thread group totals for process CPU timers.</span>
<span class="cm">	 * See thread_group_cputimer(), et al, for details.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">thread_group_cputimer</span> <span class="n">cputimer</span><span class="p">;</span>

	<span class="cm">/* Earliest-expiration cache. */</span>
	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime_expires</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cpu_timers</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">tty_old_pgrp</span><span class="p">;</span>

	<span class="cm">/* boolean value for session group leader */</span>
	<span class="kt">int</span> <span class="n">leader</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span> <span class="cm">/* NULL if no tty */</span>

<span class="cp">#ifdef CONFIG_SCHED_AUTOGROUP</span>
	<span class="k">struct</span> <span class="n">autogroup</span> <span class="o">*</span><span class="n">autogroup</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Cumulative resource counters for dead threads in the group,</span>
<span class="cm">	 * and for reaped dead child processes forked by this group.</span>
<span class="cm">	 * Live threads maintain their own counters and add to these</span>
<span class="cm">	 * in __exit_signal, except for the group leader.</span>
<span class="cm">	 */</span>
	<span class="n">cputime_t</span> <span class="n">utime</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">cutime</span><span class="p">,</span> <span class="n">cstime</span><span class="p">;</span>
	<span class="n">cputime_t</span> <span class="n">gtime</span><span class="p">;</span>
	<span class="n">cputime_t</span> <span class="n">cgtime</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_VIRT_CPU_ACCOUNTING</span>
	<span class="n">cputime_t</span> <span class="n">prev_utime</span><span class="p">,</span> <span class="n">prev_stime</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nvcsw</span><span class="p">,</span> <span class="n">nivcsw</span><span class="p">,</span> <span class="n">cnvcsw</span><span class="p">,</span> <span class="n">cnivcsw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_flt</span><span class="p">,</span> <span class="n">maj_flt</span><span class="p">,</span> <span class="n">cmin_flt</span><span class="p">,</span> <span class="n">cmaj_flt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inblock</span><span class="p">,</span> <span class="n">oublock</span><span class="p">,</span> <span class="n">cinblock</span><span class="p">,</span> <span class="n">coublock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxrss</span><span class="p">,</span> <span class="n">cmaxrss</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_io_accounting</span> <span class="n">ioac</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cumulative ns of schedule CPU time fo dead threads in the</span>
<span class="cm">	 * group, not including a zombie group leader, (This only differs</span>
<span class="cm">	 * from jiffies_to_ns(utime + stime) if sched_clock uses something</span>
<span class="cm">	 * other than jiffies.)</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum_sched_runtime</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t bother to synchronize most readers of this at all,</span>
<span class="cm">	 * because there is no reader checking a limit that actually needs</span>
<span class="cm">	 * to get both rlim_cur and rlim_max atomically, and either one</span>
<span class="cm">	 * alone is a single word that can safely be read normally.</span>
<span class="cm">	 * getrlimit/setrlimit use task_lock(current-&gt;group_leader) to</span>
<span class="cm">	 * protect this instead of the siglock, because they really</span>
<span class="cm">	 * have no need to disable irqs.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rlimit</span> <span class="n">rlim</span><span class="p">[</span><span class="n">RLIM_NLIMITS</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_BSD_PROCESS_ACCT</span>
	<span class="k">struct</span> <span class="n">pacct_struct</span> <span class="n">pacct</span><span class="p">;</span>	<span class="cm">/* per-process accounting information */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TASKSTATS</span>
	<span class="k">struct</span> <span class="n">taskstats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="kt">unsigned</span> <span class="n">audit_tty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_audit_buf</span> <span class="o">*</span><span class="n">tty_audit_buf</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CGROUPS</span>
	<span class="cm">/*</span>
<span class="cm">	 * group_rwsem prevents new tasks from entering the threadgroup and</span>
<span class="cm">	 * member tasks from exiting,a more specifically, setting of</span>
<span class="cm">	 * PF_EXITING.  fork and exit paths are protected with this rwsem</span>
<span class="cm">	 * using threadgroup_change_begin/end().  Users which require</span>
<span class="cm">	 * threadgroup to remain stable should use threadgroup_[un]lock()</span>
<span class="cm">	 * which also takes care of exec path.  Currently, cgroup is the</span>
<span class="cm">	 * only user.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">group_rwsem</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">int</span> <span class="n">oom_adj</span><span class="p">;</span>		<span class="cm">/* OOM kill score adjustment (bit shift) */</span>
	<span class="kt">int</span> <span class="n">oom_score_adj</span><span class="p">;</span>	<span class="cm">/* OOM kill score adjustment */</span>
	<span class="kt">int</span> <span class="n">oom_score_adj_min</span><span class="p">;</span>	<span class="cm">/* OOM kill score adjustment minimum value.</span>
<span class="cm">				 * Only settable by CAP_SYS_RESOURCE. */</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">cred_guard_mutex</span><span class="p">;</span>	<span class="cm">/* guard against foreign influences on</span>
<span class="cm">					 * credential calculations</span>
<span class="cm">					 * (notably. ptrace) */</span>
<span class="p">};</span>

<span class="cm">/* Context switch must be unlocked if interrupts are to be enabled */</span>
<span class="cp">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span>
<span class="cp"># define __ARCH_WANT_UNLOCKED_CTXSW</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Bits in flags field of signal_struct.</span>
<span class="cm"> */</span>
<span class="cp">#define SIGNAL_STOP_STOPPED	0x00000001 </span><span class="cm">/* job control stop in effect */</span><span class="cp"></span>
<span class="cp">#define SIGNAL_STOP_CONTINUED	0x00000002 </span><span class="cm">/* SIGCONT since WCONTINUED reap */</span><span class="cp"></span>
<span class="cp">#define SIGNAL_GROUP_EXIT	0x00000004 </span><span class="cm">/* group exit in progress */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * Pending notifications to parent.</span>
<span class="cm"> */</span>
<span class="cp">#define SIGNAL_CLD_STOPPED	0x00000010</span>
<span class="cp">#define SIGNAL_CLD_CONTINUED	0x00000020</span>
<span class="cp">#define SIGNAL_CLD_MASK		(SIGNAL_CLD_STOPPED|SIGNAL_CLD_CONTINUED)</span>

<span class="cp">#define SIGNAL_UNKILLABLE	0x00000040 </span><span class="cm">/* for init: ignore fatal signals */</span><span class="cp"></span>

<span class="cm">/* If true, all threads except -&gt;group_exit_task have pending SIGKILL */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">signal_group_exit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SIGNAL_GROUP_EXIT</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_exit_task</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some day this will be a full-fledged user tracking system..</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">user_struct</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">__count</span><span class="p">;</span>	<span class="cm">/* reference count */</span>
	<span class="n">atomic_t</span> <span class="n">processes</span><span class="p">;</span>	<span class="cm">/* How many processes does this user have? */</span>
	<span class="n">atomic_t</span> <span class="n">files</span><span class="p">;</span>		<span class="cm">/* How many open files does this user have? */</span>
	<span class="n">atomic_t</span> <span class="n">sigpending</span><span class="p">;</span>	<span class="cm">/* How many pending signals does this user have? */</span>
<span class="cp">#ifdef CONFIG_INOTIFY_USER</span>
	<span class="n">atomic_t</span> <span class="n">inotify_watches</span><span class="p">;</span> <span class="cm">/* How many inotify watches does this user have? */</span>
	<span class="n">atomic_t</span> <span class="n">inotify_devs</span><span class="p">;</span>	<span class="cm">/* How many inotify devs does this user have opened? */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FANOTIFY</span>
	<span class="n">atomic_t</span> <span class="n">fanotify_listeners</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_EPOLL</span>
	<span class="n">atomic_long_t</span> <span class="n">epoll_watches</span><span class="p">;</span> <span class="cm">/* The number of file descriptors currently watched */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_POSIX_MQUEUE</span>
	<span class="cm">/* protected by mq_lock	*/</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mq_bytes</span><span class="p">;</span>	<span class="cm">/* How many bytes can be allocated to mqueue? */</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locked_shm</span><span class="p">;</span> <span class="cm">/* How many pages of mlocked shm ? */</span>

<span class="cp">#ifdef CONFIG_KEYS</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">uid_keyring</span><span class="p">;</span>	<span class="cm">/* UID specific keyring */</span>
	<span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">session_keyring</span><span class="p">;</span>	<span class="cm">/* UID&#39;s default session keyring */</span>
<span class="cp">#endif</span>

	<span class="cm">/* Hash table maintenance information */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">uidhash_node</span><span class="p">;</span>
	<span class="n">kuid_t</span> <span class="n">uid</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PERF_EVENTS</span>
	<span class="n">atomic_long_t</span> <span class="n">locked_vm</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">uids_sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">find_user</span><span class="p">(</span><span class="n">kuid_t</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">user_struct</span> <span class="n">root_user</span><span class="p">;</span>
<span class="cp">#define INIT_USER (&amp;root_user)</span>


<span class="k">struct</span> <span class="n">backing_dev_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">reclaim_state</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span>
<span class="k">struct</span> <span class="n">sched_info</span> <span class="p">{</span>
	<span class="cm">/* cumulative counters */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pcount</span><span class="p">;</span>	      <span class="cm">/* # of times run on this cpu */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">run_delay</span><span class="p">;</span> <span class="cm">/* time spent waiting on a runqueue */</span>

	<span class="cm">/* timestamps */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">last_arrival</span><span class="p">,</span><span class="cm">/* when we last ran on a cpu */</span>
			   <span class="n">last_queued</span><span class="p">;</span>	<span class="cm">/* when we were last queued to run */</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_TASK_DELAY_ACCT</span>
<span class="k">struct</span> <span class="n">task_delay_info</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">flags</span><span class="p">;</span>	<span class="cm">/* Private per-task flags */</span>

	<span class="cm">/* For each stat XXX, add following, aligned appropriately</span>
<span class="cm">	 *</span>
<span class="cm">	 * struct timespec XXX_start, XXX_end;</span>
<span class="cm">	 * u64 XXX_delay;</span>
<span class="cm">	 * u32 XXX_count;</span>
<span class="cm">	 *</span>
<span class="cm">	 * Atomicity of updates to XXX_delay, XXX_count protected by</span>
<span class="cm">	 * single lock above (split into XXX_lock if contention is an issue).</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX_count is incremented on every XXX operation, the delay</span>
<span class="cm">	 * associated with the operation is added to XXX_delay.</span>
<span class="cm">	 * XXX_delay contains the accumulated delay time in nanoseconds.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">blkio_start</span><span class="p">,</span> <span class="n">blkio_end</span><span class="p">;</span>	<span class="cm">/* Shared by blkio, swapin */</span>
	<span class="n">u64</span> <span class="n">blkio_delay</span><span class="p">;</span>	<span class="cm">/* wait for sync block io completion */</span>
	<span class="n">u64</span> <span class="n">swapin_delay</span><span class="p">;</span>	<span class="cm">/* wait for swapin block io completion */</span>
	<span class="n">u32</span> <span class="n">blkio_count</span><span class="p">;</span>	<span class="cm">/* total count of the number of sync block */</span>
				<span class="cm">/* io operations performed */</span>
	<span class="n">u32</span> <span class="n">swapin_count</span><span class="p">;</span>	<span class="cm">/* total count of the number of swapin block */</span>
				<span class="cm">/* io operations performed */</span>

	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">freepages_start</span><span class="p">,</span> <span class="n">freepages_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">freepages_delay</span><span class="p">;</span>	<span class="cm">/* wait for memory reclaim */</span>
	<span class="n">u32</span> <span class="n">freepages_count</span><span class="p">;</span>	<span class="cm">/* total count of memory reclaim */</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_TASK_DELAY_ACCT */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sched_info_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#elif defined(CONFIG_TASK_DELAY_ACCT)</span>
	<span class="k">extern</span> <span class="kt">int</span> <span class="n">delayacct_on</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">delayacct_on</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="p">{</span>
	<span class="n">CPU_IDLE</span><span class="p">,</span>
	<span class="n">CPU_NOT_IDLE</span><span class="p">,</span>
	<span class="n">CPU_NEWLY_IDLE</span><span class="p">,</span>
	<span class="n">CPU_MAX_IDLE_TYPES</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Increase resolution of nice-level calculations for 64-bit architectures.</span>
<span class="cm"> * The extra resolution improves shares distribution and load balancing of</span>
<span class="cm"> * low-weight task groups (eg. nice +19 on an autogroup), deeper taskgroup</span>
<span class="cm"> * hierarchies, especially on larger systems. This is not a user-visible change</span>
<span class="cm"> * and does not change the user-interface for setting shares/weights.</span>
<span class="cm"> *</span>
<span class="cm"> * We increase resolution only if we have enough bits to allow this increased</span>
<span class="cm"> * resolution (i.e. BITS_PER_LONG &gt; 32). The costs for increasing resolution</span>
<span class="cm"> * when BITS_PER_LONG &lt;= 32 are pretty high and the returns do not justify the</span>
<span class="cm"> * increased costs.</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"> /* BITS_PER_LONG &gt; 32 -- currently broken: it increases power usage under light load  */</span>
<span class="c"># define SCHED_LOAD_RESOLUTION	10</span>
<span class="c"># define scale_load(w)		((w) &lt;&lt; SCHED_LOAD_RESOLUTION)</span>
<span class="c"># define scale_load_down(w)	((w) &gt;&gt; SCHED_LOAD_RESOLUTION)</span>
<span class="cp">#else</span>
<span class="cp"># define SCHED_LOAD_RESOLUTION	0</span>
<span class="cp"># define scale_load(w)		(w)</span>
<span class="cp"># define scale_load_down(w)	(w)</span>
<span class="cp">#endif</span>

<span class="cp">#define SCHED_LOAD_SHIFT	(10 + SCHED_LOAD_RESOLUTION)</span>
<span class="cp">#define SCHED_LOAD_SCALE	(1L &lt;&lt; SCHED_LOAD_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * Increase resolution of cpu_power calculations</span>
<span class="cm"> */</span>
<span class="cp">#define SCHED_POWER_SHIFT	10</span>
<span class="cp">#define SCHED_POWER_SCALE	(1L &lt;&lt; SCHED_POWER_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * sched-domains (multiprocessor balancing) declarations:</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define SD_LOAD_BALANCE		0x0001	</span><span class="cm">/* Do load balancing on this domain. */</span><span class="cp"></span>
<span class="cp">#define SD_BALANCE_NEWIDLE	0x0002	</span><span class="cm">/* Balance when about to become idle */</span><span class="cp"></span>
<span class="cp">#define SD_BALANCE_EXEC		0x0004	</span><span class="cm">/* Balance on exec */</span><span class="cp"></span>
<span class="cp">#define SD_BALANCE_FORK		0x0008	</span><span class="cm">/* Balance on fork, clone */</span><span class="cp"></span>
<span class="cp">#define SD_BALANCE_WAKE		0x0010  </span><span class="cm">/* Balance on wakeup */</span><span class="cp"></span>
<span class="cp">#define SD_WAKE_AFFINE		0x0020	</span><span class="cm">/* Wake task to waking CPU */</span><span class="cp"></span>
<span class="cp">#define SD_PREFER_LOCAL		0x0040  </span><span class="cm">/* Prefer to keep tasks local to this domain */</span><span class="cp"></span>
<span class="cp">#define SD_SHARE_CPUPOWER	0x0080	</span><span class="cm">/* Domain members share cpu power */</span><span class="cp"></span>
<span class="cp">#define SD_SHARE_PKG_RESOURCES	0x0200	</span><span class="cm">/* Domain members share cpu pkg resources */</span><span class="cp"></span>
<span class="cp">#define SD_SERIALIZE		0x0400	</span><span class="cm">/* Only a single load balancing instance */</span><span class="cp"></span>
<span class="cp">#define SD_ASYM_PACKING		0x0800  </span><span class="cm">/* Place busy groups earlier in the domain */</span><span class="cp"></span>
<span class="cp">#define SD_PREFER_SIBLING	0x1000	</span><span class="cm">/* Prefer to place tasks in a sibling domain */</span><span class="cp"></span>
<span class="cp">#define SD_OVERLAP		0x2000	</span><span class="cm">/* sched_domains of this level overlap */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__weak</span> <span class="n">arch_sd_sibiling_asym_packing</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sched_group_power</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">ref</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * CPU power of this group, SCHED_LOAD_SCALE being max power for a</span>
<span class="cm">	 * single CPU.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">power</span><span class="p">,</span> <span class="n">power_orig</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_update</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Number of busy cpus in this group.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">nr_busy_cpus</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpumask</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* iteration mask */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sched_group</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/* Must be a circular list */</span>
	<span class="n">atomic_t</span> <span class="n">ref</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group_weight</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_group_power</span> <span class="o">*</span><span class="n">sgp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The CPUs this group covers.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: this field is variable length. (Allocated dynamically</span>
<span class="cm">	 * by attaching extra space to the end of the structure,</span>
<span class="cm">	 * depending on how many CPUs the kernel has booted up with)</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpumask</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">sched_group_cpus</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cpumask masking which cpus in the group are allowed to iterate up the domain</span>
<span class="cm"> * tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">sched_group_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgp</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * group_first_cpu - Returns the first cpu in the cpumask of a sched_group.</span>
<span class="cm"> * @group: The group whose first cpu is to be returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">group_first_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">sched_group_cpus</span><span class="p">(</span><span class="n">group</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">relax_domain_level</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SD_ATTR_INIT	(struct sched_domain_attr) {	\</span>
<span class="cp">	.relax_domain_level = -1,			\</span>
<span class="cp">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sched_domain_level_max</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sched_domain</span> <span class="p">{</span>
	<span class="cm">/* These fields must be setup */</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>	<span class="cm">/* top domain must be null terminated */</span>
	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>	<span class="cm">/* bottom domain must be null terminated */</span>
	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">groups</span><span class="p">;</span>	<span class="cm">/* the balancing groups of the domain */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_interval</span><span class="p">;</span>	<span class="cm">/* Minimum balance interval ms */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_interval</span><span class="p">;</span>	<span class="cm">/* Maximum balance interval ms */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">busy_factor</span><span class="p">;</span>	<span class="cm">/* less balancing by factor if busy */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">imbalance_pct</span><span class="p">;</span>	<span class="cm">/* No balance until over watermark */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cache_nice_tries</span><span class="p">;</span>	<span class="cm">/* Leave cache hot tasks for # tries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">busy_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idle_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">newidle_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wake_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">forkexec_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">smt_gain</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>			<span class="cm">/* See SD_* */</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="cm">/* Runtime fields. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_balance</span><span class="p">;</span>	<span class="cm">/* init to jiffies. units in jiffies */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">balance_interval</span><span class="p">;</span>	<span class="cm">/* initialise to 1. units in ms. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_balance_failed</span><span class="p">;</span> <span class="cm">/* initialise to 0 */</span>

	<span class="n">u64</span> <span class="n">last_update</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="cm">/* load_balance() stats */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lb_count</span><span class="p">[</span><span class="n">CPU_MAX_IDLE_TYPES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lb_failed</span><span class="p">[</span><span class="n">CPU_MAX_IDLE_TYPES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lb_balanced</span><span class="p">[</span><span class="n">CPU_MAX_IDLE_TYPES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lb_imbalance</span><span class="p">[</span><span class="n">CPU_MAX_IDLE_TYPES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lb_gained</span><span class="p">[</span><span class="n">CPU_MAX_IDLE_TYPES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lb_hot_gained</span><span class="p">[</span><span class="n">CPU_MAX_IDLE_TYPES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lb_nobusyg</span><span class="p">[</span><span class="n">CPU_MAX_IDLE_TYPES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lb_nobusyq</span><span class="p">[</span><span class="n">CPU_MAX_IDLE_TYPES</span><span class="p">];</span>

	<span class="cm">/* Active load balancing */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alb_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alb_failed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alb_pushed</span><span class="p">;</span>

	<span class="cm">/* SD_BALANCE_EXEC stats */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbe_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbe_balanced</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbe_pushed</span><span class="p">;</span>

	<span class="cm">/* SD_BALANCE_FORK stats */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbf_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbf_balanced</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sbf_pushed</span><span class="p">;</span>

	<span class="cm">/* try_to_wake_up() stats */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ttwu_wake_remote</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ttwu_move_affine</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ttwu_move_balance</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>		<span class="cm">/* used during construction */</span>
		<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>	<span class="cm">/* used during destruction */</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">span_weight</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Span of all CPUs in this domain.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: this field is variable length. (Allocated dynamically</span>
<span class="cm">	 * by attaching extra space to the end of the structure,</span>
<span class="cm">	 * depending on how many CPUs the kernel has booted up with)</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="nf">sched_domain_span</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">partition_sched_domains</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndoms_new</span><span class="p">,</span> <span class="n">cpumask_var_t</span> <span class="n">doms_new</span><span class="p">[],</span>
				    <span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">dattr_new</span><span class="p">);</span>

<span class="cm">/* Allocate an array of sched domains, for partition_sched_domains(). */</span>
<span class="n">cpumask_var_t</span> <span class="o">*</span><span class="n">alloc_sched_domains</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndoms</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_sched_domains</span><span class="p">(</span><span class="n">cpumask_var_t</span> <span class="n">doms</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ndoms</span><span class="p">);</span>

<span class="cm">/* Test a flag in parent sched domain */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_sd_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">default_scale_freq_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">default_scale_smt_power</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="n">bool</span> <span class="n">cpus_share_cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">that_cpu</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">sched_domain_attr</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">partition_sched_domains</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndoms_new</span><span class="p">,</span> <span class="n">cpumask_var_t</span> <span class="n">doms_new</span><span class="p">[],</span>
			<span class="k">struct</span> <span class="n">sched_domain_attr</span> <span class="o">*</span><span class="n">dattr_new</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cpus_share_cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">that_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* !CONFIG_SMP */</span><span class="cp"></span>


<span class="k">struct</span> <span class="n">io_context</span><span class="p">;</span>			<span class="cm">/* See blkdev.h */</span>


<span class="cp">#ifdef ARCH_HAS_PREFETCH_SWITCH_STACK</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">prefetch_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prefetch_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">audit_context</span><span class="p">;</span>		<span class="cm">/* See audit.c */</span>
<span class="k">struct</span> <span class="n">mempolicy</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pipe_inode_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">uts_namespace</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">rq</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sched_domain</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * wake flags</span>
<span class="cm"> */</span>
<span class="cp">#define WF_SYNC		0x01		</span><span class="cm">/* waker goes to sleep after wakup */</span><span class="cp"></span>
<span class="cp">#define WF_FORK		0x02		</span><span class="cm">/* child wakeup after fork */</span><span class="cp"></span>
<span class="cp">#define WF_MIGRATED	0x04		</span><span class="cm">/* internal use, task got migrated */</span><span class="cp"></span>

<span class="cp">#define ENQUEUE_WAKEUP		1</span>
<span class="cp">#define ENQUEUE_HEAD		2</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define ENQUEUE_WAKING		4	</span><span class="cm">/* sched_class::task_waking was called */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define ENQUEUE_WAKING		0</span>
<span class="cp">#endif</span>

<span class="cp">#define DEQUEUE_SLEEP		1</span>

<span class="k">struct</span> <span class="n">sched_class</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enqueue_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dequeue_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">yield_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">yield_to_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">preempt</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">check_preempt_curr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">pick_next_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_prev_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">select_task_rq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_schedule</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">post_schedule</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">task_waking</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">task_woken</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_cpus_allowed</span><span class="p">)(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">newmask</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rq_online</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rq_offline</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_curr_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">task_tick</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">task_fork</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">switched_from</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">switched_to</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">prio_changed</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">oldprio</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_rr_interval</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">task_move_group</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on_rq</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">load_weight</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">,</span> <span class="n">inv_weight</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
<span class="k">struct</span> <span class="n">sched_statistics</span> <span class="p">{</span>
	<span class="n">u64</span>			<span class="n">wait_start</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">wait_max</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">wait_count</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">wait_sum</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">iowait_count</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">iowait_sum</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">sleep_start</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">sleep_max</span><span class="p">;</span>
	<span class="n">s64</span>			<span class="n">sum_sleep_runtime</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">block_start</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">block_max</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">exec_max</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">slice_max</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">nr_migrations_cold</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_failed_migrations_affine</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_failed_migrations_running</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_failed_migrations_hot</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_forced_migrations</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">nr_wakeups</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_wakeups_sync</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_wakeups_migrate</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_wakeups_local</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_wakeups_remote</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_wakeups_affine</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_wakeups_affine_attempts</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_wakeups_passive</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">nr_wakeups_idle</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">sched_entity</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">load_weight</span>	<span class="n">load</span><span class="p">;</span>		<span class="cm">/* for load-balancing */</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">run_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">group_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">on_rq</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">exec_start</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">sum_exec_runtime</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">vruntime</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">prev_sum_exec_runtime</span><span class="p">;</span>

	<span class="n">u64</span>			<span class="n">nr_migrations</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="k">struct</span> <span class="n">sched_statistics</span> <span class="n">statistics</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
	<span class="k">struct</span> <span class="n">sched_entity</span>	<span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="cm">/* rq on which this entity is (to be) queued: */</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span>		<span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
	<span class="cm">/* rq &quot;owned&quot; by this entity/group: */</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span>		<span class="o">*</span><span class="n">my_q</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">run_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_slice</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">back</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span>	<span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="cm">/* rq on which this entity is (to be) queued: */</span>
	<span class="k">struct</span> <span class="n">rt_rq</span>		<span class="o">*</span><span class="n">rt_rq</span><span class="p">;</span>
	<span class="cm">/* rq &quot;owned&quot; by this entity/group: */</span>
	<span class="k">struct</span> <span class="n">rt_rq</span>		<span class="o">*</span><span class="n">my_q</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * default timeslice is 100 msecs (used only for SCHED_RR tasks).</span>
<span class="cm"> * Timeslices get refilled after they expire.</span>
<span class="cm"> */</span>
<span class="cp">#define RR_TIMESLICE		(100 * HZ / 1000)</span>

<span class="k">struct</span> <span class="n">rcu_node</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">perf_event_task_context</span> <span class="p">{</span>
	<span class="n">perf_invalid_context</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">perf_hw_context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">perf_sw_context</span><span class="p">,</span>
	<span class="n">perf_nr_task_contexts</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>	<span class="cm">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">usage</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>	<span class="cm">/* per process flags, defined below */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptrace</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">llist_node</span> <span class="n">wake_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">on_cpu</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">on_rq</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="n">static_prio</span><span class="p">,</span> <span class="n">normal_prio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rt_priority</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">sched_class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="n">se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="n">rt</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PREEMPT_NOTIFIERS</span>
	<span class="cm">/* list of struct preempt_notifier: */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">preempt_notifiers</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * fpu_counter contains the number of consecutive context switches</span>
<span class="cm">	 * that the FPU is used. If this is over a threshold, the lazy fpu</span>
<span class="cm">	 * saving becomes unlazy to save the trap. This is an unsigned char</span>
<span class="cm">	 * so that after 256 times the counter wraps and the behavior turns</span>
<span class="cm">	 * lazy again; this to deal with bursty apps that only use FPU for</span>
<span class="cm">	 * a short time</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fpu_counter</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_IO_TRACE</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">btrace_seq</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_cpus_allowed</span><span class="p">;</span>
	<span class="n">cpumask_t</span> <span class="n">cpus_allowed</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PREEMPT_RCU</span>
	<span class="kt">int</span> <span class="n">rcu_read_lock_nesting</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">rcu_read_unlock_special</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rcu_node_entry</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_PREEMPT_RCU */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_TREE_PREEMPT_RCU</span>
	<span class="k">struct</span> <span class="n">rcu_node</span> <span class="o">*</span><span class="n">rcu_blocked_node</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_TREE_PREEMPT_RCU */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
	<span class="k">struct</span> <span class="n">rt_mutex</span> <span class="o">*</span><span class="n">rcu_boost_mutex</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span>
	<span class="k">struct</span> <span class="n">sched_info</span> <span class="n">sched_info</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">plist_node</span> <span class="n">pushable_tasks</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="o">*</span><span class="n">active_mm</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_COMPAT_BRK</span>
	<span class="kt">unsigned</span> <span class="n">brk_randomized</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(SPLIT_RSS_COUNTING)</span>
	<span class="k">struct</span> <span class="n">task_rss_stat</span>	<span class="n">rss_stat</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cm">/* task state */</span>
	<span class="kt">int</span> <span class="n">exit_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exit_code</span><span class="p">,</span> <span class="n">exit_signal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pdeath_signal</span><span class="p">;</span>  <span class="cm">/*  The signal sent when the parent dies  */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">jobctl</span><span class="p">;</span>	<span class="cm">/* JOBCTL_*, siglock protected */</span>
	<span class="cm">/* ??? */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">personality</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">did_exec</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">in_execve</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Tell the LSMs that the process is doing an</span>
<span class="cm">				 * execve */</span>
	<span class="kt">unsigned</span> <span class="n">in_iowait</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* task may not gain privileges */</span>
	<span class="kt">unsigned</span> <span class="n">no_new_privs</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Revert to default priority/policy when forking */</span>
	<span class="kt">unsigned</span> <span class="n">sched_reset_on_fork</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">sched_contributes_to_load</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">tgid</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CC_STACKPROTECTOR</span>
	<span class="cm">/* Canary value for the -fstack-protector gcc feature */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_canary</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * pointers to (original) parent process, youngest child, younger sibling,</span>
<span class="cm">	 * older sibling, respectively.  (p-&gt;father can be replaced with</span>
<span class="cm">	 * p-&gt;real_parent-&gt;pid)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">real_parent</span><span class="p">;</span> <span class="cm">/* real parent process */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span> <span class="cm">/* recipient of SIGCHLD, wait4() reports */</span>
	<span class="cm">/*</span>
<span class="cm">	 * children/sibling forms the list of my natural children</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>	<span class="cm">/* list of my children */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sibling</span><span class="p">;</span>	<span class="cm">/* linkage in my parent&#39;s children list */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">group_leader</span><span class="p">;</span>	<span class="cm">/* threadgroup leader */</span>

	<span class="cm">/*</span>
<span class="cm">	 * ptraced is the list of tasks this task is using ptrace on.</span>
<span class="cm">	 * This includes both natural children and PTRACE_ATTACH targets.</span>
<span class="cm">	 * p-&gt;ptrace_entry is p&#39;s link on the p-&gt;parent-&gt;ptraced list.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptraced</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptrace_entry</span><span class="p">;</span>

	<span class="cm">/* PID/PID hash table linkage. */</span>
	<span class="k">struct</span> <span class="n">pid_link</span> <span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">thread_group</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">vfork_done</span><span class="p">;</span>		<span class="cm">/* for vfork() */</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">set_child_tid</span><span class="p">;</span>		<span class="cm">/* CLONE_CHILD_SETTID */</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">clear_child_tid</span><span class="p">;</span>		<span class="cm">/* CLONE_CHILD_CLEARTID */</span>

	<span class="n">cputime_t</span> <span class="n">utime</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">utimescaled</span><span class="p">,</span> <span class="n">stimescaled</span><span class="p">;</span>
	<span class="n">cputime_t</span> <span class="n">gtime</span><span class="p">;</span>
<span class="cp">#ifndef CONFIG_VIRT_CPU_ACCOUNTING</span>
	<span class="n">cputime_t</span> <span class="n">prev_utime</span><span class="p">,</span> <span class="n">prev_stime</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nvcsw</span><span class="p">,</span> <span class="n">nivcsw</span><span class="p">;</span> <span class="cm">/* context switch counts */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">start_time</span><span class="p">;</span> 		<span class="cm">/* monotonic time */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">real_start_time</span><span class="p">;</span>	<span class="cm">/* boot based time */</span>
<span class="cm">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_flt</span><span class="p">,</span> <span class="n">maj_flt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime_expires</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cpu_timers</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="cm">/* process credentials */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">real_cred</span><span class="p">;</span> <span class="cm">/* objective and real subjective task</span>
<span class="cm">					 * credentials (COW) */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>	<span class="cm">/* effective (overridable) subjective task</span>
<span class="cm">					 * credentials (COW) */</span>
	<span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span> <span class="cm">/* executable name excluding path</span>
<span class="cm">				     - access with [gs]et_task_comm (which lock</span>
<span class="cm">				       it with task_lock())</span>
<span class="cm">				     - initialized normally by setup_new_exec */</span>
<span class="cm">/* file system info */</span>
	<span class="kt">int</span> <span class="n">link_count</span><span class="p">,</span> <span class="n">total_link_count</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SYSVIPC</span>
<span class="cm">/* ipc stuff */</span>
	<span class="k">struct</span> <span class="n">sysv_sem</span> <span class="n">sysvsem</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_DETECT_HUNG_TASK</span>
<span class="cm">/* hung task detection */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_switch_count</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cm">/* CPU-specific state of this task */</span>
	<span class="k">struct</span> <span class="n">thread_struct</span> <span class="kr">thread</span><span class="p">;</span>
<span class="cm">/* filesystem information */</span>
	<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span><span class="p">;</span>
<span class="cm">/* open file information */</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">;</span>
<span class="cm">/* namespaces */</span>
	<span class="k">struct</span> <span class="n">nsproxy</span> <span class="o">*</span><span class="n">nsproxy</span><span class="p">;</span>
<span class="cm">/* signal handlers */</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">signal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span><span class="p">;</span>

	<span class="n">sigset_t</span> <span class="n">blocked</span><span class="p">,</span> <span class="n">real_blocked</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">saved_sigmask</span><span class="p">;</span>	<span class="cm">/* restored if set_restore_sigmask() was used */</span>
	<span class="k">struct</span> <span class="n">sigpending</span> <span class="n">pending</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sas_ss_sp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sas_ss_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">notifier</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">notifier_data</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="o">*</span><span class="n">notifier_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">task_works</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">audit_context</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sessionid</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">seccomp</span> <span class="n">seccomp</span><span class="p">;</span>

<span class="cm">/* Thread group tracking */</span>
   	<span class="n">u32</span> <span class="n">parent_exec_id</span><span class="p">;</span>
   	<span class="n">u32</span> <span class="n">self_exec_id</span><span class="p">;</span>
<span class="cm">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed,</span>
<span class="cm"> * mempolicy */</span>
	<span class="n">spinlock_t</span> <span class="n">alloc_lock</span><span class="p">;</span>

	<span class="cm">/* Protection of the PI data structures: */</span>
	<span class="n">raw_spinlock_t</span> <span class="n">pi_lock</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RT_MUTEXES</span>
	<span class="cm">/* PI waiters blocked on a rt_mutex held by this task */</span>
	<span class="k">struct</span> <span class="n">plist_head</span> <span class="n">pi_waiters</span><span class="p">;</span>
	<span class="cm">/* Deadlock detection and priority inheritance handling */</span>
	<span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">pi_blocked_on</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_MUTEXES</span>
	<span class="cm">/* mutex deadlock detection */</span>
	<span class="k">struct</span> <span class="n">mutex_waiter</span> <span class="o">*</span><span class="n">blocked_on</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TRACE_IRQFLAGS</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_events</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hardirq_enable_ip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hardirq_disable_ip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hardirq_enable_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hardirq_disable_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hardirqs_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hardirq_context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">softirq_disable_ip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">softirq_enable_ip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">softirq_disable_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">softirq_enable_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">softirqs_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">softirq_context</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="cp"># define MAX_LOCK_DEPTH 48UL</span>
	<span class="n">u64</span> <span class="n">curr_chain_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lockdep_depth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lockdep_recursion</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">held_lock</span> <span class="n">held_locks</span><span class="p">[</span><span class="n">MAX_LOCK_DEPTH</span><span class="p">];</span>
	<span class="n">gfp_t</span> <span class="n">lockdep_reclaim_gfp</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* journalling filesystem info */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">journal_info</span><span class="p">;</span>

<span class="cm">/* stacked block device info */</span>
	<span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bio_list</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="cm">/* stack plugging */</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="o">*</span><span class="n">plug</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/* VM state */</span>
	<span class="k">struct</span> <span class="n">reclaim_state</span> <span class="o">*</span><span class="n">reclaim_state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">backing_dev_info</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">io_context</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptrace_message</span><span class="p">;</span>
	<span class="n">siginfo_t</span> <span class="o">*</span><span class="n">last_siginfo</span><span class="p">;</span> <span class="cm">/* For ptrace use.  */</span>
	<span class="k">struct</span> <span class="n">task_io_accounting</span> <span class="n">ioac</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_TASK_XACCT)</span>
	<span class="n">u64</span> <span class="n">acct_rss_mem1</span><span class="p">;</span>	<span class="cm">/* accumulated rss usage */</span>
	<span class="n">u64</span> <span class="n">acct_vm_mem1</span><span class="p">;</span>	<span class="cm">/* accumulated virtual memory usage */</span>
	<span class="n">cputime_t</span> <span class="n">acct_timexpd</span><span class="p">;</span>	<span class="cm">/* stime + utime since last update */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CPUSETS</span>
	<span class="n">nodemask_t</span> <span class="n">mems_allowed</span><span class="p">;</span>	<span class="cm">/* Protected by alloc_lock */</span>
	<span class="n">seqcount_t</span> <span class="n">mems_allowed_seq</span><span class="p">;</span>	<span class="cm">/* Seqence no to catch updates */</span>
	<span class="kt">int</span> <span class="n">cpuset_mem_spread_rotor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpuset_slab_spread_rotor</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CGROUPS</span>
	<span class="cm">/* Control Group info protected by css_set_lock */</span>
	<span class="k">struct</span> <span class="n">css_set</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">cgroups</span><span class="p">;</span>
	<span class="cm">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cg_list</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FUTEX</span>
	<span class="k">struct</span> <span class="n">robust_list_head</span> <span class="n">__user</span> <span class="o">*</span><span class="n">robust_list</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="k">struct</span> <span class="n">compat_robust_list_head</span> <span class="n">__user</span> <span class="o">*</span><span class="n">compat_robust_list</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pi_state_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state_cache</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PERF_EVENTS</span>
	<span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">perf_event_ctxp</span><span class="p">[</span><span class="n">perf_nr_task_contexts</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">perf_event_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">perf_event_list</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mempolicy</span><span class="p">;</span>	<span class="cm">/* Protected by alloc_lock */</span>
	<span class="kt">short</span> <span class="n">il_next</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">pref_node_fork</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * cache last used pipe for splice</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">splice_pipe</span><span class="p">;</span>
<span class="cp">#ifdef	CONFIG_TASK_DELAY_ACCT</span>
	<span class="k">struct</span> <span class="n">task_delay_info</span> <span class="o">*</span><span class="n">delays</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FAULT_INJECTION</span>
	<span class="kt">int</span> <span class="n">make_it_fail</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * when (nr_dirtied &gt;= nr_dirtied_pause), it&#39;s time to call</span>
<span class="cm">	 * balance_dirty_pages() for some dirty throttling pause</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">nr_dirtied</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_dirtied_pause</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_paused_when</span><span class="p">;</span> <span class="cm">/* start of a write-and-pause period */</span>

<span class="cp">#ifdef CONFIG_LATENCYTOP</span>
	<span class="kt">int</span> <span class="n">latency_record_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">latency_record</span> <span class="n">latency_record</span><span class="p">[</span><span class="n">LT_SAVECOUNT</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * time slack values; these are used to round up poll() and</span>
<span class="cm">	 * select() etc timeout values. These are in nanoseconds.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timer_slack_ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">default_timer_slack_ns</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">scm_work_list</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
	<span class="cm">/* Index of current stored address in ret_stack */</span>
	<span class="kt">int</span> <span class="n">curr_ret_stack</span><span class="p">;</span>
	<span class="cm">/* Stack of return addresses for return function tracing */</span>
	<span class="k">struct</span> <span class="n">ftrace_ret_stack</span>	<span class="o">*</span><span class="n">ret_stack</span><span class="p">;</span>
	<span class="cm">/* time stamp for last schedule */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ftrace_timestamp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Number of functions that haven&#39;t been traced</span>
<span class="cm">	 * because of depth overrun.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">trace_overrun</span><span class="p">;</span>
	<span class="cm">/* Pause for the tracing */</span>
	<span class="n">atomic_t</span> <span class="n">tracing_graph_pause</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TRACING</span>
	<span class="cm">/* state flags for use by tracers */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trace</span><span class="p">;</span>
	<span class="cm">/* bitmask and counter of trace recursion */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trace_recursion</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRACING */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR </span><span class="cm">/* memcg uses this to do batch job */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">memcg_batch_info</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">do_batch</span><span class="p">;</span>	<span class="cm">/* incremented when batch uncharge started */</span>
		<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span> <span class="cm">/* target memcg of uncharge */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>	<span class="cm">/* uncharged usage */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memsw_nr_pages</span><span class="p">;</span> <span class="cm">/* uncharged mem+swap usage */</span>
	<span class="p">}</span> <span class="n">memcg_batch</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_HAVE_HW_BREAKPOINT</span>
	<span class="n">atomic_t</span> <span class="n">ptrace_bp_refcnt</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_UPROBES</span>
	<span class="k">struct</span> <span class="n">uprobe_task</span> <span class="o">*</span><span class="n">utask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uprobe_srcu_id</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Future-safe accessor for struct task_struct&#39;s cpus_allowed. */</span>
<span class="cp">#define tsk_cpus_allowed(tsk) (&amp;(tsk)-&gt;cpus_allowed)</span>

<span class="cm">/*</span>
<span class="cm"> * Priority of a process goes from 0..MAX_PRIO-1, valid RT</span>
<span class="cm"> * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH</span>
<span class="cm"> * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority</span>
<span class="cm"> * values are inverted: lower p-&gt;prio value means higher priority.</span>
<span class="cm"> *</span>
<span class="cm"> * The MAX_USER_RT_PRIO value allows the actual maximum</span>
<span class="cm"> * RT priority to be separate from the value exported to</span>
<span class="cm"> * user-space.  This allows kernel threads to set their</span>
<span class="cm"> * priority to a value higher than any user task. Note:</span>
<span class="cm"> * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_USER_RT_PRIO	100</span>
<span class="cp">#define MAX_RT_PRIO		MAX_USER_RT_PRIO</span>

<span class="cp">#define MAX_PRIO		(MAX_RT_PRIO + 40)</span>
<span class="cp">#define DEFAULT_PRIO		(MAX_RT_PRIO + 20)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_prio</span><span class="p">(</span><span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">MAX_RT_PRIO</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="nf">task_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_PID</span><span class="p">].</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="nf">task_tgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_PID</span><span class="p">].</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Without tasklist or rcu lock it is not safe to dereference</span>
<span class="cm"> * the result of task_pgrp/task_session even if task == current,</span>
<span class="cm"> * we can race with another thread doing sys_setsid/sys_setpgid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="nf">task_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_PGID</span><span class="p">].</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="nf">task_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_SID</span><span class="p">].</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pid_namespace</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * the helpers to get the task&#39;s different pids as they are seen</span>
<span class="cm"> * from various namespaces</span>
<span class="cm"> *</span>
<span class="cm"> * task_xid_nr()     : global id, i.e. the id seen from the init namespace;</span>
<span class="cm"> * task_xid_vnr()    : virtual id, i.e. the id seen from the pid namespace of</span>
<span class="cm"> *                     current.</span>
<span class="cm"> * task_xid_nr_ns()  : id seen from the ns specified;</span>
<span class="cm"> *</span>
<span class="cm"> * set_task_vxid()   : assigns a virtual id to a task;</span>
<span class="cm"> *</span>
<span class="cm"> * see also pid_nr() etc in include/linux/pid.h</span>
<span class="cm"> */</span>
<span class="n">pid_t</span> <span class="n">__task_pid_nr_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_pid_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_pid_nr_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__task_pid_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_pid_vnr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__task_pid_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_tgid_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pid_t</span> <span class="n">task_tgid_nr_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_tgid_vnr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pid_vnr</span><span class="p">(</span><span class="n">task_tgid</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_pgrp_nr_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__task_pid_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_pgrp_vnr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__task_pid_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_session_nr_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__task_pid_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_session_vnr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__task_pid_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* obsolete, do not use */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pid_t</span> <span class="nf">task_pgrp_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_pgrp_nr_ns</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_pid_ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pid_alive - check that a task structure is not stale</span>
<span class="cm"> * @p: Task structure to be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * Test if a process is not yet dead (at most zombie state)</span>
<span class="cm"> * If pid_alive fails, then pointers within the task structure</span>
<span class="cm"> * can be stale and must not be dereferenced.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pid_alive</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_PID</span><span class="p">].</span><span class="n">pid</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_global_init - check if a task structure is init</span>
<span class="cm"> * @tsk: Task structure to be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * Check if a task structure is the first user space task the kernel created.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_global_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * is_container_init:</span>
<span class="cm"> * check whether in the task is init in its own pid namespace.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">is_container_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">cad_pid</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#define get_task_struct(tsk) do { atomic_inc(&amp;(tsk)-&gt;usage); } while(0)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__put_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">usage</span><span class="p">))</span>
		<span class="n">__put_task_struct</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">task_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">ut</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">st</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">thread_group_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">ut</span><span class="p">,</span> <span class="n">cputime_t</span> <span class="o">*</span><span class="n">st</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Per process flags</span>
<span class="cm"> */</span>
<span class="cp">#define PF_EXITING	0x00000004	</span><span class="cm">/* getting shut down */</span><span class="cp"></span>
<span class="cp">#define PF_EXITPIDONE	0x00000008	</span><span class="cm">/* pi exit done on shut down */</span><span class="cp"></span>
<span class="cp">#define PF_VCPU		0x00000010	</span><span class="cm">/* I&#39;m a virtual CPU */</span><span class="cp"></span>
<span class="cp">#define PF_WQ_WORKER	0x00000020	</span><span class="cm">/* I&#39;m a workqueue worker */</span><span class="cp"></span>
<span class="cp">#define PF_FORKNOEXEC	0x00000040	</span><span class="cm">/* forked but didn&#39;t exec */</span><span class="cp"></span>
<span class="cp">#define PF_MCE_PROCESS  0x00000080      </span><span class="cm">/* process policy on mce errors */</span><span class="cp"></span>
<span class="cp">#define PF_SUPERPRIV	0x00000100	</span><span class="cm">/* used super-user privileges */</span><span class="cp"></span>
<span class="cp">#define PF_DUMPCORE	0x00000200	</span><span class="cm">/* dumped core */</span><span class="cp"></span>
<span class="cp">#define PF_SIGNALED	0x00000400	</span><span class="cm">/* killed by a signal */</span><span class="cp"></span>
<span class="cp">#define PF_MEMALLOC	0x00000800	</span><span class="cm">/* Allocating memory */</span><span class="cp"></span>
<span class="cp">#define PF_NPROC_EXCEEDED 0x00001000	</span><span class="cm">/* set_user noticed that RLIMIT_NPROC was exceeded */</span><span class="cp"></span>
<span class="cp">#define PF_USED_MATH	0x00002000	</span><span class="cm">/* if unset the fpu must be initialized before use */</span><span class="cp"></span>
<span class="cp">#define PF_NOFREEZE	0x00008000	</span><span class="cm">/* this thread should not be frozen */</span><span class="cp"></span>
<span class="cp">#define PF_FROZEN	0x00010000	</span><span class="cm">/* frozen for system suspend */</span><span class="cp"></span>
<span class="cp">#define PF_FSTRANS	0x00020000	</span><span class="cm">/* inside a filesystem transaction */</span><span class="cp"></span>
<span class="cp">#define PF_KSWAPD	0x00040000	</span><span class="cm">/* I am kswapd */</span><span class="cp"></span>
<span class="cp">#define PF_LESS_THROTTLE 0x00100000	</span><span class="cm">/* Throttle me less: I clean memory */</span><span class="cp"></span>
<span class="cp">#define PF_KTHREAD	0x00200000	</span><span class="cm">/* I am a kernel thread */</span><span class="cp"></span>
<span class="cp">#define PF_RANDOMIZE	0x00400000	</span><span class="cm">/* randomize virtual address space */</span><span class="cp"></span>
<span class="cp">#define PF_SWAPWRITE	0x00800000	</span><span class="cm">/* Allowed to write to swap */</span><span class="cp"></span>
<span class="cp">#define PF_SPREAD_PAGE	0x01000000	</span><span class="cm">/* Spread page cache over cpuset */</span><span class="cp"></span>
<span class="cp">#define PF_SPREAD_SLAB	0x02000000	</span><span class="cm">/* Spread some slab caches over cpuset */</span><span class="cp"></span>
<span class="cp">#define PF_THREAD_BOUND	0x04000000	</span><span class="cm">/* Thread bound to specific cpu */</span><span class="cp"></span>
<span class="cp">#define PF_MCE_EARLY    0x08000000      </span><span class="cm">/* Early kill for mce process policy */</span><span class="cp"></span>
<span class="cp">#define PF_MEMPOLICY	0x10000000	</span><span class="cm">/* Non-default NUMA mempolicy */</span><span class="cp"></span>
<span class="cp">#define PF_MUTEX_TESTER	0x20000000	</span><span class="cm">/* Thread belongs to the rt mutex tester */</span><span class="cp"></span>
<span class="cp">#define PF_FREEZER_SKIP	0x40000000	</span><span class="cm">/* Freezer should not count it as freezable */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Only the _current_ task can read/write to tsk-&gt;flags, but other</span>
<span class="cm"> * tasks can access tsk-&gt;flags in readonly mode for example</span>
<span class="cm"> * with tsk_used_math (like during threaded core dumping).</span>
<span class="cm"> * There is however an exception to this rule during ptrace</span>
<span class="cm"> * or during fork: the ptracer task is allowed to write to the</span>
<span class="cm"> * child-&gt;flags of its traced child (same goes for fork, the parent</span>
<span class="cm"> * can write to the child-&gt;flags), because we&#39;re guaranteed the</span>
<span class="cm"> * child is not running and in turn not changing child-&gt;flags</span>
<span class="cm"> * at the same time the parent does it.</span>
<span class="cm"> */</span>
<span class="cp">#define clear_stopped_child_used_math(child) do { (child)-&gt;flags &amp;= ~PF_USED_MATH; } while (0)</span>
<span class="cp">#define set_stopped_child_used_math(child) do { (child)-&gt;flags |= PF_USED_MATH; } while (0)</span>
<span class="cp">#define clear_used_math() clear_stopped_child_used_math(current)</span>
<span class="cp">#define set_used_math() set_stopped_child_used_math(current)</span>
<span class="cp">#define conditional_stopped_child_used_math(condition, child) \</span>
<span class="cp">	do { (child)-&gt;flags &amp;= ~PF_USED_MATH, (child)-&gt;flags |= (condition) ? PF_USED_MATH : 0; } while (0)</span>
<span class="cp">#define conditional_used_math(condition) \</span>
<span class="cp">	conditional_stopped_child_used_math(condition, current)</span>
<span class="cp">#define copy_to_stopped_child_used_math(child) \</span>
<span class="cp">	do { (child)-&gt;flags &amp;= ~PF_USED_MATH, (child)-&gt;flags |= current-&gt;flags &amp; PF_USED_MATH; } while (0)</span>
<span class="cm">/* NOTE: this will return 0 or PF_USED_MATH, it will never return 1 */</span>
<span class="cp">#define tsk_used_math(p) ((p)-&gt;flags &amp; PF_USED_MATH)</span>
<span class="cp">#define used_math() tsk_used_math(current)</span>

<span class="cm">/*</span>
<span class="cm"> * task-&gt;jobctl flags</span>
<span class="cm"> */</span>
<span class="cp">#define JOBCTL_STOP_SIGMASK	0xffff	</span><span class="cm">/* signr of the last group stop */</span><span class="cp"></span>

<span class="cp">#define JOBCTL_STOP_DEQUEUED_BIT 16	</span><span class="cm">/* stop signal dequeued */</span><span class="cp"></span>
<span class="cp">#define JOBCTL_STOP_PENDING_BIT	17	</span><span class="cm">/* task should stop for group stop */</span><span class="cp"></span>
<span class="cp">#define JOBCTL_STOP_CONSUME_BIT	18	</span><span class="cm">/* consume group stop count */</span><span class="cp"></span>
<span class="cp">#define JOBCTL_TRAP_STOP_BIT	19	</span><span class="cm">/* trap for STOP */</span><span class="cp"></span>
<span class="cp">#define JOBCTL_TRAP_NOTIFY_BIT	20	</span><span class="cm">/* trap for NOTIFY */</span><span class="cp"></span>
<span class="cp">#define JOBCTL_TRAPPING_BIT	21	</span><span class="cm">/* switching to TRACED */</span><span class="cp"></span>
<span class="cp">#define JOBCTL_LISTENING_BIT	22	</span><span class="cm">/* ptracer is listening for events */</span><span class="cp"></span>

<span class="cp">#define JOBCTL_STOP_DEQUEUED	(1 &lt;&lt; JOBCTL_STOP_DEQUEUED_BIT)</span>
<span class="cp">#define JOBCTL_STOP_PENDING	(1 &lt;&lt; JOBCTL_STOP_PENDING_BIT)</span>
<span class="cp">#define JOBCTL_STOP_CONSUME	(1 &lt;&lt; JOBCTL_STOP_CONSUME_BIT)</span>
<span class="cp">#define JOBCTL_TRAP_STOP	(1 &lt;&lt; JOBCTL_TRAP_STOP_BIT)</span>
<span class="cp">#define JOBCTL_TRAP_NOTIFY	(1 &lt;&lt; JOBCTL_TRAP_NOTIFY_BIT)</span>
<span class="cp">#define JOBCTL_TRAPPING		(1 &lt;&lt; JOBCTL_TRAPPING_BIT)</span>
<span class="cp">#define JOBCTL_LISTENING	(1 &lt;&lt; JOBCTL_LISTENING_BIT)</span>

<span class="cp">#define JOBCTL_TRAP_MASK	(JOBCTL_TRAP_STOP | JOBCTL_TRAP_NOTIFY)</span>
<span class="cp">#define JOBCTL_PENDING_MASK	(JOBCTL_STOP_PENDING | JOBCTL_TRAP_MASK)</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">task_set_jobctl_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">task_clear_jobctl_trapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PREEMPT_RCU</span>

<span class="cp">#define RCU_READ_UNLOCK_BLOCKED (1 &lt;&lt; 0) </span><span class="cm">/* blocked while in RCU read-side. */</span><span class="cp"></span>
<span class="cp">#define RCU_READ_UNLOCK_NEED_QS (1 &lt;&lt; 1) </span><span class="cm">/* RCU core needs CPU response. */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_copy_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rcu_read_unlock_special</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_TREE_PREEMPT_RCU</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rcu_blocked_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_TREE_PREEMPT_RCU */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_RCU_BOOST</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rcu_boost_mutex</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_RCU_BOOST */</span><span class="cp"></span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rcu_node_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_switch_from</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">rcu_read_lock_nesting</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rcu_preempt_note_context_switch</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_copy_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_switch_from</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_set_cpus_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">do_set_cpus_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">set_cpus_allowed_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CONFIG_CPUMASK_OFFSTACK</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">set_cpus_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">cpumask_t</span> <span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Do not use outside of architecture code which knows its limitations.</span>
<span class="cm"> *</span>
<span class="cm"> * sched_clock() has no promise of monotonicity or bounded drift between</span>
<span class="cm"> * CPUs, use (which you should not) requires disabling IRQs.</span>
<span class="cm"> *</span>
<span class="cm"> * Please use one of the three interfaces below.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">notrace</span> <span class="n">sched_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * See the comment in kernel/sched/clock.c</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">cpu_clock</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">local_clock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>


<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_clock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_clock_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_clock_idle_sleep_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_clock_idle_wakeup_event</span><span class="p">(</span><span class="n">u64</span> <span class="n">delta_ns</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * Architectures can set this to 1 if they have specified</span>
<span class="cm"> * CONFIG_HAVE_UNSTABLE_SCHED_CLOCK in their arch Kconfig,</span>
<span class="cm"> * but then during bootup it turns out that sched_clock()</span>
<span class="cm"> * is reliable after all:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sched_clock_stable</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_clock_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_clock_idle_sleep_event</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_clock_idle_wakeup_event</span><span class="p">(</span><span class="n">u64</span> <span class="n">delta_ns</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>
<span class="cm">/*</span>
<span class="cm"> * An i/f to runtime opt-in for irq time accounting based off of sched_clock.</span>
<span class="cm"> * The reason for this explicit opt-in is not to have perf penalty with</span>
<span class="cm"> * slow sched_clocks.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">enable_sched_clock_irqtime</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">disable_sched_clock_irqtime</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enable_sched_clock_irqtime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_sched_clock_irqtime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>
<span class="n">task_sched_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="cm">/* sched_exec is called by processes performing an exec */</span>
<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_exec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define sched_exec()   {}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_clock_idle_sleep_event</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_clock_idle_wakeup_event</span><span class="p">(</span><span class="n">u64</span> <span class="n">delta_ns</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">idle_task_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">idle_task_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_NO_HZ) &amp;&amp; defined(CONFIG_SMP)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wake_up_idle_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wake_up_idle_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_latency</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_min_granularity</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_wakeup_granularity</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_child_runs_first</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">sched_tunable_scaling</span> <span class="p">{</span>
	<span class="n">SCHED_TUNABLESCALING_NONE</span><span class="p">,</span>
	<span class="n">SCHED_TUNABLESCALING_LOG</span><span class="p">,</span>
	<span class="n">SCHED_TUNABLESCALING_LINEAR</span><span class="p">,</span>
	<span class="n">SCHED_TUNABLESCALING_END</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">sched_tunable_scaling</span> <span class="n">sysctl_sched_tunable_scaling</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_nr_migrate</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_time_avg</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_timer_migration</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_shares_window</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sched_proc_update_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_sysctl_timer_migration</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sysctl_timer_migration</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_sysctl_timer_migration</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_rt_period</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_sched_rt_runtime</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sched_rt_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SCHED_AUTOGROUP</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_autogroup_enabled</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_autogroup_create_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_autogroup_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_autogroup_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_autogroup_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">proc_sched_autogroup_show_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">proc_sched_autogroup_set_nice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_autogroup_create_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_autogroup_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_autogroup_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_autogroup_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CFS_BANDWIDTH</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_cfs_bandwidth_slice</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_RT_MUTEXES</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rt_mutex_getprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rt_mutex_setprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rt_mutex_adjust_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tsk_is_pi_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_mutex_getprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp"># define rt_mutex_adjust_pi(p)		do { } while (0)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tsk_is_pi_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">yield_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">preempt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_user_nice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nice</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">task_prio</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">task_nice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">can_nice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">task_curr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sched_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sched_setscheduler_nocheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * is_idle_task - is the specified task an idle task?</span>
<span class="cm"> * @p: the task in question.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_idle_task</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_curr_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">yield</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The default (Linux) execution domain.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">exec_domain</span>	<span class="n">default_exec_domain</span><span class="p">;</span>

<span class="k">union</span> <span class="n">thread_union</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="n">thread_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack</span><span class="p">[</span><span class="n">THREAD_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)];</span>
<span class="p">};</span>

<span class="cp">#ifndef __HAVE_ARCH_KSTACK_END</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kstack_end</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Reliable end of stack detection:</span>
<span class="cm">	 * Some APM bios versions misalign the stack</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">THREAD_SIZE</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">union</span> <span class="n">thread_union</span> <span class="n">init_thread_union</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="n">init_task</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span>   <span class="n">mm_struct</span> <span class="n">init_mm</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="n">init_pid_ns</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * find a task by one of its numerical ids</span>
<span class="cm"> *</span>
<span class="cm"> * find_task_by_pid_ns():</span>
<span class="cm"> *      finds a task by its pid in the specified namespace</span>
<span class="cm"> * find_task_by_vpid():</span>
<span class="cm"> *      finds a task by its virtual pid</span>
<span class="cm"> *</span>
<span class="cm"> * see also find_vpid() etc in include/linux/pid.h</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">nr</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">nr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__set_special_pids</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>

<span class="cm">/* per-UID process charging. */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span> <span class="n">alloc_uid</span><span class="p">(</span><span class="n">kuid_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="nf">get_uid</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">u</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">__count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_uid</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#include &lt;asm/current.h&gt;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">xtime_update</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ticks</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">wake_up_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">wake_up_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wake_up_new_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
 <span class="k">extern</span> <span class="kt">void</span> <span class="n">kick_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#else</span>
 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kick_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_dead</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">proc_caches_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__flush_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ignore_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_signal_handlers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_default</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dequeue_signal</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dequeue_signal_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dequeue_signal</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">block_all_signals</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">notifier</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			      <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unblock_all_signals</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">release_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">send_sig_info</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">force_sigsegv</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">force_sig_info</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__kill_pgrp_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kill_pid_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kill_pid_info_as_cred</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kill_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kill_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kill_proc_info</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__must_check</span> <span class="n">bool</span> <span class="n">do_notify_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__wake_up_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">force_sig</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">send_sig</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">zap_other_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">sigqueue_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sigqueue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">send_sigqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_sigaction</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_sigaltstack</span><span class="p">(</span><span class="k">const</span> <span class="n">stack_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">stack_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restore_saved_sigmask</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_restore_sigmask</span><span class="p">())</span>
		<span class="n">__set_current_blocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">saved_sigmask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="nf">sigmask_to_save</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_restore_sigmask</span><span class="p">()))</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">saved_sigmask</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kill_cad_pid</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kill_pid</span><span class="p">(</span><span class="n">cad_pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* These can be the second arg to send_sig_info/send_group_sig_info.  */</span>
<span class="cp">#define SEND_SIG_NOINFO ((struct siginfo *) 0)</span>
<span class="cp">#define SEND_SIG_PRIV	((struct siginfo *) 1)</span>
<span class="cp">#define SEND_SIG_FORCED	((struct siginfo *) 2)</span>

<span class="cm">/*</span>
<span class="cm"> * True if we are on the alternate signal stack.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">on_sig_stack</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
	<span class="k">return</span> <span class="n">sp</span> <span class="o">&gt;=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span> <span class="o">&amp;&amp;</span>
		<span class="n">sp</span> <span class="o">-</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">sp</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span> <span class="o">&amp;&amp;</span>
		<span class="n">sp</span> <span class="o">-</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span> <span class="o">&lt;=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sas_ss_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">SS_DISABLE</span>
		<span class="o">:</span> <span class="n">on_sig_stack</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">?</span> <span class="n">SS_ONSTACK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Routines for handling mm_structs</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* mmdrop drops the mm and the page tables */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__mmdrop</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmdrop</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">)))</span>
		<span class="n">__mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* mmput gets rid of the mappings and all user-space */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mmput</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* Grab a reference to a task&#39;s mm, if it is not already going away */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">get_task_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Grab a reference to a task&#39;s mm, if it is not already going away</span>
<span class="cm"> * and ptrace_may_access with the mode parameter passed to it</span>
<span class="cm"> * succeeds.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="cm">/* Remove the current tasks stale references to the old mm_struct */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mm_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* Allocate a new mm structure and copy contents from tsk-&gt;mm */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dup_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">copy_thread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__cleanup_sighand</span><span class="p">(</span><span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_itimers</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_itimer_signals</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_group_exit</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">daemonize</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">allow_signal</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">disallow_signal</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">do_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">fork_idle</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_task_comm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">get_task_comm</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="kt">void</span> <span class="n">scheduler_ipi</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_task_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span> <span class="n">match_state</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">scheduler_ipi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">wait_task_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					       <span class="kt">long</span> <span class="n">match_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define next_task(p) \</span>
<span class="cp">	list_entry_rcu((p)-&gt;tasks.next, struct task_struct, tasks)</span>

<span class="cp">#define for_each_process(p) \</span>
<span class="cp">	for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; )</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">current_is_single_threaded</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Careful: do_each_thread/while_each_thread is a double loop so</span>
<span class="cm"> *          &#39;break&#39; will not work as expected - use goto instead.</span>
<span class="cm"> */</span>
<span class="cp">#define do_each_thread(g, t) \</span>
<span class="cp">	for (g = t = &amp;init_task ; (g = t = next_task(g)) != &amp;init_task ; ) do</span>

<span class="cp">#define while_each_thread(g, t) \</span>
<span class="cp">	while ((t = next_thread(t)) != g)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_nr_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">nr_threads</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">thread_group_leader</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Do to the insanities of de_thread it is possible for a process</span>
<span class="cm"> * to have the pid of the thread group leader without actually being</span>
<span class="cm"> * the thread group leader.  For iteration through the pids in proc</span>
<span class="cm"> * all we care about is that we have a task with the appropriate</span>
<span class="cm"> * pid, we don&#39;t actually care if we have the right task.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">has_group_leader_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">same_thread_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">==</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">next_thread</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_entry_rcu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">thread_group</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">thread_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">thread_group_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">thread_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define delay_group_leader(p) \</span>
<span class="cp">		(thread_group_leader(p) &amp;&amp; !thread_group_empty(p))</span>

<span class="cm">/*</span>
<span class="cm"> * Protects -&gt;fs, -&gt;files, -&gt;mm, -&gt;group_info, -&gt;comm, keyring</span>
<span class="cm"> * subscriptions and synchronises with wait4().  Also used in procfs.  Also</span>
<span class="cm"> * pins the final release of task.io_context.  Also protects -&gt;cpuset and</span>
<span class="cm"> * -&gt;cgroup.subsys[]. And -&gt;vfork_done.</span>
<span class="cm"> *</span>
<span class="cm"> * Nests both inside and outside of read_lock(&amp;tasklist_lock).</span>
<span class="cm"> * It must not be nested with write_lock_irq(&amp;tasklist_lock),</span>
<span class="cm"> * neither inside nor outside.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">task_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alloc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">task_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alloc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">__lock_task_sighand</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="nf">lock_task_sighand</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
						       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__lock_task_sighand</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">__cond_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_task_sighand</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUPS</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">threadgroup_change_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_rwsem</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">threadgroup_change_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_rwsem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * threadgroup_lock - lock threadgroup</span>
<span class="cm"> * @tsk: member task of the threadgroup to lock</span>
<span class="cm"> *</span>
<span class="cm"> * Lock the threadgroup @tsk belongs to.  No new task is allowed to enter</span>
<span class="cm"> * and member tasks aren&#39;t allowed to exit (as indicated by PF_EXITING) or</span>
<span class="cm"> * perform exec.  This is useful for cases where the threadgroup needs to</span>
<span class="cm"> * stay stable across blockable operations.</span>
<span class="cm"> *</span>
<span class="cm"> * fork and exit paths explicitly call threadgroup_change_{begin|end}() for</span>
<span class="cm"> * synchronization.  While held, no new task will be added to threadgroup</span>
<span class="cm"> * and no existing live task will have its PF_EXITING set.</span>
<span class="cm"> *</span>
<span class="cm"> * During exec, a task goes and puts its thread group through unusual</span>
<span class="cm"> * changes.  After de-threading, exclusive access is assumed to resources</span>
<span class="cm"> * which are usually shared by tasks in the same group - e.g. sighand may</span>
<span class="cm"> * be replaced with a new one.  Also, the exec&#39;ing task takes over group</span>
<span class="cm"> * leader role including its pid.  Exclude these changes while locked by</span>
<span class="cm"> * grabbing cred_guard_mutex which is used to synchronize exec path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">threadgroup_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * exec uses exit for de-threading nesting group_rwsem inside</span>
<span class="cm">	 * cred_guard_mutex. Grab cred_guard_mutex first.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_rwsem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * threadgroup_unlock - unlock threadgroup</span>
<span class="cm"> * @tsk: member task of the threadgroup to unlock</span>
<span class="cm"> *</span>
<span class="cm"> * Reverse threadgroup_lock().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">threadgroup_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_rwsem</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">threadgroup_change_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">threadgroup_change_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">threadgroup_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">threadgroup_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef __HAVE_THREAD_FUNCTIONS</span>

<span class="cp">#define task_thread_info(task)	((struct thread_info *)(task)-&gt;stack)</span>
<span class="cp">#define task_stack_page(task)	((task)-&gt;stack)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_thread_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">org</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">org</span><span class="p">);</span>
	<span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="nf">end_of_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">object_is_on_stack</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">stack</span> <span class="o">=</span> <span class="n">task_stack_page</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&gt;=</span> <span class="n">stack</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">stack</span> <span class="o">+</span> <span class="n">THREAD_SIZE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">thread_info_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_STACK_USAGE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">stack_not_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">end_of_stack</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span> 	<span class="cm">/* Skip over canary */</span>
		<span class="n">n</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!*</span><span class="n">n</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end_of_stack</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* set thread flags in other task&#39;s structures</span>
<span class="cm"> * - see asm/thread_info.h for TIF_xxxx flags available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_tsk_thread_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_ti_thread_flag</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_tsk_thread_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_ti_thread_flag</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_and_set_tsk_thread_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_set_ti_thread_flag</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_and_clear_tsk_thread_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_and_clear_ti_thread_flag</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_tsk_thread_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_ti_thread_flag</span><span class="p">(</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_tsk_need_resched</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span><span class="n">TIF_NEED_RESCHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_tsk_need_resched</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_tsk_thread_flag</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span><span class="n">TIF_NEED_RESCHED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">test_tsk_need_resched</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span><span class="n">TIF_NEED_RESCHED</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">restart_syscall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">TIF_SIGPENDING</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTNOINTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">signal_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">TIF_SIGPENDING</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__fatal_signal_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fatal_signal_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__fatal_signal_pending</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">signal_pending_state</span><span class="p">(</span><span class="kt">long</span> <span class="n">state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span> <span class="o">|</span> <span class="n">TASK_WAKEKILL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">)</span> <span class="o">||</span> <span class="n">__fatal_signal_pending</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">need_resched</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_NEED_RESCHED</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cond_resched() and cond_resched_lock(): latency reduction via</span>
<span class="cm"> * explicit rescheduling in places that are safe. The return</span>
<span class="cm"> * value indicates whether a reschedule was done in fact.</span>
<span class="cm"> * cond_resched_lock() will drop the spinlock before scheduling,</span>
<span class="cm"> * cond_resched_softirq() will enable bhs before scheduling.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">_cond_resched</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define cond_resched() ({			\</span>
<span class="cp">	__might_sleep(__FILE__, __LINE__, 0);	\</span>
<span class="cp">	_cond_resched();			\</span>
<span class="cp">})</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__cond_resched_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PREEMPT_COUNT</span>
<span class="cp">#define PREEMPT_LOCK_OFFSET	PREEMPT_OFFSET</span>
<span class="cp">#else</span>
<span class="cp">#define PREEMPT_LOCK_OFFSET	0</span>
<span class="cp">#endif</span>

<span class="cp">#define cond_resched_lock(lock) ({				\</span>
<span class="cp">	__might_sleep(__FILE__, __LINE__, PREEMPT_LOCK_OFFSET);	\</span>
<span class="cp">	__cond_resched_lock(lock);				\</span>
<span class="cp">})</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__cond_resched_softirq</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define cond_resched_softirq() ({					\</span>
<span class="cp">	__might_sleep(__FILE__, __LINE__, SOFTIRQ_DISABLE_OFFSET);	\</span>
<span class="cp">	__cond_resched_softirq();					\</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * Does a critical section need to be broken due to another</span>
<span class="cm"> * task waiting?: (technically does not depend on CONFIG_PREEMPT,</span>
<span class="cm"> * but a general need for low latency)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spin_needbreak</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PREEMPT</span>
	<span class="k">return</span> <span class="n">spin_is_contended</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Thread group CPU time accounting.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">thread_group_cputime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">times</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">thread_group_cputimer</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_cputime</span> <span class="o">*</span><span class="n">times</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">thread_group_cputime_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">cputimer</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reevaluate whether the task has signals pending delivery.</span>
<span class="cm"> * Wake the task if so.</span>
<span class="cm"> * This is required every time the blocked sigset_t changes.</span>
<span class="cm"> * callers must hold sighand-&gt;siglock.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">recalc_sigpending_and_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">recalc_sigpending</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">signal_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resume_stopped</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Wrappers for p-&gt;thread_info-&gt;cpu access. No-op on UP.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">task_cpu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_task_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">task_cpu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_task_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">long</span> <span class="n">sched_setaffinity</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sched_getaffinity</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">normalize_rt_tasks</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CGROUP_SCHED</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="n">root_task_group</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">sched_create_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_destroy_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sched_move_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sched_group_set_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shares</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sched_group_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_RT_GROUP_SCHED</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sched_group_set_rt_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
				      <span class="kt">long</span> <span class="n">rt_runtime_us</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sched_group_rt_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sched_group_set_rt_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
				      <span class="kt">long</span> <span class="n">rt_period_us</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">sched_group_rt_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sched_rt_can_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">task_can_switch_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">up</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TASK_XACCT</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_rchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">amt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">.</span><span class="n">rchar</span> <span class="o">+=</span> <span class="n">amt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_wchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">amt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">.</span><span class="n">wchar</span> <span class="o">+=</span> <span class="n">amt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_syscr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">.</span><span class="n">syscr</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_syscw</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">.</span><span class="n">syscw</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_rchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">amt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_wchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">amt</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_syscr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_syscw</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef TASK_SIZE_OF</span>
<span class="cp">#define TASK_SIZE_OF(tsk)	TASK_SIZE</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MM_OWNER</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mm_update_next_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mm_init_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mm_update_next_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mm_init_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MM_OWNER */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_rlimit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">limit</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_rlimit_max</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">limit</span><span class="p">].</span><span class="n">rlim_max</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">rlimit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_rlimit</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">rlimit_max</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_rlimit_max</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
