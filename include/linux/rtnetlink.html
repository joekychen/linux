<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › rtnetlink.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rtnetlink.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_RTNETLINK_H</span>
<span class="cp">#define __LINUX_RTNETLINK_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/if_link.h&gt;</span>
<span class="cp">#include &lt;linux/if_addr.h&gt;</span>
<span class="cp">#include &lt;linux/neighbour.h&gt;</span>

<span class="cm">/* rtnetlink families. Values up to 127 are reserved for real address</span>
<span class="cm"> * families, values above 128 may be used arbitrarily.</span>
<span class="cm"> */</span>
<span class="cp">#define RTNL_FAMILY_IPMR		128</span>
<span class="cp">#define RTNL_FAMILY_IP6MR		129</span>
<span class="cp">#define RTNL_FAMILY_MAX			129</span>

<span class="cm">/****</span>
<span class="cm"> *		Routing/neighbour discovery messages.</span>
<span class="cm"> ****/</span>

<span class="cm">/* Types of messages */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RTM_BASE</span>	<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="cp">#define RTM_BASE	RTM_BASE</span>

	<span class="n">RTM_NEWLINK</span>	<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="cp">#define RTM_NEWLINK	RTM_NEWLINK</span>
	<span class="n">RTM_DELLINK</span><span class="p">,</span>
<span class="cp">#define RTM_DELLINK	RTM_DELLINK</span>
	<span class="n">RTM_GETLINK</span><span class="p">,</span>
<span class="cp">#define RTM_GETLINK	RTM_GETLINK</span>
	<span class="n">RTM_SETLINK</span><span class="p">,</span>
<span class="cp">#define RTM_SETLINK	RTM_SETLINK</span>

	<span class="n">RTM_NEWADDR</span>	<span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
<span class="cp">#define RTM_NEWADDR	RTM_NEWADDR</span>
	<span class="n">RTM_DELADDR</span><span class="p">,</span>
<span class="cp">#define RTM_DELADDR	RTM_DELADDR</span>
	<span class="n">RTM_GETADDR</span><span class="p">,</span>
<span class="cp">#define RTM_GETADDR	RTM_GETADDR</span>

	<span class="n">RTM_NEWROUTE</span>	<span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
<span class="cp">#define RTM_NEWROUTE	RTM_NEWROUTE</span>
	<span class="n">RTM_DELROUTE</span><span class="p">,</span>
<span class="cp">#define RTM_DELROUTE	RTM_DELROUTE</span>
	<span class="n">RTM_GETROUTE</span><span class="p">,</span>
<span class="cp">#define RTM_GETROUTE	RTM_GETROUTE</span>

	<span class="n">RTM_NEWNEIGH</span>	<span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
<span class="cp">#define RTM_NEWNEIGH	RTM_NEWNEIGH</span>
	<span class="n">RTM_DELNEIGH</span><span class="p">,</span>
<span class="cp">#define RTM_DELNEIGH	RTM_DELNEIGH</span>
	<span class="n">RTM_GETNEIGH</span><span class="p">,</span>
<span class="cp">#define RTM_GETNEIGH	RTM_GETNEIGH</span>

	<span class="n">RTM_NEWRULE</span>	<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
<span class="cp">#define RTM_NEWRULE	RTM_NEWRULE</span>
	<span class="n">RTM_DELRULE</span><span class="p">,</span>
<span class="cp">#define RTM_DELRULE	RTM_DELRULE</span>
	<span class="n">RTM_GETRULE</span><span class="p">,</span>
<span class="cp">#define RTM_GETRULE	RTM_GETRULE</span>

	<span class="n">RTM_NEWQDISC</span>	<span class="o">=</span> <span class="mi">36</span><span class="p">,</span>
<span class="cp">#define RTM_NEWQDISC	RTM_NEWQDISC</span>
	<span class="n">RTM_DELQDISC</span><span class="p">,</span>
<span class="cp">#define RTM_DELQDISC	RTM_DELQDISC</span>
	<span class="n">RTM_GETQDISC</span><span class="p">,</span>
<span class="cp">#define RTM_GETQDISC	RTM_GETQDISC</span>

	<span class="n">RTM_NEWTCLASS</span>	<span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
<span class="cp">#define RTM_NEWTCLASS	RTM_NEWTCLASS</span>
	<span class="n">RTM_DELTCLASS</span><span class="p">,</span>
<span class="cp">#define RTM_DELTCLASS	RTM_DELTCLASS</span>
	<span class="n">RTM_GETTCLASS</span><span class="p">,</span>
<span class="cp">#define RTM_GETTCLASS	RTM_GETTCLASS</span>

	<span class="n">RTM_NEWTFILTER</span>	<span class="o">=</span> <span class="mi">44</span><span class="p">,</span>
<span class="cp">#define RTM_NEWTFILTER	RTM_NEWTFILTER</span>
	<span class="n">RTM_DELTFILTER</span><span class="p">,</span>
<span class="cp">#define RTM_DELTFILTER	RTM_DELTFILTER</span>
	<span class="n">RTM_GETTFILTER</span><span class="p">,</span>
<span class="cp">#define RTM_GETTFILTER	RTM_GETTFILTER</span>

	<span class="n">RTM_NEWACTION</span>	<span class="o">=</span> <span class="mi">48</span><span class="p">,</span>
<span class="cp">#define RTM_NEWACTION   RTM_NEWACTION</span>
	<span class="n">RTM_DELACTION</span><span class="p">,</span>
<span class="cp">#define RTM_DELACTION   RTM_DELACTION</span>
	<span class="n">RTM_GETACTION</span><span class="p">,</span>
<span class="cp">#define RTM_GETACTION   RTM_GETACTION</span>

	<span class="n">RTM_NEWPREFIX</span>	<span class="o">=</span> <span class="mi">52</span><span class="p">,</span>
<span class="cp">#define RTM_NEWPREFIX	RTM_NEWPREFIX</span>

	<span class="n">RTM_GETMULTICAST</span> <span class="o">=</span> <span class="mi">58</span><span class="p">,</span>
<span class="cp">#define RTM_GETMULTICAST RTM_GETMULTICAST</span>

	<span class="n">RTM_GETANYCAST</span>	<span class="o">=</span> <span class="mi">62</span><span class="p">,</span>
<span class="cp">#define RTM_GETANYCAST	RTM_GETANYCAST</span>

	<span class="n">RTM_NEWNEIGHTBL</span>	<span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
<span class="cp">#define RTM_NEWNEIGHTBL	RTM_NEWNEIGHTBL</span>
	<span class="n">RTM_GETNEIGHTBL</span>	<span class="o">=</span> <span class="mi">66</span><span class="p">,</span>
<span class="cp">#define RTM_GETNEIGHTBL	RTM_GETNEIGHTBL</span>
	<span class="n">RTM_SETNEIGHTBL</span><span class="p">,</span>
<span class="cp">#define RTM_SETNEIGHTBL	RTM_SETNEIGHTBL</span>

	<span class="n">RTM_NEWNDUSEROPT</span> <span class="o">=</span> <span class="mi">68</span><span class="p">,</span>
<span class="cp">#define RTM_NEWNDUSEROPT RTM_NEWNDUSEROPT</span>

	<span class="n">RTM_NEWADDRLABEL</span> <span class="o">=</span> <span class="mi">72</span><span class="p">,</span>
<span class="cp">#define RTM_NEWADDRLABEL RTM_NEWADDRLABEL</span>
	<span class="n">RTM_DELADDRLABEL</span><span class="p">,</span>
<span class="cp">#define RTM_DELADDRLABEL RTM_DELADDRLABEL</span>
	<span class="n">RTM_GETADDRLABEL</span><span class="p">,</span>
<span class="cp">#define RTM_GETADDRLABEL RTM_GETADDRLABEL</span>

	<span class="n">RTM_GETDCB</span> <span class="o">=</span> <span class="mi">78</span><span class="p">,</span>
<span class="cp">#define RTM_GETDCB RTM_GETDCB</span>
	<span class="n">RTM_SETDCB</span><span class="p">,</span>
<span class="cp">#define RTM_SETDCB RTM_SETDCB</span>

	<span class="n">__RTM_MAX</span><span class="p">,</span>
<span class="cp">#define RTM_MAX		(((__RTM_MAX + 3) &amp; ~3) - 1)</span>
<span class="p">};</span>

<span class="cp">#define RTM_NR_MSGTYPES	(RTM_MAX + 1 - RTM_BASE)</span>
<span class="cp">#define RTM_NR_FAMILIES	(RTM_NR_MSGTYPES &gt;&gt; 2)</span>
<span class="cp">#define RTM_FAM(cmd)	(((cmd) - RTM_BASE) &gt;&gt; 2)</span>

<span class="cm">/* </span>
<span class="cm">   Generic structure for encapsulation of optional route information.</span>
<span class="cm">   It is reminiscent of sockaddr, but with sa_family replaced</span>
<span class="cm">   with attribute type.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rtattr</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">rta_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">rta_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Macros to handle rtattributes */</span>

<span class="cp">#define RTA_ALIGNTO	4</span>
<span class="cp">#define RTA_ALIGN(len) ( ((len)+RTA_ALIGNTO-1) &amp; ~(RTA_ALIGNTO-1) )</span>
<span class="cp">#define RTA_OK(rta,len) ((len) &gt;= (int)sizeof(struct rtattr) &amp;&amp; \</span>
<span class="cp">			 (rta)-&gt;rta_len &gt;= sizeof(struct rtattr) &amp;&amp; \</span>
<span class="cp">			 (rta)-&gt;rta_len &lt;= (len))</span>
<span class="cp">#define RTA_NEXT(rta,attrlen)	((attrlen) -= RTA_ALIGN((rta)-&gt;rta_len), \</span>
<span class="cp">				 (struct rtattr*)(((char*)(rta)) + RTA_ALIGN((rta)-&gt;rta_len)))</span>
<span class="cp">#define RTA_LENGTH(len)	(RTA_ALIGN(sizeof(struct rtattr)) + (len))</span>
<span class="cp">#define RTA_SPACE(len)	RTA_ALIGN(RTA_LENGTH(len))</span>
<span class="cp">#define RTA_DATA(rta)   ((void*)(((char*)(rta)) + RTA_LENGTH(0)))</span>
<span class="cp">#define RTA_PAYLOAD(rta) ((int)((rta)-&gt;rta_len) - RTA_LENGTH(0))</span>




<span class="cm">/******************************************************************************</span>
<span class="cm"> *		Definitions used in routing table administration.</span>
<span class="cm"> ****/</span>

<span class="k">struct</span> <span class="n">rtmsg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtm_family</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtm_dst_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtm_src_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtm_tos</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtm_table</span><span class="p">;</span>	<span class="cm">/* Routing table id */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtm_protocol</span><span class="p">;</span>	<span class="cm">/* Routing protocol; see below	*/</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtm_scope</span><span class="p">;</span>	<span class="cm">/* See below */</span>	
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtm_type</span><span class="p">;</span>	<span class="cm">/* See below	*/</span>

	<span class="kt">unsigned</span>		<span class="n">rtm_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* rtm_type */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RTN_UNSPEC</span><span class="p">,</span>
	<span class="n">RTN_UNICAST</span><span class="p">,</span>		<span class="cm">/* Gateway or direct route	*/</span>
	<span class="n">RTN_LOCAL</span><span class="p">,</span>		<span class="cm">/* Accept locally		*/</span>
	<span class="n">RTN_BROADCAST</span><span class="p">,</span>		<span class="cm">/* Accept locally as broadcast,</span>
<span class="cm">				   send as broadcast */</span>
	<span class="n">RTN_ANYCAST</span><span class="p">,</span>		<span class="cm">/* Accept locally as broadcast,</span>
<span class="cm">				   but send as unicast */</span>
	<span class="n">RTN_MULTICAST</span><span class="p">,</span>		<span class="cm">/* Multicast route		*/</span>
	<span class="n">RTN_BLACKHOLE</span><span class="p">,</span>		<span class="cm">/* Drop				*/</span>
	<span class="n">RTN_UNREACHABLE</span><span class="p">,</span>	<span class="cm">/* Destination is unreachable   */</span>
	<span class="n">RTN_PROHIBIT</span><span class="p">,</span>		<span class="cm">/* Administratively prohibited	*/</span>
	<span class="n">RTN_THROW</span><span class="p">,</span>		<span class="cm">/* Not in this table		*/</span>
	<span class="n">RTN_NAT</span><span class="p">,</span>		<span class="cm">/* Translate this address	*/</span>
	<span class="n">RTN_XRESOLVE</span><span class="p">,</span>		<span class="cm">/* Use external resolver	*/</span>
	<span class="n">__RTN_MAX</span>
<span class="p">};</span>

<span class="cp">#define RTN_MAX (__RTN_MAX - 1)</span>


<span class="cm">/* rtm_protocol */</span>

<span class="cp">#define RTPROT_UNSPEC	0</span>
<span class="cp">#define RTPROT_REDIRECT	1	</span><span class="cm">/* Route installed by ICMP redirects;</span>
<span class="cm">				   not used by current IPv4 */</span><span class="cp"></span>
<span class="cp">#define RTPROT_KERNEL	2	</span><span class="cm">/* Route installed by kernel		*/</span><span class="cp"></span>
<span class="cp">#define RTPROT_BOOT	3	</span><span class="cm">/* Route installed during boot		*/</span><span class="cp"></span>
<span class="cp">#define RTPROT_STATIC	4	</span><span class="cm">/* Route installed by administrator	*/</span><span class="cp"></span>

<span class="cm">/* Values of protocol &gt;= RTPROT_STATIC are not interpreted by kernel;</span>
<span class="cm">   they are just passed from user and back as is.</span>
<span class="cm">   It will be used by hypothetical multiple routing daemons.</span>
<span class="cm">   Note that protocol values should be standardized in order to</span>
<span class="cm">   avoid conflicts.</span>
<span class="cm"> */</span>

<span class="cp">#define RTPROT_GATED	8	</span><span class="cm">/* Apparently, GateD */</span><span class="cp"></span>
<span class="cp">#define RTPROT_RA	9	</span><span class="cm">/* RDISC/ND router advertisements */</span><span class="cp"></span>
<span class="cp">#define RTPROT_MRT	10	</span><span class="cm">/* Merit MRT */</span><span class="cp"></span>
<span class="cp">#define RTPROT_ZEBRA	11	</span><span class="cm">/* Zebra */</span><span class="cp"></span>
<span class="cp">#define RTPROT_BIRD	12	</span><span class="cm">/* BIRD */</span><span class="cp"></span>
<span class="cp">#define RTPROT_DNROUTED	13	</span><span class="cm">/* DECnet routing daemon */</span><span class="cp"></span>
<span class="cp">#define RTPROT_XORP	14	</span><span class="cm">/* XORP */</span><span class="cp"></span>
<span class="cp">#define RTPROT_NTK	15	</span><span class="cm">/* Netsukuku */</span><span class="cp"></span>
<span class="cp">#define RTPROT_DHCP	16      </span><span class="cm">/* DHCP client */</span><span class="cp"></span>

<span class="cm">/* rtm_scope</span>

<span class="cm">   Really it is not scope, but sort of distance to the destination.</span>
<span class="cm">   NOWHERE are reserved for not existing destinations, HOST is our</span>
<span class="cm">   local addresses, LINK are destinations, located on directly attached</span>
<span class="cm">   link and UNIVERSE is everywhere in the Universe.</span>

<span class="cm">   Intermediate values are also possible f.e. interior routes</span>
<span class="cm">   could be assigned a value between UNIVERSE and LINK.</span>
<span class="cm">*/</span>

<span class="k">enum</span> <span class="n">rt_scope_t</span> <span class="p">{</span>
	<span class="n">RT_SCOPE_UNIVERSE</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="cm">/* User defined values  */</span>
	<span class="n">RT_SCOPE_SITE</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
	<span class="n">RT_SCOPE_LINK</span><span class="o">=</span><span class="mi">253</span><span class="p">,</span>
	<span class="n">RT_SCOPE_HOST</span><span class="o">=</span><span class="mi">254</span><span class="p">,</span>
	<span class="n">RT_SCOPE_NOWHERE</span><span class="o">=</span><span class="mi">255</span>
<span class="p">};</span>

<span class="cm">/* rtm_flags */</span>

<span class="cp">#define RTM_F_NOTIFY		0x100	</span><span class="cm">/* Notify user of route change	*/</span><span class="cp"></span>
<span class="cp">#define RTM_F_CLONED		0x200	</span><span class="cm">/* This route is cloned		*/</span><span class="cp"></span>
<span class="cp">#define RTM_F_EQUALIZE		0x400	</span><span class="cm">/* Multipath equalizer: NI	*/</span><span class="cp"></span>
<span class="cp">#define RTM_F_PREFIX		0x800	</span><span class="cm">/* Prefix addresses		*/</span><span class="cp"></span>

<span class="cm">/* Reserved table identifiers */</span>

<span class="k">enum</span> <span class="n">rt_class_t</span> <span class="p">{</span>
	<span class="n">RT_TABLE_UNSPEC</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="cm">/* User defined values */</span>
	<span class="n">RT_TABLE_COMPAT</span><span class="o">=</span><span class="mi">252</span><span class="p">,</span>
	<span class="n">RT_TABLE_DEFAULT</span><span class="o">=</span><span class="mi">253</span><span class="p">,</span>
	<span class="n">RT_TABLE_MAIN</span><span class="o">=</span><span class="mi">254</span><span class="p">,</span>
	<span class="n">RT_TABLE_LOCAL</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
	<span class="n">RT_TABLE_MAX</span><span class="o">=</span><span class="mh">0xFFFFFFFF</span>
<span class="p">};</span>


<span class="cm">/* Routing message attributes */</span>

<span class="k">enum</span> <span class="n">rtattr_type_t</span> <span class="p">{</span>
	<span class="n">RTA_UNSPEC</span><span class="p">,</span>
	<span class="n">RTA_DST</span><span class="p">,</span>
	<span class="n">RTA_SRC</span><span class="p">,</span>
	<span class="n">RTA_IIF</span><span class="p">,</span>
	<span class="n">RTA_OIF</span><span class="p">,</span>
	<span class="n">RTA_GATEWAY</span><span class="p">,</span>
	<span class="n">RTA_PRIORITY</span><span class="p">,</span>
	<span class="n">RTA_PREFSRC</span><span class="p">,</span>
	<span class="n">RTA_METRICS</span><span class="p">,</span>
	<span class="n">RTA_MULTIPATH</span><span class="p">,</span>
	<span class="n">RTA_PROTOINFO</span><span class="p">,</span> <span class="cm">/* no longer used */</span>
	<span class="n">RTA_FLOW</span><span class="p">,</span>
	<span class="n">RTA_CACHEINFO</span><span class="p">,</span>
	<span class="n">RTA_SESSION</span><span class="p">,</span> <span class="cm">/* no longer used */</span>
	<span class="n">RTA_MP_ALGO</span><span class="p">,</span> <span class="cm">/* no longer used */</span>
	<span class="n">RTA_TABLE</span><span class="p">,</span>
	<span class="n">RTA_MARK</span><span class="p">,</span>
	<span class="n">__RTA_MAX</span>
<span class="p">};</span>

<span class="cp">#define RTA_MAX (__RTA_MAX - 1)</span>

<span class="cp">#define RTM_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct rtmsg))))</span>
<span class="cp">#define RTM_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct rtmsg))</span>

<span class="cm">/* RTM_MULTIPATH --- array of struct rtnexthop.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;struct rtnexthop&quot; describes all necessary nexthop information,</span>
<span class="cm"> * i.e. parameters of path to a destination via this nexthop.</span>
<span class="cm"> *</span>
<span class="cm"> * At the moment it is impossible to set different prefsrc, mtu, window</span>
<span class="cm"> * and rtt for different paths from multipath.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">rtnexthop</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">rtnh_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtnh_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtnh_hops</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">rtnh_ifindex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* rtnh_flags */</span>

<span class="cp">#define RTNH_F_DEAD		1	</span><span class="cm">/* Nexthop is dead (used by multipath)	*/</span><span class="cp"></span>
<span class="cp">#define RTNH_F_PERVASIVE	2	</span><span class="cm">/* Do recursive gateway lookup	*/</span><span class="cp"></span>
<span class="cp">#define RTNH_F_ONLINK		4	</span><span class="cm">/* Gateway is forced on link	*/</span><span class="cp"></span>

<span class="cm">/* Macros to handle hexthops */</span>

<span class="cp">#define RTNH_ALIGNTO	4</span>
<span class="cp">#define RTNH_ALIGN(len) ( ((len)+RTNH_ALIGNTO-1) &amp; ~(RTNH_ALIGNTO-1) )</span>
<span class="cp">#define RTNH_OK(rtnh,len) ((rtnh)-&gt;rtnh_len &gt;= sizeof(struct rtnexthop) &amp;&amp; \</span>
<span class="cp">			   ((int)(rtnh)-&gt;rtnh_len) &lt;= (len))</span>
<span class="cp">#define RTNH_NEXT(rtnh)	((struct rtnexthop*)(((char*)(rtnh)) + RTNH_ALIGN((rtnh)-&gt;rtnh_len)))</span>
<span class="cp">#define RTNH_LENGTH(len) (RTNH_ALIGN(sizeof(struct rtnexthop)) + (len))</span>
<span class="cp">#define RTNH_SPACE(len)	RTNH_ALIGN(RTNH_LENGTH(len))</span>
<span class="cp">#define RTNH_DATA(rtnh)   ((struct rtattr*)(((char*)(rtnh)) + RTNH_LENGTH(0)))</span>

<span class="cm">/* RTM_CACHEINFO */</span>

<span class="k">struct</span> <span class="n">rta_cacheinfo</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">rta_clntref</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rta_lastuse</span><span class="p">;</span>
	<span class="n">__s32</span>	<span class="n">rta_expires</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rta_error</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rta_used</span><span class="p">;</span>

<span class="cp">#define RTNETLINK_HAVE_PEERINFO 1</span>
	<span class="n">__u32</span>	<span class="n">rta_id</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rta_ts</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rta_tsage</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* RTM_METRICS --- array of struct rtattr with types of RTAX_* */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RTAX_UNSPEC</span><span class="p">,</span>
<span class="cp">#define RTAX_UNSPEC RTAX_UNSPEC</span>
	<span class="n">RTAX_LOCK</span><span class="p">,</span>
<span class="cp">#define RTAX_LOCK RTAX_LOCK</span>
	<span class="n">RTAX_MTU</span><span class="p">,</span>
<span class="cp">#define RTAX_MTU RTAX_MTU</span>
	<span class="n">RTAX_WINDOW</span><span class="p">,</span>
<span class="cp">#define RTAX_WINDOW RTAX_WINDOW</span>
	<span class="n">RTAX_RTT</span><span class="p">,</span>
<span class="cp">#define RTAX_RTT RTAX_RTT</span>
	<span class="n">RTAX_RTTVAR</span><span class="p">,</span>
<span class="cp">#define RTAX_RTTVAR RTAX_RTTVAR</span>
	<span class="n">RTAX_SSTHRESH</span><span class="p">,</span>
<span class="cp">#define RTAX_SSTHRESH RTAX_SSTHRESH</span>
	<span class="n">RTAX_CWND</span><span class="p">,</span>
<span class="cp">#define RTAX_CWND RTAX_CWND</span>
	<span class="n">RTAX_ADVMSS</span><span class="p">,</span>
<span class="cp">#define RTAX_ADVMSS RTAX_ADVMSS</span>
	<span class="n">RTAX_REORDERING</span><span class="p">,</span>
<span class="cp">#define RTAX_REORDERING RTAX_REORDERING</span>
	<span class="n">RTAX_HOPLIMIT</span><span class="p">,</span>
<span class="cp">#define RTAX_HOPLIMIT RTAX_HOPLIMIT</span>
	<span class="n">RTAX_INITCWND</span><span class="p">,</span>
<span class="cp">#define RTAX_INITCWND RTAX_INITCWND</span>
	<span class="n">RTAX_FEATURES</span><span class="p">,</span>
<span class="cp">#define RTAX_FEATURES RTAX_FEATURES</span>
	<span class="n">RTAX_RTO_MIN</span><span class="p">,</span>
<span class="cp">#define RTAX_RTO_MIN RTAX_RTO_MIN</span>
	<span class="n">RTAX_INITRWND</span><span class="p">,</span>
<span class="cp">#define RTAX_INITRWND RTAX_INITRWND</span>
	<span class="n">__RTAX_MAX</span>
<span class="p">};</span>

<span class="cp">#define RTAX_MAX (__RTAX_MAX - 1)</span>

<span class="cp">#define RTAX_FEATURE_ECN	0x00000001</span>
<span class="cp">#define RTAX_FEATURE_SACK	0x00000002</span>
<span class="cp">#define RTAX_FEATURE_TIMESTAMP	0x00000004</span>
<span class="cp">#define RTAX_FEATURE_ALLFRAG	0x00000008</span>

<span class="k">struct</span> <span class="n">rta_session</span> <span class="p">{</span>
	<span class="n">__u8</span>	<span class="n">proto</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">pad1</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">pad2</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u16</span>	<span class="n">sport</span><span class="p">;</span>
			<span class="n">__u16</span>	<span class="n">dport</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">ports</span><span class="p">;</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span>	<span class="n">type</span><span class="p">;</span>
			<span class="n">__u8</span>	<span class="n">code</span><span class="p">;</span>
			<span class="n">__u16</span>	<span class="n">ident</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">icmpt</span><span class="p">;</span>

		<span class="n">__u32</span>		<span class="n">spi</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/****</span>
<span class="cm"> *		General form of address family dependent message.</span>
<span class="cm"> ****/</span>

<span class="k">struct</span> <span class="n">rtgenmsg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rtgen_family</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*****************************************************************</span>
<span class="cm"> *		Link layer specific messages.</span>
<span class="cm"> ****/</span>

<span class="cm">/* struct ifinfomsg</span>
<span class="cm"> * passes link level specific information, not dependent</span>
<span class="cm"> * on network protocol.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ifinfomsg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">ifi_family</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">__ifi_pad</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">ifi_type</span><span class="p">;</span>		<span class="cm">/* ARPHRD_* */</span>
	<span class="kt">int</span>		<span class="n">ifi_index</span><span class="p">;</span>		<span class="cm">/* Link index	*/</span>
	<span class="kt">unsigned</span>	<span class="n">ifi_flags</span><span class="p">;</span>		<span class="cm">/* IFF_* flags	*/</span>
	<span class="kt">unsigned</span>	<span class="n">ifi_change</span><span class="p">;</span>		<span class="cm">/* IFF_* change mask */</span>
<span class="p">};</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> *		prefix information </span>
<span class="cm"> ****/</span>

<span class="k">struct</span> <span class="n">prefixmsg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">prefix_family</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">prefix_pad1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">prefix_pad2</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">prefix_ifindex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">prefix_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">prefix_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">prefix_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">prefix_pad3</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> 
<span class="p">{</span>
	<span class="n">PREFIX_UNSPEC</span><span class="p">,</span>
	<span class="n">PREFIX_ADDRESS</span><span class="p">,</span>
	<span class="n">PREFIX_CACHEINFO</span><span class="p">,</span>
	<span class="n">__PREFIX_MAX</span>
<span class="p">};</span>

<span class="cp">#define PREFIX_MAX	(__PREFIX_MAX - 1)</span>

<span class="k">struct</span> <span class="n">prefix_cacheinfo</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">preferred_time</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">valid_time</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*****************************************************************</span>
<span class="cm"> *		Traffic control messages.</span>
<span class="cm"> ****/</span>

<span class="k">struct</span> <span class="n">tcmsg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tcm_family</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tcm__pad1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">tcm__pad2</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">tcm_ifindex</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">tcm_handle</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">tcm_parent</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">tcm_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TCA_UNSPEC</span><span class="p">,</span>
	<span class="n">TCA_KIND</span><span class="p">,</span>
	<span class="n">TCA_OPTIONS</span><span class="p">,</span>
	<span class="n">TCA_STATS</span><span class="p">,</span>
	<span class="n">TCA_XSTATS</span><span class="p">,</span>
	<span class="n">TCA_RATE</span><span class="p">,</span>
	<span class="n">TCA_FCNT</span><span class="p">,</span>
	<span class="n">TCA_STATS2</span><span class="p">,</span>
	<span class="n">TCA_STAB</span><span class="p">,</span>
	<span class="n">__TCA_MAX</span>
<span class="p">};</span>

<span class="cp">#define TCA_MAX (__TCA_MAX - 1)</span>

<span class="cp">#define TCA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcmsg))))</span>
<span class="cp">#define TCA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcmsg))</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> *		Neighbor Discovery userland options</span>
<span class="cm"> ****/</span>

<span class="k">struct</span> <span class="n">nduseroptmsg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">nduseropt_family</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">nduseropt_pad1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">nduseropt_opts_len</span><span class="p">;</span>	<span class="cm">/* Total length of options */</span>
	<span class="kt">int</span>		<span class="n">nduseropt_ifindex</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">nduseropt_icmp_type</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">nduseropt_icmp_code</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">nduseropt_pad2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">nduseropt_pad3</span><span class="p">;</span>
	<span class="cm">/* Followed by one or more ND options */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NDUSEROPT_UNSPEC</span><span class="p">,</span>
	<span class="n">NDUSEROPT_SRCADDR</span><span class="p">,</span>
	<span class="n">__NDUSEROPT_MAX</span>
<span class="p">};</span>

<span class="cp">#define NDUSEROPT_MAX	(__NDUSEROPT_MAX - 1)</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="cm">/* RTnetlink multicast groups - backwards compatibility for userspace */</span>
<span class="cp">#define RTMGRP_LINK		1</span>
<span class="cp">#define RTMGRP_NOTIFY		2</span>
<span class="cp">#define RTMGRP_NEIGH		4</span>
<span class="cp">#define RTMGRP_TC		8</span>

<span class="cp">#define RTMGRP_IPV4_IFADDR	0x10</span>
<span class="cp">#define RTMGRP_IPV4_MROUTE	0x20</span>
<span class="cp">#define RTMGRP_IPV4_ROUTE	0x40</span>
<span class="cp">#define RTMGRP_IPV4_RULE	0x80</span>

<span class="cp">#define RTMGRP_IPV6_IFADDR	0x100</span>
<span class="cp">#define RTMGRP_IPV6_MROUTE	0x200</span>
<span class="cp">#define RTMGRP_IPV6_ROUTE	0x400</span>
<span class="cp">#define RTMGRP_IPV6_IFINFO	0x800</span>

<span class="cp">#define RTMGRP_DECnet_IFADDR    0x1000</span>
<span class="cp">#define RTMGRP_DECnet_ROUTE     0x4000</span>

<span class="cp">#define RTMGRP_IPV6_PREFIX	0x20000</span>
<span class="cp">#endif</span>

<span class="cm">/* RTnetlink multicast groups */</span>
<span class="k">enum</span> <span class="n">rtnetlink_groups</span> <span class="p">{</span>
	<span class="n">RTNLGRP_NONE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_NONE		RTNLGRP_NONE</span>
	<span class="n">RTNLGRP_LINK</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_LINK		RTNLGRP_LINK</span>
	<span class="n">RTNLGRP_NOTIFY</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_NOTIFY		RTNLGRP_NOTIFY</span>
	<span class="n">RTNLGRP_NEIGH</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_NEIGH		RTNLGRP_NEIGH</span>
	<span class="n">RTNLGRP_TC</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_TC		RTNLGRP_TC</span>
	<span class="n">RTNLGRP_IPV4_IFADDR</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV4_IFADDR	RTNLGRP_IPV4_IFADDR</span>
	<span class="n">RTNLGRP_IPV4_MROUTE</span><span class="p">,</span>
<span class="cp">#define	RTNLGRP_IPV4_MROUTE	RTNLGRP_IPV4_MROUTE</span>
	<span class="n">RTNLGRP_IPV4_ROUTE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV4_ROUTE	RTNLGRP_IPV4_ROUTE</span>
	<span class="n">RTNLGRP_IPV4_RULE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV4_RULE	RTNLGRP_IPV4_RULE</span>
	<span class="n">RTNLGRP_IPV6_IFADDR</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV6_IFADDR	RTNLGRP_IPV6_IFADDR</span>
	<span class="n">RTNLGRP_IPV6_MROUTE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV6_MROUTE	RTNLGRP_IPV6_MROUTE</span>
	<span class="n">RTNLGRP_IPV6_ROUTE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV6_ROUTE	RTNLGRP_IPV6_ROUTE</span>
	<span class="n">RTNLGRP_IPV6_IFINFO</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV6_IFINFO	RTNLGRP_IPV6_IFINFO</span>
	<span class="n">RTNLGRP_DECnet_IFADDR</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_DECnet_IFADDR	RTNLGRP_DECnet_IFADDR</span>
	<span class="n">RTNLGRP_NOP2</span><span class="p">,</span>
	<span class="n">RTNLGRP_DECnet_ROUTE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_DECnet_ROUTE	RTNLGRP_DECnet_ROUTE</span>
	<span class="n">RTNLGRP_DECnet_RULE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_DECnet_RULE	RTNLGRP_DECnet_RULE</span>
	<span class="n">RTNLGRP_NOP4</span><span class="p">,</span>
	<span class="n">RTNLGRP_IPV6_PREFIX</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV6_PREFIX	RTNLGRP_IPV6_PREFIX</span>
	<span class="n">RTNLGRP_IPV6_RULE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_IPV6_RULE	RTNLGRP_IPV6_RULE</span>
	<span class="n">RTNLGRP_ND_USEROPT</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_ND_USEROPT	RTNLGRP_ND_USEROPT</span>
	<span class="n">RTNLGRP_PHONET_IFADDR</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_PHONET_IFADDR	RTNLGRP_PHONET_IFADDR</span>
	<span class="n">RTNLGRP_PHONET_ROUTE</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_PHONET_ROUTE	RTNLGRP_PHONET_ROUTE</span>
	<span class="n">RTNLGRP_DCB</span><span class="p">,</span>
<span class="cp">#define RTNLGRP_DCB		RTNLGRP_DCB</span>
	<span class="n">__RTNLGRP_MAX</span>
<span class="p">};</span>
<span class="cp">#define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)</span>

<span class="cm">/* TC action piece */</span>
<span class="k">struct</span> <span class="n">tcamsg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tca_family</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tca__pad1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">tca__pad2</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define TA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcamsg))))</span>
<span class="cp">#define TA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcamsg))</span>
<span class="cp">#define TCA_ACT_TAB 1 </span><span class="cm">/* attr type must be &gt;=1 */</span><span class="cp">	</span>
<span class="cp">#define TCAA_MAX 1</span>

<span class="cm">/* New extended info filters for IFLA_EXT_MASK */</span>
<span class="cp">#define RTEXT_FILTER_VF		(1 &lt;&lt; 0)</span>

<span class="cm">/* End of information exported to user level */</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">rtattr_strcmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rtattr</span> <span class="o">*</span><span class="n">rta</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">rta</span><span class="o">-&gt;</span><span class="n">rta_len</span> <span class="o">||</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">RTA_DATA</span><span class="p">(</span><span class="n">rta</span><span class="p">),</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">rtnetlink_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">echo</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rtnl_unicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rtnl_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rtnl_set_sk_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="n">u32</span> <span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rtnetlink_put_metrics</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">metrics</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rtnl_put_cacheinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">id</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ts</span><span class="p">,</span> <span class="n">u32</span> <span class="n">tsage</span><span class="p">,</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">error</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__rta_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrlen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cp">#define RTA_PUT(skb, attrtype, attrlen, data) \</span>
<span class="cp">({	if (unlikely(skb_tailroom(skb) &lt; (int)RTA_SPACE(attrlen))) \</span>
<span class="cp">		 goto rtattr_failure; \</span>
<span class="cp">   	__rta_fill(skb, attrtype, attrlen, data); }) </span>

<span class="cp">#define RTA_APPEND(skb, attrlen, data) \</span>
<span class="cp">({	if (unlikely(skb_tailroom(skb) &lt; (int)(attrlen))) \</span>
<span class="cp">		goto rtattr_failure; \</span>
<span class="cp">	memcpy(skb_put(skb, attrlen), data, attrlen); })</span>

<span class="cp">#define RTA_PUT_NOHDR(skb, attrlen, data) \</span>
<span class="cp">({	RTA_APPEND(skb, RTA_ALIGN(attrlen), data); \</span>
<span class="cp">	memset(skb_tail_pointer(skb) - (RTA_ALIGN(attrlen) - attrlen), 0, \</span>
<span class="cp">	       RTA_ALIGN(attrlen) - attrlen); })</span>

<span class="cp">#define RTA_PUT_U8(skb, attrtype, value) \</span>
<span class="cp">({	u8 _tmp = (value); \</span>
<span class="cp">	RTA_PUT(skb, attrtype, sizeof(u8), &amp;_tmp); })</span>

<span class="cp">#define RTA_PUT_U16(skb, attrtype, value) \</span>
<span class="cp">({	u16 _tmp = (value); \</span>
<span class="cp">	RTA_PUT(skb, attrtype, sizeof(u16), &amp;_tmp); })</span>

<span class="cp">#define RTA_PUT_U32(skb, attrtype, value) \</span>
<span class="cp">({	u32 _tmp = (value); \</span>
<span class="cp">	RTA_PUT(skb, attrtype, sizeof(u32), &amp;_tmp); })</span>

<span class="cp">#define RTA_PUT_U64(skb, attrtype, value) \</span>
<span class="cp">({	u64 _tmp = (value); \</span>
<span class="cp">	RTA_PUT(skb, attrtype, sizeof(u64), &amp;_tmp); })</span>

<span class="cp">#define RTA_PUT_SECS(skb, attrtype, value) \</span>
<span class="cp">	RTA_PUT_U64(skb, attrtype, (value) / HZ)</span>

<span class="cp">#define RTA_PUT_MSECS(skb, attrtype, value) \</span>
<span class="cp">	RTA_PUT_U64(skb, attrtype, jiffies_to_msecs(value))</span>

<span class="cp">#define RTA_PUT_STRING(skb, attrtype, value) \</span>
<span class="cp">	RTA_PUT(skb, attrtype, strlen(value) + 1, value)</span>

<span class="cp">#define RTA_PUT_FLAG(skb, attrtype) \</span>
<span class="cp">	RTA_PUT(skb, attrtype, 0, NULL);</span>

<span class="cp">#define RTA_NEST(skb, type) \</span>
<span class="cp">({	struct rtattr *__start = (struct rtattr *)skb_tail_pointer(skb); \</span>
<span class="cp">	RTA_PUT(skb, type, 0, NULL); \</span>
<span class="cp">	__start;  })</span>

<span class="cp">#define RTA_NEST_END(skb, start) \</span>
<span class="cp">({	(start)-&gt;rta_len = skb_tail_pointer(skb) - (unsigned char *)(start); \</span>
<span class="cp">	(skb)-&gt;len; })</span>

<span class="cp">#define RTA_NEST_COMPAT(skb, type, attrlen, data) \</span>
<span class="cp">({	struct rtattr *__start = (struct rtattr *)skb_tail_pointer(skb); \</span>
<span class="cp">	RTA_PUT(skb, type, attrlen, data); \</span>
<span class="cp">	RTA_NEST(skb, type); \</span>
<span class="cp">	__start; })</span>

<span class="cp">#define RTA_NEST_COMPAT_END(skb, start) \</span>
<span class="cp">({	struct rtattr *__nest = (void *)(start) + NLMSG_ALIGN((start)-&gt;rta_len); \</span>
<span class="cp">	(start)-&gt;rta_len = skb_tail_pointer(skb) - (unsigned char *)(start); \</span>
<span class="cp">	RTA_NEST_END(skb, __nest); \</span>
<span class="cp">	(skb)-&gt;len; })</span>

<span class="cp">#define RTA_NEST_CANCEL(skb, start) \</span>
<span class="cp">({	if (start) \</span>
<span class="cp">		skb_trim(skb, (unsigned char *) (start) - (skb)-&gt;data); \</span>
<span class="cp">	-1; })</span>

<span class="cp">#define RTA_GET_U8(rta) \</span>
<span class="cp">({	if (!rta || RTA_PAYLOAD(rta) &lt; sizeof(u8)) \</span>
<span class="cp">		goto rtattr_failure; \</span>
<span class="cp">	*(u8 *) RTA_DATA(rta); })</span>

<span class="cp">#define RTA_GET_U16(rta) \</span>
<span class="cp">({	if (!rta || RTA_PAYLOAD(rta) &lt; sizeof(u16)) \</span>
<span class="cp">		goto rtattr_failure; \</span>
<span class="cp">	*(u16 *) RTA_DATA(rta); })</span>

<span class="cp">#define RTA_GET_U32(rta) \</span>
<span class="cp">({	if (!rta || RTA_PAYLOAD(rta) &lt; sizeof(u32)) \</span>
<span class="cp">		goto rtattr_failure; \</span>
<span class="cp">	*(u32 *) RTA_DATA(rta); })</span>

<span class="cp">#define RTA_GET_U64(rta) \</span>
<span class="cp">({	u64 _tmp; \</span>
<span class="cp">	if (!rta || RTA_PAYLOAD(rta) &lt; sizeof(u64)) \</span>
<span class="cp">		goto rtattr_failure; \</span>
<span class="cp">	memcpy(&amp;_tmp, RTA_DATA(rta), sizeof(_tmp)); \</span>
<span class="cp">	_tmp; })</span>

<span class="cp">#define RTA_GET_FLAG(rta) (!!(rta))</span>

<span class="cp">#define RTA_GET_SECS(rta) ((unsigned long) RTA_GET_U64(rta) * HZ)</span>
<span class="cp">#define RTA_GET_MSECS(rta) (msecs_to_jiffies((unsigned long) RTA_GET_U64(rta)))</span>
		
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rtattr</span> <span class="o">*</span>
<span class="nf">__rta_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrtype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtattr</span> <span class="o">*</span><span class="n">rta</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">RTA_LENGTH</span><span class="p">(</span><span class="n">attrlen</span><span class="p">);</span>

	<span class="n">rta</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtattr</span><span class="o">*</span><span class="p">)</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">RTA_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
	<span class="n">rta</span><span class="o">-&gt;</span><span class="n">rta_type</span> <span class="o">=</span> <span class="n">attrtype</span><span class="p">;</span>
	<span class="n">rta</span><span class="o">-&gt;</span><span class="n">rta_len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">RTA_DATA</span><span class="p">(</span><span class="n">rta</span><span class="p">)</span> <span class="o">+</span> <span class="n">attrlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RTA_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __RTA_PUT(skb, attrtype, attrlen) \</span>
<span class="cp">({ 	if (unlikely(skb_tailroom(skb) &lt; (int)RTA_SPACE(attrlen))) \</span>
<span class="cp">		goto rtattr_failure; \</span>
<span class="cp">   	__rta_reserve(skb, attrtype, attrlen); })</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">change</span><span class="p">);</span>

<span class="cm">/* RTNL is used as a global lock for all changes to network configuration  */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rtnl_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rtnl_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rtnl_trylock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">rtnl_is_locked</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PROVE_LOCKING</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">lockdep_rtnl_is_held</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_PROVE_LOCKING */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * rcu_dereference_rtnl - rcu_dereference with debug checking</span>
<span class="cm"> * @p: The pointer to read, prior to dereferencing</span>
<span class="cm"> *</span>
<span class="cm"> * Do an rcu_dereference(p), but check caller either holds rcu_read_lock()</span>
<span class="cm"> * or RTNL. Note : Please prefer rtnl_dereference() or rcu_dereference()</span>
<span class="cm"> */</span>
<span class="cp">#define rcu_dereference_rtnl(p)					\</span>
<span class="cp">	rcu_dereference_check(p, lockdep_rtnl_is_held())</span>

<span class="cm">/**</span>
<span class="cm"> * rtnl_dereference - fetch RCU pointer when updates are prevented by RTNL</span>
<span class="cm"> * @p: The pointer to read, prior to dereferencing</span>
<span class="cm"> *</span>
<span class="cm"> * Return the value of the specified RCU-protected pointer, but omit</span>
<span class="cm"> * both the smp_read_barrier_depends() and the ACCESS_ONCE(), because</span>
<span class="cm"> * caller holds RTNL.</span>
<span class="cm"> */</span>
<span class="cp">#define rtnl_dereference(p)					\</span>
<span class="cp">	rcu_dereference_protected(p, lockdep_rtnl_is_held())</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="nf">dev_ingress_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ingress_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">dev_ingress_queue_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">rtnetlink_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__rtnl_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define ASSERT_RTNL() do { \</span>
<span class="cp">	if (unlikely(!rtnl_is_locked())) { \</span>
<span class="cp">		printk(KERN_ERR &quot;RTNL: assertion failed at %s (%d)\n&quot;, \</span>
<span class="cp">		       __FILE__,  __LINE__); \</span>
<span class="cp">		dump_stack(); \</span>
<span class="cp">	} \</span>
<span class="cp">} while(0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">rtm_get_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtattr</span> <span class="o">**</span><span class="n">rta</span><span class="p">,</span> <span class="n">u8</span> <span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">RTA_GET_U32</span><span class="p">(</span><span class="n">rta</span><span class="p">[</span><span class="n">RTA_TABLE</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="nl">rtattr_failure:</span>
	<span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ndo_dflt_fdb_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>


<span class="cp">#endif	</span><span class="cm">/* __LINUX_RTNETLINK_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
