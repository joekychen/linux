<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › rmap.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rmap.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_RMAP_H</span>
<span class="cp">#define _LINUX_RMAP_H</span>
<span class="cm">/*</span>
<span class="cm"> * Declarations for Reverse Mapping functions in mm/rmap.c</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The anon_vma heads a list of private &quot;related&quot; vmas, to scan if</span>
<span class="cm"> * an anonymous page pointing to this anon_vma needs to be unmapped:</span>
<span class="cm"> * the vmas on the list will be related by forking, or by splitting.</span>
<span class="cm"> *</span>
<span class="cm"> * Since vmas come and go as they are split and merged (particularly</span>
<span class="cm"> * in mprotect), the mapping field of an anonymous page cannot point</span>
<span class="cm"> * directly to a vma: instead it points to an anon_vma, on whose list</span>
<span class="cm"> * the related vmas can be easily linked or unlinked.</span>
<span class="cm"> *</span>
<span class="cm"> * After unlinking the last vma on the list, we must garbage collect</span>
<span class="cm"> * the anon_vma object itself: we&#39;re guaranteed no page can be</span>
<span class="cm"> * pointing to this anon_vma once its vma list is empty.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">anon_vma</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>	<span class="cm">/* Root of this anon_vma tree */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>	<span class="cm">/* Serialize access to vma list */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The refcount is taken on an anon_vma when there is no</span>
<span class="cm">	 * guarantee that the vma of page tables will exist for</span>
<span class="cm">	 * the duration of the operation. A caller that takes</span>
<span class="cm">	 * the reference is responsible for clearing up the</span>
<span class="cm">	 * anon_vma if they are the last user on release</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span> <span class="n">refcount</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: the LSB of the head.next is set by</span>
<span class="cm">	 * mm_take_all_locks() _after_ taking the above lock. So the</span>
<span class="cm">	 * head must only be read/written after taking the above lock</span>
<span class="cm">	 * to be sure to see a valid next pointer. The LSB bit itself</span>
<span class="cm">	 * is serialized by a system wide lock only visible to</span>
<span class="cm">	 * mm_take_all_locks() (mm_all_locks_mutex).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>	<span class="cm">/* Chain of private &quot;related&quot; vmas */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The copy-on-write semantics of fork mean that an anon_vma</span>
<span class="cm"> * can become associated with multiple processes. Furthermore,</span>
<span class="cm"> * each child process will have its own anon_vma, where new</span>
<span class="cm"> * pages for that process are instantiated.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure allows us to find the anon_vmas associated</span>
<span class="cm"> * with a VMA, or the VMAs associated with an anon_vma.</span>
<span class="cm"> * The &quot;same_vma&quot; list contains the anon_vma_chains linking</span>
<span class="cm"> * all the anon_vmas associated with this VMA.</span>
<span class="cm"> * The &quot;same_anon_vma&quot; list contains the anon_vma_chains</span>
<span class="cm"> * which link all the VMAs associated with this anon_vma.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">same_vma</span><span class="p">;</span>   <span class="cm">/* locked by mmap_sem &amp; page_table_lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">same_anon_vma</span><span class="p">;</span>	<span class="cm">/* locked by anon_vma-&gt;mutex */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__put_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
		<span class="n">__put_anon_vma</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="nf">page_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;</span> <span class="n">PAGE_MAPPING_FLAGS</span><span class="p">)</span> <span class="o">!=</span>
					    <span class="n">PAGE_MAPPING_ANON</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">page_rmapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vma_lock_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vma_unlock_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">anon_vma_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">anon_vma_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * anon_vma helper functions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">anon_vma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>	<span class="cm">/* create anon_vma_cachep */</span>
<span class="kt">int</span>  <span class="n">anon_vma_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unlink_anon_vmas</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">anon_vma_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">anon_vma_moveto_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">anon_vma_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">anon_vma_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">!=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="n">unlink_anon_vmas</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">page_get_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * rmap interfaces called when adding or removing pte of page</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">page_move_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_add_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">do_page_add_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_add_new_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_add_file_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_remove_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">hugepage_add_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hugepage_add_new_anon_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">page_dup_rmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from mm/vmscan.c to handle paging out</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">page_referenced</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_locked</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">page_referenced_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mapcount</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">ttu_flags</span> <span class="p">{</span>
	<span class="n">TTU_UNMAP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>			<span class="cm">/* unmap mode */</span>
	<span class="n">TTU_MIGRATION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* migration mode */</span>
	<span class="n">TTU_MUNLOCK</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>		<span class="cm">/* munlock mode */</span>
	<span class="n">TTU_ACTION_MASK</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>

	<span class="n">TTU_IGNORE_MLOCK</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* ignore mlock */</span>
	<span class="n">TTU_IGNORE_ACCESS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>	<span class="cm">/* don&#39;t age */</span>
	<span class="n">TTU_IGNORE_HWPOISON</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span><span class="cm">/* corrupted page is recoverable */</span>
<span class="p">};</span>
<span class="cp">#define TTU_ACTION(x) ((x) &amp; TTU_ACTION_MASK)</span>

<span class="kt">int</span> <span class="n">try_to_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ttu_flags</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">try_to_unmap_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ttu_flags</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called from mm/filemap_xip.c to unmap empty zero page</span>
<span class="cm"> */</span>
<span class="n">pte_t</span> <span class="o">*</span><span class="n">__page_check_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">spinlock_t</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="o">*</span><span class="nf">page_check_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">spinlock_t</span> <span class="o">**</span><span class="n">ptlp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

	<span class="n">__cond_lock</span><span class="p">(</span><span class="o">*</span><span class="n">ptlp</span><span class="p">,</span> <span class="n">ptep</span> <span class="o">=</span> <span class="n">__page_check_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
						       <span class="n">ptlp</span><span class="p">,</span> <span class="n">sync</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ptep</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used by swapoff to help locate where page is expected in vma.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_address_in_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Cleans the PTEs of shared mappings.</span>
<span class="cm"> * (and since clean PTEs should also be readonly, write protects them too)</span>
<span class="cm"> *</span>
<span class="cm"> * returns the number of cleaned PTEs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">page_mkclean</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * called in munlock()/munmap() path to check for other vmas holding</span>
<span class="cm"> * the page mlocked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">try_to_munlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called by memory-failure.c to kill processes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">page_lock_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_unlock_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">page_mapped_in_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called by migrate.c to remove migration ptes, but might be used more later.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">rmap_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmap_one</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="cp">#else	</span><span class="cm">/* !CONFIG_MMU */</span><span class="cp"></span>

<span class="cp">#define anon_vma_init()		do {} while (0)</span>
<span class="cp">#define anon_vma_prepare(vma)	(0)</span>
<span class="cp">#define anon_vma_link(vma)	do {} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_referenced</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_locked</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define try_to_unmap(page, refs) SWAP_FAIL</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_mkclean</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#endif	</span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Return values of try_to_unmap</span>
<span class="cm"> */</span>
<span class="cp">#define SWAP_SUCCESS	0</span>
<span class="cp">#define SWAP_AGAIN	1</span>
<span class="cp">#define SWAP_FAIL	2</span>
<span class="cp">#define SWAP_MLOCK	3</span>

<span class="cp">#endif	</span><span class="cm">/* _LINUX_RMAP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
