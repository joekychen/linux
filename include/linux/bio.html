<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › bio.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>bio.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * 2.5 block I/O model</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001 Jens Axboe &lt;axboe@suse.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public Licens</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LINUX_BIO_H</span>
<span class="cp">#define __LINUX_BIO_H</span>

<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/ioprio.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cm">/* struct bio, bio_vec and BIO_* flags are defined in blk_types.h */</span>
<span class="cp">#include &lt;linux/blk_types.h&gt;</span>

<span class="cp">#define BIO_DEBUG</span>

<span class="cp">#ifdef BIO_DEBUG</span>
<span class="cp">#define BIO_BUG_ON	BUG_ON</span>
<span class="cp">#else</span>
<span class="cp">#define BIO_BUG_ON</span>
<span class="cp">#endif</span>

<span class="cp">#define BIO_MAX_PAGES		256</span>
<span class="cp">#define BIO_MAX_SIZE		(BIO_MAX_PAGES &lt;&lt; PAGE_CACHE_SHIFT)</span>
<span class="cp">#define BIO_MAX_SECTORS		(BIO_MAX_SIZE &gt;&gt; 9)</span>

<span class="cm">/*</span>
<span class="cm"> * upper 16 bits of bi_rw define the io priority of this bio</span>
<span class="cm"> */</span>
<span class="cp">#define BIO_PRIO_SHIFT	(8 * sizeof(unsigned long) - IOPRIO_BITS)</span>
<span class="cp">#define bio_prio(bio)	((bio)-&gt;bi_rw &gt;&gt; BIO_PRIO_SHIFT)</span>
<span class="cp">#define bio_prio_valid(bio)	ioprio_valid(bio_prio(bio))</span>

<span class="cp">#define bio_set_prio(bio, prio)		do {			\</span>
<span class="cp">	WARN_ON(prio &gt;= (1 &lt;&lt; IOPRIO_BITS));			\</span>
<span class="cp">	(bio)-&gt;bi_rw &amp;= ((1UL &lt;&lt; BIO_PRIO_SHIFT) - 1);		\</span>
<span class="cp">	(bio)-&gt;bi_rw |= ((unsigned long) (prio) &lt;&lt; BIO_PRIO_SHIFT);	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * various member access, note that bio_data should of course not be used</span>
<span class="cm"> * on highmem page vectors</span>
<span class="cm"> */</span>
<span class="cp">#define bio_iovec_idx(bio, idx)	(&amp;((bio)-&gt;bi_io_vec[(idx)]))</span>
<span class="cp">#define bio_iovec(bio)		bio_iovec_idx((bio), (bio)-&gt;bi_idx)</span>
<span class="cp">#define bio_page(bio)		bio_iovec((bio))-&gt;bv_page</span>
<span class="cp">#define bio_offset(bio)		bio_iovec((bio))-&gt;bv_offset</span>
<span class="cp">#define bio_segments(bio)	((bio)-&gt;bi_vcnt - (bio)-&gt;bi_idx)</span>
<span class="cp">#define bio_sectors(bio)	((bio)-&gt;bi_size &gt;&gt; 9)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bio_cur_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bio_iovec</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* dataless requests such as discard */</span>
		<span class="k">return</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">bio_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">page_address</span><span class="p">(</span><span class="n">bio_page</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span> <span class="o">+</span> <span class="n">bio_offset</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_has_allocated_vec</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">&amp;&amp;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">!=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_inline_vecs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * will die</span>
<span class="cm"> */</span>
<span class="cp">#define bio_to_phys(bio)	(page_to_phys(bio_page((bio))) + (unsigned long) bio_offset((bio)))</span>
<span class="cp">#define bvec_to_phys(bv)	(page_to_phys((bv)-&gt;bv_page) + (unsigned long) (bv)-&gt;bv_offset)</span>

<span class="cm">/*</span>
<span class="cm"> * queues that have highmem support enabled may still need to revert to</span>
<span class="cm"> * PIO transfers occasionally and thus map high pages temporarily. For</span>
<span class="cm"> * permanent PIO fall back, user is probably better off disabling highmem</span>
<span class="cm"> * I/O completely on that queue (see ide-dma for example)</span>
<span class="cm"> */</span>
<span class="cp">#define __bio_kmap_atomic(bio, idx, kmtype)				\</span>
<span class="cp">	(kmap_atomic(bio_iovec_idx((bio), (idx))-&gt;bv_page) +	\</span>
<span class="cp">		bio_iovec_idx((bio), (idx))-&gt;bv_offset)</span>

<span class="cp">#define __bio_kunmap_atomic(addr, kmtype) kunmap_atomic(addr)</span>

<span class="cm">/*</span>
<span class="cm"> * merge helpers etc</span>
<span class="cm"> */</span>

<span class="cp">#define __BVEC_END(bio)		bio_iovec_idx((bio), (bio)-&gt;bi_vcnt - 1)</span>
<span class="cp">#define __BVEC_START(bio)	bio_iovec_idx((bio), (bio)-&gt;bi_idx)</span>

<span class="cm">/* Default implementation of BIOVEC_PHYS_MERGEABLE */</span>
<span class="cp">#define __BIOVEC_PHYS_MERGEABLE(vec1, vec2)	\</span>
<span class="cp">	((bvec_to_phys((vec1)) + (vec1)-&gt;bv_len) == bvec_to_phys((vec2)))</span>

<span class="cm">/*</span>
<span class="cm"> * allow arch override, for eg virtualized architectures (put in asm/io.h)</span>
<span class="cm"> */</span>
<span class="cp">#ifndef BIOVEC_PHYS_MERGEABLE</span>
<span class="cp">#define BIOVEC_PHYS_MERGEABLE(vec1, vec2)	\</span>
<span class="cp">	__BIOVEC_PHYS_MERGEABLE(vec1, vec2)</span>
<span class="cp">#endif</span>

<span class="cp">#define __BIO_SEG_BOUNDARY(addr1, addr2, mask) \</span>
<span class="cp">	(((addr1) | (mask)) == (((addr2) - 1) | (mask)))</span>
<span class="cp">#define BIOVEC_SEG_BOUNDARY(q, b1, b2) \</span>
<span class="cp">	__BIO_SEG_BOUNDARY(bvec_to_phys((b1)), bvec_to_phys((b2)) + (b2)-&gt;bv_len, queue_segment_boundary((q)))</span>
<span class="cp">#define BIO_SEG_BOUNDARY(q, b1, b2) \</span>
<span class="cp">	BIOVEC_SEG_BOUNDARY((q), __BVEC_END((b1)), __BVEC_START((b2)))</span>

<span class="cp">#define bio_io_error(bio) bio_endio((bio), -EIO)</span>

<span class="cm">/*</span>
<span class="cm"> * drivers should not use the __ version unless they _really_ want to</span>
<span class="cm"> * run through the entire bio and not just pending pieces</span>
<span class="cm"> */</span>
<span class="cp">#define __bio_for_each_segment(bvl, bio, i, start_idx)			\</span>
<span class="cp">	for (bvl = bio_iovec_idx((bio), (start_idx)), i = (start_idx);	\</span>
<span class="cp">	     i &lt; (bio)-&gt;bi_vcnt;					\</span>
<span class="cp">	     bvl++, i++)</span>

<span class="cp">#define bio_for_each_segment(bvl, bio, i)				\</span>
<span class="cp">	__bio_for_each_segment(bvl, bio, i, (bio)-&gt;bi_idx)</span>

<span class="cm">/*</span>
<span class="cm"> * get a reference to a bio, so it won&#39;t disappear. the intended use is</span>
<span class="cm"> * something like:</span>
<span class="cm"> *</span>
<span class="cm"> * bio_get(bio);</span>
<span class="cm"> * submit_bio(rw, bio);</span>
<span class="cm"> * if (bio-&gt;bi_flags ...)</span>
<span class="cm"> *	do_something</span>
<span class="cm"> * bio_put(bio);</span>
<span class="cm"> *</span>
<span class="cm"> * without the bio_get(), it could potentially complete I/O before submit_bio</span>
<span class="cm"> * returns. and then bio would be freed memory when if (bio-&gt;bi_flags ...)</span>
<span class="cm"> * runs</span>
<span class="cm"> */</span>
<span class="cp">#define bio_get(bio)	atomic_inc(&amp;(bio)-&gt;bi_cnt)</span>

<span class="cp">#if defined(CONFIG_BLK_DEV_INTEGRITY)</span>
<span class="cm">/*</span>
<span class="cm"> * bio integrity payload</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bip_bio</span><span class="p">;</span>	<span class="cm">/* parent bio */</span>

	<span class="n">sector_t</span>		<span class="n">bip_sector</span><span class="p">;</span>	<span class="cm">/* virtual start sector */</span>

	<span class="kt">void</span>			<span class="o">*</span><span class="n">bip_buf</span><span class="p">;</span>	<span class="cm">/* generated integrity data */</span>
	<span class="n">bio_end_io_t</span>		<span class="o">*</span><span class="n">bip_end_io</span><span class="p">;</span>	<span class="cm">/* saved I/O completion fn */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">bip_size</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">bip_slab</span><span class="p">;</span>	<span class="cm">/* slab the bip came from */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">bip_vcnt</span><span class="p">;</span>	<span class="cm">/* # of integrity bio_vecs */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">bip_idx</span><span class="p">;</span>	<span class="cm">/* current bip_vec index */</span>

	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">bip_work</span><span class="p">;</span>	<span class="cm">/* I/O completion */</span>
	<span class="k">struct</span> <span class="n">bio_vec</span>		<span class="n">bip_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* embedded bvec array */</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_INTEGRITY */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * A bio_pair is used when we need to split a bio.</span>
<span class="cm"> * This can only happen for a bio that refers to just one</span>
<span class="cm"> * page of data, and in the unusual situation when the</span>
<span class="cm"> * page crosses a chunk/device boundary</span>
<span class="cm"> *</span>
<span class="cm"> * The address of the master bio is stored in bio1.bi_private</span>
<span class="cm"> * The address of the pool the pair was allocated from is stored</span>
<span class="cm"> *   in bio2.bi_private</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_pair</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span>			<span class="n">bio1</span><span class="p">,</span> <span class="n">bio2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span>			<span class="n">bv1</span><span class="p">,</span> <span class="n">bv2</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_BLK_DEV_INTEGRITY)</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span>	<span class="n">bip1</span><span class="p">,</span> <span class="n">bip2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span>			<span class="n">iv1</span><span class="p">,</span> <span class="n">iv2</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">atomic_t</span>			<span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">error</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="n">bio_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first_sectors</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_pair_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="n">dbio</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bioset_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bioset_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_alloc</span><span class="p">(</span><span class="n">gfp_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_kmalloc</span><span class="p">(</span><span class="n">gfp_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_alloc_bioset</span><span class="p">(</span><span class="n">gfp_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">request_queue</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_phys_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__bio_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_add_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_add_pc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_get_nr_vecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">sector_t</span> <span class="n">bio_sector_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_map_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sg_iovec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">rq_map_data</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_map_user_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_unmap_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_map_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
				<span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_copy_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
				 <span class="n">gfp_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_set_pages_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_check_pages_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>

<span class="cp">#ifndef ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE</span>
<span class="cp"># error	&quot;You should define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE for your platform&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_flush_dcache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bi</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_flush_dcache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_copy_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_map_data</span> <span class="o">*</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_copy_user_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">rq_map_data</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="p">,</span>
				     <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_uncopy_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">zero_fill_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec_alloc_bs</span><span class="p">(</span><span class="n">gfp_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bvec_free_bs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bvec_nr_vecs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">idx</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
<span class="kt">int</span> <span class="n">bio_associate_current</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bio_disassociate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="cp">#else	</span><span class="cm">/* CONFIG_BLK_CGROUP */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_associate_current</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_disassociate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_BLK_CGROUP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * bio_set is used to allow other portions of the IO system to</span>
<span class="cm"> * allocate their own private memory pools for bio and iovec structures.</span>
<span class="cm"> * These memory pools in turn all allocate from the bio_slab</span>
<span class="cm"> * and the bvec_slabs[].</span>
<span class="cm"> */</span>
<span class="cp">#define BIO_POOL_SIZE 2</span>
<span class="cp">#define BIOVEC_NR_POOLS 6</span>
<span class="cp">#define BIOVEC_MAX_IDX	(BIOVEC_NR_POOLS - 1)</span>

<span class="k">struct</span> <span class="n">bio_set</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">bio_slab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">front_pad</span><span class="p">;</span>

	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">bio_pool</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_BLK_DEV_INTEGRITY)</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">bio_integrity_pool</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">bvec_pool</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">biovec_slab</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_vecs</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">fs_bio_set</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * a small number of entries is fine, not going to be performance critical.</span>
<span class="cm"> * basically we just need to survive</span>
<span class="cm"> */</span>
<span class="cp">#define BIO_SPLIT_ENTRIES 2</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="cm">/*</span>
<span class="cm"> * remember never ever reenable interrupts between a bvec_kmap_irq and</span>
<span class="cm"> * bvec_kunmap_irq!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">bvec_kmap_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * might not be a highmem page, but the preempt/irq count</span>
<span class="cm">	 * balancing is a lot nicer this way</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bvec_kunmap_irq</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buffer</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="n">kunmap_atomic</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">bvec_kmap_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page_address</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bvec_kunmap_irq</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__bio_kmap_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">idx</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bvec_kmap_irq</span><span class="p">(</span><span class="n">bio_iovec_idx</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define __bio_kunmap_irq(buf, flags)	bvec_kunmap_irq(buf, flags)</span>

<span class="cp">#define bio_kmap_irq(bio, flags) \</span>
<span class="cp">	__bio_kmap_irq((bio), (bio)-&gt;bi_idx, (flags))</span>
<span class="cp">#define bio_kunmap_irq(buf,flags)	__bio_kunmap_irq(buf, flags)</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether this bio carries any data or not. A NULL bio is allowed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_has_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bio</span> <span class="o">&amp;&amp;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * BIO list management for use by remapping drivers (e.g. DM or MD) and loop.</span>
<span class="cm"> *</span>
<span class="cm"> * A bio_list anchors a singly-linked list of bios chained through the bi_next</span>
<span class="cm"> * member of the bio.  The bio_list also caches the last list member to allow</span>
<span class="cm"> * fast access to the tail.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_list_empty</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_list_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define bio_list_for_each(bio, bl) \</span>
<span class="cp">	for (bio = (bl)-&gt;head; bio; bio = bio-&gt;bi_next)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">bio_list_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">bio_list_for_each</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bl</span><span class="p">)</span>
		<span class="n">sz</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>

	<span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_list_add_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

	<span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_list_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bl2</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="n">bl2</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bl2</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

	<span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">bl2</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_list_merge_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bl2</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
		<span class="n">bl2</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">bl2</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>

	<span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bl2</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_list_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_list_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">bi_next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
			<span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_list_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_list</span> <span class="o">*</span><span class="n">bl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

	<span class="n">bl</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">bl</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_BLK_DEV_INTEGRITY)</span>

<span class="cp">#define bip_vec_idx(bip, idx)	(&amp;(bip-&gt;bip_vec[(idx)]))</span>
<span class="cp">#define bip_vec(bip)		bip_vec_idx(bip, 0)</span>

<span class="cp">#define __bip_for_each_vec(bvl, bip, i, start_idx)			\</span>
<span class="cp">	for (bvl = bip_vec_idx((bip), (start_idx)), i = (start_idx);	\</span>
<span class="cp">	     i &lt; (bip)-&gt;bip_vcnt;					\</span>
<span class="cp">	     bvl++, i++)</span>

<span class="cp">#define bip_for_each_vec(bvl, bip, i)					\</span>
<span class="cp">	__bip_for_each_vec(bvl, bip, i, (bip)-&gt;bip_idx)</span>

<span class="cp">#define bio_for_each_integrity_vec(_bvl, _bio, _iter)			\</span>
<span class="cp">	for_each_bio(_bio)						\</span>
<span class="cp">		bip_for_each_vec(_bvl, _bio-&gt;bi_integrity, _iter)</span>

<span class="cp">#define bio_integrity(bio) (bio-&gt;bi_integrity != NULL)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bio_integrity_alloc_bioset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bio_integrity_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_integrity_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_integrity_add_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_integrity_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_integrity_set_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_integrity_get_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_integrity_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_integrity_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_integrity_advance</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_integrity_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_integrity_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bio_integrity_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bioset_integrity_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bioset_integrity_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">bio_integrity_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_BLK_DEV_INTEGRITY */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_integrity</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_integrity_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bioset_integrity_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bioset_integrity_free</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_integrity_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_integrity_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_integrity_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_src</span><span class="p">,</span>
				      <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_integrity_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_integrity_advance</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_done</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_integrity_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bio_integrity_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_INTEGRITY */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLOCK */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __LINUX_BIO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
