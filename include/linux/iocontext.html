<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › iocontext.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>iocontext.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef IOCONTEXT_H</span>
<span class="cp">#define IOCONTEXT_H</span>

<span class="cp">#include &lt;linux/radix-tree.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">ICQ_EXITED</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * An io_cq (icq) is association between an io_context (ioc) and a</span>
<span class="cm"> * request_queue (q).  This is used by elevators which need to track</span>
<span class="cm"> * information per ioc - q pair.</span>
<span class="cm"> *</span>
<span class="cm"> * Elevator can request use of icq by setting elevator_type-&gt;icq_size and</span>
<span class="cm"> * -&gt;icq_align.  Both size and align must be larger than that of struct</span>
<span class="cm"> * io_cq and elevator can use the tail area for private information.  The</span>
<span class="cm"> * recommended way to do this is defining a struct which contains io_cq as</span>
<span class="cm"> * the first member followed by private members and using its size and</span>
<span class="cm"> * align.  For example,</span>
<span class="cm"> *</span>
<span class="cm"> *	struct snail_io_cq {</span>
<span class="cm"> *		struct io_cq	icq;</span>
<span class="cm"> *		int		poke_snail;</span>
<span class="cm"> *		int		feed_snail;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct elevator_type snail_elv_type {</span>
<span class="cm"> *		.ops =		{ ... },</span>
<span class="cm"> *		.icq_size =	sizeof(struct snail_io_cq),</span>
<span class="cm"> *		.icq_align =	__alignof__(struct snail_io_cq),</span>
<span class="cm"> *		...</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> * If icq_size is set, block core will manage icq&#39;s.  All requests will</span>
<span class="cm"> * have its -&gt;elv.icq field set before elevator_ops-&gt;elevator_set_req_fn()</span>
<span class="cm"> * is called and be holding a reference to the associated io_context.</span>
<span class="cm"> *</span>
<span class="cm"> * Whenever a new icq is created, elevator_ops-&gt;elevator_init_icq_fn() is</span>
<span class="cm"> * called and, on destruction, -&gt;elevator_exit_icq_fn().  Both functions</span>
<span class="cm"> * are called with both the associated io_context and queue locks held.</span>
<span class="cm"> *</span>
<span class="cm"> * Elevator is allowed to lookup icq using ioc_lookup_icq() while holding</span>
<span class="cm"> * queue lock but the returned icq is valid only until the queue lock is</span>
<span class="cm"> * released.  Elevators can not and should not try to create or destroy</span>
<span class="cm"> * icq&#39;s.</span>
<span class="cm"> *</span>
<span class="cm"> * As icq&#39;s are linked from both ioc and q, the locking rules are a bit</span>
<span class="cm"> * complex.</span>
<span class="cm"> *</span>
<span class="cm"> * - ioc lock nests inside q lock.</span>
<span class="cm"> *</span>
<span class="cm"> * - ioc-&gt;icq_list and icq-&gt;ioc_node are protected by ioc lock.</span>
<span class="cm"> *   q-&gt;icq_list and icq-&gt;q_node by q lock.</span>
<span class="cm"> *</span>
<span class="cm"> * - ioc-&gt;icq_tree and ioc-&gt;icq_hint are protected by ioc lock, while icq</span>
<span class="cm"> *   itself is protected by q lock.  However, both the indexes and icq</span>
<span class="cm"> *   itself are also RCU managed and lookup can be performed holding only</span>
<span class="cm"> *   the q lock.</span>
<span class="cm"> *</span>
<span class="cm"> * - icq&#39;s are not reference counted.  They are destroyed when either the</span>
<span class="cm"> *   ioc or q goes away.  Each request with icq set holds an extra</span>
<span class="cm"> *   reference to ioc to ensure it stays until the request is completed.</span>
<span class="cm"> *</span>
<span class="cm"> * - Linking and unlinking icq&#39;s are performed while holding both ioc and q</span>
<span class="cm"> *   locks.  Due to the lock ordering, q exit is simple but ioc exit</span>
<span class="cm"> *   requires reverse-order double lock dance.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">io_cq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span>	<span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_context</span>	<span class="o">*</span><span class="n">ioc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * q_node and ioc_node link io_cq through icq_list of q and ioc</span>
<span class="cm">	 * respectively.  Both fields are unused once ioc_exit_icq() is</span>
<span class="cm">	 * called and shared with __rcu_icq_cache and __rcu_head which are</span>
<span class="cm">	 * used for RCU free of io_cq.</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">q_node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">kmem_cache</span>	<span class="o">*</span><span class="n">__rcu_icq_cache</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_node</span>	<span class="n">ioc_node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rcu_head</span>		<span class="n">__rcu_head</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * I/O subsystem state of the associated processes.  It is refcounted</span>
<span class="cm"> * and kmalloc&#39;ed. These could be shared between processes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">io_context</span> <span class="p">{</span>
	<span class="n">atomic_long_t</span> <span class="n">refcount</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">active_ref</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">nr_tasks</span><span class="p">;</span>

	<span class="cm">/* all the fields below are protected by this lock */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ioprio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For request batching</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">nr_batch_requests</span><span class="p">;</span>     <span class="cm">/* Number of requests left in the batch */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_waited</span><span class="p">;</span> <span class="cm">/* Time last woken after wait for request */</span>

	<span class="k">struct</span> <span class="n">radix_tree_root</span>	<span class="n">icq_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">io_cq</span> <span class="n">__rcu</span>	<span class="o">*</span><span class="n">icq_hint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span>	<span class="n">icq_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">release_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * get_io_context_active - get active reference on ioc</span>
<span class="cm"> * @ioc: ioc of interest</span>
<span class="cm"> *</span>
<span class="cm"> * Only iocs with active reference can issue new IOs.  This function</span>
<span class="cm"> * acquires an active reference on @ioc.  The caller must already have an</span>
<span class="cm"> * active reference on @ioc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_io_context_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">active_ref</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">active_ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ioc_task_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_io_context_active</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">nr_tasks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="o">-&gt;</span><span class="n">nr_tasks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="kt">void</span> <span class="n">put_io_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">put_io_context_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">exit_io_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">get_task_io_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				       <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">struct</span> <span class="n">io_context</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_io_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">exit_io_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
