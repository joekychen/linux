<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › usb.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>usb.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_USB_H</span>
<span class="cp">#define __LINUX_USB_H</span>

<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>
<span class="cp">#include &lt;linux/usb/ch9.h&gt;</span>

<span class="cp">#define USB_MAJOR			180</span>
<span class="cp">#define USB_DEVICE_MAJOR		189</span>


<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/errno.h&gt;        </span><span class="cm">/* for -ENODEV */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/delay.h&gt;	</span><span class="cm">/* for mdelay() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/interrupt.h&gt;	</span><span class="cm">/* for in_interrupt() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/list.h&gt;		</span><span class="cm">/* for struct list_head */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/kref.h&gt;		</span><span class="cm">/* for struct kref */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/device.h&gt;	</span><span class="cm">/* for struct device */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/fs.h&gt;		</span><span class="cm">/* for struct file_operations */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/completion.h&gt;	</span><span class="cm">/* for struct completion */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/sched.h&gt;	</span><span class="cm">/* for current &amp;&amp; schedule_timeout */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/mutex.h&gt;	</span><span class="cm">/* for struct mutex */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;	</span><span class="cm">/* for runtime PM */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">usb_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">usb_driver</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">wusb_dev</span><span class="p">;</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Host-side wrappers for standard USB descriptors ... these are parsed</span>
<span class="cm"> * from the data provided by devices.  Parsing turns them from a flat</span>
<span class="cm"> * sequence of descriptors into a hierarchy:</span>
<span class="cm"> *</span>
<span class="cm"> *  - devices have one (usually) or more configs;</span>
<span class="cm"> *  - configs have one (often) or more interfaces;</span>
<span class="cm"> *  - interfaces have one (usually) or more settings;</span>
<span class="cm"> *  - each interface setting has zero or (usually) more endpoints.</span>
<span class="cm"> *  - a SuperSpeed endpoint has a companion descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * And there might be other descriptors mixed in with those.</span>
<span class="cm"> *</span>
<span class="cm"> * Devices may also have class-specific or vendor-specific descriptors.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ep_device</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_host_endpoint - host-side endpoint descriptor and queue</span>
<span class="cm"> * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder</span>
<span class="cm"> * @ss_ep_comp: SuperSpeed companion descriptor for this endpoint</span>
<span class="cm"> * @urb_list: urbs queued to this endpoint; maintained by usbcore</span>
<span class="cm"> * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)</span>
<span class="cm"> *	with one or more transfer descriptors (TDs) per urb</span>
<span class="cm"> * @ep_dev: ep_device for sysfs info</span>
<span class="cm"> * @extra: descriptors following this endpoint in the configuration</span>
<span class="cm"> * @extralen: how many bytes of &quot;extra&quot; are valid</span>
<span class="cm"> * @enabled: URBs may be submitted to this endpoint</span>
<span class="cm"> *</span>
<span class="cm"> * USB requests are always queued to a given endpoint, identified by a</span>
<span class="cm"> * descriptor within an active interface in a given USB configuration.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span>		<span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ss_ep_comp_descriptor</span>	<span class="n">ss_ep_comp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">urb_list</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">hcpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_device</span>		<span class="o">*</span><span class="n">ep_dev</span><span class="p">;</span>	<span class="cm">/* For sysfs info */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">extra</span><span class="p">;</span>   <span class="cm">/* Extra descriptors */</span>
	<span class="kt">int</span> <span class="n">extralen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* host-side wrapper for one interface setting&#39;s parsed descriptors */</span>
<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_interface_descriptor</span>	<span class="n">desc</span><span class="p">;</span>

	<span class="cm">/* array of desc.bNumEndpoint endpoints associated with this</span>
<span class="cm">	 * interface setting.  these will be in no particular order.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">endpoint</span><span class="p">;</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>		<span class="cm">/* iInterface string, if present */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">extra</span><span class="p">;</span>   <span class="cm">/* Extra descriptors */</span>
	<span class="kt">int</span> <span class="n">extralen</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">usb_interface_condition</span> <span class="p">{</span>
	<span class="n">USB_INTERFACE_UNBOUND</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">USB_INTERFACE_BINDING</span><span class="p">,</span>
	<span class="n">USB_INTERFACE_BOUND</span><span class="p">,</span>
	<span class="n">USB_INTERFACE_UNBINDING</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_interface - what usb device drivers talk to</span>
<span class="cm"> * @altsetting: array of interface structures, one for each alternate</span>
<span class="cm"> *	setting that may be selected.  Each one includes a set of</span>
<span class="cm"> *	endpoint configurations.  They will be in no particular order.</span>
<span class="cm"> * @cur_altsetting: the current altsetting.</span>
<span class="cm"> * @num_altsetting: number of altsettings defined.</span>
<span class="cm"> * @intf_assoc: interface association descriptor</span>
<span class="cm"> * @minor: the minor number assigned to this interface, if this</span>
<span class="cm"> *	interface is bound to a driver that uses the USB major number.</span>
<span class="cm"> *	If this interface does not use the USB major, this field should</span>
<span class="cm"> *	be unused.  The driver should set this value in the probe()</span>
<span class="cm"> *	function of the driver, after it has been assigned a minor</span>
<span class="cm"> *	number from the USB core by calling usb_register_dev().</span>
<span class="cm"> * @condition: binding state of the interface: not bound, binding</span>
<span class="cm"> *	(in probe()), bound to a driver, or unbinding (in disconnect())</span>
<span class="cm"> * @sysfs_files_created: sysfs attributes exist</span>
<span class="cm"> * @ep_devs_created: endpoint child pseudo-devices exist</span>
<span class="cm"> * @unregistering: flag set when the interface is being unregistered</span>
<span class="cm"> * @needs_remote_wakeup: flag set when the driver requires remote-wakeup</span>
<span class="cm"> *	capability during autosuspend.</span>
<span class="cm"> * @needs_altsetting0: flag set when a set-interface request for altsetting 0</span>
<span class="cm"> *	has been deferred.</span>
<span class="cm"> * @needs_binding: flag set when the driver should be re-probed or unbound</span>
<span class="cm"> *	following a reset or suspend operation it doesn&#39;t support.</span>
<span class="cm"> * @dev: driver model&#39;s view of this device</span>
<span class="cm"> * @usb_dev: if an interface is bound to the USB major, this will point</span>
<span class="cm"> *	to the sysfs representation for that device.</span>
<span class="cm"> * @pm_usage_cnt: PM usage counter for this interface</span>
<span class="cm"> * @reset_ws: Used for scheduling resets from atomic context.</span>
<span class="cm"> * @reset_running: set to 1 if the interface is currently running a</span>
<span class="cm"> *      queued reset so that usb_cancel_queued_reset() doesn&#39;t try to</span>
<span class="cm"> *      remove from the workqueue when running inside the worker</span>
<span class="cm"> *      thread. See __usb_queue_reset_device().</span>
<span class="cm"> * @resetting_device: USB core reset the device, so use alt setting 0 as</span>
<span class="cm"> *	current; needs bandwidth alloc after reset.</span>
<span class="cm"> *</span>
<span class="cm"> * USB device drivers attach to interfaces on a physical device.  Each</span>
<span class="cm"> * interface encapsulates a single high level function, such as feeding</span>
<span class="cm"> * an audio stream to a speaker or reporting a change in a volume control.</span>
<span class="cm"> * Many USB devices only have one interface.  The protocol used to talk to</span>
<span class="cm"> * an interface&#39;s endpoints can be defined in a usb &quot;class&quot; specification,</span>
<span class="cm"> * or by a product&#39;s vendor.  The (default) control endpoint is part of</span>
<span class="cm"> * every interface, but is never listed among the interface&#39;s descriptors.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver that is bound to the interface can use standard driver model</span>
<span class="cm"> * calls such as dev_get_drvdata() on the dev member of this structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Each interface may have alternate settings.  The initial configuration</span>
<span class="cm"> * of a device sets altsetting 0, but the device driver can change</span>
<span class="cm"> * that setting using usb_set_interface().  Alternate settings are often</span>
<span class="cm"> * used to control the use of periodic endpoints, such as by having</span>
<span class="cm"> * different endpoints use different amounts of reserved USB bandwidth.</span>
<span class="cm"> * All standards-conformant USB devices that use isochronous endpoints</span>
<span class="cm"> * will use them in non-default settings.</span>
<span class="cm"> *</span>
<span class="cm"> * The USB specification says that alternate setting numbers must run from</span>
<span class="cm"> * 0 to one less than the total number of alternate settings.  But some</span>
<span class="cm"> * devices manage to mess this up, and the structures aren&#39;t necessarily</span>
<span class="cm"> * stored in numerical order anyhow.  Use usb_altnum_to_altsetting() to</span>
<span class="cm"> * look up an alternate setting in the altsetting array based on its number.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_interface</span> <span class="p">{</span>
	<span class="cm">/* array of alternate settings for this interface,</span>
<span class="cm">	 * stored in no particular order */</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">altsetting</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">cur_altsetting</span><span class="p">;</span>	<span class="cm">/* the currently</span>
<span class="cm">					 * active alternate setting */</span>
	<span class="kt">unsigned</span> <span class="n">num_altsetting</span><span class="p">;</span>	<span class="cm">/* number of alternate settings */</span>

	<span class="cm">/* If there is an interface association descriptor then it will list</span>
<span class="cm">	 * the associated interfaces */</span>
	<span class="k">struct</span> <span class="n">usb_interface_assoc_descriptor</span> <span class="o">*</span><span class="n">intf_assoc</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>			<span class="cm">/* minor number this interface is</span>
<span class="cm">					 * bound to */</span>
	<span class="k">enum</span> <span class="n">usb_interface_condition</span> <span class="n">condition</span><span class="p">;</span>		<span class="cm">/* state of binding */</span>
	<span class="kt">unsigned</span> <span class="n">sysfs_files_created</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* the sysfs attributes exist */</span>
	<span class="kt">unsigned</span> <span class="n">ep_devs_created</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* endpoint &quot;devices&quot; exist */</span>
	<span class="kt">unsigned</span> <span class="n">unregistering</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* unregistration is in progress */</span>
	<span class="kt">unsigned</span> <span class="n">needs_remote_wakeup</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* driver requires remote wakeup */</span>
	<span class="kt">unsigned</span> <span class="n">needs_altsetting0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* switch to altsetting 0 is pending */</span>
	<span class="kt">unsigned</span> <span class="n">needs_binding</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* needs delayed unbind/rebind */</span>
	<span class="kt">unsigned</span> <span class="n">reset_running</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">resetting_device</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* true: bandwidth alloc after reset */</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>		<span class="cm">/* interface specific device info */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">pm_usage_cnt</span><span class="p">;</span>		<span class="cm">/* usage counter for autosuspend */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_ws</span><span class="p">;</span>	<span class="cm">/* for resets in atomic context */</span>
<span class="p">};</span>
<span class="cp">#define	to_usb_interface(d) container_of(d, struct usb_interface, dev)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">usb_get_intfdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_set_intfdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">usb_get_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_put_intf</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>

<span class="cm">/* this maximum is arbitrary */</span>
<span class="cp">#define USB_MAXINTERFACES	32</span>
<span class="cp">#define USB_MAXIADS		(USB_MAXINTERFACES/2)</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_interface_cache - long-term representation of a device interface</span>
<span class="cm"> * @num_altsetting: number of altsettings defined.</span>
<span class="cm"> * @ref: reference counter.</span>
<span class="cm"> * @altsetting: variable-length array of interface structures, one for</span>
<span class="cm"> *	each alternate setting that may be selected.  Each one includes a</span>
<span class="cm"> *	set of endpoint configurations.  They will be in no particular order.</span>
<span class="cm"> *</span>
<span class="cm"> * These structures persist for the lifetime of a usb_device, unlike</span>
<span class="cm"> * struct usb_interface (which persists only as long as its configuration</span>
<span class="cm"> * is installed).  The altsetting arrays can be accessed through these</span>
<span class="cm"> * structures at any time, permitting comparison of configurations and</span>
<span class="cm"> * providing support for the /proc/bus/usb/devices pseudo-file.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_interface_cache</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">num_altsetting</span><span class="p">;</span>	<span class="cm">/* number of alternate settings */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">ref</span><span class="p">;</span>		<span class="cm">/* reference counter */</span>

	<span class="cm">/* variable-length array of alternate settings for this interface,</span>
<span class="cm">	 * stored in no particular order */</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="n">altsetting</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define	ref_to_usb_interface_cache(r) \</span>
<span class="cp">		container_of(r, struct usb_interface_cache, ref)</span>
<span class="cp">#define	altsetting_to_usb_interface_cache(a) \</span>
<span class="cp">		container_of(a, struct usb_interface_cache, altsetting[0])</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_host_config - representation of a device&#39;s configuration</span>
<span class="cm"> * @desc: the device&#39;s configuration descriptor.</span>
<span class="cm"> * @string: pointer to the cached version of the iConfiguration string, if</span>
<span class="cm"> *	present for this configuration.</span>
<span class="cm"> * @intf_assoc: list of any interface association descriptors in this config</span>
<span class="cm"> * @interface: array of pointers to usb_interface structures, one for each</span>
<span class="cm"> *	interface in the configuration.  The number of interfaces is stored</span>
<span class="cm"> *	in desc.bNumInterfaces.  These pointers are valid only while the</span>
<span class="cm"> *	the configuration is active.</span>
<span class="cm"> * @intf_cache: array of pointers to usb_interface_cache structures, one</span>
<span class="cm"> *	for each interface in the configuration.  These structures exist</span>
<span class="cm"> *	for the entire life of the device.</span>
<span class="cm"> * @extra: pointer to buffer containing all extra descriptors associated</span>
<span class="cm"> *	with this configuration (those preceding the first interface</span>
<span class="cm"> *	descriptor).</span>
<span class="cm"> * @extralen: length of the extra descriptors buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * USB devices may have multiple configurations, but only one can be active</span>
<span class="cm"> * at any time.  Each encapsulates a different operational environment;</span>
<span class="cm"> * for example, a dual-speed device would have separate configurations for</span>
<span class="cm"> * full-speed and high-speed operation.  The number of configurations</span>
<span class="cm"> * available is stored in the device descriptor as bNumConfigurations.</span>
<span class="cm"> *</span>
<span class="cm"> * A configuration can contain multiple interfaces.  Each corresponds to</span>
<span class="cm"> * a different function of the USB device, and all are available whenever</span>
<span class="cm"> * the configuration is active.  The USB standard says that interfaces</span>
<span class="cm"> * are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot</span>
<span class="cm"> * of devices get this wrong.  In addition, the interface array is not</span>
<span class="cm"> * guaranteed to be sorted in numerical order.  Use usb_ifnum_to_if() to</span>
<span class="cm"> * look up an interface entry based on its number.</span>
<span class="cm"> *</span>
<span class="cm"> * Device drivers should not attempt to activate configurations.  The choice</span>
<span class="cm"> * of which configuration to install is a policy decision based on such</span>
<span class="cm"> * considerations as available power, functionality provided, and the user&#39;s</span>
<span class="cm"> * desires (expressed through userspace tools).  However, drivers can call</span>
<span class="cm"> * usb_reset_configuration() to reinitialize the current configuration and</span>
<span class="cm"> * all its interfaces.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_config_descriptor</span>	<span class="n">desc</span><span class="p">;</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>		<span class="cm">/* iConfiguration string, if present */</span>

	<span class="cm">/* List of any Interface Association Descriptors in this</span>
<span class="cm">	 * configuration. */</span>
	<span class="k">struct</span> <span class="n">usb_interface_assoc_descriptor</span> <span class="o">*</span><span class="n">intf_assoc</span><span class="p">[</span><span class="n">USB_MAXIADS</span><span class="p">];</span>

	<span class="cm">/* the interfaces associated with this configuration,</span>
<span class="cm">	 * stored in no particular order */</span>
	<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">[</span><span class="n">USB_MAXINTERFACES</span><span class="p">];</span>

	<span class="cm">/* Interface information available even when this is not the</span>
<span class="cm">	 * active configuration */</span>
	<span class="k">struct</span> <span class="n">usb_interface_cache</span> <span class="o">*</span><span class="n">intf_cache</span><span class="p">[</span><span class="n">USB_MAXINTERFACES</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">extra</span><span class="p">;</span>   <span class="cm">/* Extra descriptors */</span>
	<span class="kt">int</span> <span class="n">extralen</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* USB2.0 and USB3.0 device BOS descriptor set */</span>
<span class="k">struct</span> <span class="n">usb_host_bos</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_bos_descriptor</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="cm">/* wireless cap descriptor is handled by wusb */</span>
	<span class="k">struct</span> <span class="n">usb_ext_cap_descriptor</span>	<span class="o">*</span><span class="n">ext_cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ss_cap_descriptor</span>	<span class="o">*</span><span class="n">ss_cap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_ss_container_id_descriptor</span>	<span class="o">*</span><span class="n">ss_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__usb_get_extra_descriptor</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ptr</span><span class="p">);</span>
<span class="cp">#define usb_get_extra_descriptor(ifpoint, type, ptr) \</span>
<span class="cp">				__usb_get_extra_descriptor((ifpoint)-&gt;extra, \</span>
<span class="cp">				(ifpoint)-&gt;extralen, \</span>
<span class="cp">				type, (void **)ptr)</span>

<span class="cm">/* ----------------------------------------------------------------------- */</span>

<span class="cm">/* USB device number allocation bitmap */</span>
<span class="k">struct</span> <span class="n">usb_devmap</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">devicemap</span><span class="p">[</span><span class="mi">128</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Allocated per bus (tree of devices) we have:</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_bus</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">controller</span><span class="p">;</span>	<span class="cm">/* host/master side hardware */</span>
	<span class="kt">int</span> <span class="n">busnum</span><span class="p">;</span>			<span class="cm">/* Bus number (in order of reg) */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bus_name</span><span class="p">;</span>		<span class="cm">/* stable id (PCI slot_name etc) */</span>
	<span class="n">u8</span> <span class="n">uses_dma</span><span class="p">;</span>			<span class="cm">/* Does the host controller use DMA? */</span>
	<span class="n">u8</span> <span class="n">uses_pio_for_control</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">					 * Does the host controller use PIO</span>
<span class="cm">					 * for control transfers?</span>
<span class="cm">					 */</span>
	<span class="n">u8</span> <span class="n">otg_port</span><span class="p">;</span>			<span class="cm">/* 0, or number of OTG/HNP port */</span>
	<span class="kt">unsigned</span> <span class="n">is_b_host</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* true during some HNP roleswitches */</span>
	<span class="kt">unsigned</span> <span class="n">b_hnp_enable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* OTG: did A-Host enable HNP? */</span>
	<span class="kt">unsigned</span> <span class="n">sg_tablesize</span><span class="p">;</span>		<span class="cm">/* 0 or largest number of sg list entries */</span>

	<span class="kt">int</span> <span class="n">devnum_next</span><span class="p">;</span>		<span class="cm">/* Next open device number in</span>
<span class="cm">					 * round-robin allocation */</span>

	<span class="k">struct</span> <span class="n">usb_devmap</span> <span class="n">devmap</span><span class="p">;</span>	<span class="cm">/* device address allocation map */</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">root_hub</span><span class="p">;</span>	<span class="cm">/* Root hub */</span>
	<span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">hs_companion</span><span class="p">;</span>	<span class="cm">/* Companion EHCI bus, if any */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bus_list</span><span class="p">;</span>	<span class="cm">/* list of busses */</span>

	<span class="kt">int</span> <span class="n">bandwidth_allocated</span><span class="p">;</span>	<span class="cm">/* on this bus: how much of the time</span>
<span class="cm">					 * reserved for periodic (intr/iso)</span>
<span class="cm">					 * requests is used, on average?</span>
<span class="cm">					 * Units: microseconds/frame.</span>
<span class="cm">					 * Limits: Full/low speed reserve 90%,</span>
<span class="cm">					 * while high speed reserves 80%.</span>
<span class="cm">					 */</span>
	<span class="kt">int</span> <span class="n">bandwidth_int_reqs</span><span class="p">;</span>		<span class="cm">/* number of Interrupt requests */</span>
	<span class="kt">int</span> <span class="n">bandwidth_isoc_reqs</span><span class="p">;</span>	<span class="cm">/* number of Isoc. requests */</span>

<span class="cp">#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)</span>
	<span class="k">struct</span> <span class="n">mon_bus</span> <span class="o">*</span><span class="n">mon_bus</span><span class="p">;</span>	<span class="cm">/* non-null when associated */</span>
	<span class="kt">int</span> <span class="n">monitored</span><span class="p">;</span>			<span class="cm">/* non-zero when monitored */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* ----------------------------------------------------------------------- */</span>

<span class="cm">/* This is arbitrary.</span>
<span class="cm"> * From USB 2.0 spec Table 11-13, offset 7, a hub can</span>
<span class="cm"> * have up to 255 ports. The most yet reported is 10.</span>
<span class="cm"> *</span>
<span class="cm"> * Current Wireless USB host hardware (Intel i1480 for example) allows</span>
<span class="cm"> * up to 22 devices to connect. Upcoming hardware might raise that</span>
<span class="cm"> * limit. Because the arrays need to add a bit for hub status data, we</span>
<span class="cm"> * do 31, so plus one evens out to four bytes.</span>
<span class="cm"> */</span>
<span class="cp">#define USB_MAXCHILDREN		(31)</span>

<span class="k">struct</span> <span class="n">usb_tt</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">usb_device_removable</span> <span class="p">{</span>
	<span class="n">USB_DEVICE_REMOVABLE_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">USB_DEVICE_REMOVABLE</span><span class="p">,</span>
	<span class="n">USB_DEVICE_FIXED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * USB 3.0 Link Power Management (LPM) parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * PEL and SEL are USB 3.0 Link PM latencies for device-initiated LPM exit.</span>
<span class="cm"> * MEL is the USB 3.0 Link PM latency for host-initiated LPM exit.</span>
<span class="cm"> * All three are stored in nanoseconds.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb3_lpm_parameters</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Maximum exit latency (MEL) for the host to send a packet to the</span>
<span class="cm">	 * device (either a Ping for isoc endpoints, or a data packet for</span>
<span class="cm">	 * interrupt endpoints), the hubs to decode the packet, and for all hubs</span>
<span class="cm">	 * in the path to transition the links to U0.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mel</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Maximum exit latency for a device-initiated LPM transition to bring</span>
<span class="cm">	 * all links into U0.  Abbreviated as &quot;PEL&quot; in section 9.4.12 of the USB</span>
<span class="cm">	 * 3.0 spec, with no explanation of what &quot;P&quot; stands for.  &quot;Path&quot;?</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pel</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The System Exit Latency (SEL) includes PEL, and three other</span>
<span class="cm">	 * latencies.  After a device initiates a U0 transition, it will take</span>
<span class="cm">	 * some time from when the device sends the ERDY to when it will finally</span>
<span class="cm">	 * receive the data packet.  Basically, SEL should be the worse-case</span>
<span class="cm">	 * latency from when a device starts initiating a U0 transition to when</span>
<span class="cm">	 * it will get data.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sel</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The idle timeout value that is currently programmed into the parent</span>
<span class="cm">	 * hub for this device.  When the timer counts to zero, the parent hub</span>
<span class="cm">	 * will initiate an LPM transition to either U1 or U2.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_device - kernel&#39;s representation of a USB device</span>
<span class="cm"> * @devnum: device number; address on a USB bus</span>
<span class="cm"> * @devpath: device ID string for use in messages (e.g., /port/...)</span>
<span class="cm"> * @route: tree topology hex string for use with xHCI</span>
<span class="cm"> * @state: device state: configured, not attached, etc.</span>
<span class="cm"> * @speed: device speed: high/full/low (or error)</span>
<span class="cm"> * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub</span>
<span class="cm"> * @ttport: device port on that tt hub</span>
<span class="cm"> * @toggle: one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints</span>
<span class="cm"> * @parent: our hub, unless we&#39;re the root</span>
<span class="cm"> * @bus: bus we&#39;re part of</span>
<span class="cm"> * @ep0: endpoint 0 data (default control pipe)</span>
<span class="cm"> * @dev: generic device interface</span>
<span class="cm"> * @descriptor: USB device descriptor</span>
<span class="cm"> * @bos: USB device BOS descriptor set</span>
<span class="cm"> * @config: all of the device&#39;s configs</span>
<span class="cm"> * @actconfig: the active configuration</span>
<span class="cm"> * @ep_in: array of IN endpoints</span>
<span class="cm"> * @ep_out: array of OUT endpoints</span>
<span class="cm"> * @rawdescriptors: raw descriptors for each config</span>
<span class="cm"> * @bus_mA: Current available from the bus</span>
<span class="cm"> * @portnum: parent port number (origin 1)</span>
<span class="cm"> * @level: number of USB hub ancestors</span>
<span class="cm"> * @can_submit: URBs may be submitted</span>
<span class="cm"> * @persist_enabled:  USB_PERSIST enabled for this device</span>
<span class="cm"> * @have_langid: whether string_langid is valid</span>
<span class="cm"> * @authorized: policy has said we can use it;</span>
<span class="cm"> *	(user space) policy determines if we authorize this device to be</span>
<span class="cm"> *	used or not. By default, wired USB devices are authorized.</span>
<span class="cm"> *	WUSB devices are not, until we authorize them from user space.</span>
<span class="cm"> *	FIXME -- complete doc</span>
<span class="cm"> * @authenticated: Crypto authentication passed</span>
<span class="cm"> * @wusb: device is Wireless USB</span>
<span class="cm"> * @lpm_capable: device supports LPM</span>
<span class="cm"> * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM</span>
<span class="cm"> * @usb2_hw_lpm_enabled: USB2 hardware LPM enabled</span>
<span class="cm"> * @string_langid: language ID for strings</span>
<span class="cm"> * @product: iProduct string, if present (static)</span>
<span class="cm"> * @manufacturer: iManufacturer string, if present (static)</span>
<span class="cm"> * @serial: iSerialNumber string, if present (static)</span>
<span class="cm"> * @filelist: usbfs files that are open to this device</span>
<span class="cm"> * @usb_classdev: USB class device that was created for usbfs device</span>
<span class="cm"> *	access from userspace</span>
<span class="cm"> * @usbfs_dentry: usbfs dentry entry for the device</span>
<span class="cm"> * @maxchild: number of ports if hub</span>
<span class="cm"> * @children: child devices - USB devices that are attached to this hub</span>
<span class="cm"> * @quirks: quirks of the whole device</span>
<span class="cm"> * @urbnum: number of URBs submitted for the whole device</span>
<span class="cm"> * @active_duration: total time device is not suspended</span>
<span class="cm"> * @connect_time: time device was first connected</span>
<span class="cm"> * @do_remote_wakeup:  remote wakeup should be enabled</span>
<span class="cm"> * @reset_resume: needs reset instead of resume</span>
<span class="cm"> * @wusb_dev: if this is a Wireless USB device, link to the WUSB</span>
<span class="cm"> *	specific data for the device.</span>
<span class="cm"> * @slot_id: Slot ID assigned by xHCI</span>
<span class="cm"> * @removable: Device can be physically removed from this port</span>
<span class="cm"> * @u1_params: exit latencies for USB3 U1 LPM state, and hub-initiated timeout.</span>
<span class="cm"> * @u2_params: exit latencies for USB3 U2 LPM state, and hub-initiated timeout.</span>
<span class="cm"> * @lpm_disable_count: Ref count used by usb_disable_lpm() and usb_enable_lpm()</span>
<span class="cm"> *	to keep track of the number of functions that require USB 3.0 Link Power</span>
<span class="cm"> *	Management to be disabled for this usb_device.  This count should only</span>
<span class="cm"> *	be manipulated by those functions, with the bandwidth_mutex is held.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * Usbcore drivers should not set usbdev-&gt;state directly.  Instead use</span>
<span class="cm"> * usb_set_device_state().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_device</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">devnum</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="n">devpath</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span>		<span class="n">route</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_device_state</span>	<span class="n">state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_device_speed</span>	<span class="n">speed</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_tt</span>	<span class="o">*</span><span class="n">tt</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ttport</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">toggle</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="n">ep0</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_device_descriptor</span> <span class="n">descriptor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_bos</span> <span class="o">*</span><span class="n">bos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">actconfig</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep_in</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep_out</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="kt">char</span> <span class="o">**</span><span class="n">rawdescriptors</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">bus_mA</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">portnum</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">level</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">can_submit</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">persist_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">have_langid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">authorized</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">authenticated</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">wusb</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">lpm_capable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">usb2_hw_lpm_capable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">usb2_hw_lpm_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">usb3_lpm_enabled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">string_langid</span><span class="p">;</span>

	<span class="cm">/* static strings from the device */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">product</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">manufacturer</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">serial</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">filelist</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">maxchild</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">**</span><span class="n">children</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">quirks</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">urbnum</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active_duration</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">connect_time</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">do_remote_wakeup</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">reset_resume</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">wusb_dev</span> <span class="o">*</span><span class="n">wusb_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot_id</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">usb_device_removable</span> <span class="n">removable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb3_lpm_parameters</span> <span class="n">u1_params</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb3_lpm_parameters</span> <span class="n">u2_params</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">lpm_disable_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">hub_initiated_lpm_disable_count</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define	to_usb_device(d) container_of(d, struct usb_device, dev)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="nf">interface_to_usbdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">to_usb_device</span><span class="p">(</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_get_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_put_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* USB device locking */</span>
<span class="cp">#define usb_lock_device(udev)		device_lock(&amp;(udev)-&gt;dev)</span>
<span class="cp">#define usb_unlock_device(udev)		device_unlock(&amp;(udev)-&gt;dev)</span>
<span class="cp">#define usb_trylock_device(udev)	device_trylock(&amp;(udev)-&gt;dev)</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_lock_device_for_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">);</span>

<span class="cm">/* USB port reset for device reinitialization */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_queue_reset_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>


<span class="cm">/* USB autosuspend and autoresume */</span>
<span class="cp">#ifdef CONFIG_USB_SUSPEND</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_enable_autosuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_disable_autosuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_autopm_get_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_autopm_put_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_autopm_get_interface_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_autopm_put_interface_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_autopm_get_interface_no_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_autopm_put_interface_no_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_mark_last_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pm_runtime_mark_last_busy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_enable_autosuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_disable_autosuspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_autopm_get_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_autopm_get_interface_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_autopm_put_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_autopm_put_interface_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_autopm_get_interface_no_resume</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_autopm_put_interface_no_suspend</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_mark_last_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_disable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_enable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>
<span class="cm">/* Same as above, but these functions lock/unlock the bandwidth_mutex. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_unlocked_disable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_unlocked_enable_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cm">/* for drivers using iso endpoints */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_get_current_frame_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">);</span>

<span class="cm">/* Sets up a group of bulk endpoints to support multiple stream IDs. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_alloc_streams</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_streams</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>

<span class="cm">/* Reverts a group of bulk endpoints back to not using stream IDs. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_free_streams</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_eps</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>

<span class="cm">/* used these for multi-interface device registration */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_driver_claim_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * usb_interface_claimed - returns true iff an interface is claimed</span>
<span class="cm"> * @iface: the interface being checked</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true (nonzero) iff the interface is claimed, else false (zero).</span>
<span class="cm"> * Callers must own the driver model&#39;s usb bus readlock.  So driver</span>
<span class="cm"> * probe() entries don&#39;t need extra locking, but other call contexts</span>
<span class="cm"> * may need to explicitly claim that lock.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_interface_claimed</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">driver</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_driver_release_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">usb_match_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_match_one_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">usb_find_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">minor</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">usb_ifnum_to_if</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">ifnum</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">usb_altnum_to_altsetting</span><span class="p">(</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">altnum</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">usb_find_alt_setting</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">usb_host_config</span> <span class="o">*</span><span class="n">config</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iface_num</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alt_num</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * usb_make_path - returns stable device path in the usb tree</span>
<span class="cm"> * @dev: the device whose path is being constructed</span>
<span class="cm"> * @buf: where to put the string</span>
<span class="cm"> * @size: how big is &quot;buf&quot;?</span>
<span class="cm"> *</span>
<span class="cm"> * Returns length of the string (&gt; 0) or negative if size was too small.</span>
<span class="cm"> *</span>
<span class="cm"> * This identifier is intended to be &quot;stable&quot;, reflecting physical paths in</span>
<span class="cm"> * hardware such as physical bus addresses for host controllers or ports on</span>
<span class="cm"> * USB hubs.  That makes it stay the same until systems are physically</span>
<span class="cm"> * reconfigured, by re-cabling a tree of USB devices or by moving USB host</span>
<span class="cm"> * controllers.  Adding and removing devices, including virtual root hubs</span>
<span class="cm"> * in host controller driver modules, does not change these path identifiers;</span>
<span class="cm"> * neither does rebooting or re-enumerating.  These are more useful identifiers</span>
<span class="cm"> * than changeable (&quot;unstable&quot;) ones like bus numbers or device addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * With a partial exception for devices connected to USB 2.0 root hubs, these</span>
<span class="cm"> * identifiers are also predictable.  So long as the device tree isn&#39;t changed,</span>
<span class="cm"> * plugging any USB device into a given hub port always gives it the same path.</span>
<span class="cm"> * Because of the use of &quot;companion&quot; controllers, devices connected to ports on</span>
<span class="cm"> * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are</span>
<span class="cm"> * high speed, and a different one if they are full or low speed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_make_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual</span><span class="p">;</span>
	<span class="n">actual</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s">&quot;usb-%s-%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">bus_name</span><span class="p">,</span>
			  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devpath</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">actual</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">actual</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="cp">#define USB_DEVICE_ID_MATCH_DEVICE \</span>
<span class="cp">		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_DEV_RANGE \</span>
<span class="cp">		(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION \</span>
<span class="cp">		(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_DEV_INFO \</span>
<span class="cp">		(USB_DEVICE_ID_MATCH_DEV_CLASS | \</span>
<span class="cp">		USB_DEVICE_ID_MATCH_DEV_SUBCLASS | \</span>
<span class="cp">		USB_DEVICE_ID_MATCH_DEV_PROTOCOL)</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_INT_INFO \</span>
<span class="cp">		(USB_DEVICE_ID_MATCH_INT_CLASS | \</span>
<span class="cp">		USB_DEVICE_ID_MATCH_INT_SUBCLASS | \</span>
<span class="cp">		USB_DEVICE_ID_MATCH_INT_PROTOCOL)</span>

<span class="cm">/**</span>
<span class="cm"> * USB_DEVICE - macro used to describe a specific usb device</span>
<span class="cm"> * @vend: the 16 bit USB Vendor ID</span>
<span class="cm"> * @prod: the 16 bit USB Product ID</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct usb_device_id that matches a</span>
<span class="cm"> * specific device.</span>
<span class="cm"> */</span>
<span class="cp">#define USB_DEVICE(vend, prod) \</span>
<span class="cp">	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, \</span>
<span class="cp">	.idVendor = (vend), \</span>
<span class="cp">	.idProduct = (prod)</span>
<span class="cm">/**</span>
<span class="cm"> * USB_DEVICE_VER - describe a specific usb device with a version range</span>
<span class="cm"> * @vend: the 16 bit USB Vendor ID</span>
<span class="cm"> * @prod: the 16 bit USB Product ID</span>
<span class="cm"> * @lo: the bcdDevice_lo value</span>
<span class="cm"> * @hi: the bcdDevice_hi value</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct usb_device_id that matches a</span>
<span class="cm"> * specific device, with a version range.</span>
<span class="cm"> */</span>
<span class="cp">#define USB_DEVICE_VER(vend, prod, lo, hi) \</span>
<span class="cp">	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \</span>
<span class="cp">	.idVendor = (vend), \</span>
<span class="cp">	.idProduct = (prod), \</span>
<span class="cp">	.bcdDevice_lo = (lo), \</span>
<span class="cp">	.bcdDevice_hi = (hi)</span>

<span class="cm">/**</span>
<span class="cm"> * USB_DEVICE_INTERFACE_PROTOCOL - describe a usb device with a specific interface protocol</span>
<span class="cm"> * @vend: the 16 bit USB Vendor ID</span>
<span class="cm"> * @prod: the 16 bit USB Product ID</span>
<span class="cm"> * @pr: bInterfaceProtocol value</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct usb_device_id that matches a</span>
<span class="cm"> * specific interface protocol of devices.</span>
<span class="cm"> */</span>
<span class="cp">#define USB_DEVICE_INTERFACE_PROTOCOL(vend, prod, pr) \</span>
<span class="cp">	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \</span>
<span class="cp">		       USB_DEVICE_ID_MATCH_INT_PROTOCOL, \</span>
<span class="cp">	.idVendor = (vend), \</span>
<span class="cp">	.idProduct = (prod), \</span>
<span class="cp">	.bInterfaceProtocol = (pr)</span>

<span class="cm">/**</span>
<span class="cm"> * USB_DEVICE_INFO - macro used to describe a class of usb devices</span>
<span class="cm"> * @cl: bDeviceClass value</span>
<span class="cm"> * @sc: bDeviceSubClass value</span>
<span class="cm"> * @pr: bDeviceProtocol value</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct usb_device_id that matches a</span>
<span class="cm"> * specific class of devices.</span>
<span class="cm"> */</span>
<span class="cp">#define USB_DEVICE_INFO(cl, sc, pr) \</span>
<span class="cp">	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, \</span>
<span class="cp">	.bDeviceClass = (cl), \</span>
<span class="cp">	.bDeviceSubClass = (sc), \</span>
<span class="cp">	.bDeviceProtocol = (pr)</span>

<span class="cm">/**</span>
<span class="cm"> * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces</span>
<span class="cm"> * @cl: bInterfaceClass value</span>
<span class="cm"> * @sc: bInterfaceSubClass value</span>
<span class="cm"> * @pr: bInterfaceProtocol value</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct usb_device_id that matches a</span>
<span class="cm"> * specific class of interfaces.</span>
<span class="cm"> */</span>
<span class="cp">#define USB_INTERFACE_INFO(cl, sc, pr) \</span>
<span class="cp">	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \</span>
<span class="cp">	.bInterfaceClass = (cl), \</span>
<span class="cp">	.bInterfaceSubClass = (sc), \</span>
<span class="cp">	.bInterfaceProtocol = (pr)</span>

<span class="cm">/**</span>
<span class="cm"> * USB_DEVICE_AND_INTERFACE_INFO - describe a specific usb device with a class of usb interfaces</span>
<span class="cm"> * @vend: the 16 bit USB Vendor ID</span>
<span class="cm"> * @prod: the 16 bit USB Product ID</span>
<span class="cm"> * @cl: bInterfaceClass value</span>
<span class="cm"> * @sc: bInterfaceSubClass value</span>
<span class="cm"> * @pr: bInterfaceProtocol value</span>
<span class="cm"> *</span>
<span class="cm"> * This macro is used to create a struct usb_device_id that matches a</span>
<span class="cm"> * specific device with a specific class of interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * This is especially useful when explicitly matching devices that have</span>
<span class="cm"> * vendor specific bDeviceClass values, but standards-compliant interfaces.</span>
<span class="cm"> */</span>
<span class="cp">#define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \</span>
<span class="cp">	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \</span>
<span class="cp">		| USB_DEVICE_ID_MATCH_DEVICE, \</span>
<span class="cp">	.idVendor = (vend), \</span>
<span class="cp">	.idProduct = (prod), \</span>
<span class="cp">	.bInterfaceClass = (cl), \</span>
<span class="cp">	.bInterfaceSubClass = (sc), \</span>
<span class="cp">	.bInterfaceProtocol = (pr)</span>

<span class="cm">/* ----------------------------------------------------------------------- */</span>

<span class="cm">/* Stuff for dynamic usb ids */</span>
<span class="k">struct</span> <span class="n">usb_dynids</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">usb_dynid</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">usb_store_new_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_dynids</span> <span class="o">*</span><span class="n">dynids</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">usb_show_dynids</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_dynids</span> <span class="o">*</span><span class="n">dynids</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct usbdrv_wrap - wrapper for driver-model structure</span>
<span class="cm"> * @driver: The driver-model core driver structure.</span>
<span class="cm"> * @for_devices: Non-zero for device drivers, 0 for interface drivers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usbdrv_wrap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">for_devices</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_driver - identifies USB interface driver to usbcore</span>
<span class="cm"> * @name: The driver name should be unique among USB drivers,</span>
<span class="cm"> *	and should normally be the same as the module name.</span>
<span class="cm"> * @probe: Called to see if the driver is willing to manage a particular</span>
<span class="cm"> *	interface on a device.  If it is, probe returns zero and uses</span>
<span class="cm"> *	usb_set_intfdata() to associate driver-specific data with the</span>
<span class="cm"> *	interface.  It may also use usb_set_interface() to specify the</span>
<span class="cm"> *	appropriate altsetting.  If unwilling to manage the interface,</span>
<span class="cm"> *	return -ENODEV, if genuine IO errors occurred, an appropriate</span>
<span class="cm"> *	negative errno value.</span>
<span class="cm"> * @disconnect: Called when the interface is no longer accessible, usually</span>
<span class="cm"> *	because its device has been (or is being) disconnected or the</span>
<span class="cm"> *	driver module is being unloaded.</span>
<span class="cm"> * @unlocked_ioctl: Used for drivers that want to talk to userspace through</span>
<span class="cm"> *	the &quot;usbfs&quot; filesystem.  This lets devices provide ways to</span>
<span class="cm"> *	expose information to user space regardless of where they</span>
<span class="cm"> *	do (or don&#39;t) show up otherwise in the filesystem.</span>
<span class="cm"> * @suspend: Called when the device is going to be suspended by the system.</span>
<span class="cm"> * @resume: Called when the device is being resumed by the system.</span>
<span class="cm"> * @reset_resume: Called when the suspended device has been reset instead</span>
<span class="cm"> *	of being resumed.</span>
<span class="cm"> * @pre_reset: Called by usb_reset_device() when the device is about to be</span>
<span class="cm"> *	reset.  This routine must not return until the driver has no active</span>
<span class="cm"> *	URBs for the device, and no more URBs may be submitted until the</span>
<span class="cm"> *	post_reset method is called.</span>
<span class="cm"> * @post_reset: Called by usb_reset_device() after the device</span>
<span class="cm"> *	has been reset</span>
<span class="cm"> * @id_table: USB drivers use ID table to support hotplugging.</span>
<span class="cm"> *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set</span>
<span class="cm"> *	or your driver&#39;s probe function will never get called.</span>
<span class="cm"> * @dynids: used internally to hold the list of dynamically added device</span>
<span class="cm"> *	ids for this driver.</span>
<span class="cm"> * @drvwrap: Driver-model core structure wrapper.</span>
<span class="cm"> * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be</span>
<span class="cm"> *	added to this driver by preventing the sysfs file from being created.</span>
<span class="cm"> * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend</span>
<span class="cm"> *	for interfaces bound to this driver.</span>
<span class="cm"> * @soft_unbind: if set to 1, the USB core will not kill URBs and disable</span>
<span class="cm"> *	endpoints before calling the driver&#39;s disconnect method.</span>
<span class="cm"> * @disable_hub_initiated_lpm: if set to 0, the USB core will not allow hubs</span>
<span class="cm"> *	to initiate lower power link state transitions when an idle timeout</span>
<span class="cm"> *	occurs.  Device-initiated USB 3.0 link PM will still be allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * USB interface drivers must provide a name, probe() and disconnect()</span>
<span class="cm"> * methods, and an id_table.  Other driver fields are optional.</span>
<span class="cm"> *</span>
<span class="cm"> * The id_table is used in hotplugging.  It holds a set of descriptors,</span>
<span class="cm"> * and specialized data may be associated with each entry.  That table</span>
<span class="cm"> * is used by both user and kernel mode hotplugging support.</span>
<span class="cm"> *</span>
<span class="cm"> * The probe() and disconnect() methods are called in a context where</span>
<span class="cm"> * they can sleep, but they should avoid abusing the privilege.  Most</span>
<span class="cm"> * work to connect to a device should be done when the device is opened,</span>
<span class="cm"> * and undone at the last close.  The disconnect code needs to address</span>
<span class="cm"> * concurrency issues with respect to open() and close() methods, as</span>
<span class="cm"> * well as forcing all pending I/O requests to complete (by unlinking</span>
<span class="cm"> * them as necessary, and blocking until the unlinks complete).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unlocked_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">post_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_dynids</span> <span class="n">dynids</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usbdrv_wrap</span> <span class="n">drvwrap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_dynamic_id</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">supports_autosuspend</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">disable_hub_initiated_lpm</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">soft_unbind</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_device_driver - identifies USB device driver to usbcore</span>
<span class="cm"> * @name: The driver name should be unique among USB drivers,</span>
<span class="cm"> *	and should normally be the same as the module name.</span>
<span class="cm"> * @probe: Called to see if the driver is willing to manage a particular</span>
<span class="cm"> *	device.  If it is, probe returns zero and uses dev_set_drvdata()</span>
<span class="cm"> *	to associate driver-specific data with the device.  If unwilling</span>
<span class="cm"> *	to manage the device, return a negative errno value.</span>
<span class="cm"> * @disconnect: Called when the device is no longer accessible, usually</span>
<span class="cm"> *	because it has been (or is being) disconnected or the driver&#39;s</span>
<span class="cm"> *	module is being unloaded.</span>
<span class="cm"> * @suspend: Called when the device is going to be suspended by the system.</span>
<span class="cm"> * @resume: Called when the device is being resumed by the system.</span>
<span class="cm"> * @drvwrap: Driver-model core structure wrapper.</span>
<span class="cm"> * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend</span>
<span class="cm"> *	for devices bound to this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * USB drivers must provide all the fields listed above except drvwrap.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">usbdrv_wrap</span> <span class="n">drvwrap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">supports_autosuspend</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define	to_usb_device_driver(d) container_of(d, struct usb_device_driver, \</span>
<span class="cp">		drvwrap.driver)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">usb_bus_type</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_class_driver - identifies a USB driver that wants to use the USB major number</span>
<span class="cm"> * @name: the usb class device name for this driver.  Will show up in sysfs.</span>
<span class="cm"> * @devnode: Callback to provide a naming hint for a possible</span>
<span class="cm"> *	device node to create.</span>
<span class="cm"> * @fops: pointer to the struct file_operations of this driver.</span>
<span class="cm"> * @minor_base: the start of the minor range for this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used for the usb_register_dev() and</span>
<span class="cm"> * usb_unregister_dev() functions, to consolidate a number of the</span>
<span class="cm"> * parameters used for them.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_class_driver</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">devnode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minor_base</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * use these in module_init()/module_exit()</span>
<span class="cm"> * and don&#39;t forget MODULE_DEVICE_TABLE(usb, ...)</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */</span>
<span class="cp">#define usb_register(driver) \</span>
<span class="cp">	usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_deregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * module_usb_driver() - Helper macro for registering a USB driver</span>
<span class="cm"> * @__usb_driver: usb_driver struct</span>
<span class="cm"> *</span>
<span class="cm"> * Helper macro for USB drivers which do not do anything special in module</span>
<span class="cm"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span>
<span class="cm"> * use this macro once, and calling it replaces module_init() and module_exit()</span>
<span class="cm"> */</span>
<span class="cp">#define module_usb_driver(__usb_driver) \</span>
<span class="cp">	module_driver(__usb_driver, usb_register, \</span>
<span class="cp">		       usb_deregister)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_register_device_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_deregister_device_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_driver</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_register_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">usb_class_driver</span> <span class="o">*</span><span class="n">class_driver</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_deregister_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">usb_class_driver</span> <span class="o">*</span><span class="n">class_driver</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_disabled</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* ----------------------------------------------------------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> * URB support, for asynchronous request completions</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * urb-&gt;transfer_flags:</span>
<span class="cm"> *</span>
<span class="cm"> * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().</span>
<span class="cm"> */</span>
<span class="cp">#define URB_SHORT_NOT_OK	0x0001	</span><span class="cm">/* report short reads as errors */</span><span class="cp"></span>
<span class="cp">#define URB_ISO_ASAP		0x0002	</span><span class="cm">/* iso-only, urb-&gt;start_frame</span>
<span class="cm">					 * ignored */</span><span class="cp"></span>
<span class="cp">#define URB_NO_TRANSFER_DMA_MAP	0x0004	</span><span class="cm">/* urb-&gt;transfer_dma valid on submit */</span><span class="cp"></span>
<span class="cp">#define URB_NO_FSBR		0x0020	</span><span class="cm">/* UHCI-specific */</span><span class="cp"></span>
<span class="cp">#define URB_ZERO_PACKET		0x0040	</span><span class="cm">/* Finish bulk OUT with short packet */</span><span class="cp"></span>
<span class="cp">#define URB_NO_INTERRUPT	0x0080	</span><span class="cm">/* HINT: no non-error interrupt</span>
<span class="cm">					 * needed */</span><span class="cp"></span>
<span class="cp">#define URB_FREE_BUFFER		0x0100	</span><span class="cm">/* Free transfer buffer with the URB */</span><span class="cp"></span>

<span class="cm">/* The following flags are used internally by usbcore and HCDs */</span>
<span class="cp">#define URB_DIR_IN		0x0200	</span><span class="cm">/* Transfer from device to host */</span><span class="cp"></span>
<span class="cp">#define URB_DIR_OUT		0</span>
<span class="cp">#define URB_DIR_MASK		URB_DIR_IN</span>

<span class="cp">#define URB_DMA_MAP_SINGLE	0x00010000	</span><span class="cm">/* Non-scatter-gather mapping */</span><span class="cp"></span>
<span class="cp">#define URB_DMA_MAP_PAGE	0x00020000	</span><span class="cm">/* HCD-unsupported S-G */</span><span class="cp"></span>
<span class="cp">#define URB_DMA_MAP_SG		0x00040000	</span><span class="cm">/* HCD-supported S-G */</span><span class="cp"></span>
<span class="cp">#define URB_MAP_LOCAL		0x00080000	</span><span class="cm">/* HCD-local-memory mapping */</span><span class="cp"></span>
<span class="cp">#define URB_SETUP_MAP_SINGLE	0x00100000	</span><span class="cm">/* Setup packet DMA mapped */</span><span class="cp"></span>
<span class="cp">#define URB_SETUP_MAP_LOCAL	0x00200000	</span><span class="cm">/* HCD-local setup packet */</span><span class="cp"></span>
<span class="cp">#define URB_DMA_SG_COMBINED	0x00400000	</span><span class="cm">/* S-G entries were combined */</span><span class="cp"></span>
<span class="cp">#define URB_ALIGNED_TEMP_BUFFER	0x00800000	</span><span class="cm">/* Temp buffer was alloc&#39;d */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">usb_iso_packet_descriptor</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>		<span class="cm">/* expected length */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">actual_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">urb</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">usb_anchor</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">urb_list</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">poisoned</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_usb_anchor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">urb_list</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">usb_complete_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct urb - USB Request Block</span>
<span class="cm"> * @urb_list: For use by current owner of the URB.</span>
<span class="cm"> * @anchor_list: membership in the list of an anchor</span>
<span class="cm"> * @anchor: to anchor URBs to a common mooring</span>
<span class="cm"> * @ep: Points to the endpoint&#39;s data structure.  Will eventually</span>
<span class="cm"> *	replace @pipe.</span>
<span class="cm"> * @pipe: Holds endpoint number, direction, type, and more.</span>
<span class="cm"> *	Create these values with the eight macros available;</span>
<span class="cm"> *	usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is &quot;ctrl&quot;</span>
<span class="cm"> *	(control), &quot;bulk&quot;, &quot;int&quot; (interrupt), or &quot;iso&quot; (isochronous).</span>
<span class="cm"> *	For example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint</span>
<span class="cm"> *	numbers range from zero to fifteen.  Note that &quot;in&quot; endpoint two</span>
<span class="cm"> *	is a different endpoint (and pipe) from &quot;out&quot; endpoint two.</span>
<span class="cm"> *	The current configuration controls the existence, type, and</span>
<span class="cm"> *	maximum packet size of any given endpoint.</span>
<span class="cm"> * @stream_id: the endpoint&#39;s stream ID for bulk streams</span>
<span class="cm"> * @dev: Identifies the USB device to perform the request.</span>
<span class="cm"> * @status: This is read in non-iso completion functions to get the</span>
<span class="cm"> *	status of the particular request.  ISO requests only use it</span>
<span class="cm"> *	to tell whether the URB was unlinked; detailed status for</span>
<span class="cm"> *	each frame is in the fields of the iso_frame-desc.</span>
<span class="cm"> * @transfer_flags: A variety of flags may be used to affect how URB</span>
<span class="cm"> *	submission, unlinking, or operation are handled.  Different</span>
<span class="cm"> *	kinds of URB can use different flags.</span>
<span class="cm"> * @transfer_buffer:  This identifies the buffer to (or from) which the I/O</span>
<span class="cm"> *	request will be performed unless URB_NO_TRANSFER_DMA_MAP is set</span>
<span class="cm"> *	(however, do not leave garbage in transfer_buffer even then).</span>
<span class="cm"> *	This buffer must be suitable for DMA; allocate it with</span>
<span class="cm"> *	kmalloc() or equivalent.  For transfers to &quot;in&quot; endpoints, contents</span>
<span class="cm"> *	of this buffer will be modified.  This buffer is used for the data</span>
<span class="cm"> *	stage of control transfers.</span>
<span class="cm"> * @transfer_dma: When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,</span>
<span class="cm"> *	the device driver is saying that it provided this DMA address,</span>
<span class="cm"> *	which the host controller driver should use in preference to the</span>
<span class="cm"> *	transfer_buffer.</span>
<span class="cm"> * @sg: scatter gather buffer list</span>
<span class="cm"> * @num_mapped_sgs: (internal) number of mapped sg entries</span>
<span class="cm"> * @num_sgs: number of entries in the sg list</span>
<span class="cm"> * @transfer_buffer_length: How big is transfer_buffer.  The transfer may</span>
<span class="cm"> *	be broken up into chunks according to the current maximum packet</span>
<span class="cm"> *	size for the endpoint, which is a function of the configuration</span>
<span class="cm"> *	and is encoded in the pipe.  When the length is zero, neither</span>
<span class="cm"> *	transfer_buffer nor transfer_dma is used.</span>
<span class="cm"> * @actual_length: This is read in non-iso completion functions, and</span>
<span class="cm"> *	it tells how many bytes (out of transfer_buffer_length) were</span>
<span class="cm"> *	transferred.  It will normally be the same as requested, unless</span>
<span class="cm"> *	either an error was reported or a short read was performed.</span>
<span class="cm"> *	The URB_SHORT_NOT_OK transfer flag may be used to make such</span>
<span class="cm"> *	short reads be reported as errors.</span>
<span class="cm"> * @setup_packet: Only used for control transfers, this points to eight bytes</span>
<span class="cm"> *	of setup data.  Control transfers always start by sending this data</span>
<span class="cm"> *	to the device.  Then transfer_buffer is read or written, if needed.</span>
<span class="cm"> * @setup_dma: DMA pointer for the setup packet.  The caller must not use</span>
<span class="cm"> *	this field; setup_packet must point to a valid buffer.</span>
<span class="cm"> * @start_frame: Returns the initial frame for isochronous transfers.</span>
<span class="cm"> * @number_of_packets: Lists the number of ISO transfer buffers.</span>
<span class="cm"> * @interval: Specifies the polling interval for interrupt or isochronous</span>
<span class="cm"> *	transfers.  The units are frames (milliseconds) for full and low</span>
<span class="cm"> *	speed devices, and microframes (1/8 millisecond) for highspeed</span>
<span class="cm"> *	and SuperSpeed devices.</span>
<span class="cm"> * @error_count: Returns the number of ISO transfers that reported errors.</span>
<span class="cm"> * @context: For use in completion functions.  This normally points to</span>
<span class="cm"> *	request-specific driver context.</span>
<span class="cm"> * @complete: Completion handler. This URB is passed as the parameter to the</span>
<span class="cm"> *	completion function.  The completion function may then do what</span>
<span class="cm"> *	it likes with the URB, including resubmitting or freeing it.</span>
<span class="cm"> * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to</span>
<span class="cm"> *	collect the transfer status for each buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure identifies USB transfer requests.  URBs must be allocated by</span>
<span class="cm"> * calling usb_alloc_urb() and freed with a call to usb_free_urb().</span>
<span class="cm"> * Initialization may be done using various usb_fill_*_urb() functions.  URBs</span>
<span class="cm"> * are submitted using usb_submit_urb(), and pending requests may be canceled</span>
<span class="cm"> * using usb_unlink_urb() or usb_kill_urb().</span>
<span class="cm"> *</span>
<span class="cm"> * Data Transfer Buffers:</span>
<span class="cm"> *</span>
<span class="cm"> * Normally drivers provide I/O buffers allocated with kmalloc() or otherwise</span>
<span class="cm"> * taken from the general page pool.  That is provided by transfer_buffer</span>
<span class="cm"> * (control requests also use setup_packet), and host controller drivers</span>
<span class="cm"> * perform a dma mapping (and unmapping) for each buffer transferred.  Those</span>
<span class="cm"> * mapping operations can be expensive on some platforms (perhaps using a dma</span>
<span class="cm"> * bounce buffer or talking to an IOMMU),</span>
<span class="cm"> * although they&#39;re cheap on commodity x86 and ppc hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,</span>
<span class="cm"> * which tells the host controller driver that no such mapping is needed for</span>
<span class="cm"> * the transfer_buffer since</span>
<span class="cm"> * the device driver is DMA-aware.  For example, a device driver might</span>
<span class="cm"> * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().</span>
<span class="cm"> * When this transfer flag is provided, host controller drivers will</span>
<span class="cm"> * attempt to use the dma address found in the transfer_dma</span>
<span class="cm"> * field rather than determining a dma address themselves.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that transfer_buffer must still be set if the controller</span>
<span class="cm"> * does not support DMA (as indicated by bus.uses_dma) and when talking</span>
<span class="cm"> * to root hub. If you have to trasfer between highmem zone and the device</span>
<span class="cm"> * on such controller, create a bounce buffer or bail out with an error.</span>
<span class="cm"> * If transfer_buffer cannot be set (is in highmem) and the controller is DMA</span>
<span class="cm"> * capable, assign NULL to it, so that usbmon knows not to use the value.</span>
<span class="cm"> * The setup_packet must always be set, so it cannot be located in highmem.</span>
<span class="cm"> *</span>
<span class="cm"> * Initialization:</span>
<span class="cm"> *</span>
<span class="cm"> * All URBs submitted must initialize the dev, pipe, transfer_flags (may be</span>
<span class="cm"> * zero), and complete fields.  All URBs must also initialize</span>
<span class="cm"> * transfer_buffer and transfer_buffer_length.  They may provide the</span>
<span class="cm"> * URB_SHORT_NOT_OK transfer flag, indicating that short reads are</span>
<span class="cm"> * to be treated as errors; that flag is invalid for write requests.</span>
<span class="cm"> *</span>
<span class="cm"> * Bulk URBs may</span>
<span class="cm"> * use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers</span>
<span class="cm"> * should always terminate with a short packet, even if it means adding an</span>
<span class="cm"> * extra zero length packet.</span>
<span class="cm"> *</span>
<span class="cm"> * Control URBs must provide a valid pointer in the setup_packet field.</span>
<span class="cm"> * Unlike the transfer_buffer, the setup_packet may not be mapped for DMA</span>
<span class="cm"> * beforehand.</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt URBs must provide an interval, saying how often (in milliseconds</span>
<span class="cm"> * or, for highspeed devices, 125 microsecond units)</span>
<span class="cm"> * to poll for transfers.  After the URB has been submitted, the interval</span>
<span class="cm"> * field reflects how the transfer was actually scheduled.</span>
<span class="cm"> * The polling interval may be more frequent than requested.</span>
<span class="cm"> * For example, some controllers have a maximum interval of 32 milliseconds,</span>
<span class="cm"> * while others support intervals of up to 1024 milliseconds.</span>
<span class="cm"> * Isochronous URBs also have transfer intervals.  (Note that for isochronous</span>
<span class="cm"> * endpoints, as well as high speed interrupt endpoints, the encoding of</span>
<span class="cm"> * the transfer interval in the endpoint descriptor is logarithmic.</span>
<span class="cm"> * Device drivers must convert that value to linear units themselves.)</span>
<span class="cm"> *</span>
<span class="cm"> * Isochronous URBs normally use the URB_ISO_ASAP transfer flag, telling</span>
<span class="cm"> * the host controller to schedule the transfer as soon as bandwidth</span>
<span class="cm"> * utilization allows, and then set start_frame to reflect the actual frame</span>
<span class="cm"> * selected during submission.  Otherwise drivers must specify the start_frame</span>
<span class="cm"> * and handle the case where the transfer can&#39;t begin then.  However, drivers</span>
<span class="cm"> * won&#39;t know how bandwidth is currently allocated, and while they can</span>
<span class="cm"> * find the current frame using usb_get_current_frame_number () they can&#39;t</span>
<span class="cm"> * know the range for that frame number.  (Ranges for frame counter values</span>
<span class="cm"> * are HC-specific, and can go from 256 to 65536 frames from &quot;now&quot;.)</span>
<span class="cm"> *</span>
<span class="cm"> * Isochronous URBs have a different data transfer model, in part because</span>
<span class="cm"> * the quality of service is only &quot;best effort&quot;.  Callers provide specially</span>
<span class="cm"> * allocated URBs, with number_of_packets worth of iso_frame_desc structures</span>
<span class="cm"> * at the end.  Each such packet is an individual ISO transfer.  Isochronous</span>
<span class="cm"> * URBs are normally queued, submitted by drivers to arrange that</span>
<span class="cm"> * transfers are at least double buffered, and then explicitly resubmitted</span>
<span class="cm"> * in completion handlers, so</span>
<span class="cm"> * that data (such as audio or video) streams at as constant a rate as the</span>
<span class="cm"> * host controller scheduler can support.</span>
<span class="cm"> *</span>
<span class="cm"> * Completion Callbacks:</span>
<span class="cm"> *</span>
<span class="cm"> * The completion callback is made in_interrupt(), and one of the first</span>
<span class="cm"> * things that a completion handler should do is check the status field.</span>
<span class="cm"> * The status field is provided for all URBs.  It is used to report</span>
<span class="cm"> * unlinked URBs, and status for all non-ISO transfers.  It should not</span>
<span class="cm"> * be examined before the URB is returned to the completion handler.</span>
<span class="cm"> *</span>
<span class="cm"> * The context field is normally used to link URBs back to the relevant</span>
<span class="cm"> * driver or request state.</span>
<span class="cm"> *</span>
<span class="cm"> * When the completion callback is invoked for non-isochronous URBs, the</span>
<span class="cm"> * actual_length field tells how many bytes were transferred.  This field</span>
<span class="cm"> * is updated even when the URB terminated with an error or was unlinked.</span>
<span class="cm"> *</span>
<span class="cm"> * ISO transfer status is reported in the status and actual_length fields</span>
<span class="cm"> * of the iso_frame_desc array, and the number of errors is reported in</span>
<span class="cm"> * error_count.  Completion callbacks for ISO transfers will normally</span>
<span class="cm"> * (re)submit URBs to ensure a constant transfer rate.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that even fields marked &quot;public&quot; should not be touched by the driver</span>
<span class="cm"> * when the urb is owned by the hcd, that is, since the call to</span>
<span class="cm"> * usb_submit_urb() till the entry into the completion routine.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">urb</span> <span class="p">{</span>
	<span class="cm">/* private: usb core and host controller only fields in the urb */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>		<span class="cm">/* reference count of the URB */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">hcpriv</span><span class="p">;</span>			<span class="cm">/* private data for host controller */</span>
	<span class="n">atomic_t</span> <span class="n">use_count</span><span class="p">;</span>		<span class="cm">/* concurrent submissions counter */</span>
	<span class="n">atomic_t</span> <span class="n">reject</span><span class="p">;</span>		<span class="cm">/* submissions will fail */</span>
	<span class="kt">int</span> <span class="n">unlinked</span><span class="p">;</span>			<span class="cm">/* unlink error code */</span>

	<span class="cm">/* public: documented fields in the urb that can be used by drivers */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">urb_list</span><span class="p">;</span>	<span class="cm">/* list head for use by the urb&#39;s</span>
<span class="cm">					 * current owner */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">anchor_list</span><span class="p">;</span>	<span class="cm">/* the URB may be anchored */</span>
	<span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* (in) pointer to associated device */</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>	<span class="cm">/* (internal) pointer to endpoint */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">;</span>		<span class="cm">/* (in) pipe information */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stream_id</span><span class="p">;</span>		<span class="cm">/* (in) stream ID */</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>			<span class="cm">/* (return) non-ISO status */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">transfer_flags</span><span class="p">;</span>	<span class="cm">/* (in) URB_SHORT_NOT_OK | ...*/</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">transfer_buffer</span><span class="p">;</span>		<span class="cm">/* (in) associated data buffer */</span>
	<span class="n">dma_addr_t</span> <span class="n">transfer_dma</span><span class="p">;</span>	<span class="cm">/* (in) dma addr for transfer_buffer */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>		<span class="cm">/* (in) scatter gather buffer list */</span>
	<span class="kt">int</span> <span class="n">num_mapped_sgs</span><span class="p">;</span>		<span class="cm">/* (internal) mapped sg entries */</span>
	<span class="kt">int</span> <span class="n">num_sgs</span><span class="p">;</span>			<span class="cm">/* (in) number of entries in the sg list */</span>
	<span class="n">u32</span> <span class="n">transfer_buffer_length</span><span class="p">;</span>	<span class="cm">/* (in) data buffer length */</span>
	<span class="n">u32</span> <span class="n">actual_length</span><span class="p">;</span>		<span class="cm">/* (return) actual transfer length */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">setup_packet</span><span class="p">;</span>	<span class="cm">/* (in) setup packet (control only) */</span>
	<span class="n">dma_addr_t</span> <span class="n">setup_dma</span><span class="p">;</span>		<span class="cm">/* (in) dma addr for setup_packet */</span>
	<span class="kt">int</span> <span class="n">start_frame</span><span class="p">;</span>		<span class="cm">/* (modify) start frame (ISO) */</span>
	<span class="kt">int</span> <span class="n">number_of_packets</span><span class="p">;</span>		<span class="cm">/* (in) number of ISO packets */</span>
	<span class="kt">int</span> <span class="n">interval</span><span class="p">;</span>			<span class="cm">/* (modify) transfer interval</span>
<span class="cm">					 * (INT/ISO) */</span>
	<span class="kt">int</span> <span class="n">error_count</span><span class="p">;</span>		<span class="cm">/* (return) number of ISO errors */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>			<span class="cm">/* (in) context for completion */</span>
	<span class="n">usb_complete_t</span> <span class="n">complete</span><span class="p">;</span>	<span class="cm">/* (in) completion routine */</span>
	<span class="k">struct</span> <span class="n">usb_iso_packet_descriptor</span> <span class="n">iso_frame_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
					<span class="cm">/* (in) ISO ONLY */</span>
<span class="p">};</span>

<span class="cm">/* ----------------------------------------------------------------------- */</span>

<span class="cm">/**</span>
<span class="cm"> * usb_fill_control_urb - initializes a control urb</span>
<span class="cm"> * @urb: pointer to the urb to initialize.</span>
<span class="cm"> * @dev: pointer to the struct usb_device for this urb.</span>
<span class="cm"> * @pipe: the endpoint pipe</span>
<span class="cm"> * @setup_packet: pointer to the setup_packet buffer</span>
<span class="cm"> * @transfer_buffer: pointer to the transfer buffer</span>
<span class="cm"> * @buffer_length: length of the transfer buffer</span>
<span class="cm"> * @complete_fn: pointer to the usb_complete_t function</span>
<span class="cm"> * @context: what to set the urb context to.</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes a control urb with the proper information needed to submit</span>
<span class="cm"> * it to a device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_fill_control_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">setup_packet</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">transfer_buffer</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">buffer_length</span><span class="p">,</span>
					<span class="n">usb_complete_t</span> <span class="n">complete_fn</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">setup_packet</span> <span class="o">=</span> <span class="n">setup_packet</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">buffer_length</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">complete_fn</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_fill_bulk_urb - macro to help initialize a bulk urb</span>
<span class="cm"> * @urb: pointer to the urb to initialize.</span>
<span class="cm"> * @dev: pointer to the struct usb_device for this urb.</span>
<span class="cm"> * @pipe: the endpoint pipe</span>
<span class="cm"> * @transfer_buffer: pointer to the transfer buffer</span>
<span class="cm"> * @buffer_length: length of the transfer buffer</span>
<span class="cm"> * @complete_fn: pointer to the usb_complete_t function</span>
<span class="cm"> * @context: what to set the urb context to.</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes a bulk urb with the proper information needed to submit it</span>
<span class="cm"> * to a device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_fill_bulk_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">transfer_buffer</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">buffer_length</span><span class="p">,</span>
				     <span class="n">usb_complete_t</span> <span class="n">complete_fn</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">buffer_length</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">complete_fn</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_fill_int_urb - macro to help initialize a interrupt urb</span>
<span class="cm"> * @urb: pointer to the urb to initialize.</span>
<span class="cm"> * @dev: pointer to the struct usb_device for this urb.</span>
<span class="cm"> * @pipe: the endpoint pipe</span>
<span class="cm"> * @transfer_buffer: pointer to the transfer buffer</span>
<span class="cm"> * @buffer_length: length of the transfer buffer</span>
<span class="cm"> * @complete_fn: pointer to the usb_complete_t function</span>
<span class="cm"> * @context: what to set the urb context to.</span>
<span class="cm"> * @interval: what to set the urb interval to, encoded like</span>
<span class="cm"> *	the endpoint descriptor&#39;s bInterval value.</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes a interrupt urb with the proper information needed to submit</span>
<span class="cm"> * it to a device.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that High Speed and SuperSpeed interrupt endpoints use a logarithmic</span>
<span class="cm"> * encoding of the endpoint interval, and express polling intervals in</span>
<span class="cm"> * microframes (eight per millisecond) rather than in frames (one per</span>
<span class="cm"> * millisecond).</span>
<span class="cm"> *</span>
<span class="cm"> * Wireless USB also uses the logarithmic encoding, but specifies it in units of</span>
<span class="cm"> * 128us instead of 125us.  For Wireless USB devices, the interval is passed</span>
<span class="cm"> * through to the host controller, rather than being translated into microframe</span>
<span class="cm"> * units.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">usb_fill_int_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">transfer_buffer</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">buffer_length</span><span class="p">,</span>
				    <span class="n">usb_complete_t</span> <span class="n">complete_fn</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span> <span class="o">=</span> <span class="n">transfer_buffer</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">buffer_length</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">complete</span> <span class="o">=</span> <span class="n">complete_fn</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_HIGH</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">USB_SPEED_SUPER</span><span class="p">)</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">interval</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">start_frame</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_init_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">usb_alloc_urb</span><span class="p">(</span><span class="kt">int</span> <span class="n">iso_packets</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_free_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="cp">#define usb_put_urb usb_free_urb</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">usb_get_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_unlink_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_kill_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_poison_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_unpoison_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_block_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_kill_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_poison_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_unpoison_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_unlink_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_anchor_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_unanchor_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_wait_anchor_empty_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">usb_get_from_anchor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_scuttle_anchored_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_anchor_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_anchor</span> <span class="o">*</span><span class="n">anchor</span><span class="p">);</span>

<span class="cp">#define usb_unblock_urb	usb_unpoison_urb</span>

<span class="cm">/**</span>
<span class="cm"> * usb_urb_dir_in - check if an URB describes an IN transfer</span>
<span class="cm"> * @urb: URB to be checked</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if @urb describes an IN transfer (device-to-host),</span>
<span class="cm"> * otherwise 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_urb_dir_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_DIR_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">URB_DIR_IN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * usb_urb_dir_out - check if an URB describes an OUT transfer</span>
<span class="cm"> * @urb: URB to be checked</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if @urb describes an OUT transfer (host-to-device),</span>
<span class="cm"> * otherwise 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_urb_dir_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">&amp;</span> <span class="n">URB_DIR_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">URB_DIR_OUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
	<span class="n">gfp_t</span> <span class="n">mem_flags</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_free_coherent</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">struct urb *usb_buffer_map(struct urb *urb);</span>
<span class="c">void usb_buffer_dmasync(struct urb *urb);</span>
<span class="c">void usb_buffer_unmap(struct urb *urb);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">scatterlist</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">usb_buffer_map_sg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_in</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,</span>
<span class="c">			   struct scatterlist *sg, int n_hw_ents);</span>
<span class="cp">#endif</span>
<span class="kt">void</span> <span class="n">usb_buffer_unmap_sg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_in</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_hw_ents</span><span class="p">);</span>

<span class="cm">/*-------------------------------------------------------------------*</span>
<span class="cm"> *                         SYNCHRONOUS CALL SUPPORT                  *</span>
<span class="cm"> *-------------------------------------------------------------------*/</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
	<span class="n">__u8</span> <span class="n">request</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">requesttype</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">value</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">index</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_interrupt_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">actual_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_bulk_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usb_dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">actual_length</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="cm">/* wrappers around usb_control_msg() for the most common standard requests */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">desctype</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">descindex</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* wrappers that also update important state inside usbcore */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_clear_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_reset_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alternate</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_reset_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">epaddr</span><span class="p">);</span>

<span class="cm">/* this request isn&#39;t really synchronous, but it belongs with the others */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">usb_driver_set_configuration</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">config</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * timeouts, in milliseconds, used for sending/receiving control messages</span>
<span class="cm"> * they typically complete within a few frames (msec) after they&#39;re issued</span>
<span class="cm"> * USB identifies 5 second timeouts, maybe more in a few cases, and a few</span>
<span class="cm"> * slow devices (like some MGE Ellipse UPSes) actually push that limit.</span>
<span class="cm"> */</span>
<span class="cp">#define USB_CTRL_GET_TIMEOUT	5000</span>
<span class="cp">#define USB_CTRL_SET_TIMEOUT	5000</span>


<span class="cm">/**</span>
<span class="cm"> * struct usb_sg_request - support for scatter/gather I/O</span>
<span class="cm"> * @status: zero indicates success, else negative errno</span>
<span class="cm"> * @bytes: counts bytes transferred.</span>
<span class="cm"> *</span>
<span class="cm"> * These requests are initialized using usb_sg_init(), and then are used</span>
<span class="cm"> * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most</span>
<span class="cm"> * members of the request object aren&#39;t for driver access.</span>
<span class="cm"> *</span>
<span class="cm"> * The status and bytecount values are valid only after usb_sg_wait()</span>
<span class="cm"> * returns.  If the status is zero, then the bytecount matches the total</span>
<span class="cm"> * from the request.</span>
<span class="cm"> *</span>
<span class="cm"> * After an error completion, drivers may need to clear a halt condition</span>
<span class="cm"> * on the endpoint.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="kt">size_t</span>			<span class="n">bytes</span><span class="p">;</span>

	<span class="cm">/* private:</span>
<span class="cm">	 * members below are private to usbcore,</span>
<span class="cm">	 * and are not provided for driver access!</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pipe</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">entries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span>		<span class="o">**</span><span class="n">urbs</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">complete</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">usb_sg_init</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">usb_sg_request</span>	<span class="o">*</span><span class="n">io</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">usb_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">pipe</span><span class="p">,</span>
	<span class="kt">unsigned</span>		<span class="n">period</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sg</span><span class="p">,</span>
	<span class="kt">int</span>			<span class="n">nents</span><span class="p">,</span>
	<span class="kt">size_t</span>			<span class="n">length</span><span class="p">,</span>
	<span class="n">gfp_t</span>			<span class="n">mem_flags</span>
<span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_sg_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="o">*</span><span class="n">io</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">usb_sg_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_sg_request</span> <span class="o">*</span><span class="n">io</span><span class="p">);</span>


<span class="cm">/* ----------------------------------------------------------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> * For various legacy reasons, Linux has a small cookie that&#39;s paired with</span>
<span class="cm"> * a struct usb_device to identify an endpoint queue.  Queue characteristics</span>
<span class="cm"> * are defined by the endpoint&#39;s descriptor.  This cookie is called a &quot;pipe&quot;,</span>
<span class="cm"> * an unsigned int encoded as:</span>
<span class="cm"> *</span>
<span class="cm"> *  - direction:	bit 7		(0 = Host-to-Device [Out],</span>
<span class="cm"> *					 1 = Device-to-Host [In] ...</span>
<span class="cm"> *					like endpoint bEndpointAddress)</span>
<span class="cm"> *  - device address:	bits 8-14       ... bit positions known to uhci-hcd</span>
<span class="cm"> *  - endpoint:		bits 15-18      ... bit positions known to uhci-hcd</span>
<span class="cm"> *  - pipe type:	bits 30-31	(00 = isochronous, 01 = interrupt,</span>
<span class="cm"> *					 10 = control, 11 = bulk)</span>
<span class="cm"> *</span>
<span class="cm"> * Given the device address and endpoint descriptor, pipes are redundant.</span>
<span class="cm"> */</span>

<span class="cm">/* NOTE:  these are not the standard USB_ENDPOINT_XFER_* values!! */</span>
<span class="cm">/* (yet ... they&#39;re the values used by usbfs) */</span>
<span class="cp">#define PIPE_ISOCHRONOUS		0</span>
<span class="cp">#define PIPE_INTERRUPT			1</span>
<span class="cp">#define PIPE_CONTROL			2</span>
<span class="cp">#define PIPE_BULK			3</span>

<span class="cp">#define usb_pipein(pipe)	((pipe) &amp; USB_DIR_IN)</span>
<span class="cp">#define usb_pipeout(pipe)	(!usb_pipein(pipe))</span>

<span class="cp">#define usb_pipedevice(pipe)	(((pipe) &gt;&gt; 8) &amp; 0x7f)</span>
<span class="cp">#define usb_pipeendpoint(pipe)	(((pipe) &gt;&gt; 15) &amp; 0xf)</span>

<span class="cp">#define usb_pipetype(pipe)	(((pipe) &gt;&gt; 30) &amp; 3)</span>
<span class="cp">#define usb_pipeisoc(pipe)	(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)</span>
<span class="cp">#define usb_pipeint(pipe)	(usb_pipetype((pipe)) == PIPE_INTERRUPT)</span>
<span class="cp">#define usb_pipecontrol(pipe)	(usb_pipetype((pipe)) == PIPE_CONTROL)</span>
<span class="cp">#define usb_pipebulk(pipe)	(usb_pipetype((pipe)) == PIPE_BULK)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__create_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">endpoint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">endpoint</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Create various pipes... */</span>
<span class="cp">#define usb_sndctrlpipe(dev, endpoint)	\</span>
<span class="cp">	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev, endpoint))</span>
<span class="cp">#define usb_rcvctrlpipe(dev, endpoint)	\</span>
<span class="cp">	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span>
<span class="cp">#define usb_sndisocpipe(dev, endpoint)	\</span>
<span class="cp">	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev, endpoint))</span>
<span class="cp">#define usb_rcvisocpipe(dev, endpoint)	\</span>
<span class="cp">	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span>
<span class="cp">#define usb_sndbulkpipe(dev, endpoint)	\</span>
<span class="cp">	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev, endpoint))</span>
<span class="cp">#define usb_rcvbulkpipe(dev, endpoint)	\</span>
<span class="cp">	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span>
<span class="cp">#define usb_sndintpipe(dev, endpoint)	\</span>
<span class="cp">	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev, endpoint))</span>
<span class="cp">#define usb_rcvintpipe(dev, endpoint)	\</span>
<span class="cp">	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span>
<span class="nf">usb_pipe_endpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">**</span><span class="n">eps</span><span class="p">;</span>
	<span class="n">eps</span> <span class="o">=</span> <span class="n">usb_pipein</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_in</span> <span class="o">:</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">eps</span><span class="p">[</span><span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">pipe</span><span class="p">)];</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span>
<span class="nf">usb_maxpacket</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_endpoint</span>	<span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">epnum</span> <span class="o">=</span> <span class="n">usb_pipeendpoint</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">usb_pipein</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">usb_pipeout</span><span class="p">(</span><span class="n">pipe</span><span class="p">));</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">[</span><span class="n">epnum</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* NOTE:  only 0x07ff bits are for packet size... */</span>
	<span class="k">return</span> <span class="n">usb_endpoint_maxp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ----------------------------------------------------------------------- */</span>

<span class="cm">/* translate USB error codes to codes user space understands */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">usb_translate_errors</span><span class="p">(</span><span class="kt">int</span> <span class="n">error_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">error_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENOMEM</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span>:
		<span class="k">return</span> <span class="n">error_code</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Events from the usb core */</span>
<span class="cp">#define USB_DEVICE_ADD		0x0001</span>
<span class="cp">#define USB_DEVICE_REMOVE	0x0002</span>
<span class="cp">#define USB_BUS_ADD		0x0003</span>
<span class="cp">#define USB_BUS_REMOVE		0x0004</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_register_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">usb_unregister_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define dbg(format, arg...)						\</span>
<span class="cp">	printk(KERN_DEBUG &quot;%s: &quot; format &quot;\n&quot;, __FILE__, ##arg)</span>
<span class="cp">#else</span>
<span class="cp">#define dbg(format, arg...)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (0)								\</span>
<span class="cp">		printk(KERN_DEBUG &quot;%s: &quot; format &quot;\n&quot;, __FILE__, ##arg); \</span>
<span class="cp">} while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/* debugfs stuff */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">usb_debug_root</span><span class="p">;</span>

<span class="cp">#endif  </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
