<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mmu_notifier.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>mmu_notifier.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_MMU_NOTIFIER_H</span>
<span class="cp">#define _LINUX_MMU_NOTIFIER_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mm_types.h&gt;</span>

<span class="k">struct</span> <span class="n">mmu_notifier</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mmu_notifier_ops</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MMU_NOTIFIER</span>

<span class="cm">/*</span>
<span class="cm"> * The mmu notifier_mm structure is allocated and installed in</span>
<span class="cm"> * mm-&gt;mmu_notifier_mm inside the mm_take_all_locks() protected</span>
<span class="cm"> * critical section and it&#39;s released only when mm_count reaches zero</span>
<span class="cm"> * in mmdrop().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mmu_notifier_mm</span> <span class="p">{</span>
	<span class="cm">/* all mmu notifiers registerd in this mm are queued in this list */</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="cm">/* to serialize the list modifications and hlist_unhashed */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mmu_notifier_ops</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Called either by mmu_notifier_unregister or when the mm is</span>
<span class="cm">	 * being destroyed by exit_mmap, always before all pages are</span>
<span class="cm">	 * freed. This can run concurrently with other mmu notifier</span>
<span class="cm">	 * methods (the ones invoked outside the mm context) and it</span>
<span class="cm">	 * should tear down all secondary mmu mappings and freeze the</span>
<span class="cm">	 * secondary mmu. If this method isn&#39;t implemented you&#39;ve to</span>
<span class="cm">	 * be sure that nothing could possibly write to the pages</span>
<span class="cm">	 * through the secondary mmu by the time the last thread with</span>
<span class="cm">	 * tsk-&gt;mm == mm exits.</span>
<span class="cm">	 *</span>
<span class="cm">	 * As side note: the pages freed after -&gt;release returns could</span>
<span class="cm">	 * be immediately reallocated by the gart at an alias physical</span>
<span class="cm">	 * address with a different cache model, so if -&gt;release isn&#39;t</span>
<span class="cm">	 * implemented because all _software_ driven memory accesses</span>
<span class="cm">	 * through the secondary mmu are terminated by the time the</span>
<span class="cm">	 * last thread of this mm quits, you&#39;ve also to be sure that</span>
<span class="cm">	 * speculative _hardware_ operations can&#39;t allocate dirty</span>
<span class="cm">	 * cachelines in the cpu that could not be snooped and made</span>
<span class="cm">	 * coherent with the other read and write operations happening</span>
<span class="cm">	 * through the gart alias address, so leading to memory</span>
<span class="cm">	 * corruption.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * clear_flush_young is called after the VM is</span>
<span class="cm">	 * test-and-clearing the young/accessed bitflag in the</span>
<span class="cm">	 * pte. This way the VM will provide proper aging to the</span>
<span class="cm">	 * accesses to the page through the secondary MMUs and not</span>
<span class="cm">	 * only to the ones through the Linux pte.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">clear_flush_young</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * test_young is called to check the young/accessed bitflag in</span>
<span class="cm">	 * the secondary pte. This is used to know if the page is</span>
<span class="cm">	 * frequently used without actually clearing the flag or tearing</span>
<span class="cm">	 * down the secondary mapping on the page.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test_young</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * change_pte is called in cases that pte mapping to page is changed:</span>
<span class="cm">	 * for example, when ksm remaps pte to point to a new shared page.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">change_pte</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			   <span class="n">pte_t</span> <span class="n">pte</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before this is invoked any secondary MMU is still ok to</span>
<span class="cm">	 * read/write to the page previously pointed to by the Linux</span>
<span class="cm">	 * pte because the page hasn&#39;t been freed yet and it won&#39;t be</span>
<span class="cm">	 * freed until this returns. If required set_page_dirty has to</span>
<span class="cm">	 * be called internally to this method.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invalidate_page</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * invalidate_range_start() and invalidate_range_end() must be</span>
<span class="cm">	 * paired and are called only when the mmap_sem and/or the</span>
<span class="cm">	 * locks protecting the reverse maps are held. The subsystem</span>
<span class="cm">	 * must guarantee that no additional references are taken to</span>
<span class="cm">	 * the pages in the range established between the call to</span>
<span class="cm">	 * invalidate_range_start() and the matching call to</span>
<span class="cm">	 * invalidate_range_end().</span>
<span class="cm">	 *</span>
<span class="cm">	 * Invalidation of multiple concurrent ranges may be</span>
<span class="cm">	 * optionally permitted by the driver. Either way the</span>
<span class="cm">	 * establishment of sptes is forbidden in the range passed to</span>
<span class="cm">	 * invalidate_range_begin/end for the whole duration of the</span>
<span class="cm">	 * invalidate_range_begin/end critical section.</span>
<span class="cm">	 *</span>
<span class="cm">	 * invalidate_range_start() is called when all pages in the</span>
<span class="cm">	 * range are still mapped and have at least a refcount of one.</span>
<span class="cm">	 *</span>
<span class="cm">	 * invalidate_range_end() is called when all pages in the</span>
<span class="cm">	 * range have been unmapped and the pages have been freed by</span>
<span class="cm">	 * the VM.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The VM will remove the page table entries and potentially</span>
<span class="cm">	 * the page between invalidate_range_start() and</span>
<span class="cm">	 * invalidate_range_end(). If the page must not be freed</span>
<span class="cm">	 * because of pending I/O or other circumstances then the</span>
<span class="cm">	 * invalidate_range_start() callback (or the initial mapping</span>
<span class="cm">	 * by the driver) must make sure that the refcount is kept</span>
<span class="cm">	 * elevated.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the driver increases the refcount when the pages are</span>
<span class="cm">	 * initially mapped into an address space then either</span>
<span class="cm">	 * invalidate_range_start() or invalidate_range_end() may</span>
<span class="cm">	 * decrease the refcount. If the refcount is decreased on</span>
<span class="cm">	 * invalidate_range_start() then the VM can free pages as page</span>
<span class="cm">	 * table entries are removed.  If the refcount is only</span>
<span class="cm">	 * droppped on invalidate_range_end() then the driver itself</span>
<span class="cm">	 * will drop the last refcount but it must take care to flush</span>
<span class="cm">	 * any secondary tlb before doing the final free on the</span>
<span class="cm">	 * page. Pages will no longer be referenced by the linux</span>
<span class="cm">	 * address space but may still be referenced by sptes until</span>
<span class="cm">	 * the last refcount is dropped.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invalidate_range_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invalidate_range_end</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The notifier chains are protected by mmap_sem and/or the reverse map</span>
<span class="cm"> * semaphores. Notifier chains are only changed when all reverse maps and</span>
<span class="cm"> * the mmap_sem locks are taken.</span>
<span class="cm"> *</span>
<span class="cm"> * Therefore notifier chains can only be traversed when either</span>
<span class="cm"> *</span>
<span class="cm"> * 1. mmap_sem is held.</span>
<span class="cm"> * 2. One of the reverse map locks is held (i_mmap_mutex or anon_vma-&gt;mutex).</span>
<span class="cm"> * 3. No other concurrent thread can access the list (release)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hlist</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mmu_notifier_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mm_has_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">mmu_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__mmu_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mmu_notifier_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_notifier</span> <span class="o">*</span><span class="n">mn</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__mmu_notifier_mm_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__mmu_notifier_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__mmu_notifier_clear_flush_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__mmu_notifier_test_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__mmu_notifier_change_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__mmu_notifier_invalidate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_notifiers</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">__mmu_notifier_release</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmu_notifier_clear_flush_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_notifiers</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__mmu_notifier_clear_flush_young</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmu_notifier_test_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_notifiers</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__mmu_notifier_test_young</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_change_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_notifiers</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">__mmu_notifier_change_pte</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_invalidate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_notifiers</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">__mmu_notifier_invalidate_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_notifiers</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">__mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_notifiers</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">__mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_mm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmu_notifier_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_mm_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_has_notifiers</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">__mmu_notifier_mm_destroy</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These two macros will sometime replace ptep_clear_flush.</span>
<span class="cm"> * ptep_clear_flush is implemented as macro itself, so this also is</span>
<span class="cm"> * implemented as a macro until ptep_clear_flush will converted to an</span>
<span class="cm"> * inline function, to diminish the risk of compilation failure. The</span>
<span class="cm"> * invalidate_page method over time can be moved outside the PT lock</span>
<span class="cm"> * and these two macros can be later removed.</span>
<span class="cm"> */</span>
<span class="cp">#define ptep_clear_flush_notify(__vma, __address, __ptep)		\</span>
<span class="cp">({									\</span>
<span class="cp">	pte_t __pte;							\</span>
<span class="cp">	struct vm_area_struct *___vma = __vma;				\</span>
<span class="cp">	unsigned long ___address = __address;				\</span>
<span class="cp">	__pte = ptep_clear_flush(___vma, ___address, __ptep);		\</span>
<span class="cp">	mmu_notifier_invalidate_page(___vma-&gt;vm_mm, ___address);	\</span>
<span class="cp">	__pte;								\</span>
<span class="cp">})</span>

<span class="cp">#define pmdp_clear_flush_notify(__vma, __address, __pmdp)		\</span>
<span class="cp">({									\</span>
<span class="cp">	pmd_t __pmd;							\</span>
<span class="cp">	struct vm_area_struct *___vma = __vma;				\</span>
<span class="cp">	unsigned long ___address = __address;				\</span>
<span class="cp">	VM_BUG_ON(__address &amp; ~HPAGE_PMD_MASK);				\</span>
<span class="cp">	mmu_notifier_invalidate_range_start(___vma-&gt;vm_mm, ___address,	\</span>
<span class="cp">					    (__address)+HPAGE_PMD_SIZE);\</span>
<span class="cp">	__pmd = pmdp_clear_flush(___vma, ___address, __pmdp);		\</span>
<span class="cp">	mmu_notifier_invalidate_range_end(___vma-&gt;vm_mm, ___address,	\</span>
<span class="cp">					  (__address)+HPAGE_PMD_SIZE);	\</span>
<span class="cp">	__pmd;								\</span>
<span class="cp">})</span>

<span class="cp">#define pmdp_splitting_flush_notify(__vma, __address, __pmdp)		\</span>
<span class="cp">({									\</span>
<span class="cp">	struct vm_area_struct *___vma = __vma;				\</span>
<span class="cp">	unsigned long ___address = __address;				\</span>
<span class="cp">	VM_BUG_ON(__address &amp; ~HPAGE_PMD_MASK);				\</span>
<span class="cp">	mmu_notifier_invalidate_range_start(___vma-&gt;vm_mm, ___address,	\</span>
<span class="cp">					    (__address)+HPAGE_PMD_SIZE);\</span>
<span class="cp">	pmdp_splitting_flush(___vma, ___address, __pmdp);		\</span>
<span class="cp">	mmu_notifier_invalidate_range_end(___vma-&gt;vm_mm, ___address,	\</span>
<span class="cp">					  (__address)+HPAGE_PMD_SIZE);	\</span>
<span class="cp">})</span>

<span class="cp">#define ptep_clear_flush_young_notify(__vma, __address, __ptep)		\</span>
<span class="cp">({									\</span>
<span class="cp">	int __young;							\</span>
<span class="cp">	struct vm_area_struct *___vma = __vma;				\</span>
<span class="cp">	unsigned long ___address = __address;				\</span>
<span class="cp">	__young = ptep_clear_flush_young(___vma, ___address, __ptep);	\</span>
<span class="cp">	__young |= mmu_notifier_clear_flush_young(___vma-&gt;vm_mm,	\</span>
<span class="cp">						  ___address);		\</span>
<span class="cp">	__young;							\</span>
<span class="cp">})</span>

<span class="cp">#define pmdp_clear_flush_young_notify(__vma, __address, __pmdp)		\</span>
<span class="cp">({									\</span>
<span class="cp">	int __young;							\</span>
<span class="cp">	struct vm_area_struct *___vma = __vma;				\</span>
<span class="cp">	unsigned long ___address = __address;				\</span>
<span class="cp">	__young = pmdp_clear_flush_young(___vma, ___address, __pmdp);	\</span>
<span class="cp">	__young |= mmu_notifier_clear_flush_young(___vma-&gt;vm_mm,	\</span>
<span class="cp">						  ___address);		\</span>
<span class="cp">	__young;							\</span>
<span class="cp">})</span>

<span class="cp">#define set_pte_at_notify(__mm, __address, __ptep, __pte)		\</span>
<span class="cp">({									\</span>
<span class="cp">	struct mm_struct *___mm = __mm;					\</span>
<span class="cp">	unsigned long ___address = __address;				\</span>
<span class="cp">	pte_t ___pte = __pte;						\</span>
<span class="cp">									\</span>
<span class="cp">	set_pte_at(___mm, ___address, __ptep, ___pte);			\</span>
<span class="cp">	mmu_notifier_change_pte(___mm, ___address, ___pte);		\</span>
<span class="cp">})</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_MMU_NOTIFIER */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmu_notifier_clear_flush_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mmu_notifier_test_young</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_change_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_invalidate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_mm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mmu_notifier_mm_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#define ptep_clear_flush_young_notify ptep_clear_flush_young</span>
<span class="cp">#define pmdp_clear_flush_young_notify pmdp_clear_flush_young</span>
<span class="cp">#define ptep_clear_flush_notify ptep_clear_flush</span>
<span class="cp">#define pmdp_clear_flush_notify pmdp_clear_flush</span>
<span class="cp">#define pmdp_splitting_flush_notify pmdp_splitting_flush</span>
<span class="cp">#define set_pte_at_notify set_pte_at</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU_NOTIFIER */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_MMU_NOTIFIER_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
