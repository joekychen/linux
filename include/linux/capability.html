<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › capability.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>capability.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This is &lt;linux/capability.h&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Andrew G. Morgan &lt;morgan@kernel.org&gt;</span>
<span class="cm"> * Alexander Kjeldaas &lt;astor@guardian.no&gt;</span>
<span class="cm"> * with help from Aleph1, Roland Buresund and Andrew Main.</span>
<span class="cm"> *</span>
<span class="cm"> * See here for the libcap library (&quot;POSIX draft&quot; compliance):</span>
<span class="cm"> *</span>
<span class="cm"> * ftp://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.6/</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_CAPABILITY_H</span>
<span class="cp">#define _LINUX_CAPABILITY_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="cm">/* User-level do most of the mapping between kernel and user</span>
<span class="cm">   capabilities based on the version tag given by the kernel. The</span>
<span class="cm">   kernel might be somewhat backwards compatible, but don&#39;t bet on</span>
<span class="cm">   it. */</span>

<span class="cm">/* Note, cap_t, is defined by POSIX (draft) to be an &quot;opaque&quot; pointer to</span>
<span class="cm">   a set of three capability sets.  The transposition of 3*the</span>
<span class="cm">   following structure to such a composite is better handled in a user</span>
<span class="cm">   library since the draft standard requires the use of malloc/free</span>
<span class="cm">   etc.. */</span>

<span class="cp">#define _LINUX_CAPABILITY_VERSION_1  0x19980330</span>
<span class="cp">#define _LINUX_CAPABILITY_U32S_1     1</span>

<span class="cp">#define _LINUX_CAPABILITY_VERSION_2  0x20071026  </span><span class="cm">/* deprecated - use v3 */</span><span class="cp"></span>
<span class="cp">#define _LINUX_CAPABILITY_U32S_2     2</span>

<span class="cp">#define _LINUX_CAPABILITY_VERSION_3  0x20080522</span>
<span class="cp">#define _LINUX_CAPABILITY_U32S_3     2</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__user_cap_header_struct</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cap_user_header_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__user_cap_data_struct</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">effective</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">permitted</span><span class="p">;</span>
        <span class="n">__u32</span> <span class="n">inheritable</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__user</span> <span class="o">*</span><span class="n">cap_user_data_t</span><span class="p">;</span>


<span class="cp">#define VFS_CAP_REVISION_MASK	0xFF000000</span>
<span class="cp">#define VFS_CAP_REVISION_SHIFT	24</span>
<span class="cp">#define VFS_CAP_FLAGS_MASK	~VFS_CAP_REVISION_MASK</span>
<span class="cp">#define VFS_CAP_FLAGS_EFFECTIVE	0x000001</span>

<span class="cp">#define VFS_CAP_REVISION_1	0x01000000</span>
<span class="cp">#define VFS_CAP_U32_1           1</span>
<span class="cp">#define XATTR_CAPS_SZ_1         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_1))</span>

<span class="cp">#define VFS_CAP_REVISION_2	0x02000000</span>
<span class="cp">#define VFS_CAP_U32_2           2</span>
<span class="cp">#define XATTR_CAPS_SZ_2         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_2))</span>

<span class="cp">#define XATTR_CAPS_SZ           XATTR_CAPS_SZ_2</span>
<span class="cp">#define VFS_CAP_U32             VFS_CAP_U32_2</span>
<span class="cp">#define VFS_CAP_REVISION	VFS_CAP_REVISION_2</span>

<span class="k">struct</span> <span class="n">vfs_cap_data</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">magic_etc</span><span class="p">;</span>            <span class="cm">/* Little endian */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">permitted</span><span class="p">;</span>    <span class="cm">/* Little endian */</span>
		<span class="n">__le32</span> <span class="n">inheritable</span><span class="p">;</span>  <span class="cm">/* Little endian */</span>
	<span class="p">}</span> <span class="n">data</span><span class="p">[</span><span class="n">VFS_CAP_U32</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#ifndef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * Backwardly compatible definition for source code - trapped in a</span>
<span class="cm"> * 32-bit world. If you find you need this, please consider using</span>
<span class="cm"> * libcap to untrap yourself...</span>
<span class="cm"> */</span>
<span class="cp">#define _LINUX_CAPABILITY_VERSION  _LINUX_CAPABILITY_VERSION_1</span>
<span class="cp">#define _LINUX_CAPABILITY_U32S     _LINUX_CAPABILITY_U32S_1</span>

<span class="cp">#else</span>

<span class="cp">#define _KERNEL_CAPABILITY_VERSION _LINUX_CAPABILITY_VERSION_3</span>
<span class="cp">#define _KERNEL_CAPABILITY_U32S    _LINUX_CAPABILITY_U32S_3</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">file_caps_enabled</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">kernel_cap_struct</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">cap</span><span class="p">[</span><span class="n">_KERNEL_CAPABILITY_U32S</span><span class="p">];</span>
<span class="p">}</span> <span class="n">kernel_cap_t</span><span class="p">;</span>

<span class="cm">/* exact same as vfs_cap_data but in cpu endian and always filled completely */</span>
<span class="k">struct</span> <span class="n">cpu_vfs_cap_data</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">magic_etc</span><span class="p">;</span>
	<span class="n">kernel_cap_t</span> <span class="n">permitted</span><span class="p">;</span>
	<span class="n">kernel_cap_t</span> <span class="n">inheritable</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define _USER_CAP_HEADER_SIZE  (sizeof(struct __user_cap_header_struct))</span>
<span class="cp">#define _KERNEL_CAP_T_SIZE     (sizeof(kernel_cap_t))</span>

<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> ** POSIX-draft defined capabilities.</span>
<span class="cm"> **/</span>

<span class="cm">/* In a system with the [_POSIX_CHOWN_RESTRICTED] option defined, this</span>
<span class="cm">   overrides the restriction of changing file ownership and group</span>
<span class="cm">   ownership. */</span>

<span class="cp">#define CAP_CHOWN            0</span>

<span class="cm">/* Override all DAC access, including ACL execute access if</span>
<span class="cm">   [_POSIX_ACL] is defined. Excluding DAC access covered by</span>
<span class="cm">   CAP_LINUX_IMMUTABLE. */</span>

<span class="cp">#define CAP_DAC_OVERRIDE     1</span>

<span class="cm">/* Overrides all DAC restrictions regarding read and search on files</span>
<span class="cm">   and directories, including ACL restrictions if [_POSIX_ACL] is</span>
<span class="cm">   defined. Excluding DAC access covered by CAP_LINUX_IMMUTABLE. */</span>

<span class="cp">#define CAP_DAC_READ_SEARCH  2</span>

<span class="cm">/* Overrides all restrictions about allowed operations on files, where</span>
<span class="cm">   file owner ID must be equal to the user ID, except where CAP_FSETID</span>
<span class="cm">   is applicable. It doesn&#39;t override MAC and DAC restrictions. */</span>

<span class="cp">#define CAP_FOWNER           3</span>

<span class="cm">/* Overrides the following restrictions that the effective user ID</span>
<span class="cm">   shall match the file owner ID when setting the S_ISUID and S_ISGID</span>
<span class="cm">   bits on that file; that the effective group ID (or one of the</span>
<span class="cm">   supplementary group IDs) shall match the file owner ID when setting</span>
<span class="cm">   the S_ISGID bit on that file; that the S_ISUID and S_ISGID bits are</span>
<span class="cm">   cleared on successful return from chown(2) (not implemented). */</span>

<span class="cp">#define CAP_FSETID           4</span>

<span class="cm">/* Overrides the restriction that the real or effective user ID of a</span>
<span class="cm">   process sending a signal must match the real or effective user ID</span>
<span class="cm">   of the process receiving the signal. */</span>

<span class="cp">#define CAP_KILL             5</span>

<span class="cm">/* Allows setgid(2) manipulation */</span>
<span class="cm">/* Allows setgroups(2) */</span>
<span class="cm">/* Allows forged gids on socket credentials passing. */</span>

<span class="cp">#define CAP_SETGID           6</span>

<span class="cm">/* Allows set*uid(2) manipulation (including fsuid). */</span>
<span class="cm">/* Allows forged pids on socket credentials passing. */</span>

<span class="cp">#define CAP_SETUID           7</span>


<span class="cm">/**</span>
<span class="cm"> ** Linux-specific capabilities</span>
<span class="cm"> **/</span>

<span class="cm">/* Without VFS support for capabilities:</span>
<span class="cm"> *   Transfer any capability in your permitted set to any pid,</span>
<span class="cm"> *   remove any capability in your permitted set from any pid</span>
<span class="cm"> * With VFS support for capabilities (neither of above, but)</span>
<span class="cm"> *   Add any capability from current&#39;s capability bounding set</span>
<span class="cm"> *       to the current process&#39; inheritable set</span>
<span class="cm"> *   Allow taking bits out of capability bounding set</span>
<span class="cm"> *   Allow modification of the securebits for a process</span>
<span class="cm"> */</span>

<span class="cp">#define CAP_SETPCAP          8</span>

<span class="cm">/* Allow modification of S_IMMUTABLE and S_APPEND file attributes */</span>

<span class="cp">#define CAP_LINUX_IMMUTABLE  9</span>

<span class="cm">/* Allows binding to TCP/UDP sockets below 1024 */</span>
<span class="cm">/* Allows binding to ATM VCIs below 32 */</span>

<span class="cp">#define CAP_NET_BIND_SERVICE 10</span>

<span class="cm">/* Allow broadcasting, listen to multicast */</span>

<span class="cp">#define CAP_NET_BROADCAST    11</span>

<span class="cm">/* Allow interface configuration */</span>
<span class="cm">/* Allow administration of IP firewall, masquerading and accounting */</span>
<span class="cm">/* Allow setting debug option on sockets */</span>
<span class="cm">/* Allow modification of routing tables */</span>
<span class="cm">/* Allow setting arbitrary process / process group ownership on</span>
<span class="cm">   sockets */</span>
<span class="cm">/* Allow binding to any address for transparent proxying (also via NET_RAW) */</span>
<span class="cm">/* Allow setting TOS (type of service) */</span>
<span class="cm">/* Allow setting promiscuous mode */</span>
<span class="cm">/* Allow clearing driver statistics */</span>
<span class="cm">/* Allow multicasting */</span>
<span class="cm">/* Allow read/write of device-specific registers */</span>
<span class="cm">/* Allow activation of ATM control sockets */</span>

<span class="cp">#define CAP_NET_ADMIN        12</span>

<span class="cm">/* Allow use of RAW sockets */</span>
<span class="cm">/* Allow use of PACKET sockets */</span>
<span class="cm">/* Allow binding to any address for transparent proxying (also via NET_ADMIN) */</span>

<span class="cp">#define CAP_NET_RAW          13</span>

<span class="cm">/* Allow locking of shared memory segments */</span>
<span class="cm">/* Allow mlock and mlockall (which doesn&#39;t really have anything to do</span>
<span class="cm">   with IPC) */</span>

<span class="cp">#define CAP_IPC_LOCK         14</span>

<span class="cm">/* Override IPC ownership checks */</span>

<span class="cp">#define CAP_IPC_OWNER        15</span>

<span class="cm">/* Insert and remove kernel modules - modify kernel without limit */</span>
<span class="cp">#define CAP_SYS_MODULE       16</span>

<span class="cm">/* Allow ioperm/iopl access */</span>
<span class="cm">/* Allow sending USB messages to any device via /proc/bus/usb */</span>

<span class="cp">#define CAP_SYS_RAWIO        17</span>

<span class="cm">/* Allow use of chroot() */</span>

<span class="cp">#define CAP_SYS_CHROOT       18</span>

<span class="cm">/* Allow ptrace() of any process */</span>

<span class="cp">#define CAP_SYS_PTRACE       19</span>

<span class="cm">/* Allow configuration of process accounting */</span>

<span class="cp">#define CAP_SYS_PACCT        20</span>

<span class="cm">/* Allow configuration of the secure attention key */</span>
<span class="cm">/* Allow administration of the random device */</span>
<span class="cm">/* Allow examination and configuration of disk quotas */</span>
<span class="cm">/* Allow setting the domainname */</span>
<span class="cm">/* Allow setting the hostname */</span>
<span class="cm">/* Allow calling bdflush() */</span>
<span class="cm">/* Allow mount() and umount(), setting up new smb connection */</span>
<span class="cm">/* Allow some autofs root ioctls */</span>
<span class="cm">/* Allow nfsservctl */</span>
<span class="cm">/* Allow VM86_REQUEST_IRQ */</span>
<span class="cm">/* Allow to read/write pci config on alpha */</span>
<span class="cm">/* Allow irix_prctl on mips (setstacksize) */</span>
<span class="cm">/* Allow flushing all cache on m68k (sys_cacheflush) */</span>
<span class="cm">/* Allow removing semaphores */</span>
<span class="cm">/* Used instead of CAP_CHOWN to &quot;chown&quot; IPC message queues, semaphores</span>
<span class="cm">   and shared memory */</span>
<span class="cm">/* Allow locking/unlocking of shared memory segment */</span>
<span class="cm">/* Allow turning swap on/off */</span>
<span class="cm">/* Allow forged pids on socket credentials passing */</span>
<span class="cm">/* Allow setting readahead and flushing buffers on block devices */</span>
<span class="cm">/* Allow setting geometry in floppy driver */</span>
<span class="cm">/* Allow turning DMA on/off in xd driver */</span>
<span class="cm">/* Allow administration of md devices (mostly the above, but some</span>
<span class="cm">   extra ioctls) */</span>
<span class="cm">/* Allow tuning the ide driver */</span>
<span class="cm">/* Allow access to the nvram device */</span>
<span class="cm">/* Allow administration of apm_bios, serial and bttv (TV) device */</span>
<span class="cm">/* Allow manufacturer commands in isdn CAPI support driver */</span>
<span class="cm">/* Allow reading non-standardized portions of pci configuration space */</span>
<span class="cm">/* Allow DDI debug ioctl on sbpcd driver */</span>
<span class="cm">/* Allow setting up serial ports */</span>
<span class="cm">/* Allow sending raw qic-117 commands */</span>
<span class="cm">/* Allow enabling/disabling tagged queuing on SCSI controllers and sending</span>
<span class="cm">   arbitrary SCSI commands */</span>
<span class="cm">/* Allow setting encryption key on loopback filesystem */</span>
<span class="cm">/* Allow setting zone reclaim policy */</span>

<span class="cp">#define CAP_SYS_ADMIN        21</span>

<span class="cm">/* Allow use of reboot() */</span>

<span class="cp">#define CAP_SYS_BOOT         22</span>

<span class="cm">/* Allow raising priority and setting priority on other (different</span>
<span class="cm">   UID) processes */</span>
<span class="cm">/* Allow use of FIFO and round-robin (realtime) scheduling on own</span>
<span class="cm">   processes and setting the scheduling algorithm used by another</span>
<span class="cm">   process. */</span>
<span class="cm">/* Allow setting cpu affinity on other processes */</span>

<span class="cp">#define CAP_SYS_NICE         23</span>

<span class="cm">/* Override resource limits. Set resource limits. */</span>
<span class="cm">/* Override quota limits. */</span>
<span class="cm">/* Override reserved space on ext2 filesystem */</span>
<span class="cm">/* Modify data journaling mode on ext3 filesystem (uses journaling</span>
<span class="cm">   resources) */</span>
<span class="cm">/* NOTE: ext2 honors fsuid when checking for resource overrides, so</span>
<span class="cm">   you can override using fsuid too */</span>
<span class="cm">/* Override size restrictions on IPC message queues */</span>
<span class="cm">/* Allow more than 64hz interrupts from the real-time clock */</span>
<span class="cm">/* Override max number of consoles on console allocation */</span>
<span class="cm">/* Override max number of keymaps */</span>

<span class="cp">#define CAP_SYS_RESOURCE     24</span>

<span class="cm">/* Allow manipulation of system clock */</span>
<span class="cm">/* Allow irix_stime on mips */</span>
<span class="cm">/* Allow setting the real-time clock */</span>

<span class="cp">#define CAP_SYS_TIME         25</span>

<span class="cm">/* Allow configuration of tty devices */</span>
<span class="cm">/* Allow vhangup() of tty */</span>

<span class="cp">#define CAP_SYS_TTY_CONFIG   26</span>

<span class="cm">/* Allow the privileged aspects of mknod() */</span>

<span class="cp">#define CAP_MKNOD            27</span>

<span class="cm">/* Allow taking of leases on files */</span>

<span class="cp">#define CAP_LEASE            28</span>

<span class="cp">#define CAP_AUDIT_WRITE      29</span>

<span class="cp">#define CAP_AUDIT_CONTROL    30</span>

<span class="cp">#define CAP_SETFCAP	     31</span>

<span class="cm">/* Override MAC access.</span>
<span class="cm">   The base kernel enforces no MAC policy.</span>
<span class="cm">   An LSM may enforce a MAC policy, and if it does and it chooses</span>
<span class="cm">   to implement capability based overrides of that policy, this is</span>
<span class="cm">   the capability it should use to do so. */</span>

<span class="cp">#define CAP_MAC_OVERRIDE     32</span>

<span class="cm">/* Allow MAC configuration or state changes.</span>
<span class="cm">   The base kernel requires no MAC configuration.</span>
<span class="cm">   An LSM may enforce a MAC policy, and if it does and it chooses</span>
<span class="cm">   to implement capability based checks on modifications to that</span>
<span class="cm">   policy or the data required to maintain it, this is the</span>
<span class="cm">   capability it should use to do so. */</span>

<span class="cp">#define CAP_MAC_ADMIN        33</span>

<span class="cm">/* Allow configuring the kernel&#39;s syslog (printk behaviour) */</span>

<span class="cp">#define CAP_SYSLOG           34</span>

<span class="cm">/* Allow triggering something that will wake the system */</span>

<span class="cp">#define CAP_WAKE_ALARM            35</span>

<span class="cm">/* Allow preventing system suspends while epoll events are pending */</span>

<span class="cp">#define CAP_EPOLLWAKEUP      36</span>

<span class="cp">#define CAP_LAST_CAP         CAP_EPOLLWAKEUP</span>

<span class="cp">#define cap_valid(x) ((x) &gt;= 0 &amp;&amp; (x) &lt;= CAP_LAST_CAP)</span>

<span class="cm">/*</span>
<span class="cm"> * Bit location of each capability (used by user-space library and kernel)</span>
<span class="cm"> */</span>

<span class="cp">#define CAP_TO_INDEX(x)     ((x) &gt;&gt; 5)        </span><span class="cm">/* 1 &lt;&lt; 5 == bits in __u32 */</span><span class="cp"></span>
<span class="cp">#define CAP_TO_MASK(x)      (1 &lt;&lt; ((x) &amp; 31)) </span><span class="cm">/* mask for indexed __u32 */</span><span class="cp"></span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="k">struct</span> <span class="n">inode</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dentry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">user_namespace</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">current_user_ns</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">__cap_empty_set</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">__cap_init_eff_set</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Internal kernel functions only</span>
<span class="cm"> */</span>

<span class="cp">#define CAP_FOR_EACH_U32(__capi)  \</span>
<span class="cp">	for (__capi = 0; __capi &lt; _KERNEL_CAPABILITY_U32S; ++__capi)</span>

<span class="cm">/*</span>
<span class="cm"> * CAP_FS_MASK and CAP_NFSD_MASKS:</span>
<span class="cm"> *</span>
<span class="cm"> * The fs mask is all the privileges that fsuid==0 historically meant.</span>
<span class="cm"> * At one time in the past, that included CAP_MKNOD and CAP_LINUX_IMMUTABLE.</span>
<span class="cm"> *</span>
<span class="cm"> * It has never meant setting security.* and trusted.* xattrs.</span>
<span class="cm"> *</span>
<span class="cm"> * We could also define fsmask as follows:</span>
<span class="cm"> *   1. CAP_FS_MASK is the privilege to bypass all fs-related DAC permissions</span>
<span class="cm"> *   2. The security.* and trusted.* xattrs are fs-related MAC permissions</span>
<span class="cm"> */</span>

<span class="cp"># define CAP_FS_MASK_B0     (CAP_TO_MASK(CAP_CHOWN)		\</span>
<span class="cp">			    | CAP_TO_MASK(CAP_MKNOD)		\</span>
<span class="cp">			    | CAP_TO_MASK(CAP_DAC_OVERRIDE)	\</span>
<span class="cp">			    | CAP_TO_MASK(CAP_DAC_READ_SEARCH)	\</span>
<span class="cp">			    | CAP_TO_MASK(CAP_FOWNER)		\</span>
<span class="cp">			    | CAP_TO_MASK(CAP_FSETID))</span>

<span class="cp"># define CAP_FS_MASK_B1     (CAP_TO_MASK(CAP_MAC_OVERRIDE))</span>

<span class="cp">#if _KERNEL_CAPABILITY_U32S != 2</span>
<span class="cp"># error Fix up hand-coded capability macro initializers</span>
<span class="cp">#else </span><span class="cm">/* HAND-CODED capability initializers */</span><span class="cp"></span>

<span class="cp"># define CAP_EMPTY_SET    ((kernel_cap_t){{ 0, 0 }})</span>
<span class="cp"># define CAP_FULL_SET     ((kernel_cap_t){{ ~0, ~0 }})</span>
<span class="cp"># define CAP_FS_SET       ((kernel_cap_t){{ CAP_FS_MASK_B0 \</span>
<span class="cp">				    | CAP_TO_MASK(CAP_LINUX_IMMUTABLE), \</span>
<span class="cp">				    CAP_FS_MASK_B1 } })</span>
<span class="cp"># define CAP_NFSD_SET     ((kernel_cap_t){{ CAP_FS_MASK_B0 \</span>
<span class="cp">				    | CAP_TO_MASK(CAP_SYS_RESOURCE), \</span>
<span class="cp">				    CAP_FS_MASK_B1 } })</span>

<span class="cp">#endif </span><span class="cm">/* _KERNEL_CAPABILITY_U32S != 2 */</span><span class="cp"></span>

<span class="cp"># define cap_clear(c)         do { (c) = __cap_empty_set; } while (0)</span>

<span class="cp">#define cap_raise(c, flag)  ((c).cap[CAP_TO_INDEX(flag)] |= CAP_TO_MASK(flag))</span>
<span class="cp">#define cap_lower(c, flag)  ((c).cap[CAP_TO_INDEX(flag)] &amp;= ~CAP_TO_MASK(flag))</span>
<span class="cp">#define cap_raised(c, flag) ((c).cap[CAP_TO_INDEX(flag)] &amp; CAP_TO_MASK(flag))</span>

<span class="cp">#define CAP_BOP_ALL(c, a, b, OP)                                    \</span>
<span class="cp">do {                                                                \</span>
<span class="cp">	unsigned __capi;                                            \</span>
<span class="cp">	CAP_FOR_EACH_U32(__capi) {                                  \</span>
<span class="cp">		c.cap[__capi] = a.cap[__capi] OP b.cap[__capi];     \</span>
<span class="cp">	}                                                           \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define CAP_UOP_ALL(c, a, OP)                                       \</span>
<span class="cp">do {                                                                \</span>
<span class="cp">	unsigned __capi;                                            \</span>
<span class="cp">	CAP_FOR_EACH_U32(__capi) {                                  \</span>
<span class="cp">		c.cap[__capi] = OP a.cap[__capi];                   \</span>
<span class="cp">	}                                                           \</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kernel_cap_t</span> <span class="nf">cap_combine</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kernel_cap_t</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">CAP_BOP_ALL</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">|</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kernel_cap_t</span> <span class="nf">cap_intersect</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kernel_cap_t</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">CAP_BOP_ALL</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kernel_cap_t</span> <span class="nf">cap_drop</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">drop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kernel_cap_t</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">CAP_BOP_ALL</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">drop</span><span class="p">,</span> <span class="o">&amp;~</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kernel_cap_t</span> <span class="nf">cap_invert</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kernel_cap_t</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">CAP_UOP_ALL</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">~</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cap_isclear</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">__capi</span><span class="p">;</span>
	<span class="n">CAP_FOR_EACH_U32</span><span class="p">(</span><span class="n">__capi</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">__capi</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if &quot;a&quot; is a subset of &quot;set&quot;.</span>
<span class="cm"> * return 1 if ALL of the capabilities in &quot;a&quot; are also in &quot;set&quot;</span>
<span class="cm"> *	cap_issubset(0101, 1111) will return 1</span>
<span class="cm"> * return 0 if ANY of the capabilities in &quot;a&quot; are not in &quot;set&quot;</span>
<span class="cm"> *	cap_issubset(1111, 0101) will return 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cap_issubset</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kernel_cap_t</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">dest</span> <span class="o">=</span> <span class="n">cap_drop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cap_isclear</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used to decide between falling back on the old suser() or fsuser(). */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cap_is_fs_cap</span><span class="p">(</span><span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">__cap_fs_set</span> <span class="o">=</span> <span class="n">CAP_FS_SET</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">CAP_TO_MASK</span><span class="p">(</span><span class="n">cap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">__cap_fs_set</span><span class="p">.</span><span class="n">cap</span><span class="p">[</span><span class="n">CAP_TO_INDEX</span><span class="p">(</span><span class="n">cap</span><span class="p">)]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kernel_cap_t</span> <span class="nf">cap_drop_fs_set</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">__cap_fs_set</span> <span class="o">=</span> <span class="n">CAP_FS_SET</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cap_drop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">__cap_fs_set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kernel_cap_t</span> <span class="nf">cap_raise_fs_set</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">,</span>
					    <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">permitted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">__cap_fs_set</span> <span class="o">=</span> <span class="n">CAP_FS_SET</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cap_combine</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
			   <span class="n">cap_intersect</span><span class="p">(</span><span class="n">permitted</span><span class="p">,</span> <span class="n">__cap_fs_set</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kernel_cap_t</span> <span class="nf">cap_drop_nfsd_set</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">__cap_fs_set</span> <span class="o">=</span> <span class="n">CAP_NFSD_SET</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cap_drop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">__cap_fs_set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">kernel_cap_t</span> <span class="nf">cap_raise_nfsd_set</span><span class="p">(</span><span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">a</span><span class="p">,</span>
					      <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">permitted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="n">__cap_nfsd_set</span> <span class="o">=</span> <span class="n">CAP_NFSD_SET</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cap_combine</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
			   <span class="n">cap_intersect</span><span class="p">(</span><span class="n">permitted</span><span class="p">,</span> <span class="n">__cap_nfsd_set</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">has_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">has_ns_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">has_capability_noaudit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">has_ns_capability_noaudit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">capable</span><span class="p">(</span><span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">ns_capable</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">nsown_capable</span><span class="p">(</span><span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">inode_capable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>

<span class="cm">/* audit system wants to get cap info from files as well */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">get_vfs_caps_from_disk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpu_vfs_cap_data</span> <span class="o">*</span><span class="n">cpu_caps</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* !_LINUX_CAPABILITY_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
