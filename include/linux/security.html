<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › security.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>security.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux Security plug</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001 WireX Communications, Inc &lt;chris@wirex.com&gt;</span>
<span class="cm"> * Copyright (C) 2001 Greg Kroah-Hartman &lt;greg@kroah.com&gt;</span>
<span class="cm"> * Copyright (C) 2001 Networks Associates Technology, Inc &lt;ssmalley@nai.com&gt;</span>
<span class="cm"> * Copyright (C) 2001 James Morris &lt;jmorris@intercode.com.au&gt;</span>
<span class="cm"> * Copyright (C) 2001 Silicon Graphics, Inc. (Trust Technology Group)</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	Due to this file being licensed under the GPL there is controversy over</span>
<span class="cm"> *	whether this permits you to write a module that #includes this file</span>
<span class="cm"> *	without placing your module under the GPL.  Please consult a lawyer for</span>
<span class="cm"> *	advice before doing this.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_SECURITY_H</span>
<span class="cp">#define __LINUX_SECURITY_H</span>

<span class="cp">#include &lt;linux/key.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>

<span class="k">struct</span> <span class="n">linux_binprm</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cred</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">rlimit</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">siginfo</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sem_array</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sembuf</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kern_ipc_perm</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">audit_context</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">super_block</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">inode</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dentry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vfsmount</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">path</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">qstr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">nameidata</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iattr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fown_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">file_operations</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">shmid_kernel</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">msg_msg</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">msg_queue</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xattr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfrm_sec_ctx</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mm_struct</span><span class="p">;</span>

<span class="cm">/* Maximum number of letters for an LSM name string */</span>
<span class="cp">#define SECURITY_NAME_MAX	10</span>

<span class="cm">/* If capable should audit the security request */</span>
<span class="cp">#define SECURITY_CAP_NOAUDIT 0</span>
<span class="cp">#define SECURITY_CAP_AUDIT 1</span>

<span class="k">struct</span> <span class="n">ctl_table</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">audit_krule</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">user_namespace</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">timezone</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * These functions are in security/capability.c and are used</span>
<span class="cm"> * as the default capabilities functions</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_capable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">audit</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_settime</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tz</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_ptrace_access_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_ptrace_traceme</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_capget</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_capset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
		      <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
		      <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
		      <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_bprm_set_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_bprm_secureexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_inode_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_inode_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_inode_need_killpriv</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_inode_killpriv</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_mmap_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_mmap_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_task_fix_setuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_task_prctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">option</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg4</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg5</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_task_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_task_setioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_task_setnice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_vm_enough_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">msghdr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sk_buff</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sock</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sockaddr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">socket</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">flowi</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dst_entry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfrm_selector</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfrm_policy</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfrm_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">seq_file</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">cap_netlink_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">reset_security_ops</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmap_min_addr</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dac_mmap_min_addr</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define dac_mmap_min_addr	0UL</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Values used in the task_security_ops calls</span>
<span class="cm"> */</span>
<span class="cm">/* setuid or setgid, id0 == uid or gid */</span>
<span class="cp">#define LSM_SETID_ID	1</span>

<span class="cm">/* setreuid or setregid, id0 == real, id1 == eff */</span>
<span class="cp">#define LSM_SETID_RE	2</span>

<span class="cm">/* setresuid or setresgid, id0 == real, id1 == eff, uid2 == saved */</span>
<span class="cp">#define LSM_SETID_RES	4</span>

<span class="cm">/* setfsuid or setfsgid, id0 == fsuid or fsgid */</span>
<span class="cp">#define LSM_SETID_FS	8</span>

<span class="cm">/* forward declares to avoid warnings */</span>
<span class="k">struct</span> <span class="n">sched_param</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">request_sock</span><span class="p">;</span>

<span class="cm">/* bprm-&gt;unsafe reasons */</span>
<span class="cp">#define LSM_UNSAFE_SHARE	1</span>
<span class="cp">#define LSM_UNSAFE_PTRACE	2</span>
<span class="cp">#define LSM_UNSAFE_PTRACE_CAP	4</span>
<span class="cp">#define LSM_UNSAFE_NO_NEW_PRIVS	8</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mmap_min_addr_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* security_inode_init_security callback function to write xattrs */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">initxattrs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">xattr</span> <span class="o">*</span><span class="n">xattr_array</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fs_data</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SECURITY</span>

<span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">mnt_opts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">mnt_opts_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_mnt_opts</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_init_mnt_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_free_mnt_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span><span class="p">);</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span><span class="p">);</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mnt_opts_flags</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_mnt_opts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct security_operations - main security structure</span>
<span class="cm"> *</span>
<span class="cm"> * Security module identifier.</span>
<span class="cm"> *</span>
<span class="cm"> * @name:</span>
<span class="cm"> *	A string that acts as a unique identifier for the LSM with max number</span>
<span class="cm"> *	of characters = SECURITY_NAME_MAX.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for program execution operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @bprm_set_creds:</span>
<span class="cm"> *	Save security information in the bprm-&gt;security field, typically based</span>
<span class="cm"> *	on information about the bprm-&gt;file, for later use by the apply_creds</span>
<span class="cm"> *	hook.  This hook may also optionally check permissions (e.g. for</span>
<span class="cm"> *	transitions between security domains).</span>
<span class="cm"> *	This hook may be called multiple times during a single execve, e.g. for</span>
<span class="cm"> *	interpreters.  The hook can tell whether it has already been called by</span>
<span class="cm"> *	checking to see if @bprm-&gt;security is non-NULL.  If so, then the hook</span>
<span class="cm"> *	may decide either to retain the security information saved earlier or</span>
<span class="cm"> *	to replace it.</span>
<span class="cm"> *	@bprm contains the linux_binprm structure.</span>
<span class="cm"> *	Return 0 if the hook is successful and permission is granted.</span>
<span class="cm"> * @bprm_check_security:</span>
<span class="cm"> *	This hook mediates the point when a search for a binary handler will</span>
<span class="cm"> *	begin.  It allows a check the @bprm-&gt;security value which is set in the</span>
<span class="cm"> *	preceding set_creds call.  The primary difference from set_creds is</span>
<span class="cm"> *	that the argv list and envp list are reliably available in @bprm.  This</span>
<span class="cm"> *	hook may be called multiple times during a single execve; and in each</span>
<span class="cm"> *	pass set_creds is called first.</span>
<span class="cm"> *	@bprm contains the linux_binprm structure.</span>
<span class="cm"> *	Return 0 if the hook is successful and permission is granted.</span>
<span class="cm"> * @bprm_committing_creds:</span>
<span class="cm"> *	Prepare to install the new security attributes of a process being</span>
<span class="cm"> *	transformed by an execve operation, based on the old credentials</span>
<span class="cm"> *	pointed to by @current-&gt;cred and the information set in @bprm-&gt;cred by</span>
<span class="cm"> *	the bprm_set_creds hook.  @bprm points to the linux_binprm structure.</span>
<span class="cm"> *	This hook is a good place to perform state changes on the process such</span>
<span class="cm"> *	as closing open file descriptors to which access will no longer be</span>
<span class="cm"> *	granted when the attributes are changed.  This is called immediately</span>
<span class="cm"> *	before commit_creds().</span>
<span class="cm"> * @bprm_committed_creds:</span>
<span class="cm"> *	Tidy up after the installation of the new security attributes of a</span>
<span class="cm"> *	process being transformed by an execve operation.  The new credentials</span>
<span class="cm"> *	have, by this point, been set to @current-&gt;cred.  @bprm points to the</span>
<span class="cm"> *	linux_binprm structure.  This hook is a good place to perform state</span>
<span class="cm"> *	changes on the process such as clearing out non-inheritable signal</span>
<span class="cm"> *	state.  This is called immediately after commit_creds().</span>
<span class="cm"> * @bprm_secureexec:</span>
<span class="cm"> *	Return a boolean value (0 or 1) indicating whether a &quot;secure exec&quot;</span>
<span class="cm"> *	is required.  The flag is passed in the auxiliary table</span>
<span class="cm"> *	on the initial stack to the ELF interpreter to indicate whether libc</span>
<span class="cm"> *	should enable secure mode.</span>
<span class="cm"> *	@bprm contains the linux_binprm structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for filesystem operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @sb_alloc_security:</span>
<span class="cm"> *	Allocate and attach a security structure to the sb-&gt;s_security field.</span>
<span class="cm"> *	The s_security field is initialized to NULL when the structure is</span>
<span class="cm"> *	allocated.</span>
<span class="cm"> *	@sb contains the super_block structure to be modified.</span>
<span class="cm"> *	Return 0 if operation was successful.</span>
<span class="cm"> * @sb_free_security:</span>
<span class="cm"> *	Deallocate and clear the sb-&gt;s_security field.</span>
<span class="cm"> *	@sb contains the super_block structure to be modified.</span>
<span class="cm"> * @sb_statfs:</span>
<span class="cm"> *	Check permission before obtaining filesystem statistics for the @mnt</span>
<span class="cm"> *	mountpoint.</span>
<span class="cm"> *	@dentry is a handle on the superblock for the filesystem.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @sb_mount:</span>
<span class="cm"> *	Check permission before an object specified by @dev_name is mounted on</span>
<span class="cm"> *	the mount point named by @nd.  For an ordinary mount, @dev_name</span>
<span class="cm"> *	identifies a device if the file system type requires a device.  For a</span>
<span class="cm"> *	remount (@flags &amp; MS_REMOUNT), @dev_name is irrelevant.  For a</span>
<span class="cm"> *	loopback/bind mount (@flags &amp; MS_BIND), @dev_name identifies the</span>
<span class="cm"> *	pathname of the object being mounted.</span>
<span class="cm"> *	@dev_name contains the name for object being mounted.</span>
<span class="cm"> *	@path contains the path for mount point object.</span>
<span class="cm"> *	@type contains the filesystem type.</span>
<span class="cm"> *	@flags contains the mount flags.</span>
<span class="cm"> *	@data contains the filesystem-specific data.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @sb_copy_data:</span>
<span class="cm"> *	Allow mount option data to be copied prior to parsing by the filesystem,</span>
<span class="cm"> *	so that the security module can extract security-specific mount</span>
<span class="cm"> *	options cleanly (a filesystem may modify the data e.g. with strsep()).</span>
<span class="cm"> *	This also allows the original mount data to be stripped of security-</span>
<span class="cm"> *	specific options to avoid having to make filesystems aware of them.</span>
<span class="cm"> *	@type the type of filesystem being mounted.</span>
<span class="cm"> *	@orig the original mount data copied from userspace.</span>
<span class="cm"> *	@copy copied data which will be passed to the security module.</span>
<span class="cm"> *	Returns 0 if the copy was successful.</span>
<span class="cm"> * @sb_remount:</span>
<span class="cm"> *	Extracts security system specific mount options and verifies no changes</span>
<span class="cm"> *	are being made to those options.</span>
<span class="cm"> *	@sb superblock being remounted</span>
<span class="cm"> *	@data contains the filesystem-specific data.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @sb_umount:</span>
<span class="cm"> *	Check permission before the @mnt file system is unmounted.</span>
<span class="cm"> *	@mnt contains the mounted file system.</span>
<span class="cm"> *	@flags contains the unmount flags, e.g. MNT_FORCE.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @sb_pivotroot:</span>
<span class="cm"> *	Check permission before pivoting the root filesystem.</span>
<span class="cm"> *	@old_path contains the path for the new location of the current root (put_old).</span>
<span class="cm"> *	@new_path contains the path for the new root (new_root).</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @sb_set_mnt_opts:</span>
<span class="cm"> *	Set the security relevant mount options used for a superblock</span>
<span class="cm"> *	@sb the superblock to set security mount options for</span>
<span class="cm"> *	@opts binary data structure containing all lsm mount data</span>
<span class="cm"> * @sb_clone_mnt_opts:</span>
<span class="cm"> *	Copy all security options from a given superblock to another</span>
<span class="cm"> *	@oldsb old superblock which contain information to clone</span>
<span class="cm"> *	@newsb new superblock which needs filled in</span>
<span class="cm"> * @sb_parse_opts_str:</span>
<span class="cm"> *	Parse a string of security data filling in the opts structure</span>
<span class="cm"> *	@options string containing all mount options known by the LSM</span>
<span class="cm"> *	@opts binary data structure usable by the LSM</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for inode operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @inode_alloc_security:</span>
<span class="cm"> *	Allocate and attach a security structure to @inode-&gt;i_security.  The</span>
<span class="cm"> *	i_security field is initialized to NULL when the inode structure is</span>
<span class="cm"> *	allocated.</span>
<span class="cm"> *	@inode contains the inode structure.</span>
<span class="cm"> *	Return 0 if operation was successful.</span>
<span class="cm"> * @inode_free_security:</span>
<span class="cm"> *	@inode contains the inode structure.</span>
<span class="cm"> *	Deallocate the inode security structure and set @inode-&gt;i_security to</span>
<span class="cm"> *	NULL.</span>
<span class="cm"> * @inode_init_security:</span>
<span class="cm"> *	Obtain the security attribute name suffix and value to set on a newly</span>
<span class="cm"> *	created inode and set up the incore security field for the new inode.</span>
<span class="cm"> *	This hook is called by the fs code as part of the inode creation</span>
<span class="cm"> *	transaction and provides for atomic labeling of the inode, unlike</span>
<span class="cm"> *	the post_create/mkdir/... hooks called by the VFS.  The hook function</span>
<span class="cm"> *	is expected to allocate the name and value via kmalloc, with the caller</span>
<span class="cm"> *	being responsible for calling kfree after using them.</span>
<span class="cm"> *	If the security module does not use security attributes or does</span>
<span class="cm"> *	not wish to put a security attribute on this particular inode,</span>
<span class="cm"> *	then it should return -EOPNOTSUPP to skip this processing.</span>
<span class="cm"> *	@inode contains the inode structure of the newly created inode.</span>
<span class="cm"> *	@dir contains the inode structure of the parent directory.</span>
<span class="cm"> *	@qstr contains the last path component of the new object</span>
<span class="cm"> *	@name will be set to the allocated name suffix (e.g. selinux).</span>
<span class="cm"> *	@value will be set to the allocated attribute value.</span>
<span class="cm"> *	@len will be set to the length of the value.</span>
<span class="cm"> *	Returns 0 if @name and @value have been successfully set,</span>
<span class="cm"> *		-EOPNOTSUPP if no security attribute is needed, or</span>
<span class="cm"> *		-ENOMEM on memory allocation failure.</span>
<span class="cm"> * @inode_create:</span>
<span class="cm"> *	Check permission to create a regular file.</span>
<span class="cm"> *	@dir contains inode structure of the parent of the new file.</span>
<span class="cm"> *	@dentry contains the dentry structure for the file to be created.</span>
<span class="cm"> *	@mode contains the file mode of the file to be created.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_link:</span>
<span class="cm"> *	Check permission before creating a new hard link to a file.</span>
<span class="cm"> *	@old_dentry contains the dentry structure for an existing link to the file.</span>
<span class="cm"> *	@dir contains the inode structure of the parent directory of the new link.</span>
<span class="cm"> *	@new_dentry contains the dentry structure for the new link.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_link:</span>
<span class="cm"> *	Check permission before creating a new hard link to a file.</span>
<span class="cm"> *	@old_dentry contains the dentry structure for an existing link</span>
<span class="cm"> *	to the file.</span>
<span class="cm"> *	@new_dir contains the path structure of the parent directory of</span>
<span class="cm"> *	the new link.</span>
<span class="cm"> *	@new_dentry contains the dentry structure for the new link.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_unlink:</span>
<span class="cm"> *	Check the permission to remove a hard link to a file.</span>
<span class="cm"> *	@dir contains the inode structure of parent directory of the file.</span>
<span class="cm"> *	@dentry contains the dentry structure for file to be unlinked.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_unlink:</span>
<span class="cm"> *	Check the permission to remove a hard link to a file.</span>
<span class="cm"> *	@dir contains the path structure of parent directory of the file.</span>
<span class="cm"> *	@dentry contains the dentry structure for file to be unlinked.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_symlink:</span>
<span class="cm"> *	Check the permission to create a symbolic link to a file.</span>
<span class="cm"> *	@dir contains the inode structure of parent directory of the symbolic link.</span>
<span class="cm"> *	@dentry contains the dentry structure of the symbolic link.</span>
<span class="cm"> *	@old_name contains the pathname of file.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_symlink:</span>
<span class="cm"> *	Check the permission to create a symbolic link to a file.</span>
<span class="cm"> *	@dir contains the path structure of parent directory of</span>
<span class="cm"> *	the symbolic link.</span>
<span class="cm"> *	@dentry contains the dentry structure of the symbolic link.</span>
<span class="cm"> *	@old_name contains the pathname of file.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_mkdir:</span>
<span class="cm"> *	Check permissions to create a new directory in the existing directory</span>
<span class="cm"> *	associated with inode structure @dir.</span>
<span class="cm"> *	@dir contains the inode structure of parent of the directory to be created.</span>
<span class="cm"> *	@dentry contains the dentry structure of new directory.</span>
<span class="cm"> *	@mode contains the mode of new directory.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_mkdir:</span>
<span class="cm"> *	Check permissions to create a new directory in the existing directory</span>
<span class="cm"> *	associated with path structure @path.</span>
<span class="cm"> *	@dir contains the path structure of parent of the directory</span>
<span class="cm"> *	to be created.</span>
<span class="cm"> *	@dentry contains the dentry structure of new directory.</span>
<span class="cm"> *	@mode contains the mode of new directory.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_rmdir:</span>
<span class="cm"> *	Check the permission to remove a directory.</span>
<span class="cm"> *	@dir contains the inode structure of parent of the directory to be removed.</span>
<span class="cm"> *	@dentry contains the dentry structure of directory to be removed.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_rmdir:</span>
<span class="cm"> *	Check the permission to remove a directory.</span>
<span class="cm"> *	@dir contains the path structure of parent of the directory to be</span>
<span class="cm"> *	removed.</span>
<span class="cm"> *	@dentry contains the dentry structure of directory to be removed.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_mknod:</span>
<span class="cm"> *	Check permissions when creating a special file (or a socket or a fifo</span>
<span class="cm"> *	file created via the mknod system call).  Note that if mknod operation</span>
<span class="cm"> *	is being done for a regular file, then the create hook will be called</span>
<span class="cm"> *	and not this hook.</span>
<span class="cm"> *	@dir contains the inode structure of parent of the new file.</span>
<span class="cm"> *	@dentry contains the dentry structure of the new file.</span>
<span class="cm"> *	@mode contains the mode of the new file.</span>
<span class="cm"> *	@dev contains the device number.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_mknod:</span>
<span class="cm"> *	Check permissions when creating a file. Note that this hook is called</span>
<span class="cm"> *	even if mknod operation is being done for a regular file.</span>
<span class="cm"> *	@dir contains the path structure of parent of the new file.</span>
<span class="cm"> *	@dentry contains the dentry structure of the new file.</span>
<span class="cm"> *	@mode contains the mode of the new file.</span>
<span class="cm"> *	@dev contains the undecoded device number. Use new_decode_dev() to get</span>
<span class="cm"> *	the decoded device number.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_rename:</span>
<span class="cm"> *	Check for permission to rename a file or directory.</span>
<span class="cm"> *	@old_dir contains the inode structure for parent of the old link.</span>
<span class="cm"> *	@old_dentry contains the dentry structure of the old link.</span>
<span class="cm"> *	@new_dir contains the inode structure for parent of the new link.</span>
<span class="cm"> *	@new_dentry contains the dentry structure of the new link.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_rename:</span>
<span class="cm"> *	Check for permission to rename a file or directory.</span>
<span class="cm"> *	@old_dir contains the path structure for parent of the old link.</span>
<span class="cm"> *	@old_dentry contains the dentry structure of the old link.</span>
<span class="cm"> *	@new_dir contains the path structure for parent of the new link.</span>
<span class="cm"> *	@new_dentry contains the dentry structure of the new link.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_chmod:</span>
<span class="cm"> *	Check for permission to change DAC&#39;s permission of a file or directory.</span>
<span class="cm"> *	@dentry contains the dentry structure.</span>
<span class="cm"> *	@mnt contains the vfsmnt structure.</span>
<span class="cm"> *	@mode contains DAC&#39;s mode.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_chown:</span>
<span class="cm"> *	Check for permission to change owner/group of a file or directory.</span>
<span class="cm"> *	@path contains the path structure.</span>
<span class="cm"> *	@uid contains new owner&#39;s ID.</span>
<span class="cm"> *	@gid contains new group&#39;s ID.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_chroot:</span>
<span class="cm"> *	Check for permission to change root directory.</span>
<span class="cm"> *	@path contains the path structure.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_readlink:</span>
<span class="cm"> *	Check the permission to read the symbolic link.</span>
<span class="cm"> *	@dentry contains the dentry structure for the file link.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_follow_link:</span>
<span class="cm"> *	Check permission to follow a symbolic link when looking up a pathname.</span>
<span class="cm"> *	@dentry contains the dentry structure for the link.</span>
<span class="cm"> *	@nd contains the nameidata structure for the parent directory.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_permission:</span>
<span class="cm"> *	Check permission before accessing an inode.  This hook is called by the</span>
<span class="cm"> *	existing Linux permission function, so a security module can use it to</span>
<span class="cm"> *	provide additional checking for existing Linux permission checks.</span>
<span class="cm"> *	Notice that this hook is called when a file is opened (as well as many</span>
<span class="cm"> *	other operations), whereas the file_security_ops permission hook is</span>
<span class="cm"> *	called when the actual read/write operations are performed.</span>
<span class="cm"> *	@inode contains the inode structure to check.</span>
<span class="cm"> *	@mask contains the permission mask.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_setattr:</span>
<span class="cm"> *	Check permission before setting file attributes.  Note that the kernel</span>
<span class="cm"> *	call to notify_change is performed from several locations, whenever</span>
<span class="cm"> *	file attributes change (such as when a file is truncated, chown/chmod</span>
<span class="cm"> *	operations, transferring disk quotas, etc).</span>
<span class="cm"> *	@dentry contains the dentry structure for the file.</span>
<span class="cm"> *	@attr is the iattr structure containing the new file attributes.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @path_truncate:</span>
<span class="cm"> *	Check permission before truncating a file.</span>
<span class="cm"> *	@path contains the path structure for the file.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_getattr:</span>
<span class="cm"> *	Check permission before obtaining file attributes.</span>
<span class="cm"> *	@mnt is the vfsmount where the dentry was looked up</span>
<span class="cm"> *	@dentry contains the dentry structure for the file.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_setxattr:</span>
<span class="cm"> *	Check permission before setting the extended attributes</span>
<span class="cm"> *	@value identified by @name for @dentry.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_post_setxattr:</span>
<span class="cm"> *	Update inode security field after successful setxattr operation.</span>
<span class="cm"> *	@value identified by @name for @dentry.</span>
<span class="cm"> * @inode_getxattr:</span>
<span class="cm"> *	Check permission before obtaining the extended attributes</span>
<span class="cm"> *	identified by @name for @dentry.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_listxattr:</span>
<span class="cm"> *	Check permission before obtaining the list of extended attribute</span>
<span class="cm"> *	names for @dentry.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_removexattr:</span>
<span class="cm"> *	Check permission before removing the extended attribute</span>
<span class="cm"> *	identified by @name for @dentry.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @inode_getsecurity:</span>
<span class="cm"> *	Retrieve a copy of the extended attribute representation of the</span>
<span class="cm"> *	security label associated with @name for @inode via @buffer.  Note that</span>
<span class="cm"> *	@name is the remainder of the attribute name after the security prefix</span>
<span class="cm"> *	has been removed. @alloc is used to specify of the call should return a</span>
<span class="cm"> *	value via the buffer or just the value length Return size of buffer on</span>
<span class="cm"> *	success.</span>
<span class="cm"> * @inode_setsecurity:</span>
<span class="cm"> *	Set the security label associated with @name for @inode from the</span>
<span class="cm"> *	extended attribute value @value.  @size indicates the size of the</span>
<span class="cm"> *	@value in bytes.  @flags may be XATTR_CREATE, XATTR_REPLACE, or 0.</span>
<span class="cm"> *	Note that @name is the remainder of the attribute name after the</span>
<span class="cm"> *	security. prefix has been removed.</span>
<span class="cm"> *	Return 0 on success.</span>
<span class="cm"> * @inode_listsecurity:</span>
<span class="cm"> *	Copy the extended attribute names for the security labels</span>
<span class="cm"> *	associated with @inode into @buffer.  The maximum size of @buffer</span>
<span class="cm"> *	is specified by @buffer_size.  @buffer may be NULL to request</span>
<span class="cm"> *	the size of the buffer required.</span>
<span class="cm"> *	Returns number of bytes used/required on success.</span>
<span class="cm"> * @inode_need_killpriv:</span>
<span class="cm"> *	Called when an inode has been changed.</span>
<span class="cm"> *	@dentry is the dentry being changed.</span>
<span class="cm"> *	Return &lt;0 on error to abort the inode change operation.</span>
<span class="cm"> *	Return 0 if inode_killpriv does not need to be called.</span>
<span class="cm"> *	Return &gt;0 if inode_killpriv does need to be called.</span>
<span class="cm"> * @inode_killpriv:</span>
<span class="cm"> *	The setuid bit is being removed.  Remove similar security labels.</span>
<span class="cm"> *	Called with the dentry-&gt;d_inode-&gt;i_mutex held.</span>
<span class="cm"> *	@dentry is the dentry being changed.</span>
<span class="cm"> *	Return 0 on success.  If error is returned, then the operation</span>
<span class="cm"> *	causing setuid bit removal is failed.</span>
<span class="cm"> * @inode_getsecid:</span>
<span class="cm"> *	Get the secid associated with the node.</span>
<span class="cm"> *	@inode contains a pointer to the inode.</span>
<span class="cm"> *	@secid contains a pointer to the location where result will be saved.</span>
<span class="cm"> *	In case of failure, @secid will be set to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for file operations</span>
<span class="cm"> *</span>
<span class="cm"> * @file_permission:</span>
<span class="cm"> *	Check file permissions before accessing an open file.  This hook is</span>
<span class="cm"> *	called by various operations that read or write files.  A security</span>
<span class="cm"> *	module can use this hook to perform additional checking on these</span>
<span class="cm"> *	operations, e.g.  to revalidate permissions on use to support privilege</span>
<span class="cm"> *	bracketing or policy changes.  Notice that this hook is used when the</span>
<span class="cm"> *	actual read/write operations are performed, whereas the</span>
<span class="cm"> *	inode_security_ops hook is called when a file is opened (as well as</span>
<span class="cm"> *	many other operations).</span>
<span class="cm"> *	Caveat:  Although this hook can be used to revalidate permissions for</span>
<span class="cm"> *	various system call operations that read or write files, it does not</span>
<span class="cm"> *	address the revalidation of permissions for memory-mapped files.</span>
<span class="cm"> *	Security modules must handle this separately if they need such</span>
<span class="cm"> *	revalidation.</span>
<span class="cm"> *	@file contains the file structure being accessed.</span>
<span class="cm"> *	@mask contains the requested permissions.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @file_alloc_security:</span>
<span class="cm"> *	Allocate and attach a security structure to the file-&gt;f_security field.</span>
<span class="cm"> *	The security field is initialized to NULL when the structure is first</span>
<span class="cm"> *	created.</span>
<span class="cm"> *	@file contains the file structure to secure.</span>
<span class="cm"> *	Return 0 if the hook is successful and permission is granted.</span>
<span class="cm"> * @file_free_security:</span>
<span class="cm"> *	Deallocate and free any security structures stored in file-&gt;f_security.</span>
<span class="cm"> *	@file contains the file structure being modified.</span>
<span class="cm"> * @file_ioctl:</span>
<span class="cm"> *	@file contains the file structure.</span>
<span class="cm"> *	@cmd contains the operation to perform.</span>
<span class="cm"> *	@arg contains the operational arguments.</span>
<span class="cm"> *	Check permission for an ioctl operation on @file.  Note that @arg</span>
<span class="cm"> *	sometimes represents a user space pointer; in other cases, it may be a</span>
<span class="cm"> *	simple integer value.  When @arg represents a user space pointer, it</span>
<span class="cm"> *	should never be used by the security module.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @mmap_addr :</span>
<span class="cm"> *	Check permissions for a mmap operation at @addr.</span>
<span class="cm"> *	@addr contains virtual address that will be used for the operation.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @mmap_file :</span>
<span class="cm"> *	Check permissions for a mmap operation.  The @file may be NULL, e.g.</span>
<span class="cm"> *	if mapping anonymous memory.</span>
<span class="cm"> *	@file contains the file structure for file to map (may be NULL).</span>
<span class="cm"> *	@reqprot contains the protection requested by the application.</span>
<span class="cm"> *	@prot contains the protection that will be applied by the kernel.</span>
<span class="cm"> *	@flags contains the operational flags.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @file_mprotect:</span>
<span class="cm"> *	Check permissions before changing memory access permissions.</span>
<span class="cm"> *	@vma contains the memory region to modify.</span>
<span class="cm"> *	@reqprot contains the protection requested by the application.</span>
<span class="cm"> *	@prot contains the protection that will be applied by the kernel.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @file_lock:</span>
<span class="cm"> *	Check permission before performing file locking operations.</span>
<span class="cm"> *	Note: this hook mediates both flock and fcntl style locks.</span>
<span class="cm"> *	@file contains the file structure.</span>
<span class="cm"> *	@cmd contains the posix-translated lock operation to perform</span>
<span class="cm"> *	(e.g. F_RDLCK, F_WRLCK).</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @file_fcntl:</span>
<span class="cm"> *	Check permission before allowing the file operation specified by @cmd</span>
<span class="cm"> *	from being performed on the file @file.  Note that @arg sometimes</span>
<span class="cm"> *	represents a user space pointer; in other cases, it may be a simple</span>
<span class="cm"> *	integer value.  When @arg represents a user space pointer, it should</span>
<span class="cm"> *	never be used by the security module.</span>
<span class="cm"> *	@file contains the file structure.</span>
<span class="cm"> *	@cmd contains the operation to be performed.</span>
<span class="cm"> *	@arg contains the operational arguments.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @file_set_fowner:</span>
<span class="cm"> *	Save owner security information (typically from current-&gt;security) in</span>
<span class="cm"> *	file-&gt;f_security for later use by the send_sigiotask hook.</span>
<span class="cm"> *	@file contains the file structure to update.</span>
<span class="cm"> *	Return 0 on success.</span>
<span class="cm"> * @file_send_sigiotask:</span>
<span class="cm"> *	Check permission for the file owner @fown to send SIGIO or SIGURG to the</span>
<span class="cm"> *	process @tsk.  Note that this hook is sometimes called from interrupt.</span>
<span class="cm"> *	Note that the fown_struct, @fown, is never outside the context of a</span>
<span class="cm"> *	struct file, so the file structure (and associated security information)</span>
<span class="cm"> *	can always be obtained:</span>
<span class="cm"> *		container_of(fown, struct file, f_owner)</span>
<span class="cm"> *	@tsk contains the structure of task receiving signal.</span>
<span class="cm"> *	@fown contains the file owner information.</span>
<span class="cm"> *	@sig is the signal that will be sent.  When 0, kernel sends SIGIO.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @file_receive:</span>
<span class="cm"> *	This hook allows security modules to control the ability of a process</span>
<span class="cm"> *	to receive an open file descriptor via socket IPC.</span>
<span class="cm"> *	@file contains the file structure being received.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @file_open</span>
<span class="cm"> *	Save open-time permission checking state for later use upon</span>
<span class="cm"> *	file_permission, and recheck access if anything has changed</span>
<span class="cm"> *	since inode_permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for task operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @task_create:</span>
<span class="cm"> *	Check permission before creating a child process.  See the clone(2)</span>
<span class="cm"> *	manual page for definitions of the @clone_flags.</span>
<span class="cm"> *	@clone_flags contains the flags indicating what should be shared.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_free:</span>
<span class="cm"> *	@task task being freed</span>
<span class="cm"> *	Handle release of task-related resources. (Note that this can be called</span>
<span class="cm"> *	from interrupt context.)</span>
<span class="cm"> * @cred_alloc_blank:</span>
<span class="cm"> *	@cred points to the credentials.</span>
<span class="cm"> *	@gfp indicates the atomicity of any memory allocations.</span>
<span class="cm"> *	Only allocate sufficient memory and attach to @cred such that</span>
<span class="cm"> *	cred_transfer() will not get ENOMEM.</span>
<span class="cm"> * @cred_free:</span>
<span class="cm"> *	@cred points to the credentials.</span>
<span class="cm"> *	Deallocate and clear the cred-&gt;security field in a set of credentials.</span>
<span class="cm"> * @cred_prepare:</span>
<span class="cm"> *	@new points to the new credentials.</span>
<span class="cm"> *	@old points to the original credentials.</span>
<span class="cm"> *	@gfp indicates the atomicity of any memory allocations.</span>
<span class="cm"> *	Prepare a new set of credentials by copying the data from the old set.</span>
<span class="cm"> * @cred_transfer:</span>
<span class="cm"> *	@new points to the new credentials.</span>
<span class="cm"> *	@old points to the original credentials.</span>
<span class="cm"> *	Transfer data from original creds to new creds</span>
<span class="cm"> * @kernel_act_as:</span>
<span class="cm"> *	Set the credentials for a kernel service to act as (subjective context).</span>
<span class="cm"> *	@new points to the credentials to be modified.</span>
<span class="cm"> *	@secid specifies the security ID to be set</span>
<span class="cm"> *	The current task must be the one that nominated @secid.</span>
<span class="cm"> *	Return 0 if successful.</span>
<span class="cm"> * @kernel_create_files_as:</span>
<span class="cm"> *	Set the file creation context in a set of credentials to be the same as</span>
<span class="cm"> *	the objective context of the specified inode.</span>
<span class="cm"> *	@new points to the credentials to be modified.</span>
<span class="cm"> *	@inode points to the inode to use as a reference.</span>
<span class="cm"> *	The current task must be the one that nominated @inode.</span>
<span class="cm"> *	Return 0 if successful.</span>
<span class="cm"> * @kernel_module_request:</span>
<span class="cm"> *	Ability to trigger the kernel to automatically upcall to userspace for</span>
<span class="cm"> *	userspace to load a kernel module with the given name.</span>
<span class="cm"> *	@kmod_name name of the module requested by the kernel</span>
<span class="cm"> *	Return 0 if successful.</span>
<span class="cm"> * @task_fix_setuid:</span>
<span class="cm"> *	Update the module&#39;s state after setting one or more of the user</span>
<span class="cm"> *	identity attributes of the current process.  The @flags parameter</span>
<span class="cm"> *	indicates which of the set*uid system calls invoked this hook.  If</span>
<span class="cm"> *	@new is the set of credentials that will be installed.  Modifications</span>
<span class="cm"> *	should be made to this rather than to @current-&gt;cred.</span>
<span class="cm"> *	@old is the set of credentials that are being replaces</span>
<span class="cm"> *	@flags contains one of the LSM_SETID_* values.</span>
<span class="cm"> *	Return 0 on success.</span>
<span class="cm"> * @task_setpgid:</span>
<span class="cm"> *	Check permission before setting the process group identifier of the</span>
<span class="cm"> *	process @p to @pgid.</span>
<span class="cm"> *	@p contains the task_struct for process being modified.</span>
<span class="cm"> *	@pgid contains the new pgid.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_getpgid:</span>
<span class="cm"> *	Check permission before getting the process group identifier of the</span>
<span class="cm"> *	process @p.</span>
<span class="cm"> *	@p contains the task_struct for the process.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_getsid:</span>
<span class="cm"> *	Check permission before getting the session identifier of the process</span>
<span class="cm"> *	@p.</span>
<span class="cm"> *	@p contains the task_struct for the process.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_getsecid:</span>
<span class="cm"> *	Retrieve the security identifier of the process @p.</span>
<span class="cm"> *	@p contains the task_struct for the process and place is into @secid.</span>
<span class="cm"> *	In case of failure, @secid will be set to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * @task_setnice:</span>
<span class="cm"> *	Check permission before setting the nice value of @p to @nice.</span>
<span class="cm"> *	@p contains the task_struct of process.</span>
<span class="cm"> *	@nice contains the new nice value.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_setioprio</span>
<span class="cm"> *	Check permission before setting the ioprio value of @p to @ioprio.</span>
<span class="cm"> *	@p contains the task_struct of process.</span>
<span class="cm"> *	@ioprio contains the new ioprio value</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_getioprio</span>
<span class="cm"> *	Check permission before getting the ioprio value of @p.</span>
<span class="cm"> *	@p contains the task_struct of process.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_setrlimit:</span>
<span class="cm"> *	Check permission before setting the resource limits of the current</span>
<span class="cm"> *	process for @resource to @new_rlim.  The old resource limit values can</span>
<span class="cm"> *	be examined by dereferencing (current-&gt;signal-&gt;rlim + resource).</span>
<span class="cm"> *	@resource contains the resource whose limit is being set.</span>
<span class="cm"> *	@new_rlim contains the new limits for @resource.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_setscheduler:</span>
<span class="cm"> *	Check permission before setting scheduling policy and/or parameters of</span>
<span class="cm"> *	process @p based on @policy and @lp.</span>
<span class="cm"> *	@p contains the task_struct for process.</span>
<span class="cm"> *	@policy contains the scheduling policy.</span>
<span class="cm"> *	@lp contains the scheduling parameters.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_getscheduler:</span>
<span class="cm"> *	Check permission before obtaining scheduling information for process</span>
<span class="cm"> *	@p.</span>
<span class="cm"> *	@p contains the task_struct for process.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_movememory</span>
<span class="cm"> *	Check permission before moving memory owned by process @p.</span>
<span class="cm"> *	@p contains the task_struct for process.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_kill:</span>
<span class="cm"> *	Check permission before sending signal @sig to @p.  @info can be NULL,</span>
<span class="cm"> *	the constant 1, or a pointer to a siginfo structure.  If @info is 1 or</span>
<span class="cm"> *	SI_FROMKERNEL(info) is true, then the signal should be viewed as coming</span>
<span class="cm"> *	from the kernel and should typically be permitted.</span>
<span class="cm"> *	SIGIO signals are handled separately by the send_sigiotask hook in</span>
<span class="cm"> *	file_security_ops.</span>
<span class="cm"> *	@p contains the task_struct for process.</span>
<span class="cm"> *	@info contains the signal information.</span>
<span class="cm"> *	@sig contains the signal value.</span>
<span class="cm"> *	@secid contains the sid of the process where the signal originated</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_wait:</span>
<span class="cm"> *	Check permission before allowing a process to reap a child process @p</span>
<span class="cm"> *	and collect its status information.</span>
<span class="cm"> *	@p contains the task_struct for process.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @task_prctl:</span>
<span class="cm"> *	Check permission before performing a process control operation on the</span>
<span class="cm"> *	current process.</span>
<span class="cm"> *	@option contains the operation.</span>
<span class="cm"> *	@arg2 contains a argument.</span>
<span class="cm"> *	@arg3 contains a argument.</span>
<span class="cm"> *	@arg4 contains a argument.</span>
<span class="cm"> *	@arg5 contains a argument.</span>
<span class="cm"> *	Return -ENOSYS if no-one wanted to handle this op, any other value to</span>
<span class="cm"> *	cause prctl() to return immediately with that value.</span>
<span class="cm"> * @task_to_inode:</span>
<span class="cm"> *	Set the security attributes for an inode based on an associated task&#39;s</span>
<span class="cm"> *	security attributes, e.g. for /proc/pid inodes.</span>
<span class="cm"> *	@p contains the task_struct for the task.</span>
<span class="cm"> *	@inode contains the inode structure for the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for Netlink messaging.</span>
<span class="cm"> *</span>
<span class="cm"> * @netlink_send:</span>
<span class="cm"> *	Save security information for a netlink message so that permission</span>
<span class="cm"> *	checking can be performed when the message is processed.  The security</span>
<span class="cm"> *	information can be saved using the eff_cap field of the</span>
<span class="cm"> *	netlink_skb_parms structure.  Also may be used to provide fine</span>
<span class="cm"> *	grained control over message transmission.</span>
<span class="cm"> *	@sk associated sock of task sending the message.</span>
<span class="cm"> *	@skb contains the sk_buff structure for the netlink message.</span>
<span class="cm"> *	Return 0 if the information was successfully saved and message</span>
<span class="cm"> *	is allowed to be transmitted.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for Unix domain networking.</span>
<span class="cm"> *</span>
<span class="cm"> * @unix_stream_connect:</span>
<span class="cm"> *	Check permissions before establishing a Unix domain stream connection</span>
<span class="cm"> *	between @sock and @other.</span>
<span class="cm"> *	@sock contains the sock structure.</span>
<span class="cm"> *	@other contains the peer sock structure.</span>
<span class="cm"> *	@newsk contains the new sock structure.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @unix_may_send:</span>
<span class="cm"> *	Check permissions before connecting or sending datagrams from @sock to</span>
<span class="cm"> *	@other.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@other contains the peer socket structure.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> *</span>
<span class="cm"> * The @unix_stream_connect and @unix_may_send hooks were necessary because</span>
<span class="cm"> * Linux provides an alternative to the conventional file name space for Unix</span>
<span class="cm"> * domain sockets.  Whereas binding and connecting to sockets in the file name</span>
<span class="cm"> * space is mediated by the typical file permissions (and caught by the mknod</span>
<span class="cm"> * and permission hooks in inode_security_ops), binding and connecting to</span>
<span class="cm"> * sockets in the abstract name space is completely unmediated.  Sufficient</span>
<span class="cm"> * control of Unix domain sockets in the abstract name space isn&#39;t possible</span>
<span class="cm"> * using only the socket layer hooks, since we need to know the actual target</span>
<span class="cm"> * socket, which is not looked up until we are inside the af_unix code.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for socket operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @socket_create:</span>
<span class="cm"> *	Check permissions prior to creating a new socket.</span>
<span class="cm"> *	@family contains the requested protocol family.</span>
<span class="cm"> *	@type contains the requested communications type.</span>
<span class="cm"> *	@protocol contains the requested protocol.</span>
<span class="cm"> *	@kern set to 1 if a kernel socket.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_post_create:</span>
<span class="cm"> *	This hook allows a module to update or allocate a per-socket security</span>
<span class="cm"> *	structure. Note that the security field was not added directly to the</span>
<span class="cm"> *	socket structure, but rather, the socket security information is stored</span>
<span class="cm"> *	in the associated inode.  Typically, the inode alloc_security hook will</span>
<span class="cm"> *	allocate and and attach security information to</span>
<span class="cm"> *	sock-&gt;inode-&gt;i_security.  This hook may be used to update the</span>
<span class="cm"> *	sock-&gt;inode-&gt;i_security field with additional information that wasn&#39;t</span>
<span class="cm"> *	available when the inode was allocated.</span>
<span class="cm"> *	@sock contains the newly created socket structure.</span>
<span class="cm"> *	@family contains the requested protocol family.</span>
<span class="cm"> *	@type contains the requested communications type.</span>
<span class="cm"> *	@protocol contains the requested protocol.</span>
<span class="cm"> *	@kern set to 1 if a kernel socket.</span>
<span class="cm"> * @socket_bind:</span>
<span class="cm"> *	Check permission before socket protocol layer bind operation is</span>
<span class="cm"> *	performed and the socket @sock is bound to the address specified in the</span>
<span class="cm"> *	@address parameter.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@address contains the address to bind to.</span>
<span class="cm"> *	@addrlen contains the length of address.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_connect:</span>
<span class="cm"> *	Check permission before socket protocol layer connect operation</span>
<span class="cm"> *	attempts to connect socket @sock to a remote address, @address.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@address contains the address of remote endpoint.</span>
<span class="cm"> *	@addrlen contains the length of address.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_listen:</span>
<span class="cm"> *	Check permission before socket protocol layer listen operation.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@backlog contains the maximum length for the pending connection queue.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_accept:</span>
<span class="cm"> *	Check permission before accepting a new connection.  Note that the new</span>
<span class="cm"> *	socket, @newsock, has been created and some information copied to it,</span>
<span class="cm"> *	but the accept operation has not actually been performed.</span>
<span class="cm"> *	@sock contains the listening socket structure.</span>
<span class="cm"> *	@newsock contains the newly created server socket for connection.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_sendmsg:</span>
<span class="cm"> *	Check permission before transmitting a message to another socket.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@msg contains the message to be transmitted.</span>
<span class="cm"> *	@size contains the size of message.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_recvmsg:</span>
<span class="cm"> *	Check permission before receiving a message from a socket.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@msg contains the message structure.</span>
<span class="cm"> *	@size contains the size of message structure.</span>
<span class="cm"> *	@flags contains the operational flags.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_getsockname:</span>
<span class="cm"> *	Check permission before the local address (name) of the socket object</span>
<span class="cm"> *	@sock is retrieved.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_getpeername:</span>
<span class="cm"> *	Check permission before the remote address (name) of a socket object</span>
<span class="cm"> *	@sock is retrieved.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_getsockopt:</span>
<span class="cm"> *	Check permissions before retrieving the options associated with socket</span>
<span class="cm"> *	@sock.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@level contains the protocol level to retrieve option from.</span>
<span class="cm"> *	@optname contains the name of option to retrieve.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_setsockopt:</span>
<span class="cm"> *	Check permissions before setting the options associated with socket</span>
<span class="cm"> *	@sock.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@level contains the protocol level to set options for.</span>
<span class="cm"> *	@optname contains the name of the option to set.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_shutdown:</span>
<span class="cm"> *	Checks permission before all or part of a connection on the socket</span>
<span class="cm"> *	@sock is shut down.</span>
<span class="cm"> *	@sock contains the socket structure.</span>
<span class="cm"> *	@how contains the flag indicating how future sends and receives are handled.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @socket_sock_rcv_skb:</span>
<span class="cm"> *	Check permissions on incoming network packets.  This hook is distinct</span>
<span class="cm"> *	from Netfilter&#39;s IP input hooks since it is the first time that the</span>
<span class="cm"> *	incoming sk_buff @skb has been associated with a particular socket, @sk.</span>
<span class="cm"> *	Must not sleep inside this hook because some callers hold spinlocks.</span>
<span class="cm"> *	@sk contains the sock (not socket) associated with the incoming sk_buff.</span>
<span class="cm"> *	@skb contains the incoming network data.</span>
<span class="cm"> * @socket_getpeersec_stream:</span>
<span class="cm"> *	This hook allows the security module to provide peer socket security</span>
<span class="cm"> *	state for unix or connected tcp sockets to userspace via getsockopt</span>
<span class="cm"> *	SO_GETPEERSEC.  For tcp sockets this can be meaningful if the</span>
<span class="cm"> *	socket is associated with an ipsec SA.</span>
<span class="cm"> *	@sock is the local socket.</span>
<span class="cm"> *	@optval userspace memory where the security state is to be copied.</span>
<span class="cm"> *	@optlen userspace int where the module should copy the actual length</span>
<span class="cm"> *	of the security state.</span>
<span class="cm"> *	@len as input is the maximum length to copy to userspace provided</span>
<span class="cm"> *	by the caller.</span>
<span class="cm"> *	Return 0 if all is well, otherwise, typical getsockopt return</span>
<span class="cm"> *	values.</span>
<span class="cm"> * @socket_getpeersec_dgram:</span>
<span class="cm"> *	This hook allows the security module to provide peer socket security</span>
<span class="cm"> *	state for udp sockets on a per-packet basis to userspace via</span>
<span class="cm"> *	getsockopt SO_GETPEERSEC.  The application must first have indicated</span>
<span class="cm"> *	the IP_PASSSEC option via getsockopt.  It can then retrieve the</span>
<span class="cm"> *	security state returned by this hook for a packet via the SCM_SECURITY</span>
<span class="cm"> *	ancillary message type.</span>
<span class="cm"> *	@skb is the skbuff for the packet being queried</span>
<span class="cm"> *	@secdata is a pointer to a buffer in which to copy the security data</span>
<span class="cm"> *	@seclen is the maximum length for @secdata</span>
<span class="cm"> *	Return 0 on success, error on failure.</span>
<span class="cm"> * @sk_alloc_security:</span>
<span class="cm"> *	Allocate and attach a security structure to the sk-&gt;sk_security field,</span>
<span class="cm"> *	which is used to copy security attributes between local stream sockets.</span>
<span class="cm"> * @sk_free_security:</span>
<span class="cm"> *	Deallocate security structure.</span>
<span class="cm"> * @sk_clone_security:</span>
<span class="cm"> *	Clone/copy security structure.</span>
<span class="cm"> * @sk_getsecid:</span>
<span class="cm"> *	Retrieve the LSM-specific secid for the sock to enable caching of network</span>
<span class="cm"> *	authorizations.</span>
<span class="cm"> * @sock_graft:</span>
<span class="cm"> *	Sets the socket&#39;s isec sid to the sock&#39;s sid.</span>
<span class="cm"> * @inet_conn_request:</span>
<span class="cm"> *	Sets the openreq&#39;s sid to socket&#39;s sid with MLS portion taken from peer sid.</span>
<span class="cm"> * @inet_csk_clone:</span>
<span class="cm"> *	Sets the new child socket&#39;s sid to the openreq sid.</span>
<span class="cm"> * @inet_conn_established:</span>
<span class="cm"> *	Sets the connection&#39;s peersid to the secmark on skb.</span>
<span class="cm"> * @secmark_relabel_packet:</span>
<span class="cm"> *	check if the process should be allowed to relabel packets to the given secid</span>
<span class="cm"> * @security_secmark_refcount_inc</span>
<span class="cm"> *	tells the LSM to increment the number of secmark labeling rules loaded</span>
<span class="cm"> * @security_secmark_refcount_dec</span>
<span class="cm"> *	tells the LSM to decrement the number of secmark labeling rules loaded</span>
<span class="cm"> * @req_classify_flow:</span>
<span class="cm"> *	Sets the flow&#39;s sid to the openreq sid.</span>
<span class="cm"> * @tun_dev_create:</span>
<span class="cm"> *	Check permissions prior to creating a new TUN device.</span>
<span class="cm"> * @tun_dev_post_create:</span>
<span class="cm"> *	This hook allows a module to update or allocate a per-socket security</span>
<span class="cm"> *	structure.</span>
<span class="cm"> *	@sk contains the newly created sock structure.</span>
<span class="cm"> * @tun_dev_attach:</span>
<span class="cm"> *	Check permissions prior to attaching to a persistent TUN device.  This</span>
<span class="cm"> *	hook can also be used by the module to update any security state</span>
<span class="cm"> *	associated with the TUN device&#39;s sock structure.</span>
<span class="cm"> *	@sk contains the existing sock structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for XFRM operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @xfrm_policy_alloc_security:</span>
<span class="cm"> *	@ctxp is a pointer to the xfrm_sec_ctx being added to Security Policy</span>
<span class="cm"> *	Database used by the XFRM system.</span>
<span class="cm"> *	@sec_ctx contains the security context information being provided by</span>
<span class="cm"> *	the user-level policy update program (e.g., setkey).</span>
<span class="cm"> *	Allocate a security structure to the xp-&gt;security field; the security</span>
<span class="cm"> *	field is initialized to NULL when the xfrm_policy is allocated.</span>
<span class="cm"> *	Return 0 if operation was successful (memory to allocate, legal context)</span>
<span class="cm"> * @xfrm_policy_clone_security:</span>
<span class="cm"> *	@old_ctx contains an existing xfrm_sec_ctx.</span>
<span class="cm"> *	@new_ctxp contains a new xfrm_sec_ctx being cloned from old.</span>
<span class="cm"> *	Allocate a security structure in new_ctxp that contains the</span>
<span class="cm"> *	information from the old_ctx structure.</span>
<span class="cm"> *	Return 0 if operation was successful (memory to allocate).</span>
<span class="cm"> * @xfrm_policy_free_security:</span>
<span class="cm"> *	@ctx contains the xfrm_sec_ctx</span>
<span class="cm"> *	Deallocate xp-&gt;security.</span>
<span class="cm"> * @xfrm_policy_delete_security:</span>
<span class="cm"> *	@ctx contains the xfrm_sec_ctx.</span>
<span class="cm"> *	Authorize deletion of xp-&gt;security.</span>
<span class="cm"> * @xfrm_state_alloc_security:</span>
<span class="cm"> *	@x contains the xfrm_state being added to the Security Association</span>
<span class="cm"> *	Database by the XFRM system.</span>
<span class="cm"> *	@sec_ctx contains the security context information being provided by</span>
<span class="cm"> *	the user-level SA generation program (e.g., setkey or racoon).</span>
<span class="cm"> *	@secid contains the secid from which to take the mls portion of the context.</span>
<span class="cm"> *	Allocate a security structure to the x-&gt;security field; the security</span>
<span class="cm"> *	field is initialized to NULL when the xfrm_state is allocated. Set the</span>
<span class="cm"> *	context to correspond to either sec_ctx or polsec, with the mls portion</span>
<span class="cm"> *	taken from secid in the latter case.</span>
<span class="cm"> *	Return 0 if operation was successful (memory to allocate, legal context).</span>
<span class="cm"> * @xfrm_state_free_security:</span>
<span class="cm"> *	@x contains the xfrm_state.</span>
<span class="cm"> *	Deallocate x-&gt;security.</span>
<span class="cm"> * @xfrm_state_delete_security:</span>
<span class="cm"> *	@x contains the xfrm_state.</span>
<span class="cm"> *	Authorize deletion of x-&gt;security.</span>
<span class="cm"> * @xfrm_policy_lookup:</span>
<span class="cm"> *	@ctx contains the xfrm_sec_ctx for which the access control is being</span>
<span class="cm"> *	checked.</span>
<span class="cm"> *	@fl_secid contains the flow security label that is used to authorize</span>
<span class="cm"> *	access to the policy xp.</span>
<span class="cm"> *	@dir contains the direction of the flow (input or output).</span>
<span class="cm"> *	Check permission when a flow selects a xfrm_policy for processing</span>
<span class="cm"> *	XFRMs on a packet.  The hook is called when selecting either a</span>
<span class="cm"> *	per-socket policy or a generic xfrm policy.</span>
<span class="cm"> *	Return 0 if permission is granted, -ESRCH otherwise, or -errno</span>
<span class="cm"> *	on other errors.</span>
<span class="cm"> * @xfrm_state_pol_flow_match:</span>
<span class="cm"> *	@x contains the state to match.</span>
<span class="cm"> *	@xp contains the policy to check for a match.</span>
<span class="cm"> *	@fl contains the flow to check for a match.</span>
<span class="cm"> *	Return 1 if there is a match.</span>
<span class="cm"> * @xfrm_decode_session:</span>
<span class="cm"> *	@skb points to skb to decode.</span>
<span class="cm"> *	@secid points to the flow key secid to set.</span>
<span class="cm"> *	@ckall says if all xfrms used should be checked for same secid.</span>
<span class="cm"> *	Return 0 if ckall is zero or all xfrms used have the same secid.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks affecting all Key Management operations</span>
<span class="cm"> *</span>
<span class="cm"> * @key_alloc:</span>
<span class="cm"> *	Permit allocation of a key and assign security data. Note that key does</span>
<span class="cm"> *	not have a serial number assigned at this point.</span>
<span class="cm"> *	@key points to the key.</span>
<span class="cm"> *	@flags is the allocation flags</span>
<span class="cm"> *	Return 0 if permission is granted, -ve error otherwise.</span>
<span class="cm"> * @key_free:</span>
<span class="cm"> *	Notification of destruction; free security data.</span>
<span class="cm"> *	@key points to the key.</span>
<span class="cm"> *	No return value.</span>
<span class="cm"> * @key_permission:</span>
<span class="cm"> *	See whether a specific operational right is granted to a process on a</span>
<span class="cm"> *	key.</span>
<span class="cm"> *	@key_ref refers to the key (key pointer + possession attribute bit).</span>
<span class="cm"> *	@cred points to the credentials to provide the context against which to</span>
<span class="cm"> *	evaluate the security data on the key.</span>
<span class="cm"> *	@perm describes the combination of permissions required of this key.</span>
<span class="cm"> *	Return 0 if permission is granted, -ve error otherwise.</span>
<span class="cm"> * @key_getsecurity:</span>
<span class="cm"> *	Get a textual representation of the security context attached to a key</span>
<span class="cm"> *	for the purposes of honouring KEYCTL_GETSECURITY.  This function</span>
<span class="cm"> *	allocates the storage for the NUL-terminated string and the caller</span>
<span class="cm"> *	should free it.</span>
<span class="cm"> *	@key points to the key to be queried.</span>
<span class="cm"> *	@_buffer points to a pointer that should be set to point to the</span>
<span class="cm"> *	resulting string (if no label or an error occurs).</span>
<span class="cm"> *	Return the length of the string (including terminating NUL) or -ve if</span>
<span class="cm"> *	an error.</span>
<span class="cm"> *	May also return 0 (and a NULL buffer pointer) if there is no label.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks affecting all System V IPC operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @ipc_permission:</span>
<span class="cm"> *	Check permissions for access to IPC</span>
<span class="cm"> *	@ipcp contains the kernel IPC permission structure</span>
<span class="cm"> *	@flag contains the desired (requested) permission set</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @ipc_getsecid:</span>
<span class="cm"> *	Get the secid associated with the ipc object.</span>
<span class="cm"> *	@ipcp contains the kernel IPC permission structure.</span>
<span class="cm"> *	@secid contains a pointer to the location where result will be saved.</span>
<span class="cm"> *	In case of failure, @secid will be set to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for individual messages held in System V IPC message queues</span>
<span class="cm"> * @msg_msg_alloc_security:</span>
<span class="cm"> *	Allocate and attach a security structure to the msg-&gt;security field.</span>
<span class="cm"> *	The security field is initialized to NULL when the structure is first</span>
<span class="cm"> *	created.</span>
<span class="cm"> *	@msg contains the message structure to be modified.</span>
<span class="cm"> *	Return 0 if operation was successful and permission is granted.</span>
<span class="cm"> * @msg_msg_free_security:</span>
<span class="cm"> *	Deallocate the security structure for this message.</span>
<span class="cm"> *	@msg contains the message structure to be modified.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for System V IPC Message Queues</span>
<span class="cm"> *</span>
<span class="cm"> * @msg_queue_alloc_security:</span>
<span class="cm"> *	Allocate and attach a security structure to the</span>
<span class="cm"> *	msq-&gt;q_perm.security field. The security field is initialized to</span>
<span class="cm"> *	NULL when the structure is first created.</span>
<span class="cm"> *	@msq contains the message queue structure to be modified.</span>
<span class="cm"> *	Return 0 if operation was successful and permission is granted.</span>
<span class="cm"> * @msg_queue_free_security:</span>
<span class="cm"> *	Deallocate security structure for this message queue.</span>
<span class="cm"> *	@msq contains the message queue structure to be modified.</span>
<span class="cm"> * @msg_queue_associate:</span>
<span class="cm"> *	Check permission when a message queue is requested through the</span>
<span class="cm"> *	msgget system call.  This hook is only called when returning the</span>
<span class="cm"> *	message queue identifier for an existing message queue, not when a</span>
<span class="cm"> *	new message queue is created.</span>
<span class="cm"> *	@msq contains the message queue to act upon.</span>
<span class="cm"> *	@msqflg contains the operation control flags.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @msg_queue_msgctl:</span>
<span class="cm"> *	Check permission when a message control operation specified by @cmd</span>
<span class="cm"> *	is to be performed on the message queue @msq.</span>
<span class="cm"> *	The @msq may be NULL, e.g. for IPC_INFO or MSG_INFO.</span>
<span class="cm"> *	@msq contains the message queue to act upon.  May be NULL.</span>
<span class="cm"> *	@cmd contains the operation to be performed.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @msg_queue_msgsnd:</span>
<span class="cm"> *	Check permission before a message, @msg, is enqueued on the message</span>
<span class="cm"> *	queue, @msq.</span>
<span class="cm"> *	@msq contains the message queue to send message to.</span>
<span class="cm"> *	@msg contains the message to be enqueued.</span>
<span class="cm"> *	@msqflg contains operational flags.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @msg_queue_msgrcv:</span>
<span class="cm"> *	Check permission before a message, @msg, is removed from the message</span>
<span class="cm"> *	queue, @msq.  The @target task structure contains a pointer to the</span>
<span class="cm"> *	process that will be receiving the message (not equal to the current</span>
<span class="cm"> *	process when inline receives are being performed).</span>
<span class="cm"> *	@msq contains the message queue to retrieve message from.</span>
<span class="cm"> *	@msg contains the message destination.</span>
<span class="cm"> *	@target contains the task structure for recipient process.</span>
<span class="cm"> *	@type contains the type of message requested.</span>
<span class="cm"> *	@mode contains the operational flags.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for System V Shared Memory Segments</span>
<span class="cm"> *</span>
<span class="cm"> * @shm_alloc_security:</span>
<span class="cm"> *	Allocate and attach a security structure to the shp-&gt;shm_perm.security</span>
<span class="cm"> *	field.  The security field is initialized to NULL when the structure is</span>
<span class="cm"> *	first created.</span>
<span class="cm"> *	@shp contains the shared memory structure to be modified.</span>
<span class="cm"> *	Return 0 if operation was successful and permission is granted.</span>
<span class="cm"> * @shm_free_security:</span>
<span class="cm"> *	Deallocate the security struct for this memory segment.</span>
<span class="cm"> *	@shp contains the shared memory structure to be modified.</span>
<span class="cm"> * @shm_associate:</span>
<span class="cm"> *	Check permission when a shared memory region is requested through the</span>
<span class="cm"> *	shmget system call.  This hook is only called when returning the shared</span>
<span class="cm"> *	memory region identifier for an existing region, not when a new shared</span>
<span class="cm"> *	memory region is created.</span>
<span class="cm"> *	@shp contains the shared memory structure to be modified.</span>
<span class="cm"> *	@shmflg contains the operation control flags.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @shm_shmctl:</span>
<span class="cm"> *	Check permission when a shared memory control operation specified by</span>
<span class="cm"> *	@cmd is to be performed on the shared memory region @shp.</span>
<span class="cm"> *	The @shp may be NULL, e.g. for IPC_INFO or SHM_INFO.</span>
<span class="cm"> *	@shp contains shared memory structure to be modified.</span>
<span class="cm"> *	@cmd contains the operation to be performed.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @shm_shmat:</span>
<span class="cm"> *	Check permissions prior to allowing the shmat system call to attach the</span>
<span class="cm"> *	shared memory segment @shp to the data segment of the calling process.</span>
<span class="cm"> *	The attaching address is specified by @shmaddr.</span>
<span class="cm"> *	@shp contains the shared memory structure to be modified.</span>
<span class="cm"> *	@shmaddr contains the address to attach memory region to.</span>
<span class="cm"> *	@shmflg contains the operational flags.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for System V Semaphores</span>
<span class="cm"> *</span>
<span class="cm"> * @sem_alloc_security:</span>
<span class="cm"> *	Allocate and attach a security structure to the sma-&gt;sem_perm.security</span>
<span class="cm"> *	field.  The security field is initialized to NULL when the structure is</span>
<span class="cm"> *	first created.</span>
<span class="cm"> *	@sma contains the semaphore structure</span>
<span class="cm"> *	Return 0 if operation was successful and permission is granted.</span>
<span class="cm"> * @sem_free_security:</span>
<span class="cm"> *	deallocate security struct for this semaphore</span>
<span class="cm"> *	@sma contains the semaphore structure.</span>
<span class="cm"> * @sem_associate:</span>
<span class="cm"> *	Check permission when a semaphore is requested through the semget</span>
<span class="cm"> *	system call.  This hook is only called when returning the semaphore</span>
<span class="cm"> *	identifier for an existing semaphore, not when a new one must be</span>
<span class="cm"> *	created.</span>
<span class="cm"> *	@sma contains the semaphore structure.</span>
<span class="cm"> *	@semflg contains the operation control flags.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @sem_semctl:</span>
<span class="cm"> *	Check permission when a semaphore operation specified by @cmd is to be</span>
<span class="cm"> *	performed on the semaphore @sma.  The @sma may be NULL, e.g. for</span>
<span class="cm"> *	IPC_INFO or SEM_INFO.</span>
<span class="cm"> *	@sma contains the semaphore structure.  May be NULL.</span>
<span class="cm"> *	@cmd contains the operation to be performed.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @sem_semop</span>
<span class="cm"> *	Check permissions before performing operations on members of the</span>
<span class="cm"> *	semaphore set @sma.  If the @alter flag is nonzero, the semaphore set</span>
<span class="cm"> *	may be modified.</span>
<span class="cm"> *	@sma contains the semaphore structure.</span>
<span class="cm"> *	@sops contains the operations to perform.</span>
<span class="cm"> *	@nsops contains the number of operations to perform.</span>
<span class="cm"> *	@alter contains the flag indicating whether changes are to be made.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> *</span>
<span class="cm"> * @ptrace_access_check:</span>
<span class="cm"> *	Check permission before allowing the current process to trace the</span>
<span class="cm"> *	@child process.</span>
<span class="cm"> *	Security modules may also want to perform a process tracing check</span>
<span class="cm"> *	during an execve in the set_security or apply_creds hooks of</span>
<span class="cm"> *	tracing check during an execve in the bprm_set_creds hook of</span>
<span class="cm"> *	binprm_security_ops if the process is being traced and its security</span>
<span class="cm"> *	attributes would be changed by the execve.</span>
<span class="cm"> *	@child contains the task_struct structure for the target process.</span>
<span class="cm"> *	@mode contains the PTRACE_MODE flags indicating the form of access.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @ptrace_traceme:</span>
<span class="cm"> *	Check that the @parent process has sufficient permission to trace the</span>
<span class="cm"> *	current process before allowing the current process to present itself</span>
<span class="cm"> *	to the @parent process for tracing.</span>
<span class="cm"> *	The parent process will still have to undergo the ptrace_access_check</span>
<span class="cm"> *	checks before it is allowed to trace this one.</span>
<span class="cm"> *	@parent contains the task_struct structure for debugger process.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @capget:</span>
<span class="cm"> *	Get the @effective, @inheritable, and @permitted capability sets for</span>
<span class="cm"> *	the @target process.  The hook may also perform permission checking to</span>
<span class="cm"> *	determine if the current process is allowed to see the capability sets</span>
<span class="cm"> *	of the @target process.</span>
<span class="cm"> *	@target contains the task_struct structure for target process.</span>
<span class="cm"> *	@effective contains the effective capability set.</span>
<span class="cm"> *	@inheritable contains the inheritable capability set.</span>
<span class="cm"> *	@permitted contains the permitted capability set.</span>
<span class="cm"> *	Return 0 if the capability sets were successfully obtained.</span>
<span class="cm"> * @capset:</span>
<span class="cm"> *	Set the @effective, @inheritable, and @permitted capability sets for</span>
<span class="cm"> *	the current process.</span>
<span class="cm"> *	@new contains the new credentials structure for target process.</span>
<span class="cm"> *	@old contains the current credentials structure for target process.</span>
<span class="cm"> *	@effective contains the effective capability set.</span>
<span class="cm"> *	@inheritable contains the inheritable capability set.</span>
<span class="cm"> *	@permitted contains the permitted capability set.</span>
<span class="cm"> *	Return 0 and update @new if permission is granted.</span>
<span class="cm"> * @capable:</span>
<span class="cm"> *	Check whether the @tsk process has the @cap capability in the indicated</span>
<span class="cm"> *	credentials.</span>
<span class="cm"> *	@cred contains the credentials to use.</span>
<span class="cm"> *	@ns contains the user namespace we want the capability in</span>
<span class="cm"> *	@cap contains the capability &lt;include/linux/capability.h&gt;.</span>
<span class="cm"> *	@audit: Whether to write an audit message or not</span>
<span class="cm"> *	Return 0 if the capability is granted for @tsk.</span>
<span class="cm"> * @syslog:</span>
<span class="cm"> *	Check permission before accessing the kernel message ring or changing</span>
<span class="cm"> *	logging to the console.</span>
<span class="cm"> *	See the syslog(2) manual page for an explanation of the @type values.</span>
<span class="cm"> *	@type contains the type of action.</span>
<span class="cm"> *	@from_file indicates the context of action (if it came from /proc).</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @settime:</span>
<span class="cm"> *	Check permission to change the system time.</span>
<span class="cm"> *	struct timespec and timezone are defined in include/linux/time.h</span>
<span class="cm"> *	@ts contains new time</span>
<span class="cm"> *	@tz contains new timezone</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> * @vm_enough_memory:</span>
<span class="cm"> *	Check permissions for allocating a new virtual mapping.</span>
<span class="cm"> *	@mm contains the mm struct it is being added to.</span>
<span class="cm"> *	@pages contains the number of pages.</span>
<span class="cm"> *	Return 0 if permission is granted.</span>
<span class="cm"> *</span>
<span class="cm"> * @secid_to_secctx:</span>
<span class="cm"> *	Convert secid to security context.  If secdata is NULL the length of</span>
<span class="cm"> *	the result will be returned in seclen, but no secdata will be returned.</span>
<span class="cm"> *	This does mean that the length could change between calls to check the</span>
<span class="cm"> *	length and the next call which actually allocates and returns the secdata.</span>
<span class="cm"> *	@secid contains the security ID.</span>
<span class="cm"> *	@secdata contains the pointer that stores the converted security context.</span>
<span class="cm"> *	@seclen pointer which contains the length of the data</span>
<span class="cm"> * @secctx_to_secid:</span>
<span class="cm"> *	Convert security context to secid.</span>
<span class="cm"> *	@secid contains the pointer to the generated security ID.</span>
<span class="cm"> *	@secdata contains the security context.</span>
<span class="cm"> *</span>
<span class="cm"> * @release_secctx:</span>
<span class="cm"> *	Release the security context.</span>
<span class="cm"> *	@secdata contains the security context.</span>
<span class="cm"> *	@seclen contains the length of the security context.</span>
<span class="cm"> *</span>
<span class="cm"> * Security hooks for Audit</span>
<span class="cm"> *</span>
<span class="cm"> * @audit_rule_init:</span>
<span class="cm"> *	Allocate and initialize an LSM audit rule structure.</span>
<span class="cm"> *	@field contains the required Audit action. Fields flags are defined in include/linux/audit.h</span>
<span class="cm"> *	@op contains the operator the rule uses.</span>
<span class="cm"> *	@rulestr contains the context where the rule will be applied to.</span>
<span class="cm"> *	@lsmrule contains a pointer to receive the result.</span>
<span class="cm"> *	Return 0 if @lsmrule has been successfully set,</span>
<span class="cm"> *	-EINVAL in case of an invalid rule.</span>
<span class="cm"> *</span>
<span class="cm"> * @audit_rule_known:</span>
<span class="cm"> *	Specifies whether given @rule contains any fields related to current LSM.</span>
<span class="cm"> *	@rule contains the audit rule of interest.</span>
<span class="cm"> *	Return 1 in case of relation found, 0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * @audit_rule_match:</span>
<span class="cm"> *	Determine if given @secid matches a rule previously approved</span>
<span class="cm"> *	by @audit_rule_known.</span>
<span class="cm"> *	@secid contains the security id in question.</span>
<span class="cm"> *	@field contains the field which relates to current LSM.</span>
<span class="cm"> *	@op contains the operator that will be used for matching.</span>
<span class="cm"> *	@rule points to the audit rule that will be checked against.</span>
<span class="cm"> *	@actx points to the audit context associated with the check.</span>
<span class="cm"> *	Return 1 if secid matches the rule, 0 if it does not, -ERRNO on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * @audit_rule_free:</span>
<span class="cm"> *	Deallocate the LSM audit rule structure previously allocated by</span>
<span class="cm"> *	audit_rule_init.</span>
<span class="cm"> *	@rule contains the allocated rule</span>
<span class="cm"> *</span>
<span class="cm"> * @inode_notifysecctx:</span>
<span class="cm"> *	Notify the security module of what the security context of an inode</span>
<span class="cm"> *	should be.  Initializes the incore security context managed by the</span>
<span class="cm"> *	security module for this inode.  Example usage:  NFS client invokes</span>
<span class="cm"> *	this hook to initialize the security context in its incore inode to the</span>
<span class="cm"> *	value provided by the server for the file when the server returned the</span>
<span class="cm"> *	file&#39;s attributes to the client.</span>
<span class="cm"> *</span>
<span class="cm"> * 	Must be called with inode-&gt;i_mutex locked.</span>
<span class="cm"> *</span>
<span class="cm"> * 	@inode we wish to set the security context of.</span>
<span class="cm"> * 	@ctx contains the string which we wish to set in the inode.</span>
<span class="cm"> * 	@ctxlen contains the length of @ctx.</span>
<span class="cm"> *</span>
<span class="cm"> * @inode_setsecctx:</span>
<span class="cm"> * 	Change the security context of an inode.  Updates the</span>
<span class="cm"> * 	incore security context managed by the security module and invokes the</span>
<span class="cm"> * 	fs code as needed (via __vfs_setxattr_noperm) to update any backing</span>
<span class="cm"> * 	xattrs that represent the context.  Example usage:  NFS server invokes</span>
<span class="cm"> * 	this hook to change the security context in its incore inode and on the</span>
<span class="cm"> * 	backing filesystem to a value provided by the client on a SETATTR</span>
<span class="cm"> * 	operation.</span>
<span class="cm"> *</span>
<span class="cm"> * 	Must be called with inode-&gt;i_mutex locked.</span>
<span class="cm"> *</span>
<span class="cm"> * 	@dentry contains the inode we wish to set the security context of.</span>
<span class="cm"> * 	@ctx contains the string which we wish to set in the inode.</span>
<span class="cm"> * 	@ctxlen contains the length of @ctx.</span>
<span class="cm"> *</span>
<span class="cm"> * @inode_getsecctx:</span>
<span class="cm"> *	Returns a string containing all relevant security context information</span>
<span class="cm"> *</span>
<span class="cm"> * 	@inode we wish to get the security context of.</span>
<span class="cm"> *	@ctx is a pointer in which to place the allocated security context.</span>
<span class="cm"> *	@ctxlen points to the place to put the length of @ctx.</span>
<span class="cm"> * This is the main security structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">security_operations</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">SECURITY_NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptrace_access_check</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptrace_traceme</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">capget</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
		       <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
		       <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">capset</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">capable</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">audit</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">quotactl</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">cmds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">quota_on</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">syslog</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">settime</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tz</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">vm_enough_memory</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bprm_set_creds</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bprm_check_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bprm_secureexec</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bprm_committing_creds</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bprm_committed_creds</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_copy_data</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">copy</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_remount</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_kern_mount</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_show_options</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_statfs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_mount</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_umount</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_pivotroot</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_path</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_set_mnt_opts</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_clone_mnt_opts</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">oldsb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">newsb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sb_parse_opts_str</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SECURITY_PATH</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_unlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_mkdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_rmdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_mknod</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_truncate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_symlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_rename</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_chmod</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_chown</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">path_chroot</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_init_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">**</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_unlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_symlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_mkdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_rmdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_mknod</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			    <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_rename</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_readlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_follow_link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_permission</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_setattr</span><span class="p">)</span>	<span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_getattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_setxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_post_setxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_getxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_listxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_removexattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_need_killpriv</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_killpriv</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_getsecurity</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bool</span> <span class="n">alloc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_setsecurity</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_listsecurity</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_getsecid</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_permission</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">file_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmap_addr</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmap_file</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_mprotect</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_lock</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_fcntl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_set_fowner</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_send_sigiotask</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_receive</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">file_open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_create</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">task_free</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cred_alloc_blank</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cred_free</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cred_prepare</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
			    <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cred_transfer</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kernel_act_as</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kernel_create_files_as</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kernel_module_request</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="n">kmod_name</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_fix_setuid</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_setpgid</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pgid</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_getpgid</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_getsid</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">task_getsecid</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_setnice</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_setioprio</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_getioprio</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_setrlimit</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resource</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">new_rlim</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_setscheduler</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_getscheduler</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_movememory</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_kill</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_wait</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">task_prctl</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">option</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg4</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg5</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">task_to_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipc_permission</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="kt">short</span> <span class="n">flag</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipc_getsecid</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_msg_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_msg_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_queue_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_queue_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_queue_associate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_queue_msgctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_queue_msgsnd</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">msg_queue_msgrcv</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
				 <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">shm_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">shm_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">shm_associate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">shm_shmctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">shm_shmat</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sem_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sem_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sem_associate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sem_semctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sem_semop</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alter</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">netlink_send</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">d_instantiate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getprocattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">value</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setprocattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">secid_to_secctx</span><span class="p">)</span> <span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">seclen</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">secctx_to_secid</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release_secctx</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_notifysecctx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_setsecctx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inode_getsecctx</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctxlen</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unix_stream_connect</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unix_may_send</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">other</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_create</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_post_create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_bind</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_connect</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_listen</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_accept</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_sendmsg</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_recvmsg</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_getsockname</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_getpeername</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_getsockopt</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_setsockopt</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_shutdown</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_sock_rcv_skb</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_getpeersec_stream</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">socket_getpeersec_dgram</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sk_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sk_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sk_clone_security</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sk_getsecid</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sock_graft</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">inet_conn_request</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inet_csk_clone</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inet_conn_established</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">secmark_relabel_packet</span><span class="p">)</span> <span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">secmark_refcount_inc</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">secmark_refcount_dec</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">req_classify_flow</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tun_dev_create</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">tun_dev_post_create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">tun_dev_attach</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY_NETWORK */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK_XFRM</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_policy_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">**</span><span class="n">ctxp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span> <span class="o">*</span><span class="n">sec_ctx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_policy_clone_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">old_ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">**</span><span class="n">new_ctx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_policy_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_policy_delete_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_state_alloc_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span> <span class="o">*</span><span class="n">sec_ctx</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_state_free_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_state_delete_security</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_policy_lookup</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fl_secid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dir</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_state_pol_flow_match</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">xfrm_decode_session</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ckall</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY_NETWORK_XFRM */</span><span class="cp"></span>

	<span class="cm">/* key management security hooks */</span>
<span class="cp">#ifdef CONFIG_KEYS</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">key_alloc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">key_free</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">key_permission</span><span class="p">)</span> <span class="p">(</span><span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
			       <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">key_getsecurity</span><span class="p">)(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">_buffer</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_KEYS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">audit_rule_init</span><span class="p">)</span> <span class="p">(</span><span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rulestr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">lsmrule</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">audit_rule_known</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">krule</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">audit_rule_match</span><span class="p">)</span> <span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">lsmrule</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">actx</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">audit_rule_free</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">lsmrule</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_AUDIT */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/* prototypes */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">security_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">security_module_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">security_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">security_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">security_fixup_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">security_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>


<span class="cm">/* Security operations */</span>
<span class="kt">int</span> <span class="n">security_ptrace_access_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_ptrace_traceme</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_capget</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
		    <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
		    <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
		    <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_capset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
		    <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
		    <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
		    <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_capable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_capable_noaudit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">cap</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_quotactl</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_quota_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_syslog</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_settime</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tz</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_bprm_set_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_bprm_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_bprm_committing_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_bprm_committed_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_bprm_secureexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_sb_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_copy_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">copy</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_kern_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_mount</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_pivotroot</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_path</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_set_mnt_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_sb_clone_mnt_opts</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">oldsb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">newsb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sb_parse_opts_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">security_inode_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_inode_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_init_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span>
				 <span class="n">initxattrs</span> <span class="n">initxattrs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fs_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_old_inode_init_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">**</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_inode_post_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_listxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_need_killpriv</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_killpriv</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_getsecurity</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bool</span> <span class="n">alloc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_setsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_listsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_inode_getsecid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_file_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_mmap_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_mmap_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_mprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_fcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_set_fowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_send_sigiotask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_task_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_cred_alloc_blank</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_cred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_prepare_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_transfer_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_kernel_act_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_kernel_create_files_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_kernel_module_request</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">kmod_name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_fix_setuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_setpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pgid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_getpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_getsid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_task_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_setnice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_setioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_getioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_setrlimit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resource</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">new_rlim</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_movememory</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_task_prctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">option</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg4</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg5</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_task_to_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_ipc_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="kt">short</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_ipc_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_msg_msg_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_msg_msg_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_msg_queue_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_msg_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_msg_queue_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_msg_queue_msgctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_msg_queue_msgsnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_msg_queue_msgrcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_shm_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_shm_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_shm_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_shm_shmctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_shm_shmat</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sem_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_sem_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sem_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sem_semctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sem_semop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alter</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_getprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_setprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_netlink_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_secid_to_secctx</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">seclen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_secctx_to_secid</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_release_secctx</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">security_inode_notifysecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_setsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inode_getsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctxlen</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_SECURITY */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="p">{</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_init_mnt_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_free_mnt_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the default capabilities functionality.  Most of these functions</span>
<span class="cm"> * are just stubbed out, but a few must call the proper capable code.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_ptrace_access_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_ptrace_access_check</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_ptrace_traceme</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_ptrace_traceme</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_capget</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
				   <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
				   <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
				   <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_capget</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">effective</span><span class="p">,</span> <span class="n">inheritable</span><span class="p">,</span> <span class="n">permitted</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_capset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">effective</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">inheritable</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">kernel_cap_t</span> <span class="o">*</span><span class="n">permitted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_capset</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">effective</span><span class="p">,</span> <span class="n">inheritable</span><span class="p">,</span> <span class="n">permitted</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_capable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_capable</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">SECURITY_CAP_AUDIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_capable_noaudit</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_capable</span><span class="p">(</span><span class="n">cred</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">SECURITY_CAP_NOAUDIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_quotactl</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_quota_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_syslog</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_settime</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_settime</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">tz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_vm_enough_memory_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_vm_enough_memory</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_bprm_set_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_bprm_set_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_bprm_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_bprm_committing_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_bprm_committed_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_bprm_secureexec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_bprm_secureexec</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_sb_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_copy_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_kern_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_mount</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				    <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
				    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_pivotroot</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_path</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_set_mnt_opts</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_sb_clone_mnt_opts</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">oldsb</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">newsb</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sb_parse_opts_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">security_mnt_opts</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_inode_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_init_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span>
						<span class="k">const</span> <span class="n">initxattrs</span> <span class="n">initxattrs</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">fs_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_old_inode_init_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
						   <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span>
						   <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">value</span><span class="p">,</span>
						   <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					 <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_inode_setxattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_inode_post_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_listxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_inode_removexattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_need_killpriv</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_inode_need_killpriv</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_killpriv</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_inode_killpriv</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_getsecurity</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bool</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_setsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_listsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_inode_getsecid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_file_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_mmap_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_mmap_addr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_mmap_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_mprotect</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reqprot</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_fcntl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_set_fowner</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_send_sigiotask</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_task_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_cred_alloc_blank</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_cred_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_prepare_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
					 <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_transfer_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_kernel_act_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_kernel_create_files_as</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_kernel_module_request</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">kmod_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_fix_setuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_task_fix_setuid</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_setpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_getpgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_getsid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_task_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_setnice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_task_setnice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nice</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_setioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_task_setioprio</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ioprio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_getioprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_setrlimit</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resource</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">new_rlim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_task_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_getscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_movememory</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_task_prctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">option</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg2</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg3</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg4</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg5</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_task_prctl</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">arg5</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_task_to_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_ipc_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span>
					  <span class="kt">short</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_ipc_getsecid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kern_ipc_perm</span> <span class="o">*</span><span class="n">ipcp</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">secid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_msg_msg_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_msg_msg_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_msg_queue_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_msg_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_msg_queue_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">msqflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_msg_queue_msgctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_msg_queue_msgsnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msqflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_msg_queue_msgrcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">msg_queue</span> <span class="o">*</span><span class="n">msq</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">msg_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
					    <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_shm_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_shm_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_shm_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">shmflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_shm_shmctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_shm_shmat</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmid_kernel</span> <span class="o">*</span><span class="n">shp</span><span class="p">,</span>
				     <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shmflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sem_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_sem_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sem_associate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sem_semctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sem_semop</span><span class="p">(</span><span class="k">struct</span> <span class="n">sem_array</span> <span class="o">*</span><span class="n">sma</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">alter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_getprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_setprocattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_netlink_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cap_netlink_send</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_secid_to_secctx</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">seclen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_secctx_to_secid</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span>
					   <span class="n">u32</span> <span class="n">seclen</span><span class="p">,</span>
					   <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_release_secctx</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">secdata</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seclen</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_notifysecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_setsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inode_getsecctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK</span>

<span class="kt">int</span> <span class="n">security_unix_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_unix_may_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">other</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_getsockname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_getpeername</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sock_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_getpeersec_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_socket_getpeersec_dgram</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_sk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_sk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_sk_clone</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_sk_classify_flow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_req_classify_flow</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_sock_graft</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_inet_conn_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_inet_csk_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_inet_conn_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_secmark_relabel_packet</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_secmark_refcount_inc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_secmark_refcount_dec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_tun_dev_create</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_tun_dev_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_tun_dev_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_SECURITY_NETWORK */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_unix_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_unix_may_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">family</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_getsockname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_getpeername</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sock_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_getpeersec_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_socket_getpeersec_dgram</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_sk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_sk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_sk_clone</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_sk_classify_flow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_req_classify_flow</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_sock_graft</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_inet_conn_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_inet_csk_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_inet_conn_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_secmark_relabel_packet</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_secmark_refcount_inc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_secmark_refcount_dec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_tun_dev_create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_tun_dev_post_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_tun_dev_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY_NETWORK */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK_XFRM</span>

<span class="kt">int</span> <span class="n">security_xfrm_policy_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">**</span><span class="n">ctxp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span> <span class="o">*</span><span class="n">sec_ctx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_xfrm_policy_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">old_ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">**</span><span class="n">new_ctxp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_xfrm_policy_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_xfrm_policy_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_xfrm_state_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span> <span class="o">*</span><span class="n">sec_ctx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_xfrm_state_alloc_acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">polsec</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_xfrm_state_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_xfrm_state_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_xfrm_policy_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fl_secid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dir</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_xfrm_state_pol_flow_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_xfrm_decode_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_skb_classify_flow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_SECURITY_NETWORK_XFRM */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_policy_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">**</span><span class="n">ctxp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span> <span class="o">*</span><span class="n">sec_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_policy_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">**</span><span class="n">new_ctxp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_xfrm_policy_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_policy_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_state_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">xfrm_user_sec_ctx</span> <span class="o">*</span><span class="n">sec_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_state_alloc_acquire</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">polsec</span><span class="p">,</span> <span class="n">u32</span> <span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_xfrm_state_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_state_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_policy_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_sec_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">fl_secid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_state_pol_flow_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">xfrm_state</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">xfrm_policy</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_xfrm_decode_session</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">secid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_skb_classify_flow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY_NETWORK_XFRM */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SECURITY_PATH</span>
<span class="kt">int</span> <span class="n">security_path_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_chmod</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_chown</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_path_chroot</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="cp">#else	</span><span class="cm">/* CONFIG_SECURITY_PATH */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				      <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				      <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_chmod</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_chown</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">gid_t</span> <span class="n">gid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_path_chroot</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SECURITY_PATH */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_KEYS</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>

<span class="kt">int</span> <span class="n">security_key_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_key_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_key_permission</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_key_getsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">_buffer</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_key_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_key_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_key_permission</span><span class="p">(</span><span class="n">key_ref_t</span> <span class="n">key_ref</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
					  <span class="n">key_perm_t</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_key_getsecurity</span><span class="p">(</span><span class="k">struct</span> <span class="n">key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KEYS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_AUDIT</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
<span class="kt">int</span> <span class="n">security_audit_rule_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rulestr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">lsmrule</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_audit_rule_known</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">krule</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">security_audit_rule_match</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">lsmrule</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">actx</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">security_audit_rule_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">lsmrule</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_audit_rule_init</span><span class="p">(</span><span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rulestr</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">**</span><span class="n">lsmrule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_audit_rule_known</span><span class="p">(</span><span class="k">struct</span> <span class="n">audit_krule</span> <span class="o">*</span><span class="n">krule</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">security_audit_rule_match</span><span class="p">(</span><span class="n">u32</span> <span class="n">secid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">field</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">lsmrule</span><span class="p">,</span> <span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">actx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">security_audit_rule_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">lsmrule</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SECURITY */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_AUDIT */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SECURITYFS</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">securityfs_create_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">securityfs_create_dir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">securityfs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_SECURITYFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">securityfs_create_dir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">securityfs_create_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						    <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
						    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
						    <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">securityfs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SECURITY</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">alloc_secdata</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_secdata</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">secdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">secdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">alloc_secdata</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_secdata</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">secdata</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SECURITY */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* ! __LINUX_SECURITY_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
