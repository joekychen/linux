<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › time.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>time.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_TIME_H</span>
<span class="cp">#define _LINUX_TIME_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp"># include &lt;linux/cache.h&gt;</span>
<span class="cp"># include &lt;linux/seqlock.h&gt;</span>
<span class="cp"># include &lt;linux/math64.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef _STRUCT_TIMESPEC</span>
<span class="cp">#define _STRUCT_TIMESPEC</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="p">{</span>
	<span class="n">__kernel_time_t</span>	<span class="n">tv_sec</span><span class="p">;</span>			<span class="cm">/* seconds */</span>
	<span class="kt">long</span>		<span class="n">tv_nsec</span><span class="p">;</span>		<span class="cm">/* nanoseconds */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">timeval</span> <span class="p">{</span>
	<span class="n">__kernel_time_t</span>		<span class="n">tv_sec</span><span class="p">;</span>		<span class="cm">/* seconds */</span>
	<span class="n">__kernel_suseconds_t</span>	<span class="n">tv_usec</span><span class="p">;</span>	<span class="cm">/* microseconds */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">timezone</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">tz_minuteswest</span><span class="p">;</span>	<span class="cm">/* minutes west of Greenwich */</span>
	<span class="kt">int</span>	<span class="n">tz_dsttime</span><span class="p">;</span>	<span class="cm">/* type of dst correction */</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="n">sys_tz</span><span class="p">;</span>

<span class="cm">/* Parameters used to convert the timespec values: */</span>
<span class="cp">#define MSEC_PER_SEC	1000L</span>
<span class="cp">#define USEC_PER_MSEC	1000L</span>
<span class="cp">#define NSEC_PER_USEC	1000L</span>
<span class="cp">#define NSEC_PER_MSEC	1000000L</span>
<span class="cp">#define USEC_PER_SEC	1000000L</span>
<span class="cp">#define NSEC_PER_SEC	1000000000L</span>
<span class="cp">#define FSEC_PER_SEC	1000000000000000LL</span>

<span class="cp">#define TIME_T_MAX	(time_t)((1UL &lt;&lt; ((sizeof(time_t) &lt;&lt; 3) - 1)) - 1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">timespec_equal</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lhs &lt; rhs:  return &lt;0</span>
<span class="cm"> * lhs == rhs: return 0</span>
<span class="cm"> * lhs &gt; rhs:  return &gt;0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">timespec_compare</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lhs</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">timeval_compare</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lhs</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">tv_usec</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mktime</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">year</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mon</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hour</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sec</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_normalized_timespec</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="kt">time_t</span> <span class="n">sec</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nsec</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * timespec_add_safe assumes both values are positive and checks</span>
<span class="cm"> * for overflow. It will return TIME_T_MAX if the reutrn would be</span>
<span class="cm"> * smaller then either of the arguments.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">timespec_add_safe</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">lhs</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">rhs</span><span class="p">);</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="nf">timespec_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">lhs</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">timespec</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts_delta</span><span class="p">;</span>
	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts_delta</span><span class="p">,</span> <span class="n">lhs</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
				<span class="n">lhs</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ts_delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sub = lhs - rhs, in normalized form</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="nf">timespec_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">lhs</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">timespec</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts_delta</span><span class="p">;</span>
	<span class="n">set_normalized_timespec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts_delta</span><span class="p">,</span> <span class="n">lhs</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
				<span class="n">lhs</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ts_delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns true if the timespec is norm, false if denorm:</span>
<span class="cm"> */</span>
<span class="cp">#define timespec_valid(ts) \</span>
<span class="cp">	(((ts)-&gt;tv_sec &gt;= 0) &amp;&amp; (((unsigned long) (ts)-&gt;tv_nsec) &lt; NSEC_PER_SEC))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">read_persistent_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">read_boot_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">update_persistent_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">timekeeping_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">timekeeping_suspended</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_seconds</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="n">current_kernel_time</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__current_kernel_time</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="cm">/* does not take xtime_lock */</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="n">get_monotonic_coarse</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">get_xtime_and_monotonic_and_sleep_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">xtim</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">wtom</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">sleep</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">timekeeping_inject_sleeptime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">delta</span><span class="p">);</span>

<span class="cp">#define CURRENT_TIME		(current_kernel_time())</span>
<span class="cp">#define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })</span>

<span class="cm">/* Some architectures do not supply their own clocksource.</span>
<span class="cm"> * This is mainly the case in architectures that get their</span>
<span class="cm"> * inter-tick times by reading the counter on their interval</span>
<span class="cm"> * timer. Since these timers wrap every tick, they&#39;re not really</span>
<span class="cm"> * useful as clocksources. Wrapping them to act like one is possible</span>
<span class="cm"> * but not very efficient. So we provide a callout these arches</span>
<span class="cm"> * can implement for use with the jiffies clocksource to provide</span>
<span class="cm"> * finer then tick granular time.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">arch_gettimeoffset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">arch_gettimeoffset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_gettimeofday</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_settimeofday</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_sys_settimeofday</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tv</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="n">tz</span><span class="p">);</span>
<span class="cp">#define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">do_utimes</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">times</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">itimerval</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_setitimer</span><span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="k">struct</span> <span class="n">itimerval</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">itimerval</span> <span class="o">*</span><span class="n">ovalue</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alarm_setitimer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_getitimer</span><span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="k">struct</span> <span class="n">itimerval</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">getnstimeofday</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tv</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">getrawmonotonic</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">getnstime_raw_and_real</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts_raw</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts_real</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">getboottime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">monotonic_to_bootbased</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">get_monotonic_boottime</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">timespec_trunc</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">gran</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">timekeeping_valid_for_hres</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">timekeeping_max_deferment</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">timekeeping_inject_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tms</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_sys_times</span><span class="p">(</span><span class="k">struct</span> <span class="n">tms</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to the struct tm in userspace &lt;time.h&gt;, but it needs to be here so</span>
<span class="cm"> * that the kernel source is self contained.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tm</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * the number of seconds after the minute, normally in the range</span>
<span class="cm">	 * 0 to 59, but can be up to 60 to allow for leap seconds</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">tm_sec</span><span class="p">;</span>
	<span class="cm">/* the number of minutes after the hour, in the range 0 to 59*/</span>
	<span class="kt">int</span> <span class="n">tm_min</span><span class="p">;</span>
	<span class="cm">/* the number of hours past midnight, in the range 0 to 23 */</span>
	<span class="kt">int</span> <span class="n">tm_hour</span><span class="p">;</span>
	<span class="cm">/* the day of the month, in the range 1 to 31 */</span>
	<span class="kt">int</span> <span class="n">tm_mday</span><span class="p">;</span>
	<span class="cm">/* the number of months since January, in the range 0 to 11 */</span>
	<span class="kt">int</span> <span class="n">tm_mon</span><span class="p">;</span>
	<span class="cm">/* the number of years since 1900 */</span>
	<span class="kt">long</span> <span class="n">tm_year</span><span class="p">;</span>
	<span class="cm">/* the number of days since Sunday, in the range 0 to 6 */</span>
	<span class="kt">int</span> <span class="n">tm_wday</span><span class="p">;</span>
	<span class="cm">/* the number of days since January 1, in the range 0 to 365 */</span>
	<span class="kt">int</span> <span class="n">tm_yday</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">time_to_tm</span><span class="p">(</span><span class="kt">time_t</span> <span class="n">totalsecs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tm</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * timespec_to_ns - Convert timespec to nanoseconds</span>
<span class="cm"> * @ts:		pointer to the timespec variable to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the scalar nanosecond representation of the timespec</span>
<span class="cm"> * parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">timespec_to_ns</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="o">+</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * timeval_to_ns - Convert timeval to nanoseconds</span>
<span class="cm"> * @ts:		pointer to the timeval variable to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the scalar nanosecond representation of the timeval</span>
<span class="cm"> * parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">timeval_to_ns</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span> <span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_usec</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ns_to_timespec - Convert nanoseconds to timespec</span>
<span class="cm"> * @nsec:	the nanoseconds value to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the timespec representation of the nsec parameter.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">ns_to_timespec</span><span class="p">(</span><span class="k">const</span> <span class="n">s64</span> <span class="n">nsec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ns_to_timeval - Convert nanoseconds to timeval</span>
<span class="cm"> * @nsec:	the nanoseconds value to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the timeval representation of the nsec parameter.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">ns_to_timeval</span><span class="p">(</span><span class="k">const</span> <span class="n">s64</span> <span class="n">nsec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * timespec_add_ns - Adds nanoseconds to a timespec</span>
<span class="cm"> * @a:		pointer to timespec to be incremented</span>
<span class="cm"> * @ns:		unsigned nanoseconds value to be added</span>
<span class="cm"> *</span>
<span class="cm"> * This must always be inlined because its used from the x86-64 vdso,</span>
<span class="cm"> * which cannot call other kernel functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">timespec_add_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">+=</span> <span class="n">__iter_div_u64_rem</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">ns</span><span class="p">,</span> <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#define NFDBITS			__NFDBITS</span>

<span class="cp">#define FD_SETSIZE		__FD_SETSIZE</span>
<span class="cp">#define FD_SET(fd,fdsetp)	__FD_SET(fd,fdsetp)</span>
<span class="cp">#define FD_CLR(fd,fdsetp)	__FD_CLR(fd,fdsetp)</span>
<span class="cp">#define FD_ISSET(fd,fdsetp)	__FD_ISSET(fd,fdsetp)</span>
<span class="cp">#define FD_ZERO(fdsetp)		__FD_ZERO(fdsetp)</span>

<span class="cm">/*</span>
<span class="cm"> * Names of the interval timers, and structure</span>
<span class="cm"> * defining a timer setting:</span>
<span class="cm"> */</span>
<span class="cp">#define	ITIMER_REAL		0</span>
<span class="cp">#define	ITIMER_VIRTUAL		1</span>
<span class="cp">#define	ITIMER_PROF		2</span>

<span class="k">struct</span> <span class="n">itimerspec</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">it_interval</span><span class="p">;</span>	<span class="cm">/* timer period */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">it_value</span><span class="p">;</span>	<span class="cm">/* timer expiration */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">itimerval</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">it_interval</span><span class="p">;</span>	<span class="cm">/* timer interval */</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">it_value</span><span class="p">;</span>	<span class="cm">/* current value */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The IDs of the various system clocks (for POSIX.1b interval timers):</span>
<span class="cm"> */</span>
<span class="cp">#define CLOCK_REALTIME			0</span>
<span class="cp">#define CLOCK_MONOTONIC			1</span>
<span class="cp">#define CLOCK_PROCESS_CPUTIME_ID	2</span>
<span class="cp">#define CLOCK_THREAD_CPUTIME_ID		3</span>
<span class="cp">#define CLOCK_MONOTONIC_RAW		4</span>
<span class="cp">#define CLOCK_REALTIME_COARSE		5</span>
<span class="cp">#define CLOCK_MONOTONIC_COARSE		6</span>
<span class="cp">#define CLOCK_BOOTTIME			7</span>
<span class="cp">#define CLOCK_REALTIME_ALARM		8</span>
<span class="cp">#define CLOCK_BOOTTIME_ALARM		9</span>

<span class="cm">/*</span>
<span class="cm"> * The IDs of various hardware clocks:</span>
<span class="cm"> */</span>
<span class="cp">#define CLOCK_SGI_CYCLE			10</span>
<span class="cp">#define MAX_CLOCKS			16</span>
<span class="cp">#define CLOCKS_MASK			(CLOCK_REALTIME | CLOCK_MONOTONIC)</span>
<span class="cp">#define CLOCKS_MONO			CLOCK_MONOTONIC</span>

<span class="cm">/*</span>
<span class="cm"> * The various flags for setting POSIX.1b interval timers:</span>
<span class="cm"> */</span>
<span class="cp">#define TIMER_ABSTIME			0x01</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
