<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › hrtimer.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hrtimer.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  include/linux/hrtimer.h</span>
<span class="cm"> *</span>
<span class="cm"> *  hrtimers - High-resolution kernel timers</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright(C) 2005, Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *   Copyright(C) 2005, Red Hat, Inc., Ingo Molnar</span>
<span class="cm"> *</span>
<span class="cm"> *  data type definitions, declarations, prototypes</span>
<span class="cm"> *</span>
<span class="cm"> *  Started by: Thomas Gleixner and Ingo Molnar</span>
<span class="cm"> *</span>
<span class="cm"> *  For licencing details see kernel-base/COPYING</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_HRTIMER_H</span>
<span class="cp">#define _LINUX_HRTIMER_H</span>

<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/timerqueue.h&gt;</span>

<span class="k">struct</span> <span class="n">hrtimer_clock_base</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Mode arguments of xxx_hrtimer functions:</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="p">{</span>
	<span class="n">HRTIMER_MODE_ABS</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>		<span class="cm">/* Time value is absolute */</span>
	<span class="n">HRTIMER_MODE_REL</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>		<span class="cm">/* Time value is relative to now */</span>
	<span class="n">HRTIMER_MODE_PINNED</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>	<span class="cm">/* Timer is bound to CPU */</span>
	<span class="n">HRTIMER_MODE_ABS_PINNED</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">HRTIMER_MODE_REL_PINNED</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Return values for the callback function</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="p">{</span>
	<span class="n">HRTIMER_NORESTART</span><span class="p">,</span>	<span class="cm">/* Timer is not restarted */</span>
	<span class="n">HRTIMER_RESTART</span><span class="p">,</span>	<span class="cm">/* Timer must be restarted */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Values to track state of the timer</span>
<span class="cm"> *</span>
<span class="cm"> * Possible states:</span>
<span class="cm"> *</span>
<span class="cm"> * 0x00		inactive</span>
<span class="cm"> * 0x01		enqueued into rbtree</span>
<span class="cm"> * 0x02		callback function running</span>
<span class="cm"> * 0x04		timer is migrated to another cpu</span>
<span class="cm"> *</span>
<span class="cm"> * Special cases:</span>
<span class="cm"> * 0x03		callback function running and enqueued</span>
<span class="cm"> *		(was requeued on another CPU)</span>
<span class="cm"> * 0x05		timer was migrated on CPU hotunplug</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;callback function running and enqueued&quot; status is only possible on</span>
<span class="cm"> * SMP. It happens for example when a posix timer expired and the callback</span>
<span class="cm"> * queued a signal. Between dropping the lock which protects the posix timer</span>
<span class="cm"> * and reacquiring the base lock of the hrtimer, another CPU can deliver the</span>
<span class="cm"> * signal and rearm the timer. We have to preserve the callback running state,</span>
<span class="cm"> * as otherwise the timer could be removed before the softirq code finishes the</span>
<span class="cm"> * the handling of the timer.</span>
<span class="cm"> *</span>
<span class="cm"> * The HRTIMER_STATE_ENQUEUED bit is always or&#39;ed to the current state</span>
<span class="cm"> * to preserve the HRTIMER_STATE_CALLBACK in the above scenario. This</span>
<span class="cm"> * also affects HRTIMER_STATE_MIGRATE where the preservation is not</span>
<span class="cm"> * necessary. HRTIMER_STATE_MIGRATE is cleared after the timer is</span>
<span class="cm"> * enqueued on the new cpu.</span>
<span class="cm"> *</span>
<span class="cm"> * All state transitions are protected by cpu_base-&gt;lock.</span>
<span class="cm"> */</span>
<span class="cp">#define HRTIMER_STATE_INACTIVE	0x00</span>
<span class="cp">#define HRTIMER_STATE_ENQUEUED	0x01</span>
<span class="cp">#define HRTIMER_STATE_CALLBACK	0x02</span>
<span class="cp">#define HRTIMER_STATE_MIGRATE	0x04</span>

<span class="cm">/**</span>
<span class="cm"> * struct hrtimer - the basic hrtimer structure</span>
<span class="cm"> * @node:	timerqueue node, which also manages node.expires,</span>
<span class="cm"> *		the absolute expiry time in the hrtimers internal</span>
<span class="cm"> *		representation. The time is related to the clock on</span>
<span class="cm"> *		which the timer is based. Is setup by adding</span>
<span class="cm"> *		slack to the _softexpires value. For non range timers</span>
<span class="cm"> *		identical to _softexpires.</span>
<span class="cm"> * @_softexpires: the absolute earliest expiry time of the hrtimer.</span>
<span class="cm"> *		The time which was given as expiry time when the timer</span>
<span class="cm"> *		was armed.</span>
<span class="cm"> * @function:	timer expiry callback function</span>
<span class="cm"> * @base:	pointer to the timer base (per cpu and per clock)</span>
<span class="cm"> * @state:	state information (See bit values above)</span>
<span class="cm"> * @start_site:	timer statistics field to store the site where the timer</span>
<span class="cm"> *		was started</span>
<span class="cm"> * @start_comm: timer statistics field to store the name of the process which</span>
<span class="cm"> *		started the timer</span>
<span class="cm"> * @start_pid: timer statistics field to store the pid of the task which</span>
<span class="cm"> *		started the timer</span>
<span class="cm"> *</span>
<span class="cm"> * The hrtimer structure must be initialized by hrtimer_init()</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hrtimer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timerqueue_node</span>		<span class="n">node</span><span class="p">;</span>
	<span class="n">ktime_t</span>				<span class="n">_softexpires</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hrtimer_restart</span>		<span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span>	<span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">state</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_TIMER_STATS</span>
	<span class="kt">int</span>				<span class="n">start_pid</span><span class="p">;</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">start_site</span><span class="p">;</span>
	<span class="kt">char</span>				<span class="n">start_comm</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct hrtimer_sleeper - simple sleeper structure</span>
<span class="cm"> * @timer:	embedded timer structure</span>
<span class="cm"> * @task:	task to wake up</span>
<span class="cm"> *</span>
<span class="cm"> * task is set to NULL, when the timer expires.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct hrtimer_clock_base - the timer base for a specific clock</span>
<span class="cm"> * @cpu_base:		per cpu clock base</span>
<span class="cm"> * @index:		clock type index for per_cpu support when moving a</span>
<span class="cm"> *			timer to a base on another cpu.</span>
<span class="cm"> * @clockid:		clock id for per_cpu support</span>
<span class="cm"> * @active:		red black tree root node for the active timers</span>
<span class="cm"> * @resolution:		the resolution of the clock, in nanoseconds</span>
<span class="cm"> * @get_time:		function to retrieve the current time of the clock</span>
<span class="cm"> * @softirq_time:	the time when running the hrtimer queue in the softirq</span>
<span class="cm"> * @offset:		offset of this clock to the monotonic base</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hrtimer_clock_base</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span>	<span class="o">*</span><span class="n">cpu_base</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>
	<span class="n">clockid_t</span>		<span class="n">clockid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timerqueue_head</span>	<span class="n">active</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">resolution</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="p">(</span><span class="o">*</span><span class="n">get_time</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="n">ktime_t</span>			<span class="n">softirq_time</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span>  <span class="n">hrtimer_base_type</span> <span class="p">{</span>
	<span class="n">HRTIMER_BASE_MONOTONIC</span><span class="p">,</span>
	<span class="n">HRTIMER_BASE_REALTIME</span><span class="p">,</span>
	<span class="n">HRTIMER_BASE_BOOTTIME</span><span class="p">,</span>
	<span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct hrtimer_cpu_base - the per cpu clock bases</span>
<span class="cm"> * @lock:		lock protecting the base and associated clock bases</span>
<span class="cm"> *			and timers</span>
<span class="cm"> * @active_bases:	Bitfield to mark bases with active timers</span>
<span class="cm"> * @expires_next:	absolute time of the next event which was scheduled</span>
<span class="cm"> *			via clock_set_next_event()</span>
<span class="cm"> * @hres_active:	State of high resolution mode</span>
<span class="cm"> * @hang_detected:	The last hrtimer interrupt detected a hang</span>
<span class="cm"> * @nr_events:		Total number of hrtimer interrupt events</span>
<span class="cm"> * @nr_retries:		Total number of hrtimer interrupt retries</span>
<span class="cm"> * @nr_hangs:		Total number of hrtimer interrupt hangs</span>
<span class="cm"> * @max_hang_time:	Maximum time spent in hrtimer_interrupt</span>
<span class="cm"> * @clock_base:		array of clock bases for this cpu</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hrtimer_cpu_base</span> <span class="p">{</span>
	<span class="n">raw_spinlock_t</span>			<span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">active_bases</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>
	<span class="n">ktime_t</span>				<span class="n">expires_next</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">hres_active</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">hang_detected</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">nr_events</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">nr_retries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">nr_hangs</span><span class="p">;</span>
	<span class="n">ktime_t</span>				<span class="n">max_hang_time</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">hrtimer_clock_base</span>	<span class="n">clock_base</span><span class="p">[</span><span class="n">HRTIMER_MAX_CLOCK_BASES</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_set_expires</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_set_expires_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">time</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_add_safe</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_set_expires_range_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">time</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_add_safe</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">delta</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_set_expires_tv64</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">s64</span> <span class="n">tv64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">tv64</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="n">tv64</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_add_expires</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_add_safe</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span> <span class="o">=</span> <span class="n">ktime_add_safe</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_add_expires_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">hrtimer_get_expires</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">hrtimer_get_softexpires</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">hrtimer_get_expires_tv64</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">hrtimer_get_softexpires_tv64</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">_softexpires</span><span class="p">.</span><span class="n">tv64</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">s64</span> <span class="nf">hrtimer_get_expires_ns</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">hrtimer_expires_remaining</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">expires</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">());</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIGH_RES_TIMERS</span>
<span class="k">struct</span> <span class="n">clock_event_device</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">hrtimer_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">clock_event_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * In high resolution mode the time reference must be read accurate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">hrtimer_cb_get_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_is_hres_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="o">-&gt;</span><span class="n">hres_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">hrtimer_peek_ahead_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The resolution of the clocks. The resolution value is returned in</span>
<span class="cm"> * the clock_getres() system call to give application programmers an</span>
<span class="cm"> * idea of the (in)accuracy of timers. Timer values are rounded up to</span>
<span class="cm"> * this resolution values.</span>
<span class="cm"> */</span>
<span class="cp"># define HIGH_RES_NSEC		1</span>
<span class="cp"># define KTIME_HIGH_RES		(ktime_t) { .tv64 = HIGH_RES_NSEC }</span>
<span class="cp"># define MONOTONIC_RES_NSEC	HIGH_RES_NSEC</span>
<span class="cp"># define KTIME_MONOTONIC_RES	KTIME_HIGH_RES</span>

<span class="cp">#else</span>

<span class="cp"># define MONOTONIC_RES_NSEC	LOW_RES_NSEC</span>
<span class="cp"># define KTIME_MONOTONIC_RES	KTIME_LOW_RES</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_peek_ahead_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In non high resolution mode the time reference is taken from</span>
<span class="cm"> * the base softirq time variable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">hrtimer_cb_get_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">softirq_time</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_is_hres_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">clock_was_set</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_TIMERFD</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">timerfd_clock_was_set</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timerfd_clock_was_set</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hrtimers_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">ktime_get</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">ktime_get_real</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">ktime_get_boottime</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">ktime_get_monotonic_offset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">tick_device</span><span class="p">,</span> <span class="n">tick_cpu_device</span><span class="p">);</span>


<span class="cm">/* Exported timer functions: */</span>

<span class="cm">/* Initialize timers: */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hrtimer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
			 <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_TIMERS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hrtimer_init_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
				  <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtimer_init_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					 <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span>
					 <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hrtimer_init</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">which_clock</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">destroy_hrtimer_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Basic timer operations: */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hrtimer_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">tim</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hrtimer_start_range_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">tim</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">range_ns</span><span class="p">,</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">__hrtimer_start_range_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">tim</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta_ns</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wakeup</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">hrtimer_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hrtimer_try_to_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_start_expires</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
						<span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">;</span>
	<span class="n">soft</span> <span class="o">=</span> <span class="n">hrtimer_get_softexpires</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">hard</span> <span class="o">=</span> <span class="n">hrtimer_get_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">hard</span><span class="p">,</span> <span class="n">soft</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">hrtimer_start_range_ns</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">soft</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Query timers: */</span>
<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">hrtimer_get_remaining</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hrtimer_get_res</span><span class="p">(</span><span class="k">const</span> <span class="n">clockid_t</span> <span class="n">which_clock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">ktime_t</span> <span class="n">hrtimer_get_next_event</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * A timer is active, when it is enqueued into the rbtree or the</span>
<span class="cm"> * callback function is running or it&#39;s in the state of being migrated</span>
<span class="cm"> * to another cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_active</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">HRTIMER_STATE_INACTIVE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function to check, whether the timer is on one of the queues</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_is_queued</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">HRTIMER_STATE_ENQUEUED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function to check, whether the timer is running the callback</span>
<span class="cm"> * function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hrtimer_callback_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">HRTIMER_STATE_CALLBACK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Forward a hrtimer so it expires after now: */</span>
<span class="k">extern</span> <span class="n">u64</span>
<span class="n">hrtimer_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">now</span><span class="p">,</span> <span class="n">ktime_t</span> <span class="n">interval</span><span class="p">);</span>

<span class="cm">/* Forward a hrtimer so it expires after the hrtimer&#39;s current now */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">hrtimer_forward_now</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
				      <span class="n">ktime_t</span> <span class="n">interval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hrtimer_forward</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">(),</span> <span class="n">interval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Precise sleep: */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">hrtimer_nanosleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">rqtp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rmtp</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">clockid_t</span> <span class="n">clockid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">hrtimer_nanosleep_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart_block</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">hrtimer_init_sleeper</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer_sleeper</span> <span class="o">*</span><span class="n">sl</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">schedule_hrtimeout_range</span><span class="p">(</span><span class="n">ktime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">schedule_hrtimeout_range_clock</span><span class="p">(</span><span class="n">ktime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">,</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clock</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">schedule_hrtimeout</span><span class="p">(</span><span class="n">ktime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">hrtimer_mode</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/* Soft interrupt function to run the hrtimer queues: */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hrtimer_run_queues</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hrtimer_run_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Bootup initialization: */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">hrtimers_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#if BITS_PER_LONG &lt; 64</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">ktime_divns</span><span class="p">(</span><span class="k">const</span> <span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="n">s64</span> <span class="n">div</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* BITS_PER_LONG &lt; 64 */</span><span class="cp"></span>
<span class="cp"># define ktime_divns(kt, div)		(u64)((kt).tv64 / (div))</span>
<span class="cp">#endif</span>

<span class="cm">/* Show pending timers: */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sysrq_timer_list_show</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
