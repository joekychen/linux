<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>mm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_MM_H</span>
<span class="cp">#define _LINUX_MM_H</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mmzone.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/prio_tree.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/debug_locks.h&gt;</span>
<span class="cp">#include &lt;linux/mm_types.h&gt;</span>
<span class="cp">#include &lt;linux/range.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/shrinker.h&gt;</span>

<span class="k">struct</span> <span class="n">mempolicy</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">anon_vma</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">file_ra_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">user_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">writeback_control</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_DISCONTIGMEM          </span><span class="cm">/* Don&#39;t use mapnrs, do it properly */</span><span class="cp"></span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_mapnr</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_physpages</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">totalram_pages</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">high_memory</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">page_cluster</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_legacy_va_layout</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#define sysctl_legacy_va_layout 0</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>

<span class="cp">#define nth_page(page,n) pfn_to_page(page_to_pfn((page)) + (n))</span>

<span class="cm">/* to align the pointer to the (next) page boundary */</span>
<span class="cp">#define PAGE_ALIGN(addr) ALIGN(addr, PAGE_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * Linux kernel virtual memory manager primitives.</span>
<span class="cm"> * The idea being to have a &quot;virtual&quot; mm in the same way</span>
<span class="cm"> * we have a virtual fs - giving a cleaner interface to the</span>
<span class="cm"> * mm details, and allowing different kinds of memory mappings</span>
<span class="cm"> * (from shared memory to executable loading to arbitrary</span>
<span class="cm"> * mmap() functions).</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">vm_area_cachep</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_MMU</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">nommu_region_tree</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">nommu_region_sem</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kobjsize</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * vm_flags in vm_area_struct, see mm_types.h.</span>
<span class="cm"> */</span>
<span class="cp">#define VM_READ		0x00000001	</span><span class="cm">/* currently active flags */</span><span class="cp"></span>
<span class="cp">#define VM_WRITE	0x00000002</span>
<span class="cp">#define VM_EXEC		0x00000004</span>
<span class="cp">#define VM_SHARED	0x00000008</span>

<span class="cm">/* mprotect() hardcodes VM_MAYREAD &gt;&gt; 4 == VM_READ, and so for r/w/x bits. */</span>
<span class="cp">#define VM_MAYREAD	0x00000010	</span><span class="cm">/* limits for mprotect() etc */</span><span class="cp"></span>
<span class="cp">#define VM_MAYWRITE	0x00000020</span>
<span class="cp">#define VM_MAYEXEC	0x00000040</span>
<span class="cp">#define VM_MAYSHARE	0x00000080</span>

<span class="cp">#define VM_GROWSDOWN	0x00000100	</span><span class="cm">/* general info on the segment */</span><span class="cp"></span>
<span class="cp">#if defined(CONFIG_STACK_GROWSUP) || defined(CONFIG_IA64)</span>
<span class="cp">#define VM_GROWSUP	0x00000200</span>
<span class="cp">#else</span>
<span class="cp">#define VM_GROWSUP	0x00000000</span>
<span class="cp">#define VM_NOHUGEPAGE	0x00000200	</span><span class="cm">/* MADV_NOHUGEPAGE marked this vma */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#define VM_PFNMAP	0x00000400	</span><span class="cm">/* Page-ranges managed without &quot;struct page&quot;, just pure PFN */</span><span class="cp"></span>
<span class="cp">#define VM_DENYWRITE	0x00000800	</span><span class="cm">/* ETXTBSY on write attempts.. */</span><span class="cp"></span>

<span class="cp">#define VM_EXECUTABLE	0x00001000</span>
<span class="cp">#define VM_LOCKED	0x00002000</span>
<span class="cp">#define VM_IO           0x00004000	</span><span class="cm">/* Memory mapped I/O or similar */</span><span class="cp"></span>

					<span class="cm">/* Used by sys_madvise() */</span>
<span class="cp">#define VM_SEQ_READ	0x00008000	</span><span class="cm">/* App will access data sequentially */</span><span class="cp"></span>
<span class="cp">#define VM_RAND_READ	0x00010000	</span><span class="cm">/* App will not benefit from clustered reads */</span><span class="cp"></span>

<span class="cp">#define VM_DONTCOPY	0x00020000      </span><span class="cm">/* Do not copy this vma on fork */</span><span class="cp"></span>
<span class="cp">#define VM_DONTEXPAND	0x00040000	</span><span class="cm">/* Cannot expand with mremap() */</span><span class="cp"></span>
<span class="cp">#define VM_RESERVED	0x00080000	</span><span class="cm">/* Count as reserved_vm like IO */</span><span class="cp"></span>
<span class="cp">#define VM_ACCOUNT	0x00100000	</span><span class="cm">/* Is a VM accounted object */</span><span class="cp"></span>
<span class="cp">#define VM_NORESERVE	0x00200000	</span><span class="cm">/* should the VM suppress accounting */</span><span class="cp"></span>
<span class="cp">#define VM_HUGETLB	0x00400000	</span><span class="cm">/* Huge TLB Page VM */</span><span class="cp"></span>
<span class="cp">#define VM_NONLINEAR	0x00800000	</span><span class="cm">/* Is non-linear (remap_file_pages) */</span><span class="cp"></span>
<span class="cp">#ifndef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="cp">#define VM_MAPPED_COPY	0x01000000	</span><span class="cm">/* T if mapped copy of data (nommu mmap) */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define VM_HUGEPAGE	0x01000000	</span><span class="cm">/* MADV_HUGEPAGE marked this vma */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#define VM_INSERTPAGE	0x02000000	</span><span class="cm">/* The vma has had &quot;vm_insert_page()&quot; done on it */</span><span class="cp"></span>
<span class="cp">#define VM_NODUMP	0x04000000	</span><span class="cm">/* Do not include in the core dump */</span><span class="cp"></span>

<span class="cp">#define VM_CAN_NONLINEAR 0x08000000	</span><span class="cm">/* Has -&gt;fault &amp; does nonlinear pages */</span><span class="cp"></span>
<span class="cp">#define VM_MIXEDMAP	0x10000000	</span><span class="cm">/* Can contain &quot;struct page&quot; and pure PFN pages */</span><span class="cp"></span>
<span class="cp">#define VM_SAO		0x20000000	</span><span class="cm">/* Strong Access Ordering (powerpc) */</span><span class="cp"></span>
<span class="cp">#define VM_PFN_AT_MMAP	0x40000000	</span><span class="cm">/* PFNMAP vma that is fully mapped at mmap time */</span><span class="cp"></span>
<span class="cp">#define VM_MERGEABLE	0x80000000	</span><span class="cm">/* KSM may merge identical pages */</span><span class="cp"></span>

<span class="cm">/* Bits set in the VMA until the stack is in its final location */</span>
<span class="cp">#define VM_STACK_INCOMPLETE_SETUP	(VM_RAND_READ | VM_SEQ_READ)</span>

<span class="cp">#ifndef VM_STACK_DEFAULT_FLAGS		</span><span class="cm">/* arch can override this */</span><span class="cp"></span>
<span class="cp">#define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
<span class="cp">#define VM_STACK_FLAGS	(VM_GROWSUP | VM_STACK_DEFAULT_FLAGS | VM_ACCOUNT)</span>
<span class="cp">#else</span>
<span class="cp">#define VM_STACK_FLAGS	(VM_GROWSDOWN | VM_STACK_DEFAULT_FLAGS | VM_ACCOUNT)</span>
<span class="cp">#endif</span>

<span class="cp">#define VM_READHINTMASK			(VM_SEQ_READ | VM_RAND_READ)</span>
<span class="cp">#define VM_ClearReadHint(v)		(v)-&gt;vm_flags &amp;= ~VM_READHINTMASK</span>
<span class="cp">#define VM_NormalReadHint(v)		(!((v)-&gt;vm_flags &amp; VM_READHINTMASK))</span>
<span class="cp">#define VM_SequentialReadHint(v)	((v)-&gt;vm_flags &amp; VM_SEQ_READ)</span>
<span class="cp">#define VM_RandomReadHint(v)		((v)-&gt;vm_flags &amp; VM_RAND_READ)</span>

<span class="cm">/*</span>
<span class="cm"> * Special vmas that are non-mergable, non-mlock()able.</span>
<span class="cm"> * Note: mm/huge_memory.c VM_NO_THP depends on this definition.</span>
<span class="cm"> */</span>
<span class="cp">#define VM_SPECIAL (VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_PFNMAP)</span>

<span class="cm">/*</span>
<span class="cm"> * mapping from the currently active vm_flags protection bits (the</span>
<span class="cm"> * low four bits) to a page protection mask..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">pgprot_t</span> <span class="n">protection_map</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="cp">#define FAULT_FLAG_WRITE	0x01	</span><span class="cm">/* Fault was a write access */</span><span class="cp"></span>
<span class="cp">#define FAULT_FLAG_NONLINEAR	0x02	</span><span class="cm">/* Fault was via a nonlinear mapping */</span><span class="cp"></span>
<span class="cp">#define FAULT_FLAG_MKWRITE	0x04	</span><span class="cm">/* Fault was mkwrite of existing pte */</span><span class="cp"></span>
<span class="cp">#define FAULT_FLAG_ALLOW_RETRY	0x08	</span><span class="cm">/* Retry fault if blocking */</span><span class="cp"></span>
<span class="cp">#define FAULT_FLAG_RETRY_NOWAIT	0x10	</span><span class="cm">/* Don&#39;t drop mmap_sem and wait when retrying */</span><span class="cp"></span>
<span class="cp">#define FAULT_FLAG_KILLABLE	0x20	</span><span class="cm">/* The fault task is in SIGKILL killable region */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This interface is used by x86 PAT code to identify a pfn mapping that is</span>
<span class="cm"> * linear over entire vma. This is to optimize PAT code that deals with</span>
<span class="cm"> * marking the physical region with a particular prot. This is not for generic</span>
<span class="cm"> * mm use. Note also that this check will not work if the pfn mapping is</span>
<span class="cm"> * linear for a vma starting at physical address 0. In which case PAT code</span>
<span class="cm"> * falls back to slow path of reserving physical range page by page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_linear_pfn_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_PFN_AT_MMAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_pfn_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_PFNMAP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vm_fault is filled by the the pagefault handler and passed to the vma&#39;s</span>
<span class="cm"> * -&gt;fault function. The vma&#39;s -&gt;fault is responsible for returning a bitmask</span>
<span class="cm"> * of VM_FAULT_xxx flags that give details about how the fault was handled.</span>
<span class="cm"> *</span>
<span class="cm"> * pgoff should be used in favour of virtual_address, if possible. If pgoff</span>
<span class="cm"> * is used, one may set VM_CAN_NONLINEAR in the vma-&gt;vm_flags to get nonlinear</span>
<span class="cm"> * mapping support.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vm_fault</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* FAULT_FLAG_xxx flags */</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">;</span>			<span class="cm">/* Logical page offset based on vma */</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">virtual_address</span><span class="p">;</span>	<span class="cm">/* Faulting virtual address */</span>

	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>		<span class="cm">/* -&gt;fault handlers should return a</span>
<span class="cm">					 * page here, unless VM_FAULT_NOPAGE</span>
<span class="cm">					 * is set (which is also implied by</span>
<span class="cm">					 * VM_FAULT_ERROR).</span>
<span class="cm">					 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * These are the virtual MM functions - opening of an area, closing and</span>
<span class="cm"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span>
<span class="cm"> * to the functions called when a no-page or a wp-page exception occurs. </span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">area</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">area</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fault</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">);</span>

	<span class="cm">/* notification that a previously read-only page is about to become</span>
<span class="cm">	 * writable, if an error is returned it will cause a SIGBUS */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">page_mkwrite</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">);</span>

	<span class="cm">/* called by access_process_vm when get_user_pages() fails, typically</span>
<span class="cm">	 * for use by special VMAs that can switch between memory and hardware</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">access</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="cm">/*</span>
<span class="cm">	 * set_policy() op must add a reference to any non-NULL @new mempolicy</span>
<span class="cm">	 * to hold the policy upon return.  Caller should pass NULL @new to</span>
<span class="cm">	 * remove a policy and fall back to surrounding context--i.e. do not</span>
<span class="cm">	 * install a MPOL_DEFAULT policy, nor the task or system default</span>
<span class="cm">	 * mempolicy.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_policy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">new</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * get_policy() op must add reference [mpol_get()] to any policy at</span>
<span class="cm">	 * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure</span>
<span class="cm">	 * in mm/mempolicy.c will do this automatically.</span>
<span class="cm">	 * get_policy() must NOT add a ref if the policy at (vma,addr) is not</span>
<span class="cm">	 * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.</span>
<span class="cm">	 * If no [shared/vma] mempolicy exists at the addr, get_policy() op</span>
<span class="cm">	 * must return NULL--i.e., do not &quot;fallback&quot; to task or system default</span>
<span class="cm">	 * policy.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_policy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">migrate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mmu_gather</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">inode</span><span class="p">;</span>

<span class="cp">#define page_private(page)		((page)-&gt;private)</span>
<span class="cp">#define set_page_private(page, v)	((page)-&gt;private = (v))</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: take this include out, include page-flags.h in</span>
<span class="cm"> * files which need it (119 of them)</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/page-flags.h&gt;</span>
<span class="cp">#include &lt;linux/huge_mm.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Methods to modify the page usage count.</span>
<span class="cm"> *</span>
<span class="cm"> * What counts for a page usage:</span>
<span class="cm"> * - cache mapping   (page-&gt;mapping)</span>
<span class="cm"> * - private data    (page-&gt;private)</span>
<span class="cm"> * - page mapped in a task&#39;s page tables, each mapping</span>
<span class="cm"> *   is counted separately</span>
<span class="cm"> *</span>
<span class="cm"> * Also, many kernel routines increase the page count before a critical</span>
<span class="cm"> * routine so they can be sure the page doesn&#39;t go away from under them.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Drop a ref, return true if the refcount fell to zero (the page has no users)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">put_page_testzero</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to grab a ref unless the page has a refcount of zero, return false if</span>
<span class="cm"> * that is the case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_page_unless_zero</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">page_is_ram</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>

<span class="cm">/* Support for virtually mapped pages */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">vmalloc_to_page</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vmalloc_to_pfn</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if an address is within the vmalloc range</span>
<span class="cm"> *</span>
<span class="cm"> * On nommu, vmalloc/vfree wrap through kmalloc/kfree directly, so there</span>
<span class="cm"> * is no special casing required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_vmalloc_addr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MMU</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">VMALLOC_START</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">VMALLOC_END</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">is_vmalloc_or_module_addr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_vmalloc_or_module_addr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">compound_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">bit_spin_lock</span><span class="p">(</span><span class="n">PG_compound_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">compound_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">bit_spin_unlock</span><span class="p">(</span><span class="n">PG_compound_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">compound_lock_irqsave</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">compound_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">compound_unlock_irqrestore</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
	<span class="n">compound_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">compound_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageTail</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">first_page</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The atomic page-&gt;_mapcount, starts from -1: so that transitions</span>
<span class="cm"> * both from it and to it can be tracked, using atomic_inc_and_test</span>
<span class="cm"> * and atomic_add_negative(-1).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reset_page_mapcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_mapcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_huge_page_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * __split_huge_page_refcount() cannot run</span>
<span class="cm">	 * from under us.</span>
<span class="cm">	 */</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">__get_page_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">get_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageTail</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">__get_page_tail</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Getting a normal page or the head of a compound page</span>
<span class="cm">	 * requires to already have an elevated page-&gt;_count.</span>
<span class="cm">	 */</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">virt_to_head_page</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup the page count before being freed into the page allocator for</span>
<span class="cm"> * the first time (boot or memory hotplug)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_page_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PageBuddy() indicate that the page is free and in the buddy system</span>
<span class="cm"> * (see mm/page_alloc.c).</span>
<span class="cm"> *</span>
<span class="cm"> * PAGE_BUDDY_MAPCOUNT_VALUE must be &lt;= -2 but better not too close to</span>
<span class="cm"> * -2 so that an underflow of the page_mapcount() won&#39;t be mistaken</span>
<span class="cm"> * for a genuine PAGE_BUDDY_MAPCOUNT_VALUE. -128 can be created very</span>
<span class="cm"> * efficiently by most CPU architectures.</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_BUDDY_MAPCOUNT_VALUE (-128)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">PageBuddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">)</span> <span class="o">==</span> <span class="n">PAGE_BUDDY_MAPCOUNT_VALUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__SetPageBuddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">,</span> <span class="n">PAGE_BUDDY_MAPCOUNT_VALUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__ClearPageBuddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageBuddy</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">put_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">put_pages_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">split_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">split_free_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Compound pages have a destructor function.  Provide a</span>
<span class="cm"> * prototype for that function and accessor functions.</span>
<span class="cm"> * These are _only_ valid on the head of a PG_compound page.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="n">compound_page_dtor</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_compound_page_dtor</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
						<span class="n">compound_page_dtor</span> <span class="o">*</span><span class="n">dtor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dtor</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">compound_page_dtor</span> <span class="o">*</span><span class="nf">get_compound_page_dtor</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">compound_page_dtor</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">compound_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">compound_trans_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">compound_lock_irqsave</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">compound_unlock_irqrestore</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_compound_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="cm">/*</span>
<span class="cm"> * Do pte_mkwrite, but only if the vma says VM_WRITE.  We do this when</span>
<span class="cm"> * servicing faults for write access.  In the normal case, do always want</span>
<span class="cm"> * pte_mkwrite.  But get_user_pages can cause write faults for mappings</span>
<span class="cm"> * that do not have writing enabled, when used by access_process_vm.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="nf">maybe_mkwrite</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">))</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_mkwrite</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pte</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Multiple processes may &quot;see&quot; the same page. E.g. for untouched</span>
<span class="cm"> * mappings of /dev/null, all processes see the same page full of</span>
<span class="cm"> * zeroes, and text pages of executables and shared libraries have</span>
<span class="cm"> * only one copy in memory, at most, normally.</span>
<span class="cm"> *</span>
<span class="cm"> * For the non-reserved pages, page_count(page) denotes a reference count.</span>
<span class="cm"> *   page_count() == 0 means the page is free. page-&gt;lru is then used for</span>
<span class="cm"> *   freelist management in the buddy allocator.</span>
<span class="cm"> *   page_count() &gt; 0  means the page has been allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * Pages are allocated by the slab allocator in order to provide memory</span>
<span class="cm"> * to kmalloc and kmem_cache_alloc. In this case, the management of the</span>
<span class="cm"> * page, and the fields in &#39;struct page&#39; are the responsibility of mm/slab.c</span>
<span class="cm"> * unless a particular usage is carefully commented. (the responsibility of</span>
<span class="cm"> * freeing the kmalloc memory is the caller&#39;s, of course).</span>
<span class="cm"> *</span>
<span class="cm"> * A page may be used by anyone else who does a __get_free_page().</span>
<span class="cm"> * In this case, page_count still tracks the references, and should only</span>
<span class="cm"> * be used through the normal accessor functions. The top bits of page-&gt;flags</span>
<span class="cm"> * and page-&gt;virtual store page management information, but all other fields</span>
<span class="cm"> * are unused and could be used privately, carefully. The management of this</span>
<span class="cm"> * page is the responsibility of the one who allocated it, and those who have</span>
<span class="cm"> * subsequently been given references to it.</span>
<span class="cm"> *</span>
<span class="cm"> * The other pages (we may call them &quot;pagecache pages&quot;) are completely</span>
<span class="cm"> * managed by the Linux memory manager: I/O, buffers, swapping etc.</span>
<span class="cm"> * The following discussion applies only to them.</span>
<span class="cm"> *</span>
<span class="cm"> * A pagecache page contains an opaque `private&#39; member, which belongs to the</span>
<span class="cm"> * page&#39;s address_space. Usually, this is the address of a circular list of</span>
<span class="cm"> * the page&#39;s disk buffers. PG_private must be set to tell the VM to call</span>
<span class="cm"> * into the filesystem to release these pages.</span>
<span class="cm"> *</span>
<span class="cm"> * A page may belong to an inode&#39;s memory mapping. In this case, page-&gt;mapping</span>
<span class="cm"> * is the pointer to the inode, and page-&gt;index is the file offset of the page,</span>
<span class="cm"> * in units of PAGE_CACHE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * If pagecache pages are not associated with an inode, they are said to be</span>
<span class="cm"> * anonymous pages. These may become associated with the swapcache, and in that</span>
<span class="cm"> * case PG_swapcache is set, and page-&gt;private is an offset into the swapcache.</span>
<span class="cm"> *</span>
<span class="cm"> * In either case (swapcache or inode backed), the pagecache itself holds one</span>
<span class="cm"> * reference to the page. Setting PG_private should also increment the</span>
<span class="cm"> * refcount. The each user mapping also has a reference to the page.</span>
<span class="cm"> *</span>
<span class="cm"> * The pagecache pages are stored in a per-mapping radix tree, which is</span>
<span class="cm"> * rooted at mapping-&gt;page_tree, and indexed by offset.</span>
<span class="cm"> * Where 2.4 and early 2.6 kernels kept dirty/clean pages in per-address_space</span>
<span class="cm"> * lists, we instead now tag pages as dirty/writeback in the radix tree.</span>
<span class="cm"> *</span>
<span class="cm"> * All pagecache pages may be subject to I/O:</span>
<span class="cm"> * - inode pages may need to be read from disk,</span>
<span class="cm"> * - inode pages which have been modified and are MAP_SHARED may need</span>
<span class="cm"> *   to be written back to the inode on disk,</span>
<span class="cm"> * - anonymous pages (including MAP_PRIVATE file mappings) which have been</span>
<span class="cm"> *   modified may need to be swapped out to swap space and (later) to be read</span>
<span class="cm"> *   back into memory.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The zone field is never updated after free_area_init_core()</span>
<span class="cm"> * sets it, so none of the operations on it need to be atomic.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * page-&gt;flags layout:</span>
<span class="cm"> *</span>
<span class="cm"> * There are three possibilities for how page-&gt;flags get</span>
<span class="cm"> * laid out.  The first is for the normal case, without</span>
<span class="cm"> * sparsemem.  The second is for sparsemem when there is</span>
<span class="cm"> * plenty of space for node and section.  The last is when</span>
<span class="cm"> * we have run out of space and have to fall back to an</span>
<span class="cm"> * alternate (slower) way of determining the node.</span>
<span class="cm"> *</span>
<span class="cm"> * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE | ... | FLAGS |</span>
<span class="cm"> * classic sparse with space for node:| SECTION | NODE | ZONE | ... | FLAGS |</span>
<span class="cm"> * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_SPARSEMEM) &amp;&amp; !defined(CONFIG_SPARSEMEM_VMEMMAP)</span>
<span class="cp">#define SECTIONS_WIDTH		SECTIONS_SHIFT</span>
<span class="cp">#else</span>
<span class="cp">#define SECTIONS_WIDTH		0</span>
<span class="cp">#endif</span>

<span class="cp">#define ZONES_WIDTH		ZONES_SHIFT</span>

<span class="cp">#if SECTIONS_WIDTH+ZONES_WIDTH+NODES_SHIFT &lt;= BITS_PER_LONG - NR_PAGEFLAGS</span>
<span class="cp">#define NODES_WIDTH		NODES_SHIFT</span>
<span class="cp">#else</span>
<span class="cp">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
<span class="cp">#error &quot;Vmemmap: No space for nodes field in page flags&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#define NODES_WIDTH		0</span>
<span class="cp">#endif</span>

<span class="cm">/* Page flags: | [SECTION] | [NODE] | ZONE | ... | FLAGS | */</span>
<span class="cp">#define SECTIONS_PGOFF		((sizeof(unsigned long)*8) - SECTIONS_WIDTH)</span>
<span class="cp">#define NODES_PGOFF		(SECTIONS_PGOFF - NODES_WIDTH)</span>
<span class="cp">#define ZONES_PGOFF		(NODES_PGOFF - ZONES_WIDTH)</span>

<span class="cm">/*</span>
<span class="cm"> * We are going to use the flags for the page to node mapping if its in</span>
<span class="cm"> * there.  This includes the case where there is no node, so it is implicit.</span>
<span class="cm"> */</span>
<span class="cp">#if !(NODES_WIDTH &gt; 0 || NODES_SHIFT == 0)</span>
<span class="cp">#define NODE_NOT_IN_PAGE_FLAGS</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Define the bit shifts to access each section.  For non-existent</span>
<span class="cm"> * sections we define the shift as 0; that plus a 0 mask ensures</span>
<span class="cm"> * the compiler will optimise away reference to them.</span>
<span class="cm"> */</span>
<span class="cp">#define SECTIONS_PGSHIFT	(SECTIONS_PGOFF * (SECTIONS_WIDTH != 0))</span>
<span class="cp">#define NODES_PGSHIFT		(NODES_PGOFF * (NODES_WIDTH != 0))</span>
<span class="cp">#define ZONES_PGSHIFT		(ZONES_PGOFF * (ZONES_WIDTH != 0))</span>

<span class="cm">/* NODE:ZONE or SECTION:ZONE is used to ID a zone for the buddy allocator */</span>
<span class="cp">#ifdef NODE_NOT_IN_PAGE_FLAGS</span>
<span class="cp">#define ZONEID_SHIFT		(SECTIONS_SHIFT + ZONES_SHIFT)</span>
<span class="cp">#define ZONEID_PGOFF		((SECTIONS_PGOFF &lt; ZONES_PGOFF)? \</span>
<span class="cp">						SECTIONS_PGOFF : ZONES_PGOFF)</span>
<span class="cp">#else</span>
<span class="cp">#define ZONEID_SHIFT		(NODES_SHIFT + ZONES_SHIFT)</span>
<span class="cp">#define ZONEID_PGOFF		((NODES_PGOFF &lt; ZONES_PGOFF)? \</span>
<span class="cp">						NODES_PGOFF : ZONES_PGOFF)</span>
<span class="cp">#endif</span>

<span class="cp">#define ZONEID_PGSHIFT		(ZONEID_PGOFF * (ZONEID_SHIFT != 0))</span>

<span class="cp">#if SECTIONS_WIDTH+NODES_WIDTH+ZONES_WIDTH &gt; BITS_PER_LONG - NR_PAGEFLAGS</span>
<span class="cp">#error SECTIONS_WIDTH+NODES_WIDTH+ZONES_WIDTH &gt; BITS_PER_LONG - NR_PAGEFLAGS</span>
<span class="cp">#endif</span>

<span class="cp">#define ZONES_MASK		((1UL &lt;&lt; ZONES_WIDTH) - 1)</span>
<span class="cp">#define NODES_MASK		((1UL &lt;&lt; NODES_WIDTH) - 1)</span>
<span class="cp">#define SECTIONS_MASK		((1UL &lt;&lt; SECTIONS_WIDTH) - 1)</span>
<span class="cp">#define ZONEID_MASK		((1UL &lt;&lt; ZONEID_SHIFT) - 1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">zone_type</span> <span class="nf">page_zonenum</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="n">ZONES_PGSHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ZONES_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The identification function is only used by the buddy allocator for</span>
<span class="cm"> * determining if two pages could be buddies. We are not really</span>
<span class="cm"> * identifying a zone since we could be using a the section number</span>
<span class="cm"> * id if we have not node id available in page flags.</span>
<span class="cm"> * We guarantee only that it will return the same value for two</span>
<span class="cm"> * combinable pages in a zone.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_zone_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="n">ZONEID_PGSHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ZONEID_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zone_to_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="k">return</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef NODE_NOT_IN_PAGE_FLAGS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_to_nid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="n">NODES_PGSHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NODES_MASK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="nf">page_zone</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="p">[</span><span class="n">page_zonenum</span><span class="p">(</span><span class="n">page</span><span class="p">)];</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_SPARSEMEM) &amp;&amp; !defined(CONFIG_SPARSEMEM_VMEMMAP)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_page_section</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">section</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SECTIONS_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">SECTIONS_PGSHIFT</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">section</span> <span class="o">&amp;</span> <span class="n">SECTIONS_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">SECTIONS_PGSHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">page_to_section</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="n">SECTIONS_PGSHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SECTIONS_MASK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_page_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">zone_type</span> <span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ZONES_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">ZONES_PGSHIFT</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">zone</span> <span class="o">&amp;</span> <span class="n">ZONES_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">ZONES_PGSHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_page_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NODES_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">NODES_PGSHIFT</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">node</span> <span class="o">&amp;</span> <span class="n">NODES_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">NODES_PGSHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_page_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">zone_type</span> <span class="n">zone</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
	<span class="n">set_page_node</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_SPARSEMEM) &amp;&amp; !defined(CONFIG_SPARSEMEM_VMEMMAP)</span>
	<span class="n">set_page_section</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pfn_to_section_nr</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some inline functions in vmstat.h depend on page_zone()</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/vmstat.h&gt;</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">lowmem_page_address</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__va</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_HIGHMEM) &amp;&amp; !defined(WANT_PAGE_VIRTUAL)</span>
<span class="cp">#define HASHED_PAGE_VIRTUAL</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(WANT_PAGE_VIRTUAL)</span>
<span class="cp">#define page_address(page) ((page)-&gt;virtual)</span>
<span class="cp">#define set_page_address(page, address)			\</span>
<span class="cp">	do {						\</span>
<span class="cp">		(page)-&gt;virtual = (address);		\</span>
<span class="cp">	} while(0)</span>
<span class="cp">#define page_address_init()  do { } while(0)</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(HASHED_PAGE_VIRTUAL)</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">page_address</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_page_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="k">virtual</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_address_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(HASHED_PAGE_VIRTUAL) &amp;&amp; !defined(WANT_PAGE_VIRTUAL)</span>
<span class="cp">#define page_address(page) lowmem_page_address(page)</span>
<span class="cp">#define set_page_address(page, address)  do { } while(0)</span>
<span class="cp">#define page_address_init()  do { } while(0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * On an anonymous page mapped into a user virtual memory area,</span>
<span class="cm"> * page-&gt;mapping points to its anon_vma, not to a struct address_space;</span>
<span class="cm"> * with the PAGE_MAPPING_ANON bit set to distinguish it.  See rmap.h.</span>
<span class="cm"> *</span>
<span class="cm"> * On an anonymous page in a VM_MERGEABLE area, if CONFIG_KSM is enabled,</span>
<span class="cm"> * the PAGE_MAPPING_KSM bit may be set along with the PAGE_MAPPING_ANON bit;</span>
<span class="cm"> * and then page-&gt;mapping points, not to an anon_vma, but to a private</span>
<span class="cm"> * structure which KSM associates with that merged page.  See ksm.h.</span>
<span class="cm"> *</span>
<span class="cm"> * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is currently never used.</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that, confusingly, &quot;page_mapping&quot; refers to the inode</span>
<span class="cm"> * address_space which maps the page from disk; whereas &quot;page_mapped&quot;</span>
<span class="cm"> * refers to user virtual address space into which the page is mapped.</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_MAPPING_ANON	1</span>
<span class="cp">#define PAGE_MAPPING_KSM	2</span>
<span class="cp">#define PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="n">swapper_space</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="nf">page_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">swapper_space</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mapping</span> <span class="o">&amp;</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">)</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mapping</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Neutral page-&gt;mapping pointer to address_space or anon_vma or other */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">page_rmapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MAPPING_FLAGS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">PageAnon</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;</span> <span class="n">PAGE_MAPPING_ANON</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the pagecache index of the passed page.  Regular pagecache pages</span>
<span class="cm"> * use -&gt;index whereas swapcache pages use -&gt;private</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgoff_t</span> <span class="nf">page_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if this page is mapped into pagetables.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">page</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">_mapcount</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Different kinds of faults, as returned by handle_mm_fault().</span>
<span class="cm"> * Used to decide whether a process gets delivered SIGBUS or</span>
<span class="cm"> * just gets major/minor fault counters bumped up.</span>
<span class="cm"> */</span>

<span class="cp">#define VM_FAULT_MINOR	0 </span><span class="cm">/* For backwards compat. Remove me quickly. */</span><span class="cp"></span>

<span class="cp">#define VM_FAULT_OOM	0x0001</span>
<span class="cp">#define VM_FAULT_SIGBUS	0x0002</span>
<span class="cp">#define VM_FAULT_MAJOR	0x0004</span>
<span class="cp">#define VM_FAULT_WRITE	0x0008	</span><span class="cm">/* Special case for get_user_pages */</span><span class="cp"></span>
<span class="cp">#define VM_FAULT_HWPOISON 0x0010	</span><span class="cm">/* Hit poisoned small page */</span><span class="cp"></span>
<span class="cp">#define VM_FAULT_HWPOISON_LARGE 0x0020  </span><span class="cm">/* Hit poisoned large page. Index encoded in upper bits */</span><span class="cp"></span>

<span class="cp">#define VM_FAULT_NOPAGE	0x0100	</span><span class="cm">/* -&gt;fault installed the pte, not return page */</span><span class="cp"></span>
<span class="cp">#define VM_FAULT_LOCKED	0x0200	</span><span class="cm">/* -&gt;fault locked the returned page */</span><span class="cp"></span>
<span class="cp">#define VM_FAULT_RETRY	0x0400	</span><span class="cm">/* -&gt;fault blocked, must retry */</span><span class="cp"></span>

<span class="cp">#define VM_FAULT_HWPOISON_LARGE_MASK 0xf000 </span><span class="cm">/* encodes hpage index for large hwpoison */</span><span class="cp"></span>

<span class="cp">#define VM_FAULT_ERROR	(VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_HWPOISON | \</span>
<span class="cp">			 VM_FAULT_HWPOISON_LARGE)</span>

<span class="cm">/* Encode hstate index for a hwpoisoned large page */</span>
<span class="cp">#define VM_FAULT_SET_HINDEX(x) ((x) &lt;&lt; 12)</span>
<span class="cp">#define VM_FAULT_GET_HINDEX(x) (((x) &gt;&gt; 12) &amp; 0xf)</span>

<span class="cm">/*</span>
<span class="cm"> * Can be called by the pagefault handler when it gets a VM_FAULT_OOM.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pagefault_out_of_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define offset_in_page(p)	((unsigned long)(p) &amp; ~PAGE_MASK)</span>

<span class="cm">/*</span>
<span class="cm"> * Flags passed to show_mem() and show_free_areas() to suppress output in</span>
<span class="cm"> * various contexts.</span>
<span class="cm"> */</span>
<span class="cp">#define SHOW_MEM_FILTER_NODES	(0x0001u)	</span><span class="cm">/* filter disallowed nodes */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">show_free_areas</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">skip_free_areas_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">shmem_zero_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">can_do_mlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">user_shm_lock</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">user_shm_unlock</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Parameter block passed down to zap_pte_range in exceptional cases.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">zap_details</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">nonlinear_vma</span><span class="p">;</span>	<span class="cm">/* Check page-&gt;index if set */</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">check_mapping</span><span class="p">;</span>	<span class="cm">/* Check page-&gt;mapping if set */</span>
	<span class="n">pgoff_t</span>	<span class="n">first_index</span><span class="p">;</span>			<span class="cm">/* Lowest page-&gt;index to unmap */</span>
	<span class="n">pgoff_t</span> <span class="n">last_index</span><span class="p">;</span>			<span class="cm">/* Highest page-&gt;index to unmap */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">vm_normal_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="n">pte_t</span> <span class="n">pte</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">zap_vma_ptes</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">zap_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zap_details</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unmap_vmas</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">start_vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mm_walk - callbacks for walk_page_range</span>
<span class="cm"> * @pgd_entry: if set, called for each non-empty PGD (top-level) entry</span>
<span class="cm"> * @pud_entry: if set, called for each non-empty PUD (2nd-level) entry</span>
<span class="cm"> * @pmd_entry: if set, called for each non-empty PMD (3rd-level) entry</span>
<span class="cm"> *	       this handler is required to be able to handle</span>
<span class="cm"> *	       pmd_trans_huge() pmds.  They may simply choose to</span>
<span class="cm"> *	       split_huge_page() instead of handling it explicitly.</span>
<span class="cm"> * @pte_entry: if set, called for each non-empty PTE (4th-level) entry</span>
<span class="cm"> * @pte_hole: if set, called for each hole at all levels</span>
<span class="cm"> * @hugetlb_entry: if set, called for each hugetlb entry</span>
<span class="cm"> *		   *Caution*: The caller must hold mmap_sem() if @hugetlb_entry</span>
<span class="cm"> * 			      is used.</span>
<span class="cm"> *</span>
<span class="cm"> * (see walk_page_range for more details)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mm_walk</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pgd_entry</span><span class="p">)(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pud_entry</span><span class="p">)(</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pmd_entry</span><span class="p">)(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pte_entry</span><span class="p">)(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pte_hole</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hugetlb_entry</span><span class="p">)(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">walk_page_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_pgd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmu_gather</span> <span class="o">*</span><span class="n">tlb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ceiling</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">copy_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unmap_mapping_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="k">const</span> <span class="n">holebegin</span><span class="p">,</span> <span class="n">loff_t</span> <span class="k">const</span> <span class="n">holelen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">even_cows</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">follow_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">follow_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">generic_access_phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unmap_shared_mapping_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="k">const</span> <span class="n">holebegin</span><span class="p">,</span> <span class="n">loff_t</span> <span class="k">const</span> <span class="n">holelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">holebegin</span><span class="p">,</span> <span class="n">holelen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">truncate_pagecache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">old</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">truncate_setsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">newsize</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vmtruncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">truncate_pagecache_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">truncate_inode_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">generic_error_remove_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">invalidate_inode_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">fixup_user_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fault_flags</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* should never happen if there&#39;s no MMU */</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fixup_user_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fault_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* should never happen if there&#39;s no MMU */</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">make_pages_present</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">access_remote_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__get_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">foll_flags</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="o">*</span><span class="n">nonblocking</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">get_user_pages_fast</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">get_dump_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">try_to_release_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__set_page_dirty_no_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">account_page_dirtied</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">account_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">set_page_dirty_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cm">/* Is the vma a continuation of the stack vma above it? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vma_growsdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSDOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">stack_guard_page_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSDOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">vma_growsdown</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Is the vma a continuation of the stack vma below it? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vma_growsup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSUP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">stack_guard_page_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">vma_growsup</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">pid_t</span>
<span class="n">vm_is_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_group</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">move_page_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">new_vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">do_mremap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_len</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mprotect_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">pprev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">newflags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * doesn&#39;t attempt to fault and will return short.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__get_user_pages_fast</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * per-process(per-mm_struct) statistics.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_mm_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">member</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">member</span><span class="p">]);</span>

<span class="cp">#ifdef SPLIT_RSS_COUNTING</span>
	<span class="cm">/*</span>
<span class="cm">	 * counter is updated in asynchronous manner and may go to minus.</span>
<span class="cm">	 * But it&#39;s never be expected number for users.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_mm_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">member</span><span class="p">,</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">member</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_mm_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">member</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">member</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dec_mm_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">member</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">rss_stat</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">member</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_mm_rss</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_FILEPAGES</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">get_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_mm_hiwater_rss</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">hiwater_rss</span><span class="p">,</span> <span class="n">get_mm_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_mm_hiwater_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">hiwater_vm</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_hiwater_rss</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_rss</span> <span class="o">=</span> <span class="n">get_mm_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hiwater_rss</span> <span class="o">&lt;</span> <span class="n">_rss</span><span class="p">)</span>
		<span class="p">(</span><span class="n">mm</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hiwater_rss</span> <span class="o">=</span> <span class="n">_rss</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_hiwater_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">hiwater_vm</span> <span class="o">&lt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span><span class="p">)</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">hiwater_vm</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setmax_mm_hiwater_rss</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">maxrss</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hiwater_rss</span> <span class="o">=</span> <span class="n">get_mm_hiwater_rss</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">maxrss</span> <span class="o">&lt;</span> <span class="n">hiwater_rss</span><span class="p">)</span>
		<span class="o">*</span><span class="n">maxrss</span> <span class="o">=</span> <span class="n">hiwater_rss</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(SPLIT_RSS_COUNTING)</span>
<span class="kt">void</span> <span class="n">sync_mm_rss</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sync_mm_rss</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">vma_wants_writenotify</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">__get_locked_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			       <span class="n">spinlock_t</span> <span class="o">**</span><span class="n">ptl</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pte_t</span> <span class="o">*</span><span class="nf">get_locked_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				    <span class="n">spinlock_t</span> <span class="o">**</span><span class="n">ptl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">__cond_lock</span><span class="p">(</span><span class="o">*</span><span class="n">ptl</span><span class="p">,</span> <span class="n">ptep</span> <span class="o">=</span> <span class="n">__get_locked_pte</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptl</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ptep</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __PAGETABLE_PUD_FOLDED</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__pud_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="n">__pud_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __PAGETABLE_PMD_FOLDED</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__pmd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="n">__pmd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">__pte_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__pte_alloc_kernel</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The following ifdef needed to get the 4level-fixup.h header to work.</span>
<span class="cm"> * Remove it when 4level-fixup.h has been removed.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_MMU) &amp;&amp; !defined(__ARCH_HAS_4LEVEL_HACK)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pud_t</span> <span class="o">*</span><span class="nf">pud_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">__pud_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span><span class="o">?</span>
		<span class="nl">NULL:</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="nf">pmd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">__pmd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span><span class="o">?</span>
		<span class="nl">NULL:</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU &amp;&amp; !__ARCH_HAS_4LEVEL_HACK */</span><span class="cp"></span>

<span class="cp">#if USE_SPLIT_PTLOCKS</span>
<span class="cm">/*</span>
<span class="cm"> * We tuck a spinlock to guard each pagetable page into its struct page,</span>
<span class="cm"> * at page-&gt;private, with BUILD_BUG_ON to make sure that this will not</span>
<span class="cm"> * overflow into the next struct page (as it might with DEBUG_SPINLOCK).</span>
<span class="cm"> * When freeing, reset page-&gt;mapping so free_pages_check won&#39;t complain.</span>
<span class="cm"> */</span>
<span class="cp">#define __pte_lockptr(page)	&amp;((page)-&gt;ptl)</span>
<span class="cp">#define pte_lock_init(_page)	do {					\</span>
<span class="cp">	spin_lock_init(__pte_lockptr(_page));				\</span>
<span class="cp">} while (0)</span>
<span class="cp">#define pte_lock_deinit(page)	((page)-&gt;mapping = NULL)</span>
<span class="cp">#define pte_lockptr(mm, pmd)	({(void)(mm); __pte_lockptr(pmd_page(*(pmd)));})</span>
<span class="cp">#else	</span><span class="cm">/* !USE_SPLIT_PTLOCKS */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * We use mm-&gt;page_table_lock to guard all pagetable pages of the mm.</span>
<span class="cm"> */</span>
<span class="cp">#define pte_lock_init(page)	do {} while (0)</span>
<span class="cp">#define pte_lock_deinit(page)	do {} while (0)</span>
<span class="cp">#define pte_lockptr(mm, pmd)	({(void)(pmd); &amp;(mm)-&gt;page_table_lock;})</span>
<span class="cp">#endif </span><span class="cm">/* USE_SPLIT_PTLOCKS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgtable_page_ctor</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_lock_init</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_PAGETABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pgtable_page_dtor</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_lock_deinit</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_PAGETABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define pte_offset_map_lock(mm, pmd, address, ptlp)	\</span>
<span class="cp">({							\</span>
<span class="cp">	spinlock_t *__ptl = pte_lockptr(mm, pmd);	\</span>
<span class="cp">	pte_t *__pte = pte_offset_map(pmd, address);	\</span>
<span class="cp">	*(ptlp) = __ptl;				\</span>
<span class="cp">	spin_lock(__ptl);				\</span>
<span class="cp">	__pte;						\</span>
<span class="cp">})</span>

<span class="cp">#define pte_unmap_unlock(pte, ptl)	do {		\</span>
<span class="cp">	spin_unlock(ptl);				\</span>
<span class="cp">	pte_unmap(pte);					\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define pte_alloc_map(mm, vma, pmd, address)				\</span>
<span class="cp">	((unlikely(pmd_none(*(pmd))) &amp;&amp; __pte_alloc(mm, vma,	\</span>
<span class="cp">							pmd, address))?	\</span>
<span class="cp">	 NULL: pte_offset_map(pmd, address))</span>

<span class="cp">#define pte_alloc_map_lock(mm, pmd, address, ptlp)	\</span>
<span class="cp">	((unlikely(pmd_none(*(pmd))) &amp;&amp; __pte_alloc(mm, NULL,	\</span>
<span class="cp">							pmd, address))?	\</span>
<span class="cp">		NULL: pte_offset_map_lock(mm, pmd, address, ptlp))</span>

<span class="cp">#define pte_alloc_kernel(pmd, address)			\</span>
<span class="cp">	((unlikely(pmd_none(*(pmd))) &amp;&amp; __pte_alloc_kernel(pmd, address))? \</span>
<span class="cp">		NULL: pte_offset_kernel(pmd, address))</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_area_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">zones_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_area_init_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">zones_size</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_start_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">zholes_size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_initmem</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP</span>
<span class="cm">/*</span>
<span class="cm"> * With CONFIG_HAVE_MEMBLOCK_NODE_MAP set, an architecture may initialise its</span>
<span class="cm"> * zones, allocate the backing mem_map and account for memory holes in a more</span>
<span class="cm"> * architecture independent manner. This is a substitute for creating the</span>
<span class="cm"> * zone_sizes[] and zholes_size[] arrays and passing them to</span>
<span class="cm"> * free_area_init_node()</span>
<span class="cm"> *</span>
<span class="cm"> * An architecture is expected to register range of page frames backed by</span>
<span class="cm"> * physical memory with memblock_add[_node]() before calling</span>
<span class="cm"> * free_area_init_nodes() passing in the PFN each zone ends at. At a basic</span>
<span class="cm"> * usage, an architecture is expected to do something like</span>
<span class="cm"> *</span>
<span class="cm"> * unsigned long max_zone_pfns[MAX_NR_ZONES] = {max_dma, max_normal_pfn,</span>
<span class="cm"> * 							 max_highmem_pfn};</span>
<span class="cm"> * for_each_valid_physical_page_range()</span>
<span class="cm"> * 	memblock_add_node(base, size, nid)</span>
<span class="cm"> * free_area_init_nodes(max_zone_pfns);</span>
<span class="cm"> *</span>
<span class="cm"> * free_bootmem_with_active_regions() calls free_bootmem_node() for each</span>
<span class="cm"> * registered physical page range.  Similarly</span>
<span class="cm"> * sparse_memory_present_with_active_regions() calls memory_present() for</span>
<span class="cm"> * each range when SPARSEMEM is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * See mm/page_alloc.c for more information on each function exposed by</span>
<span class="cm"> * CONFIG_HAVE_MEMBLOCK_NODE_MAP.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_area_init_nodes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">max_zone_pfn</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_map_pfn_alignment</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__absent_pages_in_range</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">absent_pages_in_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">get_pfn_range_for_nid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">start_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">end_pfn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">find_min_pfn_with_active_regions</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">free_bootmem_with_active_regions</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_low_pfn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">sparse_memory_present_with_active_regions</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_MEMBLOCK_NODE_MAP */</span><span class="cp"></span>

<span class="cp">#if !defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) &amp;&amp; \</span>
<span class="cp">    !defined(CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__early_pfn_to_nid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/* please see mm/page_alloc.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__meminit</span> <span class="n">early_pfn_to_nid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID</span>
<span class="cm">/* there is a per-arch backend function. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__meminit</span> <span class="n">__early_pfn_to_nid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_dma_reserve</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_dma_reserve</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">memmap_init_zone</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">enum</span> <span class="n">memmap_context</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">setup_per_zone_wmarks</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__meminit</span> <span class="n">init_per_zone_wmark_min</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">mmap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">show_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">si_meminfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysinfo</span> <span class="o">*</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">si_meminfo_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysinfo</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">after_bootmem</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">warn_alloc_failed</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">setup_per_cpu_pageset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">zone_pcp_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">);</span>

<span class="cm">/* nommu.c */</span>
<span class="k">extern</span> <span class="n">atomic_long_t</span> <span class="n">mmap_pages_allocated</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">nommu_shrink_inode_mappings</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cm">/* prio_tree.c */</span>
<span class="kt">void</span> <span class="n">vma_prio_tree_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">old</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vma_prio_tree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vma_prio_tree_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">prio_tree_root</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma_prio_tree_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>

<span class="cp">#define vma_prio_tree_foreach(vma, iter, root, begin, end)	\</span>
<span class="cp">	for (prio_tree_iter_init(iter, root, begin, end), vma = NULL;	\</span>
<span class="cp">		(vma = vma_prio_tree_next(vma, iter)); )</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vma_nonlinear_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">.</span><span class="n">vm_set</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">.</span><span class="n">vm_set</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* mmap.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__vm_enough_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap_sys_admin</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vma_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">insert</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">pgoff_t</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">find_mergeable_anon_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">split_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_below</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">insert_vm_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__vma_link_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unlink_file_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">copy_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">exit_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">mm_take_all_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mm_drop_all_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>

<span class="cm">/* From fs/proc/base.c. callers must _not_ hold the mm&#39;s exe_file_lock */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">added_exe_file_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">removed_exe_file_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_mm_exe_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">new_exe_file</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">get_mm_exe_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">may_expand_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">install_special_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmap_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
	<span class="n">vm_flags_t</span> <span class="n">vm_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">do_mmap_pgoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">do_munmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cm">/* These take the mm semaphore themselves */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_brk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">vm_munmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cm">/* truncate.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">truncate_inode_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">truncate_inode_pages_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="p">,</span>
				       <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lend</span><span class="p">);</span>

<span class="cm">/* generic vm_area_ops exported for stackable file systems */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">filemap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* mm/page-writeback.c */</span>
<span class="kt">int</span> <span class="n">write_one_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">task_dirty_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>

<span class="cm">/* readahead.c */</span>
<span class="cp">#define VM_MAX_READAHEAD	128	</span><span class="cm">/* kbytes */</span><span class="cp"></span>
<span class="cp">#define VM_MIN_READAHEAD	16	</span><span class="cm">/* kbytes (includes current page) */</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">force_page_cache_readahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_read</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">page_cache_sync_readahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
			       <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">page_cache_async_readahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pg</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_sane_readahead</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>

<span class="cm">/* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">expand_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>

<span class="cm">/* CONFIG_STACK_GROWSUP still needs to to grow downwards at some places */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">expand_downwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="cp">#if VM_GROWSUP</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">expand_upwards</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>
<span class="cp">#else</span>
  <span class="cp">#define expand_upwards(vma, address) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">find_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">find_vma_prev</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">pprev</span><span class="p">);</span>

<span class="cm">/* Look up the first VMA which intersects the interval start_addr..end_addr-1,</span>
<span class="cm">   NULL if none.  Assume start_addr &lt; end_addr. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="nf">find_vma_intersection</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span><span class="n">start_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">end_addr</span> <span class="o">&lt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vma_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look up the first VMA which exactly match the interval vm_start ... vm_end */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">find_exact_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vm_start</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">!=</span> <span class="n">vm_start</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">!=</span> <span class="n">vm_end</span><span class="p">))</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="n">pgprot_t</span> <span class="n">vm_get_page_prot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgprot_t</span> <span class="nf">vm_get_page_prot</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pgprot</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">find_extend_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">remap_pfn_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vm_insert_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vm_insert_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vm_insert_mixed</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">follow_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">foll_flags</span><span class="p">);</span>
<span class="cp">#define FOLL_WRITE	0x01	</span><span class="cm">/* check pte is writable */</span><span class="cp"></span>
<span class="cp">#define FOLL_TOUCH	0x02	</span><span class="cm">/* mark page accessed */</span><span class="cp"></span>
<span class="cp">#define FOLL_GET	0x04	</span><span class="cm">/* do get_page on page */</span><span class="cp"></span>
<span class="cp">#define FOLL_DUMP	0x08	</span><span class="cm">/* give error on hole if it would be zero */</span><span class="cp"></span>
<span class="cp">#define FOLL_FORCE	0x10	</span><span class="cm">/* get_user_pages read/write w/o permission */</span><span class="cp"></span>
<span class="cp">#define FOLL_NOWAIT	0x20	</span><span class="cm">/* if a disk transfer is needed, start the IO</span>
<span class="cm">				 * and return without waiting upon it */</span><span class="cp"></span>
<span class="cp">#define FOLL_MLOCK	0x40	</span><span class="cm">/* mark page as mlocked */</span><span class="cp"></span>
<span class="cp">#define FOLL_SPLIT	0x80	</span><span class="cm">/* don&#39;t return transhuge pages, split them */</span><span class="cp"></span>
<span class="cp">#define FOLL_HWPOISON	0x100	</span><span class="cm">/* check page is hwpoisoned */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pte_fn_t</span><span class="p">)(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">pgtable_t</span> <span class="n">token</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">apply_to_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pte_fn_t</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="kt">void</span> <span class="n">vm_stat_account</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">vm_stat_account</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">kernel_map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HIBERNATION</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">kernel_page_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIBERNATION */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">kernel_map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numpages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#ifdef CONFIG_HIBERNATION</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">kernel_page_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIBERNATION */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">get_gate_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#ifdef	__HAVE_ARCH_GATE_AREA</span>
<span class="kt">int</span> <span class="n">in_gate_area_no_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">in_gate_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="n">in_gate_area_no_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">);</span>
<span class="cp">#define in_gate_area(mm, addr) ({(void)mm; in_gate_area_no_mm(addr);})</span>
<span class="cp">#endif	</span><span class="cm">/* __HAVE_ARCH_GATE_AREA */</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">drop_caches_sysctl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
					<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shrink_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">shrink</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages_scanned</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lru_pages</span><span class="p">);</span>

<span class="cp">#ifndef CONFIG_MMU</span>
<span class="cp">#define randomize_va_space 0</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">randomize_va_space</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">arch_vma_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">print_vma_addr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rip</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">sparse_mem_maps_populate_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">map_map</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pnum_begin</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pnum_end</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">map_count</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">nodeid</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">sparse_mem_map_populate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">);</span>
<span class="n">pgd_t</span> <span class="o">*</span><span class="n">vmemmap_pgd_populate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="n">pud_t</span> <span class="o">*</span><span class="n">vmemmap_pud_populate</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="n">pmd_t</span> <span class="o">*</span><span class="n">vmemmap_pmd_populate</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="n">pte_t</span> <span class="o">*</span><span class="n">vmemmap_pte_populate</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">vmemmap_alloc_block</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">vmemmap_alloc_block_buf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vmemmap_verify</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vmemmap_populate_basepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start_page</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">vmemmap_populate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">start_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">vmemmap_populate_print_last</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="k">enum</span> <span class="n">mf_flags</span> <span class="p">{</span>
	<span class="n">MF_COUNT_INCREASED</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MF_ACTION_REQUIRED</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">memory_failure</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">memory_failure_queue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">unpoison_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_memory_failure_early_kill</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_memory_failure_recovery</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">shake_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">access</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">atomic_long_t</span> <span class="n">mce_bad_pages</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">soft_offline_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">dump_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_TRANSPARENT_HUGEPAGE) || defined(CONFIG_HUGETLBFS)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">clear_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_per_huge_page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">copy_user_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_per_huge_page</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_debug_guardpage_minorder</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">debug_guardpage_minorder</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">_debug_guardpage_minorder</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">page_is_guard</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">PAGE_DEBUG_FLAG_GUARD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">debug_flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">debug_guardpage_minorder</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">page_is_guard</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_PAGEALLOC */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_MM_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
