<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › edac.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>edac.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Generic EDAC defs</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Dave Jiang &lt;djiang@mvista.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 2006-2008 (c) MontaVista Software, Inc. This file is licensed under</span>
<span class="cm"> * the terms of the GNU General Public License version 2. This program</span>
<span class="cm"> * is licensed &quot;as is&quot; without any warranty of any kind, whether express</span>
<span class="cm"> * or implied.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_EDAC_H_</span>
<span class="cp">#define _LINUX_EDAC_H_</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cp">#define EDAC_OPSTATE_INVAL	-1</span>
<span class="cp">#define EDAC_OPSTATE_POLL	0</span>
<span class="cp">#define EDAC_OPSTATE_NMI	1</span>
<span class="cp">#define EDAC_OPSTATE_INT	2</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_op_state</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_err_assert</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">edac_handlers</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">edac_subsys</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">edac_handler_set</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_atomic_assert_error</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">edac_get_sysfs_subsys</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">edac_put_sysfs_subsys</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">opstate_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">edac_op_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EDAC_OPSTATE_POLL</span>:
	<span class="k">case</span> <span class="n">EDAC_OPSTATE_NMI</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">edac_op_state</span> <span class="o">=</span> <span class="n">EDAC_OPSTATE_POLL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define EDAC_MC_LABEL_LEN	31</span>
<span class="cp">#define MC_PROC_NAME_MAX_LEN	7</span>

<span class="cm">/* memory devices */</span>
<span class="k">enum</span> <span class="n">dev_type</span> <span class="p">{</span>
	<span class="n">DEV_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DEV_X1</span><span class="p">,</span>
	<span class="n">DEV_X2</span><span class="p">,</span>
	<span class="n">DEV_X4</span><span class="p">,</span>
	<span class="n">DEV_X8</span><span class="p">,</span>
	<span class="n">DEV_X16</span><span class="p">,</span>
	<span class="n">DEV_X32</span><span class="p">,</span>		<span class="cm">/* Do these parts exist? */</span>
	<span class="n">DEV_X64</span>			<span class="cm">/* Do these parts exist? */</span>
<span class="p">};</span>

<span class="cp">#define DEV_FLAG_UNKNOWN	BIT(DEV_UNKNOWN)</span>
<span class="cp">#define DEV_FLAG_X1		BIT(DEV_X1)</span>
<span class="cp">#define DEV_FLAG_X2		BIT(DEV_X2)</span>
<span class="cp">#define DEV_FLAG_X4		BIT(DEV_X4)</span>
<span class="cp">#define DEV_FLAG_X8		BIT(DEV_X8)</span>
<span class="cp">#define DEV_FLAG_X16		BIT(DEV_X16)</span>
<span class="cp">#define DEV_FLAG_X32		BIT(DEV_X32)</span>
<span class="cp">#define DEV_FLAG_X64		BIT(DEV_X64)</span>

<span class="cm">/**</span>
<span class="cm"> * enum hw_event_mc_err_type - type of the detected error</span>
<span class="cm"> *</span>
<span class="cm"> * @HW_EVENT_ERR_CORRECTED:	Corrected Error - Indicates that an ECC</span>
<span class="cm"> *				corrected error was detected</span>
<span class="cm"> * @HW_EVENT_ERR_UNCORRECTED:	Uncorrected Error - Indicates an error that</span>
<span class="cm"> *				can&#39;t be corrected by ECC, but it is not</span>
<span class="cm"> *				fatal (maybe it is on an unused memory area,</span>
<span class="cm"> *				or the memory controller could recover from</span>
<span class="cm"> *				it for example, by re-trying the operation).</span>
<span class="cm"> * @HW_EVENT_ERR_FATAL:		Fatal Error - Uncorrected error that could not</span>
<span class="cm"> *				be recovered.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">hw_event_mc_err_type</span> <span class="p">{</span>
	<span class="n">HW_EVENT_ERR_CORRECTED</span><span class="p">,</span>
	<span class="n">HW_EVENT_ERR_UNCORRECTED</span><span class="p">,</span>
	<span class="n">HW_EVENT_ERR_FATAL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum mem_type - memory types. For a more detailed reference, please see</span>
<span class="cm"> *			http://en.wikipedia.org/wiki/DRAM</span>
<span class="cm"> *</span>
<span class="cm"> * @MEM_EMPTY		Empty csrow</span>
<span class="cm"> * @MEM_RESERVED:	Reserved csrow type</span>
<span class="cm"> * @MEM_UNKNOWN:	Unknown csrow type</span>
<span class="cm"> * @MEM_FPM:		FPM - Fast Page Mode, used on systems up to 1995.</span>
<span class="cm"> * @MEM_EDO:		EDO - Extended data out, used on systems up to 1998.</span>
<span class="cm"> * @MEM_BEDO:		BEDO - Burst Extended data out, an EDO variant.</span>
<span class="cm"> * @MEM_SDR:		SDR - Single data rate SDRAM</span>
<span class="cm"> *			http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory</span>
<span class="cm"> *			They use 3 pins for chip select: Pins 0 and 2 are</span>
<span class="cm"> *			for rank 0; pins 1 and 3 are for rank 1, if the memory</span>
<span class="cm"> *			is dual-rank.</span>
<span class="cm"> * @MEM_RDR:		Registered SDR SDRAM</span>
<span class="cm"> * @MEM_DDR:		Double data rate SDRAM</span>
<span class="cm"> *			http://en.wikipedia.org/wiki/DDR_SDRAM</span>
<span class="cm"> * @MEM_RDDR:		Registered Double data rate SDRAM</span>
<span class="cm"> *			This is a variant of the DDR memories.</span>
<span class="cm"> *			A registered memory has a buffer inside it, hiding</span>
<span class="cm"> *			part of the memory details to the memory controller.</span>
<span class="cm"> * @MEM_RMBS:		Rambus DRAM, used on a few Pentium III/IV controllers.</span>
<span class="cm"> * @MEM_DDR2:		DDR2 RAM, as described at JEDEC JESD79-2F.</span>
<span class="cm"> *			Those memories are labed as &quot;PC2-&quot; instead of &quot;PC&quot; to</span>
<span class="cm"> *			differenciate from DDR.</span>
<span class="cm"> * @MEM_FB_DDR2:	Fully-Buffered DDR2, as described at JEDEC Std No. 205</span>
<span class="cm"> *			and JESD206.</span>
<span class="cm"> *			Those memories are accessed per DIMM slot, and not by</span>
<span class="cm"> *			a chip select signal.</span>
<span class="cm"> * @MEM_RDDR2:		Registered DDR2 RAM</span>
<span class="cm"> *			This is a variant of the DDR2 memories.</span>
<span class="cm"> * @MEM_XDR:		Rambus XDR</span>
<span class="cm"> *			It is an evolution of the original RAMBUS memories,</span>
<span class="cm"> *			created to compete with DDR2. Weren&#39;t used on any</span>
<span class="cm"> *			x86 arch, but cell_edac PPC memory controller uses it.</span>
<span class="cm"> * @MEM_DDR3:		DDR3 RAM</span>
<span class="cm"> * @MEM_RDDR3:		Registered DDR3 RAM</span>
<span class="cm"> *			This is a variant of the DDR3 memories.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mem_type</span> <span class="p">{</span>
	<span class="n">MEM_EMPTY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MEM_RESERVED</span><span class="p">,</span>
	<span class="n">MEM_UNKNOWN</span><span class="p">,</span>
	<span class="n">MEM_FPM</span><span class="p">,</span>
	<span class="n">MEM_EDO</span><span class="p">,</span>
	<span class="n">MEM_BEDO</span><span class="p">,</span>
	<span class="n">MEM_SDR</span><span class="p">,</span>
	<span class="n">MEM_RDR</span><span class="p">,</span>
	<span class="n">MEM_DDR</span><span class="p">,</span>
	<span class="n">MEM_RDDR</span><span class="p">,</span>
	<span class="n">MEM_RMBS</span><span class="p">,</span>
	<span class="n">MEM_DDR2</span><span class="p">,</span>
	<span class="n">MEM_FB_DDR2</span><span class="p">,</span>
	<span class="n">MEM_RDDR2</span><span class="p">,</span>
	<span class="n">MEM_XDR</span><span class="p">,</span>
	<span class="n">MEM_DDR3</span><span class="p">,</span>
	<span class="n">MEM_RDDR3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define MEM_FLAG_EMPTY		BIT(MEM_EMPTY)</span>
<span class="cp">#define MEM_FLAG_RESERVED	BIT(MEM_RESERVED)</span>
<span class="cp">#define MEM_FLAG_UNKNOWN	BIT(MEM_UNKNOWN)</span>
<span class="cp">#define MEM_FLAG_FPM		BIT(MEM_FPM)</span>
<span class="cp">#define MEM_FLAG_EDO		BIT(MEM_EDO)</span>
<span class="cp">#define MEM_FLAG_BEDO		BIT(MEM_BEDO)</span>
<span class="cp">#define MEM_FLAG_SDR		BIT(MEM_SDR)</span>
<span class="cp">#define MEM_FLAG_RDR		BIT(MEM_RDR)</span>
<span class="cp">#define MEM_FLAG_DDR		BIT(MEM_DDR)</span>
<span class="cp">#define MEM_FLAG_RDDR		BIT(MEM_RDDR)</span>
<span class="cp">#define MEM_FLAG_RMBS		BIT(MEM_RMBS)</span>
<span class="cp">#define MEM_FLAG_DDR2           BIT(MEM_DDR2)</span>
<span class="cp">#define MEM_FLAG_FB_DDR2        BIT(MEM_FB_DDR2)</span>
<span class="cp">#define MEM_FLAG_RDDR2          BIT(MEM_RDDR2)</span>
<span class="cp">#define MEM_FLAG_XDR            BIT(MEM_XDR)</span>
<span class="cp">#define MEM_FLAG_DDR3		 BIT(MEM_DDR3)</span>
<span class="cp">#define MEM_FLAG_RDDR3		 BIT(MEM_RDDR3)</span>

<span class="cm">/* chipset Error Detection and Correction capabilities and mode */</span>
<span class="k">enum</span> <span class="n">edac_type</span> <span class="p">{</span>
	<span class="n">EDAC_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Unknown if ECC is available */</span>
	<span class="n">EDAC_NONE</span><span class="p">,</span>		<span class="cm">/* Doesn&#39;t support ECC */</span>
	<span class="n">EDAC_RESERVED</span><span class="p">,</span>		<span class="cm">/* Reserved ECC type */</span>
	<span class="n">EDAC_PARITY</span><span class="p">,</span>		<span class="cm">/* Detects parity errors */</span>
	<span class="n">EDAC_EC</span><span class="p">,</span>		<span class="cm">/* Error Checking - no correction */</span>
	<span class="n">EDAC_SECDED</span><span class="p">,</span>		<span class="cm">/* Single bit error correction, Double detection */</span>
	<span class="n">EDAC_S2ECD2ED</span><span class="p">,</span>		<span class="cm">/* Chipkill x2 devices - do these exist? */</span>
	<span class="n">EDAC_S4ECD4ED</span><span class="p">,</span>		<span class="cm">/* Chipkill x4 devices */</span>
	<span class="n">EDAC_S8ECD8ED</span><span class="p">,</span>		<span class="cm">/* Chipkill x8 devices */</span>
	<span class="n">EDAC_S16ECD16ED</span><span class="p">,</span>	<span class="cm">/* Chipkill x16 devices */</span>
<span class="p">};</span>

<span class="cp">#define EDAC_FLAG_UNKNOWN	BIT(EDAC_UNKNOWN)</span>
<span class="cp">#define EDAC_FLAG_NONE		BIT(EDAC_NONE)</span>
<span class="cp">#define EDAC_FLAG_PARITY	BIT(EDAC_PARITY)</span>
<span class="cp">#define EDAC_FLAG_EC		BIT(EDAC_EC)</span>
<span class="cp">#define EDAC_FLAG_SECDED	BIT(EDAC_SECDED)</span>
<span class="cp">#define EDAC_FLAG_S2ECD2ED	BIT(EDAC_S2ECD2ED)</span>
<span class="cp">#define EDAC_FLAG_S4ECD4ED	BIT(EDAC_S4ECD4ED)</span>
<span class="cp">#define EDAC_FLAG_S8ECD8ED	BIT(EDAC_S8ECD8ED)</span>
<span class="cp">#define EDAC_FLAG_S16ECD16ED	BIT(EDAC_S16ECD16ED)</span>

<span class="cm">/* scrubbing capabilities */</span>
<span class="k">enum</span> <span class="n">scrub_type</span> <span class="p">{</span>
	<span class="n">SCRUB_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Unknown if scrubber is available */</span>
	<span class="n">SCRUB_NONE</span><span class="p">,</span>		<span class="cm">/* No scrubber */</span>
	<span class="n">SCRUB_SW_PROG</span><span class="p">,</span>		<span class="cm">/* SW progressive (sequential) scrubbing */</span>
	<span class="n">SCRUB_SW_SRC</span><span class="p">,</span>		<span class="cm">/* Software scrub only errors */</span>
	<span class="n">SCRUB_SW_PROG_SRC</span><span class="p">,</span>	<span class="cm">/* Progressive software scrub from an error */</span>
	<span class="n">SCRUB_SW_TUNABLE</span><span class="p">,</span>	<span class="cm">/* Software scrub frequency is tunable */</span>
	<span class="n">SCRUB_HW_PROG</span><span class="p">,</span>		<span class="cm">/* HW progressive (sequential) scrubbing */</span>
	<span class="n">SCRUB_HW_SRC</span><span class="p">,</span>		<span class="cm">/* Hardware scrub only errors */</span>
	<span class="n">SCRUB_HW_PROG_SRC</span><span class="p">,</span>	<span class="cm">/* Progressive hardware scrub from an error */</span>
	<span class="n">SCRUB_HW_TUNABLE</span>	<span class="cm">/* Hardware scrub frequency is tunable */</span>
<span class="p">};</span>

<span class="cp">#define SCRUB_FLAG_SW_PROG	BIT(SCRUB_SW_PROG)</span>
<span class="cp">#define SCRUB_FLAG_SW_SRC	BIT(SCRUB_SW_SRC)</span>
<span class="cp">#define SCRUB_FLAG_SW_PROG_SRC	BIT(SCRUB_SW_PROG_SRC)</span>
<span class="cp">#define SCRUB_FLAG_SW_TUN	BIT(SCRUB_SW_SCRUB_TUNABLE)</span>
<span class="cp">#define SCRUB_FLAG_HW_PROG	BIT(SCRUB_HW_PROG)</span>
<span class="cp">#define SCRUB_FLAG_HW_SRC	BIT(SCRUB_HW_SRC)</span>
<span class="cp">#define SCRUB_FLAG_HW_PROG_SRC	BIT(SCRUB_HW_PROG_SRC)</span>
<span class="cp">#define SCRUB_FLAG_HW_TUN	BIT(SCRUB_HW_TUNABLE)</span>

<span class="cm">/* FIXME - should have notify capabilities: NMI, LOG, PROC, etc */</span>

<span class="cm">/* EDAC internal operation states */</span>
<span class="cp">#define	OP_ALLOC		0x100</span>
<span class="cp">#define OP_RUNNING_POLL		0x201</span>
<span class="cp">#define OP_RUNNING_INTERRUPT	0x202</span>
<span class="cp">#define OP_RUNNING_POLL_INTR	0x203</span>
<span class="cp">#define OP_OFFLINE		0x300</span>

<span class="cm">/*</span>
<span class="cm"> * Concepts used at the EDAC subsystem</span>
<span class="cm"> *</span>
<span class="cm"> * There are several things to be aware of that aren&#39;t at all obvious:</span>
<span class="cm"> *</span>
<span class="cm"> * SOCKETS, SOCKET SETS, BANKS, ROWS, CHIP-SELECT ROWS, CHANNELS, etc..</span>
<span class="cm"> *</span>
<span class="cm"> * These are some of the many terms that are thrown about that don&#39;t always</span>
<span class="cm"> * mean what people think they mean (Inconceivable!).  In the interest of</span>
<span class="cm"> * creating a common ground for discussion, terms and their definitions</span>
<span class="cm"> * will be established.</span>
<span class="cm"> *</span>
<span class="cm"> * Memory devices:	The individual DRAM chips on a memory stick.  These</span>
<span class="cm"> *			devices commonly output 4 and 8 bits each (x4, x8).</span>
<span class="cm"> *			Grouping several of these in parallel provides the</span>
<span class="cm"> *			number of bits that the memory controller expects:</span>
<span class="cm"> *			typically 72 bits, in order to provide 64 bits +</span>
<span class="cm"> *			8 bits of ECC data.</span>
<span class="cm"> *</span>
<span class="cm"> * Memory Stick:	A printed circuit board that aggregates multiple</span>
<span class="cm"> *			memory devices in parallel.  In general, this is the</span>
<span class="cm"> *			Field Replaceable Unit (FRU) which gets replaced, in</span>
<span class="cm"> *			the case of excessive errors. Most often it is also</span>
<span class="cm"> *			called DIMM (Dual Inline Memory Module).</span>
<span class="cm"> *</span>
<span class="cm"> * Memory Socket:	A physical connector on the motherboard that accepts</span>
<span class="cm"> *			a single memory stick. Also called as &quot;slot&quot; on several</span>
<span class="cm"> *			datasheets.</span>
<span class="cm"> *</span>
<span class="cm"> * Channel:		A memory controller channel, responsible to communicate</span>
<span class="cm"> *			with a group of DIMMs. Each channel has its own</span>
<span class="cm"> *			independent control (command) and data bus, and can</span>
<span class="cm"> *			be used independently or grouped with other channels.</span>
<span class="cm"> *</span>
<span class="cm"> * Branch:		It is typically the highest hierarchy on a</span>
<span class="cm"> *			Fully-Buffered DIMM memory controller.</span>
<span class="cm"> *			Typically, it contains two channels.</span>
<span class="cm"> *			Two channels at the same branch can be used in single</span>
<span class="cm"> *			mode or in lockstep mode.</span>
<span class="cm"> *			When lockstep is enabled, the cacheline is doubled,</span>
<span class="cm"> *			but it generally brings some performance penalty.</span>
<span class="cm"> *			Also, it is generally not possible to point to just one</span>
<span class="cm"> *			memory stick when an error occurs, as the error</span>
<span class="cm"> *			correction code is calculated using two DIMMs instead</span>
<span class="cm"> *			of one. Due to that, it is capable of correcting more</span>
<span class="cm"> *			errors than on single mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Single-channel:	The data accessed by the memory controller is contained</span>
<span class="cm"> *			into one dimm only. E. g. if the data is 64 bits-wide,</span>
<span class="cm"> *			the data flows to the CPU using one 64 bits parallel</span>
<span class="cm"> *			access.</span>
<span class="cm"> *			Typically used with SDR, DDR, DDR2 and DDR3 memories.</span>
<span class="cm"> *			FB-DIMM and RAMBUS use a different concept for channel,</span>
<span class="cm"> *			so this concept doesn&#39;t apply there.</span>
<span class="cm"> *</span>
<span class="cm"> * Double-channel:	The data size accessed by the memory controller is</span>
<span class="cm"> *			interlaced into two dimms, accessed at the same time.</span>
<span class="cm"> *			E. g. if the DIMM is 64 bits-wide (72 bits with ECC),</span>
<span class="cm"> *			the data flows to the CPU using a 128 bits parallel</span>
<span class="cm"> *			access.</span>
<span class="cm"> *</span>
<span class="cm"> * Chip-select row:	This is the name of the DRAM signal used to select the</span>
<span class="cm"> *			DRAM ranks to be accessed. Common chip-select rows for</span>
<span class="cm"> *			single channel are 64 bits, for dual channel 128 bits.</span>
<span class="cm"> *			It may not be visible by the memory controller, as some</span>
<span class="cm"> *			DIMM types have a memory buffer that can hide direct</span>
<span class="cm"> *			access to it from the Memory Controller.</span>
<span class="cm"> *</span>
<span class="cm"> * Single-Ranked stick:	A Single-ranked stick has 1 chip-select row of memory.</span>
<span class="cm"> *			Motherboards commonly drive two chip-select pins to</span>
<span class="cm"> *			a memory stick. A single-ranked stick, will occupy</span>
<span class="cm"> *			only one of those rows. The other will be unused.</span>
<span class="cm"> *</span>
<span class="cm"> * Double-Ranked stick:	A double-ranked stick has two chip-select rows which</span>
<span class="cm"> *			access different sets of memory devices.  The two</span>
<span class="cm"> *			rows cannot be accessed concurrently.</span>
<span class="cm"> *</span>
<span class="cm"> * Double-sided stick:	DEPRECATED TERM, see Double-Ranked stick.</span>
<span class="cm"> *			A double-sided stick has two chip-select rows which</span>
<span class="cm"> *			access different sets of memory devices. The two</span>
<span class="cm"> *			rows cannot be accessed concurrently. &quot;Double-sided&quot;</span>
<span class="cm"> *			is irrespective of the memory devices being mounted</span>
<span class="cm"> *			on both sides of the memory stick.</span>
<span class="cm"> *</span>
<span class="cm"> * Socket set:		All of the memory sticks that are required for</span>
<span class="cm"> *			a single memory access or all of the memory sticks</span>
<span class="cm"> *			spanned by a chip-select row.  A single socket set</span>
<span class="cm"> *			has two chip-select rows and if double-sided sticks</span>
<span class="cm"> *			are used these will occupy those chip-select rows.</span>
<span class="cm"> *</span>
<span class="cm"> * Bank:		This term is avoided because it is unclear when</span>
<span class="cm"> *			needing to distinguish between chip-select rows and</span>
<span class="cm"> *			socket sets.</span>
<span class="cm"> *</span>
<span class="cm"> * Controller pages:</span>
<span class="cm"> *</span>
<span class="cm"> * Physical pages:</span>
<span class="cm"> *</span>
<span class="cm"> * Virtual pages:</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * STRUCTURE ORGANIZATION AND CHOICES</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * PS - I enjoyed writing all that about as much as you enjoyed reading it.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * enum edac_mc_layer - memory controller hierarchy layer</span>
<span class="cm"> *</span>
<span class="cm"> * @EDAC_MC_LAYER_BRANCH:	memory layer is named &quot;branch&quot;</span>
<span class="cm"> * @EDAC_MC_LAYER_CHANNEL:	memory layer is named &quot;channel&quot;</span>
<span class="cm"> * @EDAC_MC_LAYER_SLOT:		memory layer is named &quot;slot&quot;</span>
<span class="cm"> * @EDAC_MC_LAYER_CHIP_SELECT:	memory layer is named &quot;chip select&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * This enum is used by the drivers to tell edac_mc_sysfs what name should</span>
<span class="cm"> * be used when describing a memory stick location.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">edac_mc_layer_type</span> <span class="p">{</span>
	<span class="n">EDAC_MC_LAYER_BRANCH</span><span class="p">,</span>
	<span class="n">EDAC_MC_LAYER_CHANNEL</span><span class="p">,</span>
	<span class="n">EDAC_MC_LAYER_SLOT</span><span class="p">,</span>
	<span class="n">EDAC_MC_LAYER_CHIP_SELECT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct edac_mc_layer - describes the memory controller hierarchy</span>
<span class="cm"> * @layer:		layer type</span>
<span class="cm"> * @size:		number of components per layer. For example,</span>
<span class="cm"> *			if the channel layer has two channels, size = 2</span>
<span class="cm"> * @is_virt_csrow:	This layer is part of the &quot;csrow&quot; when old API</span>
<span class="cm"> *			compatibility mode is enabled. Otherwise, it is</span>
<span class="cm"> *			a channel</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">edac_mc_layer_type</span>	<span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">size</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">is_virt_csrow</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of layers used by the memory controller to uniquely</span>
<span class="cm"> * identify a single memory stick.</span>
<span class="cm"> * NOTE: Changing this constant requires not only to change the constant</span>
<span class="cm"> * below, but also to change the existing code at the core, as there are</span>
<span class="cm"> * some code there that are optimized for 3 layers.</span>
<span class="cm"> */</span>
<span class="cp">#define EDAC_MAX_LAYERS		3</span>

<span class="cm">/**</span>
<span class="cm"> * EDAC_DIMM_PTR - Macro responsible to find a pointer inside a pointer array</span>
<span class="cm"> *		   for the element given by [layer0,layer1,layer2] position</span>
<span class="cm"> *</span>
<span class="cm"> * @layers:	a struct edac_mc_layer array, describing how many elements</span>
<span class="cm"> *		were allocated for each layer</span>
<span class="cm"> * @var:	name of the var where we want to get the pointer</span>
<span class="cm"> *		(like mci-&gt;dimms)</span>
<span class="cm"> * @n_layers:	Number of layers at the @layers array</span>
<span class="cm"> * @layer0:	layer0 position</span>
<span class="cm"> * @layer1:	layer1 position. Unused if n_layers &lt; 2</span>
<span class="cm"> * @layer2:	layer2 position. Unused if n_layers &lt; 3</span>
<span class="cm"> *</span>
<span class="cm"> * For 1 layer, this macro returns &amp;var[layer0]</span>
<span class="cm"> * For 2 layers, this macro is similar to allocate a bi-dimensional array</span>
<span class="cm"> *		and to return &quot;&amp;var[layer0][layer1]&quot;</span>
<span class="cm"> * For 3 layers, this macro is similar to allocate a tri-dimensional array</span>
<span class="cm"> *		and to return &quot;&amp;var[layer0][layer1][layer2]&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * A loop could be used here to make it more generic, but, as we only have</span>
<span class="cm"> * 3 layers, this is a little faster.</span>
<span class="cm"> * By design, layers can never be 0 or more than 3. If that ever happens,</span>
<span class="cm"> * a NULL is returned, causing an OOPS during the memory allocation routine,</span>
<span class="cm"> * with would point to the developer that he&#39;s doing something wrong.</span>
<span class="cm"> */</span>
<span class="cp">#define EDAC_DIMM_PTR(layers, var, nlayers, layer0, layer1, layer2) ({	\</span>
<span class="cp">	typeof(var) __p;						\</span>
<span class="cp">	if ((nlayers) == 1)						\</span>
<span class="cp">		__p = &amp;var[layer0];					\</span>
<span class="cp">	else if ((nlayers) == 2)					\</span>
<span class="cp">		__p = &amp;var[(layer1) + ((layers[1]).size * (layer0))];	\</span>
<span class="cp">	else if ((nlayers) == 3)					\</span>
<span class="cp">		__p = &amp;var[(layer2) + ((layers[2]).size * ((layer1) +	\</span>
<span class="cp">			    ((layers[1]).size * (layer0))))];		\</span>
<span class="cp">	else								\</span>
<span class="cp">		__p = NULL;						\</span>
<span class="cp">	__p;								\</span>
<span class="cp">})</span>


<span class="cm">/* FIXME: add the proper per-location error counts */</span>
<span class="k">struct</span> <span class="n">dimm_info</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">label</span><span class="p">[</span><span class="n">EDAC_MC_LABEL_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/* DIMM label on motherboard */</span>

	<span class="cm">/* Memory location data */</span>
	<span class="kt">unsigned</span> <span class="n">location</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>	<span class="cm">/* the parent */</span>

	<span class="n">u32</span> <span class="n">grain</span><span class="p">;</span>		<span class="cm">/* granularity of reported error in bytes */</span>
	<span class="k">enum</span> <span class="n">dev_type</span> <span class="n">dtype</span><span class="p">;</span>	<span class="cm">/* memory device type */</span>
	<span class="k">enum</span> <span class="n">mem_type</span> <span class="n">mtype</span><span class="p">;</span>	<span class="cm">/* memory dimm type */</span>
	<span class="k">enum</span> <span class="n">edac_type</span> <span class="n">edac_mode</span><span class="p">;</span>	<span class="cm">/* EDAC mode for this dimm */</span>

	<span class="n">u32</span> <span class="n">nr_pages</span><span class="p">;</span>			<span class="cm">/* number of pages on this dimm */</span>

	<span class="kt">unsigned</span> <span class="n">csrow</span><span class="p">,</span> <span class="n">cschannel</span><span class="p">;</span>	<span class="cm">/* Points to the old API data */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rank_info - contains the information for one DIMM rank</span>
<span class="cm"> *</span>
<span class="cm"> * @chan_idx:	channel number where the rank is (typically, 0 or 1)</span>
<span class="cm"> * @ce_count:	number of correctable errors for this rank</span>
<span class="cm"> * @csrow:	A pointer to the chip select row structure (the parent</span>
<span class="cm"> *		structure). The location of the rank is given by</span>
<span class="cm"> *		the (csrow-&gt;csrow_idx, chan_idx) vector.</span>
<span class="cm"> * @dimm:	A pointer to the DIMM structure, where the DIMM label</span>
<span class="cm"> *		information is stored.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: Currently, the EDAC core model will assume one DIMM per rank.</span>
<span class="cm"> *	  This is a bad assumption, but it makes this patch easier. Later</span>
<span class="cm"> *	  patches in this series will fix this issue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rank_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">chan_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimm</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">ce_count</span><span class="p">;</span>		<span class="cm">/* Correctable Errors for this csrow */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">csrow_info</span> <span class="p">{</span>
	<span class="cm">/* Used only by edac_mc_find_csrow_by_page() */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_page</span><span class="p">;</span>	<span class="cm">/* first page number in csrow */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_page</span><span class="p">;</span>	<span class="cm">/* last page number in csrow */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_mask</span><span class="p">;</span>	<span class="cm">/* used for interleaving -</span>
<span class="cm">					 * 0UL for non intlv */</span>

	<span class="kt">int</span> <span class="n">csrow_idx</span><span class="p">;</span>			<span class="cm">/* the chip-select row */</span>

	<span class="n">u32</span> <span class="n">ue_count</span><span class="p">;</span>		<span class="cm">/* Uncorrectable Errors for this csrow */</span>
	<span class="n">u32</span> <span class="n">ce_count</span><span class="p">;</span>		<span class="cm">/* Correctable Errors for this csrow */</span>

	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>	<span class="cm">/* the parent */</span>

	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>	<span class="cm">/* sysfs kobject for this csrow */</span>

	<span class="cm">/* channel information for this csrow */</span>
	<span class="n">u32</span> <span class="n">nr_channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rank_info</span> <span class="o">*</span><span class="n">channels</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mcidev_sysfs_group</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>				<span class="cm">/* group name */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">mcidev_attr</span><span class="p">;</span> <span class="cm">/* group attributes */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mcidev_sysfs_group_kobj</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>		<span class="cm">/* list for all instances within a mc */</span>

	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>		<span class="cm">/* kobj for the group */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">mcidev_sysfs_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>	<span class="cm">/* group description table */</span>
	<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="n">mci</span><span class="p">;</span>	<span class="cm">/* the parent */</span>
<span class="p">};</span>

<span class="cm">/* mcidev_sysfs_attribute structure</span>
<span class="cm"> *	used for driver sysfs attributes and in mem_ctl_info</span>
<span class="cm"> * 	sysfs top level entries</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="p">{</span>
	<span class="cm">/* It should use either attr or grp */</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mcidev_sysfs_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">;</span>	<span class="cm">/* Points to a group of attributes */</span>

	<span class="cm">/* Ops for show/store values at the attribute - not used on group */</span>
        <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
        <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span><span class="kt">size_t</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* MEMORY controller information structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>	<span class="cm">/* for global list of mem_ctl_info structs */</span>

	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>	<span class="cm">/* Module owner of this control struct */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mtype_cap</span><span class="p">;</span>	<span class="cm">/* memory types supported by mc */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">edac_ctl_cap</span><span class="p">;</span>	<span class="cm">/* Mem controller EDAC capabilities */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">edac_cap</span><span class="p">;</span>	<span class="cm">/* configuration capabilities - this is</span>
<span class="cm">				 * closely related to edac_ctl_cap.  The</span>
<span class="cm">				 * difference is that the controller may be</span>
<span class="cm">				 * capable of s4ecd4ed which would be listed</span>
<span class="cm">				 * in edac_ctl_cap, but if channels aren&#39;t</span>
<span class="cm">				 * capable of s4ecd4ed then the edac_cap would</span>
<span class="cm">				 * not have that capability.</span>
<span class="cm">				 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scrub_cap</span><span class="p">;</span>	<span class="cm">/* chipset scrub capabilities */</span>
	<span class="k">enum</span> <span class="n">scrub_type</span> <span class="n">scrub_mode</span><span class="p">;</span>	<span class="cm">/* current scrub mode */</span>

	<span class="cm">/* Translates sdram memory scrub rate given in bytes/sec to the</span>
<span class="cm">	   internal representation and configures whatever else needs</span>
<span class="cm">	   to be configured.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_sdram_scrub_rate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span> <span class="n">mci</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bw</span><span class="p">);</span>

	<span class="cm">/* Get the current sdram memory scrub rate from the internal</span>
<span class="cm">	   representation and converts it to the closest matching</span>
<span class="cm">	   bandwidth in bytes/sec.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_sdram_scrub_rate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span> <span class="n">mci</span><span class="p">);</span>


	<span class="cm">/* pointer to edac checking routine */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">edac_check</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span> <span class="n">mci</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remaps memory pages: controller pages to physical pages.</span>
<span class="cm">	 * For most MC&#39;s, this will be NULL.</span>
<span class="cm">	 */</span>
	<span class="cm">/* FIXME - why not send the phys page to begin with? */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">ctl_page_to_phys</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mem_ctl_info</span> <span class="o">*</span> <span class="n">mci</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mc_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">csrow_info</span> <span class="o">*</span><span class="n">csrows</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nr_csrows</span><span class="p">,</span> <span class="n">num_cschannel</span><span class="p">;</span>

	<span class="cm">/* Memory Controller hierarchy */</span>
	<span class="kt">unsigned</span> <span class="n">n_layers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">edac_mc_layer</span> <span class="o">*</span><span class="n">layers</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">mem_is_per_rank</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * DIMM info. Will eventually remove the entire csrows_info some day</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">tot_dimms</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dimm_info</span> <span class="o">*</span><span class="n">dimms</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME - what about controllers on other busses? - IDs must be</span>
<span class="cm">	 * unique.  dev pointer should be sufficiently unique, but</span>
<span class="cm">	 * BUS:SLOT.FUNC numbers may not be unique.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_ver</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctl_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">proc_name</span><span class="p">[</span><span class="n">MC_PROC_NAME_MAX_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pvt_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">;</span>	<span class="cm">/* mci load start time (in jiffies) */</span>

	<span class="cm">/*</span>
<span class="cm">	 * drivers shouldn&#39;t access those fields directly, as the core</span>
<span class="cm">	 * already handles that.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ce_noinfo_count</span><span class="p">,</span> <span class="n">ue_noinfo_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ue_mc</span><span class="p">,</span> <span class="n">ce_mc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">ce_per_layer</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">],</span> <span class="o">*</span><span class="n">ue_per_layer</span><span class="p">[</span><span class="n">EDAC_MAX_LAYERS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">completion</span> <span class="n">complete</span><span class="p">;</span>

	<span class="cm">/* edac sysfs device control */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">edac_mci_kobj</span><span class="p">;</span>

	<span class="cm">/* list for all grp instances within a mc */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">grp_kobj_list</span><span class="p">;</span>

	<span class="cm">/* Additional top controller level attributes, but specified</span>
<span class="cm">	 * by the low level driver.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set by the low level driver to provide attributes at the</span>
<span class="cm">	 * controller level.</span>
<span class="cm">	 * An array of structures, NULL terminated</span>
<span class="cm">	 *</span>
<span class="cm">	 * If attributes are desired, then set to array of attributes</span>
<span class="cm">	 * If no attributes are desired, leave NULL</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mcidev_sysfs_attribute</span> <span class="o">*</span><span class="n">mc_driver_sysfs_attributes</span><span class="p">;</span>

	<span class="cm">/* work struct for this MC */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">work</span><span class="p">;</span>

	<span class="cm">/* the internal state of this controller instance */</span>
	<span class="kt">int</span> <span class="n">op_state</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
