<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › parport.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>parport.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Any part of this program may be used in documents licensed under</span>
<span class="cm"> * the GNU Free Documentation License, Version 1.1 or any later version</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _PARPORT_H_</span>
<span class="cp">#define _PARPORT_H_</span>

<span class="cm">/* Start off with user-visible constants */</span>

<span class="cm">/* Maximum of 16 ports per machine */</span>
<span class="cp">#define PARPORT_MAX  16</span>

<span class="cm">/* Magic numbers */</span>
<span class="cp">#define PARPORT_IRQ_NONE  -1</span>
<span class="cp">#define PARPORT_DMA_NONE  -1</span>
<span class="cp">#define PARPORT_IRQ_AUTO  -2</span>
<span class="cp">#define PARPORT_DMA_AUTO  -2</span>
<span class="cp">#define PARPORT_DMA_NOFIFO -3</span>
<span class="cp">#define PARPORT_DISABLE   -2</span>
<span class="cp">#define PARPORT_IRQ_PROBEONLY -3</span>
<span class="cp">#define PARPORT_IOHI_AUTO -1</span>

<span class="cp">#define PARPORT_CONTROL_STROBE    0x1</span>
<span class="cp">#define PARPORT_CONTROL_AUTOFD    0x2</span>
<span class="cp">#define PARPORT_CONTROL_INIT      0x4</span>
<span class="cp">#define PARPORT_CONTROL_SELECT    0x8</span>

<span class="cp">#define PARPORT_STATUS_ERROR      0x8</span>
<span class="cp">#define PARPORT_STATUS_SELECT     0x10</span>
<span class="cp">#define PARPORT_STATUS_PAPEROUT   0x20</span>
<span class="cp">#define PARPORT_STATUS_ACK        0x40</span>
<span class="cp">#define PARPORT_STATUS_BUSY       0x80</span>

<span class="cm">/* Type classes for Plug-and-Play probe.  */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">PARPORT_CLASS_LEGACY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>       <span class="cm">/* Non-IEEE1284 device */</span>
	<span class="n">PARPORT_CLASS_PRINTER</span><span class="p">,</span>
	<span class="n">PARPORT_CLASS_MODEM</span><span class="p">,</span>
	<span class="n">PARPORT_CLASS_NET</span><span class="p">,</span>
	<span class="n">PARPORT_CLASS_HDC</span><span class="p">,</span>              <span class="cm">/* Hard disk controller */</span>
	<span class="n">PARPORT_CLASS_PCMCIA</span><span class="p">,</span>
	<span class="n">PARPORT_CLASS_MEDIA</span><span class="p">,</span>            <span class="cm">/* Multimedia device */</span>
	<span class="n">PARPORT_CLASS_FDC</span><span class="p">,</span>              <span class="cm">/* Floppy disk controller */</span>
	<span class="n">PARPORT_CLASS_PORTS</span><span class="p">,</span>
	<span class="n">PARPORT_CLASS_SCANNER</span><span class="p">,</span>
	<span class="n">PARPORT_CLASS_DIGCAM</span><span class="p">,</span>
	<span class="n">PARPORT_CLASS_OTHER</span><span class="p">,</span>            <span class="cm">/* Anything else */</span>
	<span class="n">PARPORT_CLASS_UNSPEC</span><span class="p">,</span>           <span class="cm">/* No CLS field in ID */</span>
	<span class="n">PARPORT_CLASS_SCSIADAPTER</span>
<span class="p">}</span> <span class="n">parport_device_class</span><span class="p">;</span>

<span class="cm">/* The &quot;modes&quot; entry in parport is a bit field representing the</span>
<span class="cm">   capabilities of the hardware. */</span>
<span class="cp">#define PARPORT_MODE_PCSPP	(1&lt;&lt;0) </span><span class="cm">/* IBM PC registers available. */</span><span class="cp"></span>
<span class="cp">#define PARPORT_MODE_TRISTATE	(1&lt;&lt;1) </span><span class="cm">/* Can tristate. */</span><span class="cp"></span>
<span class="cp">#define PARPORT_MODE_EPP	(1&lt;&lt;2) </span><span class="cm">/* Hardware EPP. */</span><span class="cp"></span>
<span class="cp">#define PARPORT_MODE_ECP	(1&lt;&lt;3) </span><span class="cm">/* Hardware ECP. */</span><span class="cp"></span>
<span class="cp">#define PARPORT_MODE_COMPAT	(1&lt;&lt;4) </span><span class="cm">/* Hardware &#39;printer protocol&#39;. */</span><span class="cp"></span>
<span class="cp">#define PARPORT_MODE_DMA	(1&lt;&lt;5) </span><span class="cm">/* Hardware can DMA. */</span><span class="cp"></span>
<span class="cp">#define PARPORT_MODE_SAFEININT	(1&lt;&lt;6) </span><span class="cm">/* SPP registers accessible in IRQ. */</span><span class="cp"></span>

<span class="cm">/* IEEE1284 modes: </span>
<span class="cm">   Nibble mode, byte mode, ECP, ECPRLE and EPP are their own</span>
<span class="cm">   &#39;extensibility request&#39; values.  Others are special.</span>
<span class="cm">   &#39;Real&#39; ECP modes must have the IEEE1284_MODE_ECP bit set.  */</span>
<span class="cp">#define IEEE1284_MODE_NIBBLE             0</span>
<span class="cp">#define IEEE1284_MODE_BYTE              (1&lt;&lt;0)</span>
<span class="cp">#define IEEE1284_MODE_COMPAT            (1&lt;&lt;8)</span>
<span class="cp">#define IEEE1284_MODE_BECP              (1&lt;&lt;9) </span><span class="cm">/* Bounded ECP mode */</span><span class="cp"></span>
<span class="cp">#define IEEE1284_MODE_ECP               (1&lt;&lt;4)</span>
<span class="cp">#define IEEE1284_MODE_ECPRLE            (IEEE1284_MODE_ECP | (1&lt;&lt;5))</span>
<span class="cp">#define IEEE1284_MODE_ECPSWE            (1&lt;&lt;10) </span><span class="cm">/* Software-emulated */</span><span class="cp"></span>
<span class="cp">#define IEEE1284_MODE_EPP               (1&lt;&lt;6)</span>
<span class="cp">#define IEEE1284_MODE_EPPSL             (1&lt;&lt;11) </span><span class="cm">/* EPP 1.7 */</span><span class="cp"></span>
<span class="cp">#define IEEE1284_MODE_EPPSWE            (1&lt;&lt;12) </span><span class="cm">/* Software-emulated */</span><span class="cp"></span>
<span class="cp">#define IEEE1284_DEVICEID               (1&lt;&lt;2)  </span><span class="cm">/* This is a flag */</span><span class="cp"></span>
<span class="cp">#define IEEE1284_EXT_LINK               (1&lt;&lt;14) </span><span class="cm">/* This flag causes the</span>
<span class="cm">						 * extensibility link to</span>
<span class="cm">						 * be requested, using</span>
<span class="cm">						 * bits 0-6. */</span><span class="cp"></span>

<span class="cm">/* For the benefit of parport_read/write, you can use these with</span>
<span class="cm"> * parport_negotiate to use address operations.  They have no effect</span>
<span class="cm"> * other than to make parport_read/write use address transfers. */</span>
<span class="cp">#define IEEE1284_ADDR			(1&lt;&lt;13)	</span><span class="cm">/* This is a flag */</span><span class="cp"></span>
<span class="cp">#define IEEE1284_DATA			 0	</span><span class="cm">/* So is this */</span><span class="cp"></span>

<span class="cm">/* Flags for block transfer operations. */</span>
<span class="cp">#define PARPORT_EPP_FAST		(1&lt;&lt;0) </span><span class="cm">/* Unreliable counts. */</span><span class="cp"></span>
<span class="cp">#define PARPORT_W91284PIC		(1&lt;&lt;1) </span><span class="cm">/* have a Warp9 w91284pic in the device */</span><span class="cp"></span>

<span class="cm">/* The rest is for the kernel only */</span>
<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/irqreturn.h&gt;</span>
<span class="cp">#include &lt;linux/semaphore.h&gt;</span>
<span class="cp">#include &lt;asm/ptrace.h&gt;</span>

<span class="cm">/* Define this later. */</span>
<span class="k">struct</span> <span class="n">parport</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pardevice</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pc_parport_state</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ax_parport_state</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dcsr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* used by both parport_amiga and parport_mfc3 */</span>
<span class="k">struct</span> <span class="n">amiga_parport_state</span> <span class="p">{</span>
       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>     <span class="cm">/* ciaa.prb */</span>
       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">datadir</span><span class="p">;</span>  <span class="cm">/* ciaa.ddrb */</span>
       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>   <span class="cm">/* ciab.pra &amp; 7 */</span>
       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">statusdir</span><span class="p">;</span><span class="cm">/* ciab.ddrb &amp; 7 */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ax88796_parport_state</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cpr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ip32_parport_state</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dcr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">parport_state</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pc_parport_state</span> <span class="n">pc</span><span class="p">;</span>
		<span class="cm">/* ARC has no state. */</span>
		<span class="k">struct</span> <span class="n">ax_parport_state</span> <span class="n">ax</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">amiga_parport_state</span> <span class="n">amiga</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ax88796_parport_state</span> <span class="n">ax88796</span><span class="p">;</span>
		<span class="cm">/* Atari has not state. */</span>
		<span class="k">struct</span> <span class="n">ip32_parport_state</span> <span class="n">ip32</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">misc</span><span class="p">;</span> 
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">parport_operations</span> <span class="p">{</span>
	<span class="cm">/* IBM PC-style virtual registers. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">read_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_control</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">read_control</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">frob_control</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">read_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* IRQs. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">disable_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Data direction. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">data_forward</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">data_reverse</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* For core parport code. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">save_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">restore_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Block read/write */</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">epp_write_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">epp_read_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">epp_write_addr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">epp_read_addr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">ecp_write_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">ecp_read_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">ecp_write_addr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_write_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nibble_read_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">byte_read_data</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">parport_device_info</span> <span class="p">{</span>
	<span class="n">parport_device_class</span> <span class="n">class</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">class_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mfr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdset</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">description</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Each device can have two callback functions:</span>
<span class="cm"> *  1) a preemption function, called by the resource manager to request</span>
<span class="cm"> *     that the driver relinquish control of the port.  The driver should</span>
<span class="cm"> *     return zero if it agrees to release the port, and nonzero if it </span>
<span class="cm"> *     refuses.  Do not call parport_release() - the kernel will do this</span>
<span class="cm"> *     implicitly.</span>
<span class="cm"> *</span>
<span class="cm"> *  2) a wake-up function, called by the resource manager to tell drivers</span>
<span class="cm"> *     that the port is available to be claimed.  If a driver wants to use</span>
<span class="cm"> *     the port, it should call parport_claim() here.</span>
<span class="cm"> */</span>

<span class="cm">/* A parallel port device */</span>
<span class="k">struct</span> <span class="n">pardevice</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">daisy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">preempt</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wakeup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>     <span class="cm">/* saved status over preemption */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait_q</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">timeslice</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">waiting</span><span class="p">;</span>		 <span class="cm">/* long req&#39;d for set_bit --RR */</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">waitprev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">waitnext</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span> <span class="n">sysctl_table</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* IEEE1284 information */</span>

<span class="cm">/* IEEE1284 phases. These are exposed to userland through ppdev IOCTL</span>
<span class="cm"> * PP[GS]ETPHASE, so do not change existing values. */</span>
<span class="k">enum</span> <span class="n">ieee1284_phase</span> <span class="p">{</span>
	<span class="n">IEEE1284_PH_FWD_DATA</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_TERMINATE</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_NEGOTIATION</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_HBUSY_DNA</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_REV_IDLE</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_HBUSY_DAVAIL</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_REV_DATA</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_ECP_SETUP</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_ECP_FWD_TO_REV</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_ECP_REV_TO_FWD</span><span class="p">,</span>
	<span class="n">IEEE1284_PH_ECP_DIR_UNKNOWN</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ieee1284_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="k">enum</span> <span class="n">ieee1284_phase</span> <span class="n">phase</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">semaphore</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* A parallel port */</span>
<span class="k">struct</span> <span class="n">parport</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">;</span>	<span class="cm">/* base address */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_hi</span><span class="p">;</span>  <span class="cm">/* base address (hi - ECR) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>	<span class="cm">/* IO extent */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">modes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>		<span class="cm">/* interrupt (or -1 for none) */</span>
	<span class="kt">int</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">muxport</span><span class="p">;</span>		<span class="cm">/* which muxport (if any) this is */</span>
	<span class="kt">int</span> <span class="n">portnum</span><span class="p">;</span>		<span class="cm">/* which physical parallel port (not mux) */</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>	<span class="cm">/* Physical device associated with IO/DMA.</span>
<span class="cm">				 * This may unfortulately be null if the</span>
<span class="cm">				 * port has a legacy driver.</span>
<span class="cm">				 */</span>

	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">physport</span><span class="p">;</span>
				<span class="cm">/* If this is a non-default mux</span>
<span class="cm">				   parport, i.e. we&#39;re a clone of a real</span>
<span class="cm">				   physical port, this is a pointer to that</span>
<span class="cm">				   port. The locking is only done in the</span>
<span class="cm">				   real port.  For a clone port, the</span>
<span class="cm">				   following structure members are</span>
<span class="cm">				   meaningless: devices, cad, muxsel,</span>
<span class="cm">				   waithead, waittail, flags, pdir,</span>
<span class="cm">				   dev, ieee1284, *_lock.</span>

<span class="cm">				   It this is a default mux parport, or</span>
<span class="cm">				   there is no mux involved, this points to</span>
<span class="cm">				   ourself. */</span>

	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">devices</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">cad</span><span class="p">;</span>	<span class="cm">/* port owner */</span>
	<span class="kt">int</span> <span class="n">daisy</span><span class="p">;</span>		<span class="cm">/* currently selected daisy addr */</span>
	<span class="kt">int</span> <span class="n">muxsel</span><span class="p">;</span>		<span class="cm">/* currently selected mux port */</span>

	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">waithead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">waittail</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">sysctl_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_device_info</span> <span class="n">probe_info</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="cm">/* 0-3 + non-IEEE1284.3 */</span>
	<span class="k">struct</span> <span class="n">ieee1284_info</span> <span class="n">ieee1284</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">parport_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private_data</span><span class="p">;</span>     <span class="cm">/* for lowlevel driver */</span>

	<span class="kt">int</span> <span class="n">number</span><span class="p">;</span>		<span class="cm">/* port index - the `n&#39; in `parportn&#39; */</span>
	<span class="n">spinlock_t</span> <span class="n">pardevice_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">waitlist_lock</span><span class="p">;</span>
	<span class="n">rwlock_t</span> <span class="n">cad_lock</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">spintime</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">ref_count</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">devflags</span><span class="p">;</span>
<span class="cp">#define PARPORT_DEVPROC_REGISTERED	0</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">proc_device</span><span class="p">;</span>	<span class="cm">/* Currently register proc device */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">full_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">slaves</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define DEFAULT_SPIN_TIME 500 </span><span class="cm">/* us */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">parport_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">attach</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">detach</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* parport_register_port registers a new parallel port at the given</span>
<span class="cm">   address (if one does not already exist) and returns a pointer to it.</span>
<span class="cm">   This entails claiming the I/O region, IRQ and DMA.  NULL is returned</span>
<span class="cm">   if initialisation fails. */</span>
<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">parport_register_port</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">parport_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>

<span class="cm">/* Once a registered port is ready for high-level drivers to use, the</span>
<span class="cm">   low-level driver that registered it should announce it.  This will</span>
<span class="cm">   call the high-level drivers&#39; attach() functions (after things like</span>
<span class="cm">   determining the IEEE 1284.3 topology of the port and collecting</span>
<span class="cm">   DeviceIDs). */</span>
<span class="kt">void</span> <span class="n">parport_announce_port</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>

<span class="cm">/* Unregister a port. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_remove_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>

<span class="cm">/* Register a new high-level driver. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_register_driver</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport_driver</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Unregister a high-level driver. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_unregister_driver</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport_driver</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* If parport_register_driver doesn&#39;t fit your needs, perhaps</span>
<span class="cm"> * parport_find_xxx does. */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">parport_find_number</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">parport_find_base</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cm">/* generic irq handler, if it suits your needs */</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">parport_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="cm">/* Reference counting for ports. */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">parport_get_port</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_put_port</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* parport_register_device declares that a device is connected to a</span>
<span class="cm">   port, and tells the kernel all it needs to know.</span>
<span class="cm">   - pf is the preemption function (may be NULL for no callback)</span>
<span class="cm">   - kf is the wake-up function (may be NULL for no callback)</span>
<span class="cm">   - irq_func is the interrupt handler (may be NULL for no interrupts)</span>
<span class="cm">   - handle is a user pointer that gets handed to callback functions.  */</span>
<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">parport_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> 
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kf</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> 
			  <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>

<span class="cm">/* parport_unregister unlinks a device from the chain. */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* parport_claim tries to gain ownership of the port for a particular</span>
<span class="cm">   driver.  This may fail (return non-zero) if another driver is busy.</span>
<span class="cm">   If this driver has registered an interrupt handler, it will be</span>
<span class="cm">   enabled.  */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_claim</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* parport_claim_or_block is the same, but sleeps if the port cannot</span>
<span class="cm">   be claimed.  Return value is 1 if it slept, 0 normally and -errno</span>
<span class="cm">   on error.  */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_claim_or_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* parport_release reverses a previous parport_claim.  This can never</span>
<span class="cm">   fail, though the effects are undefined (except that they are bad)</span>
<span class="cm">   if you didn&#39;t previously own the port.  Once you have released the</span>
<span class="cm">   port you should make sure that neither your code nor the hardware</span>
<span class="cm">   on the port tries to initiate any communication without first</span>
<span class="cm">   re-claiming the port.  If you mess with the port state (enabling</span>
<span class="cm">   ECP for example) you should clean up before releasing the port. */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * parport_yield - relinquish a parallel port temporarily</span>
<span class="cm"> * @dev: a device on the parallel port</span>
<span class="cm"> *</span>
<span class="cm"> * This function relinquishes the port if it would be helpful to other</span>
<span class="cm"> * drivers to do so.  Afterwards it tries to reclaim the port using</span>
<span class="cm"> * parport_claim(), and the return value is the same as for</span>
<span class="cm"> * parport_claim().  If it fails, the port is left unclaimed and it is</span>
<span class="cm"> * the driver&#39;s responsibility to reclaim the port.</span>
<span class="cm"> *</span>
<span class="cm"> * The parport_yield() and parport_yield_blocking() functions are for</span>
<span class="cm"> * marking points in the driver at which other drivers may claim the</span>
<span class="cm"> * port and use their devices.  Yielding the port is similar to</span>
<span class="cm"> * releasing it and reclaiming it, but is more efficient because no</span>
<span class="cm"> * action is taken if there are no other devices needing the port.  In</span>
<span class="cm"> * fact, nothing is done even if there are other devices waiting but</span>
<span class="cm"> * the current device is still within its &quot;timeslice&quot;.  The default</span>
<span class="cm"> * timeslice is half a second, but it can be adjusted via the /proc</span>
<span class="cm"> * interface.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">parport_yield</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">timeslip</span> <span class="o">=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waithead</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">timeslip</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">timeslice</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">parport_release</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">parport_claim</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_yield_blocking - relinquish a parallel port temporarily</span>
<span class="cm"> * @dev: a device on the parallel port</span>
<span class="cm"> *</span>
<span class="cm"> * This function relinquishes the port if it would be helpful to other</span>
<span class="cm"> * drivers to do so.  Afterwards it tries to reclaim the port using</span>
<span class="cm"> * parport_claim_or_block(), and the return value is the same as for</span>
<span class="cm"> * parport_claim_or_block().</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">parport_yield_blocking</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">timeslip</span> <span class="o">=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waithead</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">timeslip</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">timeslice</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">parport_release</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">parport_claim_or_block</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Flags used to identify what a device does. */</span>
<span class="cp">#define PARPORT_DEV_TRAN		0	</span><span class="cm">/* WARNING !! DEPRECATED !! */</span><span class="cp"></span>
<span class="cp">#define PARPORT_DEV_LURK		(1&lt;&lt;0)	</span><span class="cm">/* WARNING !! DEPRECATED !! */</span><span class="cp"></span>
<span class="cp">#define PARPORT_DEV_EXCL		(1&lt;&lt;1)	</span><span class="cm">/* Need exclusive access. */</span><span class="cp"></span>

<span class="cp">#define PARPORT_FLAG_EXCL		(1&lt;&lt;1)	</span><span class="cm">/* EXCL driver registered. */</span><span class="cp"></span>

<span class="cm">/* IEEE1284 functions */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_ieee1284_interrupt</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_negotiate</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">parport_write</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">parport_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#define PARPORT_INACTIVITY_O_NONBLOCK 1</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">parport_set_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span> <span class="n">inactivity</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_wait_event</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_poll_peripheral</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">usec</span><span class="p">);</span>

<span class="cm">/* For architectural drivers */</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_write_compat</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_read_nibble</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_read_byte</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_ecp_read_data</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					      <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_ecp_write_data</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_ecp_write_addr</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_epp_write_data</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_epp_read_data</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					      <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_epp_write_addr</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">parport_ieee1284_epp_read_addr</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span>
					      <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* IEEE1284.3 functions */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_daisy_init</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_daisy_fini</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">parport_open</span> <span class="p">(</span><span class="kt">int</span> <span class="n">devnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_close</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">parport_device_id</span> <span class="p">(</span><span class="kt">int</span> <span class="n">devnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">parport_daisy_deselect_all</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_daisy_select</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">daisy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>

<span class="cm">/* Lowlevel drivers _can_ call this support function to handle irqs.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_generic_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">parport_ieee1284_interrupt</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">&amp;&amp;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">irq_func</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">irq_func</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Prototypes from parport_procfs */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_proc_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_proc_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_device_proc_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_device_proc_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">device</span><span class="p">);</span>

<span class="cm">/* If PC hardware is the only type supported, we can optimise a bit.  */</span>
<span class="cp">#if !defined(CONFIG_PARPORT_NOT_PC)</span>

<span class="cp">#include &lt;linux/parport_pc.h&gt;</span>
<span class="cp">#define parport_write_data(p,x)            parport_pc_write_data(p,x)</span>
<span class="cp">#define parport_read_data(p)               parport_pc_read_data(p)</span>
<span class="cp">#define parport_write_control(p,x)         parport_pc_write_control(p,x)</span>
<span class="cp">#define parport_read_control(p)            parport_pc_read_control(p)</span>
<span class="cp">#define parport_frob_control(p,m,v)        parport_pc_frob_control(p,m,v)</span>
<span class="cp">#define parport_read_status(p)             parport_pc_read_status(p)</span>
<span class="cp">#define parport_enable_irq(p)              parport_pc_enable_irq(p)</span>
<span class="cp">#define parport_disable_irq(p)             parport_pc_disable_irq(p)</span>
<span class="cp">#define parport_data_forward(p)            parport_pc_data_forward(p)</span>
<span class="cp">#define parport_data_reverse(p)            parport_pc_data_reverse(p)</span>

<span class="cp">#else  </span><span class="cm">/*  !CONFIG_PARPORT_NOT_PC  */</span><span class="cp"></span>

<span class="cm">/* Generic operations vector through the dispatch table. */</span>
<span class="cp">#define parport_write_data(p,x)            (p)-&gt;ops-&gt;write_data(p,x)</span>
<span class="cp">#define parport_read_data(p)               (p)-&gt;ops-&gt;read_data(p)</span>
<span class="cp">#define parport_write_control(p,x)         (p)-&gt;ops-&gt;write_control(p,x)</span>
<span class="cp">#define parport_read_control(p)            (p)-&gt;ops-&gt;read_control(p)</span>
<span class="cp">#define parport_frob_control(p,m,v)        (p)-&gt;ops-&gt;frob_control(p,m,v)</span>
<span class="cp">#define parport_read_status(p)             (p)-&gt;ops-&gt;read_status(p)</span>
<span class="cp">#define parport_enable_irq(p)              (p)-&gt;ops-&gt;enable_irq(p)</span>
<span class="cp">#define parport_disable_irq(p)             (p)-&gt;ops-&gt;disable_irq(p)</span>
<span class="cp">#define parport_data_forward(p)            (p)-&gt;ops-&gt;data_forward(p)</span>
<span class="cp">#define parport_data_reverse(p)            (p)-&gt;ops-&gt;data_reverse(p)</span>

<span class="cp">#endif </span><span class="cm">/*  !CONFIG_PARPORT_NOT_PC  */</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parport_default_timeslice</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">parport_default_spintime</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _PARPORT_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
