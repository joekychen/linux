<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › zorro.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>zorro.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/zorro.h -- Amiga AutoConfig (Zorro) Bus Definitions</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1995--2003 Geert Uytterhoeven</span>
<span class="cm"> *</span>
<span class="cm"> *  This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> *  License.  See the file COPYING in the main directory of this archive</span>
<span class="cm"> *  for more details.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_ZORRO_H</span>
<span class="cp">#define _LINUX_ZORRO_H</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>


    <span class="cm">/*</span>
<span class="cm">     *  Each Zorro board has a 32-bit ID of the form</span>
<span class="cm">     *</span>
<span class="cm">     *      mmmmmmmmmmmmmmmmppppppppeeeeeeee</span>
<span class="cm">     *</span>
<span class="cm">     *  with</span>
<span class="cm">     *</span>
<span class="cm">     *      mmmmmmmmmmmmmmmm	16-bit Manufacturer ID (assigned by CBM (sigh))</span>
<span class="cm">     *      pppppppp		8-bit Product ID (assigned by manufacturer)</span>
<span class="cm">     *      eeeeeeee		8-bit Extended Product ID (currently only used</span>
<span class="cm">     *				for some GVP boards)</span>
<span class="cm">     */</span>


<span class="cp">#define ZORRO_MANUF(id)		((id) &gt;&gt; 16)</span>
<span class="cp">#define ZORRO_PROD(id)		(((id) &gt;&gt; 8) &amp; 0xff)</span>
<span class="cp">#define ZORRO_EPC(id)		((id) &amp; 0xff)</span>

<span class="cp">#define ZORRO_ID(manuf, prod, epc) \</span>
<span class="cp">    ((ZORRO_MANUF_##manuf &lt;&lt; 16) | ((prod) &lt;&lt; 8) | (epc))</span>

<span class="k">typedef</span> <span class="n">__u32</span> <span class="n">zorro_id</span><span class="p">;</span>


<span class="cm">/* Include the ID list */</span>
<span class="cp">#include &lt;linux/zorro_ids.h&gt;</span>


    <span class="cm">/*</span>
<span class="cm">     *  GVP identifies most of its products through the &#39;extended product code&#39;</span>
<span class="cm">     *  (epc). The epc has to be ANDed with the GVP_PRODMASK before the</span>
<span class="cm">     *  identification.</span>
<span class="cm">     */</span>

<span class="cp">#define GVP_PRODMASK			(0xf8)</span>
<span class="cp">#define GVP_SCSICLKMASK			(0x01)</span>

<span class="k">enum</span> <span class="n">GVP_flags</span> <span class="p">{</span>
    <span class="n">GVP_IO</span>		<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
    <span class="n">GVP_ACCEL</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
    <span class="n">GVP_SCSI</span>		<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
    <span class="n">GVP_24BITDMA</span>	<span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
    <span class="n">GVP_25BITDMA</span>	<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
    <span class="n">GVP_NOBANK</span>		<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
    <span class="n">GVP_14MHZ</span>		<span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">struct</span>  <span class="n">Node</span> <span class="o">*</span><span class="n">ln_Succ</span><span class="p">;</span>	<span class="cm">/* Pointer to next (successor) */</span>
    <span class="k">struct</span>  <span class="n">Node</span> <span class="o">*</span><span class="n">ln_Pred</span><span class="p">;</span>	<span class="cm">/* Pointer to previous (predecessor) */</span>
    <span class="n">__u8</span>    <span class="n">ln_Type</span><span class="p">;</span>
    <span class="n">__s8</span>    <span class="n">ln_Pri</span><span class="p">;</span>		<span class="cm">/* Priority, for sorting */</span>
    <span class="n">__s8</span>    <span class="o">*</span><span class="n">ln_Name</span><span class="p">;</span>		<span class="cm">/* ID string, null terminated */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">ExpansionRom</span> <span class="p">{</span>
    <span class="cm">/* -First 16 bytes of the expansion ROM */</span>
    <span class="n">__u8</span>  <span class="n">er_Type</span><span class="p">;</span>		<span class="cm">/* Board type, size and flags */</span>
    <span class="n">__u8</span>  <span class="n">er_Product</span><span class="p">;</span>		<span class="cm">/* Product number, assigned by manufacturer */</span>
    <span class="n">__u8</span>  <span class="n">er_Flags</span><span class="p">;</span>		<span class="cm">/* Flags */</span>
    <span class="n">__u8</span>  <span class="n">er_Reserved03</span><span class="p">;</span>	<span class="cm">/* Must be zero ($ff inverted) */</span>
    <span class="n">__u16</span> <span class="n">er_Manufacturer</span><span class="p">;</span>	<span class="cm">/* Unique ID, ASSIGNED BY COMMODORE-AMIGA! */</span>
    <span class="n">__u32</span> <span class="n">er_SerialNumber</span><span class="p">;</span>	<span class="cm">/* Available for use by manufacturer */</span>
    <span class="n">__u16</span> <span class="n">er_InitDiagVec</span><span class="p">;</span>	<span class="cm">/* Offset to optional &quot;DiagArea&quot; structure */</span>
    <span class="n">__u8</span>  <span class="n">er_Reserved0c</span><span class="p">;</span>
    <span class="n">__u8</span>  <span class="n">er_Reserved0d</span><span class="p">;</span>
    <span class="n">__u8</span>  <span class="n">er_Reserved0e</span><span class="p">;</span>
    <span class="n">__u8</span>  <span class="n">er_Reserved0f</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* er_Type board type bits */</span>
<span class="cp">#define ERT_TYPEMASK	0xc0</span>
<span class="cp">#define ERT_ZORROII	0xc0</span>
<span class="cp">#define ERT_ZORROIII	0x80</span>

<span class="cm">/* other bits defined in er_Type */</span>
<span class="cp">#define ERTB_MEMLIST	5		</span><span class="cm">/* Link RAM into free memory list */</span><span class="cp"></span>
<span class="cp">#define ERTF_MEMLIST	(1&lt;&lt;5)</span>

<span class="k">struct</span> <span class="n">ConfigDev</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Node</span>		<span class="n">cd_Node</span><span class="p">;</span>
    <span class="n">__u8</span>		<span class="n">cd_Flags</span><span class="p">;</span>	<span class="cm">/* (read/write) */</span>
    <span class="n">__u8</span>		<span class="n">cd_Pad</span><span class="p">;</span>		<span class="cm">/* reserved */</span>
    <span class="k">struct</span> <span class="n">ExpansionRom</span> <span class="n">cd_Rom</span><span class="p">;</span>		<span class="cm">/* copy of board&#39;s expansion ROM */</span>
    <span class="kt">void</span>		<span class="o">*</span><span class="n">cd_BoardAddr</span><span class="p">;</span>	<span class="cm">/* where in memory the board was placed */</span>
    <span class="n">__u32</span>		<span class="n">cd_BoardSize</span><span class="p">;</span>	<span class="cm">/* size of board in bytes */</span>
    <span class="n">__u16</span>		<span class="n">cd_SlotAddr</span><span class="p">;</span>	<span class="cm">/* which slot number (PRIVATE) */</span>
    <span class="n">__u16</span>		<span class="n">cd_SlotSize</span><span class="p">;</span>	<span class="cm">/* number of slots (PRIVATE) */</span>
    <span class="kt">void</span>		<span class="o">*</span><span class="n">cd_Driver</span><span class="p">;</span>	<span class="cm">/* pointer to node of driver */</span>
    <span class="k">struct</span> <span class="n">ConfigDev</span>	<span class="o">*</span><span class="n">cd_NextCD</span><span class="p">;</span>	<span class="cm">/* linked list of drivers to config */</span>
    <span class="n">__u32</span>		<span class="n">cd_Unused</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* for whatever the driver wants */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define ZORRO_NUM_AUTO		16</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/mod_devicetable.h&gt;</span>

<span class="cp">#include &lt;asm/zorro.h&gt;</span>


    <span class="cm">/*</span>
<span class="cm">     *  Zorro devices</span>
<span class="cm">     */</span>

<span class="k">struct</span> <span class="n">zorro_dev</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">ExpansionRom</span> <span class="n">rom</span><span class="p">;</span>
    <span class="n">zorro_id</span> <span class="n">id</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zorro_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>	<span class="cm">/* which driver has allocated this device */</span>
    <span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>			<span class="cm">/* Generic device interface */</span>
    <span class="n">u16</span> <span class="n">slotaddr</span><span class="p">;</span>
    <span class="n">u16</span> <span class="n">slotsize</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">resource</span> <span class="n">resource</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	to_zorro_dev(n)	container_of(n, struct zorro_dev, dev)</span>


    <span class="cm">/*</span>
<span class="cm">     *  Zorro bus</span>
<span class="cm">     */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">zorro_bus_type</span><span class="p">;</span>


    <span class="cm">/*</span>
<span class="cm">     *  Zorro device drivers</span>
<span class="cm">     */</span>

<span class="k">struct</span> <span class="n">zorro_driver</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">zorro_device_id</span> <span class="o">*</span><span class="n">id_table</span><span class="p">;</span>	<span class="cm">/* NULL if wants all devices */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">zorro_dev</span> <span class="o">*</span><span class="n">z</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">zorro_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>	<span class="cm">/* New device inserted */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">zorro_dev</span> <span class="o">*</span><span class="n">z</span><span class="p">);</span>	<span class="cm">/* Device removed (NULL if not a hot-plug capable driver) */</span>
    <span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	to_zorro_driver(drv)	container_of(drv, struct zorro_driver, driver)</span>


<span class="cp">#define zorro_for_each_dev(dev)	\</span>
<span class="cp">	for (dev = &amp;zorro_autocon[0]; dev &lt; zorro_autocon+zorro_num_autocon; dev++)</span>


<span class="cm">/* New-style probing */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">zorro_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">zorro_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">zorro_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">zorro_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">zorro_device_id</span> <span class="o">*</span><span class="n">zorro_match_device</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">zorro_device_id</span> <span class="o">*</span><span class="n">ids</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">zorro_dev</span> <span class="o">*</span><span class="n">z</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">zorro_driver</span> <span class="o">*</span><span class="nf">zorro_dev_driver</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">zorro_dev</span> <span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">zorro_num_autocon</span><span class="p">;</span>	<span class="cm">/* # of autoconfig devices found */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">zorro_dev</span> <span class="n">zorro_autocon</span><span class="p">[</span><span class="n">ZORRO_NUM_AUTO</span><span class="p">];</span>


    <span class="cm">/*</span>
<span class="cm">     *  Zorro Functions</span>
<span class="cm">     */</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">zorro_dev</span> <span class="o">*</span><span class="n">zorro_find_device</span><span class="p">(</span><span class="n">zorro_id</span> <span class="n">id</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">zorro_dev</span> <span class="o">*</span><span class="n">from</span><span class="p">);</span>

<span class="cp">#define zorro_resource_start(z)	((z)-&gt;resource.start)</span>
<span class="cp">#define zorro_resource_end(z)	((z)-&gt;resource.end)</span>
<span class="cp">#define zorro_resource_len(z)	(resource_size(&amp;(z)-&gt;resource))</span>
<span class="cp">#define zorro_resource_flags(z)	((z)-&gt;resource.flags)</span>

<span class="cp">#define zorro_request_device(z, name) \</span>
<span class="cp">    request_mem_region(zorro_resource_start(z), zorro_resource_len(z), name)</span>
<span class="cp">#define zorro_release_device(z) \</span>
<span class="cp">    release_mem_region(zorro_resource_start(z), zorro_resource_len(z))</span>

<span class="cm">/* Similar to the helpers above, these manipulate per-zorro_dev</span>
<span class="cm"> * driver-specific data.  They are really just a wrapper around</span>
<span class="cm"> * the generic device structure functions of these calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">zorro_get_drvdata</span> <span class="p">(</span><span class="k">struct</span> <span class="n">zorro_dev</span> <span class="o">*</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">zorro_set_drvdata</span> <span class="p">(</span><span class="k">struct</span> <span class="n">zorro_dev</span> <span class="o">*</span><span class="n">z</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>


    <span class="cm">/*</span>
<span class="cm">     *  Bitmask indicating portions of available Zorro II RAM that are unused</span>
<span class="cm">     *  by the system. Every bit represents a 64K chunk, for a maximum of 8MB</span>
<span class="cm">     *  (128 chunks, physical 0x00200000-0x009fffff).</span>
<span class="cm">     *</span>
<span class="cm">     *  If you want to use (= allocate) portions of this RAM, you should clear</span>
<span class="cm">     *  the corresponding bits.</span>
<span class="cm">     */</span>

<span class="k">extern</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">zorro_unused_z2ram</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

<span class="cp">#define Z2RAM_START		(0x00200000)</span>
<span class="cp">#define Z2RAM_END		(0x00a00000)</span>
<span class="cp">#define Z2RAM_SIZE		(0x00800000)</span>
<span class="cp">#define Z2RAM_CHUNKSIZE		(0x00010000)</span>
<span class="cp">#define Z2RAM_CHUNKMASK		(0x0000ffff)</span>
<span class="cp">#define Z2RAM_CHUNKSHIFT	(16)</span>


<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_ZORRO_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
