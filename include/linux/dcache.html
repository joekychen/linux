<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › dcache.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dcache.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_DCACHE_H</span>
<span class="cp">#define __LINUX_DCACHE_H</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/rculist_bl.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/seqlock.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="k">struct</span> <span class="n">nameidata</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">path</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vfsmount</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * linux/include/linux/dcache.h</span>
<span class="cm"> *</span>
<span class="cm"> * Dirent cache data structures</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 1997 Thomas Schoebel-Theuer,</span>
<span class="cm"> * with heavy changes by Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#define IS_ROOT(x) ((x) == (x)-&gt;d_parent)</span>

<span class="cm">/* The hash is always the low bits of hash_len */</span>
<span class="cp">#ifdef __LITTLE_ENDIAN</span>
 <span class="cp">#define HASH_LEN_DECLARE u32 hash; u32 len;</span>
<span class="cp">#else</span>
 <span class="cp">#define HASH_LEN_DECLARE u32 len; u32 hash;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * &quot;quick string&quot; -- eases parameter passing, but more importantly</span>
<span class="cm"> * saves &quot;metadata&quot; about the string (ie length and the hash).</span>
<span class="cm"> *</span>
<span class="cm"> * hash comes first so it snuggles against d_parent in the</span>
<span class="cm"> * dentry.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qstr</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">HASH_LEN_DECLARE</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="n">u64</span> <span class="n">hash_len</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define QSTR_INIT(n,l) { { { .len = l } }, .name = n }</span>
<span class="cp">#define hashlen_hash(hashlen) ((u32) (hashlen))</span>
<span class="cp">#define hashlen_len(hashlen)  ((u32)((hashlen) &gt;&gt; 32))</span>

<span class="k">struct</span> <span class="n">dentry_stat_t</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_unused</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">age_limit</span><span class="p">;</span>          <span class="cm">/* age in seconds */</span>
	<span class="kt">int</span> <span class="n">want_pages</span><span class="p">;</span>         <span class="cm">/* pages requested by system */</span>
	<span class="kt">int</span> <span class="n">dummy</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry_stat_t</span> <span class="n">dentry_stat</span><span class="p">;</span>

<span class="cm">/* Name hashing routines. Initial hash value */</span>
<span class="cm">/* Hash courtesy of the R5 hash in reiserfs modulo sign bits */</span>
<span class="cp">#define init_name_hash()		0</span>

<span class="cm">/* partial hash update function. Assume roughly 4 bits per character */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">partial_name_hash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">c</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prevhash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">prevhash</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">*</span> <span class="mi">11</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finally: cut down the number of bits to a int value (and try to avoid</span>
<span class="cm"> * losing bits)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">end_name_hash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compute the hash for a name string. */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Try to keep struct dentry aligned on 64 byte cachelines (this will</span>
<span class="cm"> * give reasonable cacheline footprint with larger lines without the</span>
<span class="cm"> * large memory footprint increase).</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
<span class="cp"># define DNAME_INLINE_LEN 32 </span><span class="cm">/* 192 bytes */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp"># ifdef CONFIG_SMP</span>
<span class="cp">#  define DNAME_INLINE_LEN 36 </span><span class="cm">/* 128 bytes */</span><span class="cp"></span>
<span class="cp"># else</span>
<span class="cp">#  define DNAME_INLINE_LEN 40 </span><span class="cm">/* 128 bytes */</span><span class="cp"></span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
	<span class="cm">/* RCU lookup touched fields */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_flags</span><span class="p">;</span>		<span class="cm">/* protected by d_lock */</span>
	<span class="n">seqcount_t</span> <span class="n">d_seq</span><span class="p">;</span>		<span class="cm">/* per dentry seqlock */</span>
	<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="n">d_hash</span><span class="p">;</span>	<span class="cm">/* lookup hash list */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_parent</span><span class="p">;</span>	<span class="cm">/* parent directory */</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">d_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">d_inode</span><span class="p">;</span>		<span class="cm">/* Where the name belongs to - NULL is</span>
<span class="cm">					 * negative */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN</span><span class="p">];</span>	<span class="cm">/* small names */</span>

	<span class="cm">/* Ref lookup also touches following */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_count</span><span class="p">;</span>		<span class="cm">/* protected by d_lock */</span>
	<span class="n">spinlock_t</span> <span class="n">d_lock</span><span class="p">;</span>		<span class="cm">/* per dentry lock */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">d_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">d_sb</span><span class="p">;</span>	<span class="cm">/* The root of the dentry tree */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">d_time</span><span class="p">;</span>		<span class="cm">/* used by d_revalidate */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">d_fsdata</span><span class="p">;</span>			<span class="cm">/* fs-specific data */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_lru</span><span class="p">;</span>		<span class="cm">/* LRU list */</span>
	<span class="cm">/*</span>
<span class="cm">	 * d_child and d_rcu can share memory</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_child</span><span class="p">;</span>	<span class="cm">/* child of parent list */</span>
	 	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">d_rcu</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">d_u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_subdirs</span><span class="p">;</span>	<span class="cm">/* our children */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_alias</span><span class="p">;</span>	<span class="cm">/* inode alias list */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * dentry-&gt;d_lock spinlock nesting subclasses:</span>
<span class="cm"> *</span>
<span class="cm"> * 0: normal</span>
<span class="cm"> * 1: nested</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">dentry_d_lock_class</span>
<span class="p">{</span>
	<span class="n">DENTRY_D_LOCK_NORMAL</span><span class="p">,</span> <span class="cm">/* implicitly used by plain spin_lock() APIs. */</span>
	<span class="n">DENTRY_D_LOCK_NESTED</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dentry_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">d_revalidate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">d_hash</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">d_compare</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">d_delete</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">d_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">d_prune</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">d_iput</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">d_dname</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">d_automount</span><span class="p">)(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">d_manage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
<span class="p">}</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Locking rules for dentry_operations callbacks are to be found in</span>
<span class="cm"> * Documentation/filesystems/Locking. Keep it updated!</span>
<span class="cm"> *</span>
<span class="cm"> * FUrther descriptions are found in Documentation/filesystems/vfs.txt.</span>
<span class="cm"> * Keep it updated too!</span>
<span class="cm"> */</span>

<span class="cm">/* d_flags entries */</span>
<span class="cp">#define DCACHE_OP_HASH		0x0001</span>
<span class="cp">#define DCACHE_OP_COMPARE	0x0002</span>
<span class="cp">#define DCACHE_OP_REVALIDATE	0x0004</span>
<span class="cp">#define DCACHE_OP_DELETE	0x0008</span>
<span class="cp">#define DCACHE_OP_PRUNE         0x0010</span>

<span class="cp">#define	DCACHE_DISCONNECTED	0x0020</span>
     <span class="cm">/* This dentry is possibly not currently connected to the dcache tree, in</span>
<span class="cm">      * which case its parent will either be itself, or will have this flag as</span>
<span class="cm">      * well.  nfsd will not use a dentry with this bit set, but will first</span>
<span class="cm">      * endeavour to clear the bit either by discovering that it is connected,</span>
<span class="cm">      * or by performing lookup operations.   Any filesystem which supports</span>
<span class="cm">      * nfsd_operations MUST have a lookup function which, if it finds a</span>
<span class="cm">      * directory inode with a DCACHE_DISCONNECTED dentry, will d_move that</span>
<span class="cm">      * dentry into place and return that dentry rather than the passed one,</span>
<span class="cm">      * typically using d_splice_alias. */</span>

<span class="cp">#define DCACHE_REFERENCED	0x0040  </span><span class="cm">/* Recently used, don&#39;t discard. */</span><span class="cp"></span>
<span class="cp">#define DCACHE_RCUACCESS	0x0080	</span><span class="cm">/* Entry has ever been RCU-visible */</span><span class="cp"></span>

<span class="cp">#define DCACHE_CANT_MOUNT	0x0100</span>
<span class="cp">#define DCACHE_GENOCIDE		0x0200</span>
<span class="cp">#define DCACHE_SHRINK_LIST	0x0400</span>

<span class="cp">#define DCACHE_NFSFS_RENAMED	0x1000</span>
     <span class="cm">/* this dentry has been &quot;silly renamed&quot; and has to be deleted on the last</span>
<span class="cm">      * dput() */</span>
<span class="cp">#define DCACHE_COOKIE		0x2000	</span><span class="cm">/* For use by dcookie subsystem */</span><span class="cp"></span>
<span class="cp">#define DCACHE_FSNOTIFY_PARENT_WATCHED 0x4000</span>
     <span class="cm">/* Parent inode is watched by some fsnotify listener */</span>

<span class="cp">#define DCACHE_MOUNTED		0x10000	</span><span class="cm">/* is a mountpoint */</span><span class="cp"></span>
<span class="cp">#define DCACHE_NEED_AUTOMOUNT	0x20000	</span><span class="cm">/* handle automount on this dir */</span><span class="cp"></span>
<span class="cp">#define DCACHE_MANAGE_TRANSIT	0x40000	</span><span class="cm">/* manage transit from this dirent */</span><span class="cp"></span>
<span class="cp">#define DCACHE_NEED_LOOKUP	0x80000 </span><span class="cm">/* dentry requires i_op-&gt;lookup */</span><span class="cp"></span>
<span class="cp">#define DCACHE_MANAGED_DENTRY \</span>
<span class="cp">	(DCACHE_MOUNTED|DCACHE_NEED_AUTOMOUNT|DCACHE_MANAGE_TRANSIT)</span>

<span class="k">extern</span> <span class="n">seqlock_t</span> <span class="n">rename_lock</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dname_external</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are the low-level FS interfaces to the dcache..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d_instantiate_unique</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d_materialise_unique</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__d_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_set_d_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>

<span class="cm">/* allocate/de-allocate */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d_alloc_pseudo</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d_splice_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d_add_ci</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_find_any_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d_obtain_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">shrink_dcache_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">shrink_dcache_for_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">d_invalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* only used at mount-time */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">d_make_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* &lt;clickety&gt;-&lt;click&gt; the ramfs-type tree */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_genocide</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_find_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_prune_aliases</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* test whether we have any submounts in a subdir tree */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">have_submounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This adds the entry to the hash queues.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_add - add dentry to hash queues</span>
<span class="cm"> * @entry: dentry to add</span>
<span class="cm"> * @inode: The inode to attach to this dentry</span>
<span class="cm"> *</span>
<span class="cm"> * This adds the entry to the hash queues and initializes @inode.</span>
<span class="cm"> * The entry was actually filled in earlier during d_alloc().</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">d_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">d_rehash</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_add_unique - add dentry to hash queues without aliasing</span>
<span class="cm"> * @entry: dentry to add</span>
<span class="cm"> * @inode: The inode to attach to this dentry</span>
<span class="cm"> *</span>
<span class="cm"> * This adds the entry to the hash queues and initializes @inode.</span>
<span class="cm"> * The entry was actually filled in earlier during d_alloc().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_add_unique</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">d_instantiate_unique</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">d_rehash</span><span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="n">entry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">dentry_update_name_case</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* used for rename() and baskets */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_ancestor</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* appendix may either be NULL or be used for transname suffixes */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_hash_and_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">__d_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">__d_lookup_rcu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __d_rcu_to_refcount - take a refcount on dentry if sequence check is ok</span>
<span class="cm"> * @dentry: dentry to take a ref on</span>
<span class="cm"> * @seq: seqcount to verify against</span>
<span class="cm"> * Returns: 0 on failure, else 1.</span>
<span class="cm"> *</span>
<span class="cm"> * __d_rcu_to_refcount operates on a dentry,seq pair that was returned</span>
<span class="cm"> * by __d_lookup_rcu, to get a reference on an rcu-walk dentry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__d_rcu_to_refcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* validate &quot;insecure&quot; dentry pointer */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">d_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * helper function for dentry_operations.d_dname() members</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dynamic_dname</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__d_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d_absolute_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d_path_with_unreachable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dentry_path_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dentry_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* Allocation counts.. */</span>

<span class="cm">/**</span>
<span class="cm"> *	dget, dget_dlock -	get a reference to a dentry</span>
<span class="cm"> *	@dentry: dentry to get a reference to</span>
<span class="cm"> *</span>
<span class="cm"> *	Given a dentry or %NULL pointer increment the reference count</span>
<span class="cm"> *	if appropriate and return the dentry. A dentry will not be </span>
<span class="cm"> *	destroyed when it has references.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">dget_dlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">dget</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">dget_dlock</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dget_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	d_unhashed -	is dentry hashed</span>
<span class="cm"> *	@dentry: entry to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if the dentry passed is not currently hashed.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">d_unhashed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hlist_bl_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">d_unlinked</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cant_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_CANT_MOUNT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dont_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_CANT_MOUNT</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">dput</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">d_managed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_MANAGED_DENTRY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">d_mountpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_MOUNTED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">d_need_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NEED_LOOKUP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">d_clear_need_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">sysctl_vfs_cache_pressure</span><span class="p">;</span>

<span class="cp">#endif	</span><span class="cm">/* __LINUX_DCACHE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
