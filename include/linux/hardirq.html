<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › hardirq.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hardirq.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef LINUX_HARDIRQ_H</span>
<span class="cp">#define LINUX_HARDIRQ_H</span>

<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;linux/lockdep.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace_irq.h&gt;</span>
<span class="cp">#include &lt;asm/hardirq.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * We put the hardirq and softirq counter into the preemption</span>
<span class="cm"> * counter. The bitmask has the following meaning:</span>
<span class="cm"> *</span>
<span class="cm"> * - bits 0-7 are the preemption count (max preemption depth: 256)</span>
<span class="cm"> * - bits 8-15 are the softirq count (max # of softirqs: 256)</span>
<span class="cm"> *</span>
<span class="cm"> * The hardirq count can in theory reach the same as NR_IRQS.</span>
<span class="cm"> * In reality, the number of nested IRQS is limited to the stack</span>
<span class="cm"> * size as well. For archs with over 1000 IRQS it is not practical</span>
<span class="cm"> * to expect that they will all nest. We give a max of 10 bits for</span>
<span class="cm"> * hardirq nesting. An arch may choose to give less than 10 bits.</span>
<span class="cm"> * m68k expects it to be 8.</span>
<span class="cm"> *</span>
<span class="cm"> * - bits 16-25 are the hardirq count (max # of nested hardirqs: 1024)</span>
<span class="cm"> * - bit 26 is the NMI_MASK</span>
<span class="cm"> * - bit 28 is the PREEMPT_ACTIVE flag</span>
<span class="cm"> *</span>
<span class="cm"> * PREEMPT_MASK: 0x000000ff</span>
<span class="cm"> * SOFTIRQ_MASK: 0x0000ff00</span>
<span class="cm"> * HARDIRQ_MASK: 0x03ff0000</span>
<span class="cm"> *     NMI_MASK: 0x04000000</span>
<span class="cm"> */</span>
<span class="cp">#define PREEMPT_BITS	8</span>
<span class="cp">#define SOFTIRQ_BITS	8</span>
<span class="cp">#define NMI_BITS	1</span>

<span class="cp">#define MAX_HARDIRQ_BITS 10</span>

<span class="cp">#ifndef HARDIRQ_BITS</span>
<span class="cp"># define HARDIRQ_BITS	MAX_HARDIRQ_BITS</span>
<span class="cp">#endif</span>

<span class="cp">#if HARDIRQ_BITS &gt; MAX_HARDIRQ_BITS</span>
<span class="cp">#error HARDIRQ_BITS too high!</span>
<span class="cp">#endif</span>

<span class="cp">#define PREEMPT_SHIFT	0</span>
<span class="cp">#define SOFTIRQ_SHIFT	(PREEMPT_SHIFT + PREEMPT_BITS)</span>
<span class="cp">#define HARDIRQ_SHIFT	(SOFTIRQ_SHIFT + SOFTIRQ_BITS)</span>
<span class="cp">#define NMI_SHIFT	(HARDIRQ_SHIFT + HARDIRQ_BITS)</span>

<span class="cp">#define __IRQ_MASK(x)	((1UL &lt;&lt; (x))-1)</span>

<span class="cp">#define PREEMPT_MASK	(__IRQ_MASK(PREEMPT_BITS) &lt;&lt; PREEMPT_SHIFT)</span>
<span class="cp">#define SOFTIRQ_MASK	(__IRQ_MASK(SOFTIRQ_BITS) &lt;&lt; SOFTIRQ_SHIFT)</span>
<span class="cp">#define HARDIRQ_MASK	(__IRQ_MASK(HARDIRQ_BITS) &lt;&lt; HARDIRQ_SHIFT)</span>
<span class="cp">#define NMI_MASK	(__IRQ_MASK(NMI_BITS)     &lt;&lt; NMI_SHIFT)</span>

<span class="cp">#define PREEMPT_OFFSET	(1UL &lt;&lt; PREEMPT_SHIFT)</span>
<span class="cp">#define SOFTIRQ_OFFSET	(1UL &lt;&lt; SOFTIRQ_SHIFT)</span>
<span class="cp">#define HARDIRQ_OFFSET	(1UL &lt;&lt; HARDIRQ_SHIFT)</span>
<span class="cp">#define NMI_OFFSET	(1UL &lt;&lt; NMI_SHIFT)</span>

<span class="cp">#define SOFTIRQ_DISABLE_OFFSET	(2 * SOFTIRQ_OFFSET)</span>

<span class="cp">#ifndef PREEMPT_ACTIVE</span>
<span class="cp">#define PREEMPT_ACTIVE_BITS	1</span>
<span class="cp">#define PREEMPT_ACTIVE_SHIFT	(NMI_SHIFT + NMI_BITS)</span>
<span class="cp">#define PREEMPT_ACTIVE	(__IRQ_MASK(PREEMPT_ACTIVE_BITS) &lt;&lt; PREEMPT_ACTIVE_SHIFT)</span>
<span class="cp">#endif</span>

<span class="cp">#if PREEMPT_ACTIVE &lt; (1 &lt;&lt; (NMI_SHIFT + NMI_BITS))</span>
<span class="cp">#error PREEMPT_ACTIVE is too low!</span>
<span class="cp">#endif</span>

<span class="cp">#define hardirq_count()	(preempt_count() &amp; HARDIRQ_MASK)</span>
<span class="cp">#define softirq_count()	(preempt_count() &amp; SOFTIRQ_MASK)</span>
<span class="cp">#define irq_count()	(preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span>
<span class="cp">				 | NMI_MASK))</span>

<span class="cm">/*</span>
<span class="cm"> * Are we doing bottom half or hardware interrupt processing?</span>
<span class="cm"> * Are we in a softirq context? Interrupt context?</span>
<span class="cm"> * in_softirq - Are we currently processing softirq or have bh disabled?</span>
<span class="cm"> * in_serving_softirq - Are we currently processing softirq?</span>
<span class="cm"> */</span>
<span class="cp">#define in_irq()		(hardirq_count())</span>
<span class="cp">#define in_softirq()		(softirq_count())</span>
<span class="cp">#define in_interrupt()		(irq_count())</span>
<span class="cp">#define in_serving_softirq()	(softirq_count() &amp; SOFTIRQ_OFFSET)</span>

<span class="cm">/*</span>
<span class="cm"> * Are we in NMI context?</span>
<span class="cm"> */</span>
<span class="cp">#define in_nmi()	(preempt_count() &amp; NMI_MASK)</span>

<span class="cp">#if defined(CONFIG_PREEMPT_COUNT)</span>
<span class="cp"># define PREEMPT_CHECK_OFFSET 1</span>
<span class="cp">#else</span>
<span class="cp"># define PREEMPT_CHECK_OFFSET 0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Are we running in atomic context?  WARNING: this macro cannot</span>
<span class="cm"> * always detect atomic context; in particular, it cannot know about</span>
<span class="cm"> * held spinlocks in non-preemptible kernels.  Thus it should not be</span>
<span class="cm"> * used in the general case to determine whether sleeping is possible.</span>
<span class="cm"> * Do not use in_atomic() in driver code.</span>
<span class="cm"> */</span>
<span class="cp">#define in_atomic()	((preempt_count() &amp; ~PREEMPT_ACTIVE) != 0)</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether we were atomic before we did preempt_disable():</span>
<span class="cm"> * (used by the scheduler, *after* releasing the kernel lock)</span>
<span class="cm"> */</span>
<span class="cp">#define in_atomic_preempt_off() \</span>
<span class="cp">		((preempt_count() &amp; ~PREEMPT_ACTIVE) != PREEMPT_CHECK_OFFSET)</span>

<span class="cp">#ifdef CONFIG_PREEMPT_COUNT</span>
<span class="cp"># define preemptible()	(preempt_count() == 0 &amp;&amp; !irqs_disabled())</span>
<span class="cp"># define IRQ_EXIT_OFFSET (HARDIRQ_OFFSET-1)</span>
<span class="cp">#else</span>
<span class="cp"># define preemptible()	0</span>
<span class="cp"># define IRQ_EXIT_OFFSET HARDIRQ_OFFSET</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_SMP) || defined(CONFIG_GENERIC_HARDIRQS)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">synchronize_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp"># define synchronize_irq(irq)	barrier()</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">task_struct</span><span class="p">;</span>

<span class="cp">#if !defined(CONFIG_VIRT_CPU_ACCOUNTING) &amp;&amp; !defined(CONFIG_IRQ_TIME_ACCOUNTING)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">account_system_vtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">account_system_vtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_TINY_RCU) || defined(CONFIG_TINY_PREEMPT_RCU)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_nmi_enter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rcu_nmi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rcu_nmi_enter</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">rcu_nmi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * It is safe to do non-atomic ops on -&gt;hardirq_context,</span>
<span class="cm"> * because NMI handlers may not preempt and the ops are</span>
<span class="cm"> * always balanced, so the interrupted value of -&gt;hardirq_context</span>
<span class="cm"> * will always be restored.</span>
<span class="cm"> */</span>
<span class="cp">#define __irq_enter()					\</span>
<span class="cp">	do {						\</span>
<span class="cp">		account_system_vtime(current);		\</span>
<span class="cp">		add_preempt_count(HARDIRQ_OFFSET);	\</span>
<span class="cp">		trace_hardirq_enter();			\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Enter irq context (on NO_HZ, update jiffies):</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">irq_enter</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Exit irq context without processing softirqs:</span>
<span class="cm"> */</span>
<span class="cp">#define __irq_exit()					\</span>
<span class="cp">	do {						\</span>
<span class="cp">		trace_hardirq_exit();			\</span>
<span class="cp">		account_system_vtime(current);		\</span>
<span class="cp">		sub_preempt_count(HARDIRQ_OFFSET);	\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Exit irq context and process softirqs if needed:</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">irq_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define nmi_enter()						\</span>
<span class="cp">	do {							\</span>
<span class="cp">		ftrace_nmi_enter();				\</span>
<span class="cp">		BUG_ON(in_nmi());				\</span>
<span class="cp">		add_preempt_count(NMI_OFFSET + HARDIRQ_OFFSET);	\</span>
<span class="cp">		lockdep_off();					\</span>
<span class="cp">		rcu_nmi_enter();				\</span>
<span class="cp">		trace_hardirq_enter();				\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define nmi_exit()						\</span>
<span class="cp">	do {							\</span>
<span class="cp">		trace_hardirq_exit();				\</span>
<span class="cp">		rcu_nmi_exit();					\</span>
<span class="cp">		lockdep_on();					\</span>
<span class="cp">		BUG_ON(!in_nmi());				\</span>
<span class="cp">		sub_preempt_count(NMI_OFFSET + HARDIRQ_OFFSET);	\</span>
<span class="cp">		ftrace_nmi_exit();				\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#endif </span><span class="cm">/* LINUX_HARDIRQ_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
