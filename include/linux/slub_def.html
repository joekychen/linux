<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › slub_def.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>slub_def.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_SLUB_DEF_H</span>
<span class="cp">#define _LINUX_SLUB_DEF_H</span>

<span class="cm">/*</span>
<span class="cm"> * SLUB : A Slab allocator without object queues.</span>
<span class="cm"> *</span>
<span class="cm"> * (C) 2007 SGI, Christoph Lameter</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>

<span class="cp">#include &lt;linux/kmemleak.h&gt;</span>

<span class="k">enum</span> <span class="n">stat_item</span> <span class="p">{</span>
	<span class="n">ALLOC_FASTPATH</span><span class="p">,</span>		<span class="cm">/* Allocation from cpu slab */</span>
	<span class="n">ALLOC_SLOWPATH</span><span class="p">,</span>		<span class="cm">/* Allocation by getting a new cpu slab */</span>
	<span class="n">FREE_FASTPATH</span><span class="p">,</span>		<span class="cm">/* Free to cpu slub */</span>
	<span class="n">FREE_SLOWPATH</span><span class="p">,</span>		<span class="cm">/* Freeing not to cpu slab */</span>
	<span class="n">FREE_FROZEN</span><span class="p">,</span>		<span class="cm">/* Freeing to frozen slab */</span>
	<span class="n">FREE_ADD_PARTIAL</span><span class="p">,</span>	<span class="cm">/* Freeing moves slab to partial list */</span>
	<span class="n">FREE_REMOVE_PARTIAL</span><span class="p">,</span>	<span class="cm">/* Freeing removes last object */</span>
	<span class="n">ALLOC_FROM_PARTIAL</span><span class="p">,</span>	<span class="cm">/* Cpu slab acquired from node partial list */</span>
	<span class="n">ALLOC_SLAB</span><span class="p">,</span>		<span class="cm">/* Cpu slab acquired from page allocator */</span>
	<span class="n">ALLOC_REFILL</span><span class="p">,</span>		<span class="cm">/* Refill cpu slab from slab freelist */</span>
	<span class="n">ALLOC_NODE_MISMATCH</span><span class="p">,</span>	<span class="cm">/* Switching cpu slab */</span>
	<span class="n">FREE_SLAB</span><span class="p">,</span>		<span class="cm">/* Slab freed to the page allocator */</span>
	<span class="n">CPUSLAB_FLUSH</span><span class="p">,</span>		<span class="cm">/* Abandoning of the cpu slab */</span>
	<span class="n">DEACTIVATE_FULL</span><span class="p">,</span>	<span class="cm">/* Cpu slab was full when deactivated */</span>
	<span class="n">DEACTIVATE_EMPTY</span><span class="p">,</span>	<span class="cm">/* Cpu slab was empty when deactivated */</span>
	<span class="n">DEACTIVATE_TO_HEAD</span><span class="p">,</span>	<span class="cm">/* Cpu slab was moved to the head of partials */</span>
	<span class="n">DEACTIVATE_TO_TAIL</span><span class="p">,</span>	<span class="cm">/* Cpu slab was moved to the tail of partials */</span>
	<span class="n">DEACTIVATE_REMOTE_FREES</span><span class="p">,</span><span class="cm">/* Slab contained remotely freed objects */</span>
	<span class="n">DEACTIVATE_BYPASS</span><span class="p">,</span>	<span class="cm">/* Implicit deactivation */</span>
	<span class="n">ORDER_FALLBACK</span><span class="p">,</span>		<span class="cm">/* Number of times fallback was necessary */</span>
	<span class="n">CMPXCHG_DOUBLE_CPU_FAIL</span><span class="p">,</span><span class="cm">/* Failure of this_cpu_cmpxchg_double */</span>
	<span class="n">CMPXCHG_DOUBLE_FAIL</span><span class="p">,</span>	<span class="cm">/* Number of times that cmpxchg double did not match */</span>
	<span class="n">CPU_PARTIAL_ALLOC</span><span class="p">,</span>	<span class="cm">/* Used cpu partial on alloc */</span>
	<span class="n">CPU_PARTIAL_FREE</span><span class="p">,</span>	<span class="cm">/* Refill cpu partial on free */</span>
	<span class="n">CPU_PARTIAL_NODE</span><span class="p">,</span>	<span class="cm">/* Refill cpu partial from node partial */</span>
	<span class="n">CPU_PARTIAL_DRAIN</span><span class="p">,</span>	<span class="cm">/* Drain cpu partial to node partial */</span>
	<span class="n">NR_SLUB_STAT_ITEMS</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">freelist</span><span class="p">;</span>	<span class="cm">/* Pointer to next available object */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">;</span>	<span class="cm">/* Globally unique transaction id */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>	<span class="cm">/* The slab from which we are allocating */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">partial</span><span class="p">;</span>	<span class="cm">/* Partially allocated frozen slabs */</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>		<span class="cm">/* The node of the page (or -1 for debug) */</span>
<span class="cp">#ifdef CONFIG_SLUB_STATS</span>
	<span class="kt">unsigned</span> <span class="n">stat</span><span class="p">[</span><span class="n">NR_SLUB_STAT_ITEMS</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">list_lock</span><span class="p">;</span>	<span class="cm">/* Protect partial list and nr_partial */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_partial</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">partial</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="n">atomic_long_t</span> <span class="n">nr_slabs</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">total_objects</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">full</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Word size structure that can be atomically updated or read and that</span>
<span class="cm"> * contains both the order and the number of objects that a slab of the</span>
<span class="cm"> * given order would contain.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Slab cache management.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">cpu_slab</span><span class="p">;</span>
	<span class="cm">/* Used for retriving partial slabs etc */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_partial</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* The size of an object including meta data */</span>
	<span class="kt">int</span> <span class="n">objsize</span><span class="p">;</span>		<span class="cm">/* The size of an object without meta data */</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>		<span class="cm">/* Free pointer offset. */</span>
	<span class="kt">int</span> <span class="n">cpu_partial</span><span class="p">;</span>	<span class="cm">/* Number of per cpu partial objects to keep around */</span>
	<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">oo</span><span class="p">;</span>

	<span class="cm">/* Allocation and freeing of slabs */</span>
	<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">min</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">allocflags</span><span class="p">;</span>	<span class="cm">/* gfp flags to use on each alloc */</span>
	<span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>		<span class="cm">/* Refcount for slab cache destroy */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">inuse</span><span class="p">;</span>		<span class="cm">/* Offset to metadata */</span>
	<span class="kt">int</span> <span class="n">align</span><span class="p">;</span>		<span class="cm">/* Alignment */</span>
	<span class="kt">int</span> <span class="n">reserved</span><span class="p">;</span>		<span class="cm">/* Reserved bytes at the end of slabs */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>	<span class="cm">/* Name (only for display!) */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>	<span class="cm">/* List of slab caches */</span>
<span class="cp">#ifdef CONFIG_SYSFS</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>	<span class="cm">/* For sysfs */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="cm">/*</span>
<span class="cm">	 * Defragmentation by allocating from a remote node.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">remote_node_defrag_ratio</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">node</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Kmalloc subsystem.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(ARCH_DMA_MINALIGN) &amp;&amp; ARCH_DMA_MINALIGN &gt; 8</span>
<span class="cp">#define KMALLOC_MIN_SIZE ARCH_DMA_MINALIGN</span>
<span class="cp">#else</span>
<span class="cp">#define KMALLOC_MIN_SIZE 8</span>
<span class="cp">#endif</span>

<span class="cp">#define KMALLOC_SHIFT_LOW ilog2(KMALLOC_MIN_SIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum kmalloc object size handled by SLUB. Larger object allocations</span>
<span class="cm"> * are passed through to the page allocator. The page allocator &quot;fastpath&quot;</span>
<span class="cm"> * is relatively slow so we need this value sufficiently high so that</span>
<span class="cm"> * performance critical objects are allocated through the SLUB fastpath.</span>
<span class="cm"> *</span>
<span class="cm"> * This should be dropped to PAGE_SIZE / 2 once the page allocator</span>
<span class="cm"> * &quot;fastpath&quot; becomes competitive with the slab allocator fastpaths.</span>
<span class="cm"> */</span>
<span class="cp">#define SLUB_MAX_SIZE (2 * PAGE_SIZE)</span>

<span class="cp">#define SLUB_PAGE_SHIFT (PAGE_SHIFT + 2)</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
<span class="cp">#define SLUB_DMA __GFP_DMA</span>
<span class="cp">#else</span>
<span class="cm">/* Disable DMA functionality */</span>
<span class="cp">#define SLUB_DMA (__force gfp_t)0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * We keep the general caches in an array of slab caches that are used for</span>
<span class="cm"> * 2^x bytes of allocations.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">SLUB_PAGE_SHIFT</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * Sorry that the following has to be that ugly but some versions of GCC</span>
<span class="cm"> * have trouble with constant propagation and loops.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span> <span class="nf">kmalloc_index</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">KMALLOC_MIN_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">KMALLOC_SHIFT_LOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&lt;=</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">64</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">96</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&lt;=</span> <span class="mi">64</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">128</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">192</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>          <span class="mi">8</span><span class="p">)</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>         <span class="mi">16</span><span class="p">)</span> <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>         <span class="mi">32</span><span class="p">)</span> <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>         <span class="mi">64</span><span class="p">)</span> <span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>        <span class="mi">128</span><span class="p">)</span> <span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>        <span class="mi">256</span><span class="p">)</span> <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>        <span class="mi">512</span><span class="p">)</span> <span class="k">return</span> <span class="mi">9</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>       <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>   <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">11</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>   <span class="mi">4</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * The following is only needed to support architectures with a larger page</span>
<span class="cm"> * size than 4k. We need to support 2 * PAGE_SIZE here. So for a 64k page</span>
<span class="cm"> * size we would have to go up to 128k.</span>
<span class="cm"> */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>   <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">13</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>  <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">14</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>  <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">15</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>  <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">17</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">18</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">19</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">20</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span>  <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">return</span> <span class="mi">21</span><span class="p">;</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Will never be reached */</span>

<span class="cm">/*</span>
<span class="cm"> * What we really wanted to do and cannot do because of compiler issues is:</span>
<span class="cm"> *	int i;</span>
<span class="cm"> *	for (i = KMALLOC_SHIFT_LOW; i &lt;= KMALLOC_SHIFT_HIGH; i++)</span>
<span class="cm"> *		if (size &lt;= (1 &lt;&lt; i))</span>
<span class="cm"> *			return i;</span>
<span class="cm"> */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the slab cache for a given combination of allocation flags and size.</span>
<span class="cm"> *</span>
<span class="cm"> * This ought to end up with a global pointer to the right cache</span>
<span class="cm"> * in kmalloc_caches.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">kmalloc_slab</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">kmalloc_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">__kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">kmalloc_order</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="n">kmemleak_alloc</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Calling this on allocated memory will check that the memory</span>
<span class="cm"> * is expected to be in use, and print warnings if not.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">verify_mem_not_deleted</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">verify_mem_not_deleted</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span>
<span class="n">kmem_cache_alloc_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">kmalloc_order_trace</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">kmem_cache_alloc_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">kmalloc_order_trace</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmalloc_order</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmalloc_large</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kmalloc_order_trace</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">SLUB_MAX_SIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">kmalloc_large</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLUB_DMA</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc_slab</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ZERO_SIZE_PTR</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">kmem_cache_alloc_trace</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">__kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">__kmalloc_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">kmem_cache_alloc_node_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
					   <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">kmem_cache_alloc_node_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmalloc_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">size</span> <span class="o">&lt;=</span> <span class="n">SLUB_MAX_SIZE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLUB_DMA</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc_slab</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ZERO_SIZE_PTR</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">kmem_cache_alloc_node_trace</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">__kmalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_SLUB_DEF_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
