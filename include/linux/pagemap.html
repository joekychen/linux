<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › pagemap.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pagemap.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_PAGEMAP_H</span>
<span class="cp">#define _LINUX_PAGEMAP_H</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright 1995 Linus Torvalds</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt; </span><span class="cm">/* for in_interrupt() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/hugetlb_inline.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Bits in mapping-&gt;flags.  The lower __GFP_BITS_SHIFT bits are the page</span>
<span class="cm"> * allocation mode flags.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mapping_flags</span> <span class="p">{</span>
	<span class="n">AS_EIO</span>		<span class="o">=</span> <span class="n">__GFP_BITS_SHIFT</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* IO error on async write */</span>
	<span class="n">AS_ENOSPC</span>	<span class="o">=</span> <span class="n">__GFP_BITS_SHIFT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* ENOSPC on async write */</span>
	<span class="n">AS_MM_ALL_LOCKS</span>	<span class="o">=</span> <span class="n">__GFP_BITS_SHIFT</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* under mm_take_all_locks() */</span>
	<span class="n">AS_UNEVICTABLE</span>	<span class="o">=</span> <span class="n">__GFP_BITS_SHIFT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* e.g., ramdisk, SHM_LOCK */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mapping_set_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">AS_ENOSPC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">AS_EIO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mapping_set_unevictable</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">AS_UNEVICTABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mapping_clear_unevictable</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">AS_UNEVICTABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mapping_unevictable</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">AS_UNEVICTABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!!</span><span class="n">mapping</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gfp_t</span> <span class="nf">mapping_gfp_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span> <span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__force</span> <span class="n">gfp_t</span><span class="p">)</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_BITS_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is non-atomic.  Only to be used before the mapping is activated.</span>
<span class="cm"> * Probably needs a barrier...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mapping_set_gfp_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">__force</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__GFP_BITS_MASK</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">__force</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The page cache can done in larger chunks than</span>
<span class="cm"> * one page, because it allows for more efficient</span>
<span class="cm"> * throughput (it can then be mapped into user</span>
<span class="cm"> * space in smaller chunks for same flexibility).</span>
<span class="cm"> *</span>
<span class="cm"> * Or rather, it _will_ be done in larger chunks.</span>
<span class="cm"> */</span>
<span class="cp">#define PAGE_CACHE_SHIFT	PAGE_SHIFT</span>
<span class="cp">#define PAGE_CACHE_SIZE		PAGE_SIZE</span>
<span class="cp">#define PAGE_CACHE_MASK		PAGE_MASK</span>
<span class="cp">#define PAGE_CACHE_ALIGN(addr)	(((addr)+PAGE_CACHE_SIZE-1)&amp;PAGE_CACHE_MASK)</span>

<span class="cp">#define page_cache_get(page)		get_page(page)</span>
<span class="cp">#define page_cache_release(page)	put_page(page)</span>
<span class="kt">void</span> <span class="n">release_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cold</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * speculatively take a reference to a page.</span>
<span class="cm"> * If the page is free (_count == 0), then _count is untouched, and 0</span>
<span class="cm"> * is returned. Otherwise, _count is incremented by 1 and 1 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called inside the same rcu_read_lock() section as has</span>
<span class="cm"> * been used to lookup the page in the pagecache radix-tree (or page table):</span>
<span class="cm"> * this allows allocators to use a synchronize_rcu() to stabilize _count.</span>
<span class="cm"> *</span>
<span class="cm"> * Unless an RCU grace period has passed, the count of all pages coming out</span>
<span class="cm"> * of the allocator must be considered unstable. page_count may return higher</span>
<span class="cm"> * than expected, and put_page must be able to do the right thing when the</span>
<span class="cm"> * page has been finished with, no matter what it is subsequently allocated</span>
<span class="cm"> * for (because put_page is what is used here to drop an invalid speculative</span>
<span class="cm"> * reference).</span>
<span class="cm"> *</span>
<span class="cm"> * This is the interesting part of the lockless pagecache (and lockless</span>
<span class="cm"> * get_user_pages) locking protocol, where the lookup-side (eg. find_get_page)</span>
<span class="cm"> * has the following pattern:</span>
<span class="cm"> * 1. find page in radix tree</span>
<span class="cm"> * 2. conditionally increment refcount</span>
<span class="cm"> * 3. check the page is still in pagecache (if no, goto 1)</span>
<span class="cm"> *</span>
<span class="cm"> * Remove-side that cares about stability of _count (eg. reclaim) has the</span>
<span class="cm"> * following (with tree_lock held for write):</span>
<span class="cm"> * A. atomically check refcount is correct and set it to 0 (atomic_cmpxchg)</span>
<span class="cm"> * B. remove page from pagecache</span>
<span class="cm"> * C. free the page</span>
<span class="cm"> *</span>
<span class="cm"> * There are 2 critical interleavings that matter:</span>
<span class="cm"> * - 2 runs before A: in this case, A sees elevated refcount and bails out</span>
<span class="cm"> * - A runs before 2: in this case, 2 sees zero refcount and retries;</span>
<span class="cm"> *   subsequently, B will complete and 1 will find no page, causing the</span>
<span class="cm"> *   lookup to return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * It is possible that between 1 and 2, the page is removed then the exact same</span>
<span class="cm"> * page is inserted into the same position in pagecache. That&#39;s OK: the</span>
<span class="cm"> * old find_get_page using tree_lock could equally have run before or after</span>
<span class="cm"> * such a re-insertion, depending on order that locks are granted.</span>
<span class="cm"> *</span>
<span class="cm"> * Lookups racing against pagecache insertion isn&#39;t a big problem: either 1</span>
<span class="cm"> * will find the page or it will not. Likewise, the old find_get_page could run</span>
<span class="cm"> * either before the insertion or afterwards, depending on timing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_cache_get_speculative</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

<span class="cp">#if !defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_TREE_RCU)</span>
<span class="cp"># ifdef CONFIG_PREEMPT_COUNT</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">in_atomic</span><span class="p">());</span>
<span class="cp"># endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Preempt must be disabled here - we rely on rcu_read_lock doing</span>
<span class="cm">	 * this for us.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Pagecache won&#39;t be truncated from interrupt context, so if we have</span>
<span class="cm">	 * found a page in the radix tree here, we have pinned its refcount by</span>
<span class="cm">	 * disabling preempt, and hence no need for the &quot;speculative get&quot; that</span>
<span class="cm">	 * SMP requires.</span>
<span class="cm">	 */</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">);</span>

<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">get_page_unless_zero</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Either the page has been freed, or will be freed.</span>
<span class="cm">		 * In either case, retry here and the caller should</span>
<span class="cm">		 * do the right thing (see comments above).</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageTail</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Same as above, but add instead of inc (could just be merged)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_cache_add_speculative</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

<span class="cp">#if !defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_TREE_RCU)</span>
<span class="cp"># ifdef CONFIG_PREEMPT_COUNT</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">in_atomic</span><span class="p">());</span>
<span class="cp"># endif</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">);</span>

<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page</span> <span class="o">!=</span> <span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">page_freeze_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">likely</span><span class="p">(</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">page_unfreeze_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__page_cache_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">page_cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">page_cache_alloc_cold</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span><span class="n">__GFP_COLD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">page_cache_alloc_readahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span>
				  <span class="n">__GFP_COLD</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">filler_t</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">find_get_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">find_get_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">find_get_pages_contig</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">find_get_pages_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Returns locked page at given index in given cache, creating it if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">grab_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
								<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">grab_cache_page_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">read_cache_page_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">filler_t</span> <span class="o">*</span><span class="n">filler</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">read_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">filler_t</span> <span class="o">*</span><span class="n">filler</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">read_cache_page_gfp</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">read_cache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="n">filler_t</span> <span class="o">*</span><span class="n">filler</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">read_mapping_page_async</span><span class="p">(</span>
				<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">filler_t</span> <span class="o">*</span><span class="n">filler</span> <span class="o">=</span> <span class="p">(</span><span class="n">filler_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">read_cache_page_async</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">read_mapping_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">filler_t</span> <span class="o">*</span><span class="n">filler</span> <span class="o">=</span> <span class="p">(</span><span class="n">filler_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">read_cache_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return byte-offset into filesystem object for page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">page_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">pgoff_t</span> <span class="n">linear_hugepage_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgoff_t</span> <span class="nf">linear_page_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">linear_hugepage_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">pgoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pgoff</span> <span class="o">+=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pgoff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__lock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__lock_page_killable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__lock_page_or_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">unlock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__set_page_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">PG_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__clear_page_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">PG_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">trylock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit_lock</span><span class="p">(</span><span class="n">PG_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lock_page may only be called if we have the page&#39;s inode pinned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">__lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lock_page_killable is like lock_page but can be interrupted by fatal</span>
<span class="cm"> * signals.  It returns 0 if it locked the page and -EINTR if it was</span>
<span class="cm"> * killed while waiting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lock_page_killable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">__lock_page_killable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lock_page_or_retry - Lock the page, unless this would block and the</span>
<span class="cm"> * caller indicated that it can handle a retry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">lock_page_or_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">__lock_page_or_retry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is exported only for wait_on_page_locked/wait_on_page_writeback.</span>
<span class="cm"> * Never use this directly!</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">wait_on_page_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_nr</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">wait_on_page_bit_killable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_nr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">wait_on_page_locked_killable</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">wait_on_page_bit_killable</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PG_locked</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Wait for a page to be unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called with the caller &quot;holding&quot; the page,</span>
<span class="cm"> * ie with increased &quot;page-&gt;count&quot; so that the page won&#39;t</span>
<span class="cm"> * go away during the wait..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_on_page_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">wait_on_page_bit</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PG_locked</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Wait for a page to complete writeback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_on_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">wait_on_page_bit</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PG_writeback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">end_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Add an arbitrary waiter to a page&#39;s wait queue</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">add_page_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">waiter</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Fault a userspace page into pagetables.  Return non-zero on a fault.</span>
<span class="cm"> *</span>
<span class="cm"> * This assumes that two userspace pages are always sufficient.  That&#39;s</span>
<span class="cm"> * not true if PAGE_CACHE_SIZE &gt; PAGE_SIZE.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fault_in_pages_writeable</span><span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Writing zeroes into userspace here is OK, because we know that if</span>
<span class="cm">	 * the zero gets there, we&#39;ll be overwriting it.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the page was already mapped, this will get a cache miss</span>
<span class="cm">		 * for sure, so try to avoid doing it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uaddr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">!=</span>
				<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fault_in_pages_readable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uaddr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">!=</span>
				<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">c</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Multipage variants of the above prefault helpers, useful if more than</span>
<span class="cm"> * PAGE_SIZE of data needs to be prefaulted. These are separate from the above</span>
<span class="cm"> * functions (which only handle up to PAGE_SIZE) to avoid clobbering the</span>
<span class="cm"> * filemap.c hotpaths.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fault_in_multipages_writeable</span><span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Writing zeroes into userspace here is OK, because we know that if</span>
<span class="cm">	 * the zero gets there, we&#39;ll be overwriting it.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">uaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check whether the range spilled into the next page. */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uaddr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fault_in_multipages_readable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">uaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check whether the range spilled into the next page. */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uaddr</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">end</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">add_to_page_cache_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">delete_from_page_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__delete_from_page_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">replace_page_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Like add_to_page_cache_locked, but used to add newly allocated pages:</span>
<span class="cm"> * the page is new, so we can just run __set_page_locked() against it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add_to_page_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">__set_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">add_to_page_cache_locked</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="n">__clear_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_PAGEMAP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
