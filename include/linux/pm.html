<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › pm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  pm.h - Power management interface</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2000 Andrew Henroid</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_PM_H</span>
<span class="cp">#define _LINUX_PM_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Callbacks for platform drivers to implement.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pm_idle</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pm_power_off</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pm_power_off_prepare</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Device power management</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">power_group_name</span><span class="p">[];</span>		<span class="cm">/* = &quot;power&quot; */</span>
<span class="cp">#else</span>
<span class="cp">#define power_group_name	NULL</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">pm_message</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pm_message_t</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct dev_pm_ops - device PM callbacks</span>
<span class="cm"> *</span>
<span class="cm"> * Several device power state transitions are externally visible, affecting</span>
<span class="cm"> * the state of pending I/O queues and (for drivers that touch hardware)</span>
<span class="cm"> * interrupts, wakeups, DMA, and other hardware state.  There may also be</span>
<span class="cm"> * internal transitions to various low-power modes which are transparent</span>
<span class="cm"> * to the rest of the driver stack (such as a driver that&#39;s ON gating off</span>
<span class="cm"> * clocks which are not in active use).</span>
<span class="cm"> *</span>
<span class="cm"> * The externally visible transitions are handled with the help of callbacks</span>
<span class="cm"> * included in this structure in such a way that two levels of callbacks are</span>
<span class="cm"> * involved.  First, the PM core executes callbacks provided by PM domains,</span>
<span class="cm"> * device types, classes and bus types.  They are the subsystem-level callbacks</span>
<span class="cm"> * supposed to execute callbacks provided by device drivers, although they may</span>
<span class="cm"> * choose not to do that.  If the driver callbacks are executed, they have to</span>
<span class="cm"> * collaborate with the subsystem-level callbacks to achieve the goals</span>
<span class="cm"> * appropriate for the given system transition, given transition phase and the</span>
<span class="cm"> * subsystem the device belongs to.</span>
<span class="cm"> *</span>
<span class="cm"> * @prepare: The principal role of this callback is to prevent new children of</span>
<span class="cm"> *	the device from being registered after it has returned (the driver&#39;s</span>
<span class="cm"> *	subsystem and generally the rest of the kernel is supposed to prevent</span>
<span class="cm"> *	new calls to the probe method from being made too once @prepare() has</span>
<span class="cm"> *	succeeded).  If @prepare() detects a situation it cannot handle (e.g.</span>
<span class="cm"> *	registration of a child already in progress), it may return -EAGAIN, so</span>
<span class="cm"> *	that the PM core can execute it once again (e.g. after a new child has</span>
<span class="cm"> *	been registered) to recover from the race condition.</span>
<span class="cm"> *	This method is executed for all kinds of suspend transitions and is</span>
<span class="cm"> *	followed by one of the suspend callbacks: @suspend(), @freeze(), or</span>
<span class="cm"> *	@poweroff().  The PM core executes subsystem-level @prepare() for all</span>
<span class="cm"> *	devices before starting to invoke suspend callbacks for any of them, so</span>
<span class="cm"> *	generally devices may be assumed to be functional or to respond to</span>
<span class="cm"> *	runtime resume requests while @prepare() is being executed.  However,</span>
<span class="cm"> *	device drivers may NOT assume anything about the availability of user</span>
<span class="cm"> *	space at that time and it is NOT valid to request firmware from within</span>
<span class="cm"> *	@prepare() (it&#39;s too late to do that).  It also is NOT valid to allocate</span>
<span class="cm"> *	substantial amounts of memory from @prepare() in the GFP_KERNEL mode.</span>
<span class="cm"> *	[To work around these limitations, drivers may register suspend and</span>
<span class="cm"> *	hibernation notifiers to be executed before the freezing of tasks.]</span>
<span class="cm"> *</span>
<span class="cm"> * @complete: Undo the changes made by @prepare().  This method is executed for</span>
<span class="cm"> *	all kinds of resume transitions, following one of the resume callbacks:</span>
<span class="cm"> *	@resume(), @thaw(), @restore().  Also called if the state transition</span>
<span class="cm"> *	fails before the driver&#39;s suspend callback: @suspend(), @freeze() or</span>
<span class="cm"> *	@poweroff(), can be executed (e.g. if the suspend callback fails for one</span>
<span class="cm"> *	of the other devices that the PM core has unsuccessfully attempted to</span>
<span class="cm"> *	suspend earlier).</span>
<span class="cm"> *	The PM core executes subsystem-level @complete() after it has executed</span>
<span class="cm"> *	the appropriate resume callbacks for all devices.</span>
<span class="cm"> *</span>
<span class="cm"> * @suspend: Executed before putting the system into a sleep state in which the</span>
<span class="cm"> *	contents of main memory are preserved.  The exact action to perform</span>
<span class="cm"> *	depends on the device&#39;s subsystem (PM domain, device type, class or bus</span>
<span class="cm"> *	type), but generally the device must be quiescent after subsystem-level</span>
<span class="cm"> *	@suspend() has returned, so that it doesn&#39;t do any I/O or DMA.</span>
<span class="cm"> *	Subsystem-level @suspend() is executed for all devices after invoking</span>
<span class="cm"> *	subsystem-level @prepare() for all of them.</span>
<span class="cm"> *</span>
<span class="cm"> * @suspend_late: Continue operations started by @suspend().  For a number of</span>
<span class="cm"> *	devices @suspend_late() may point to the same callback routine as the</span>
<span class="cm"> *	runtime suspend callback.</span>
<span class="cm"> *</span>
<span class="cm"> * @resume: Executed after waking the system up from a sleep state in which the</span>
<span class="cm"> *	contents of main memory were preserved.  The exact action to perform</span>
<span class="cm"> *	depends on the device&#39;s subsystem, but generally the driver is expected</span>
<span class="cm"> *	to start working again, responding to hardware events and software</span>
<span class="cm"> *	requests (the device itself may be left in a low-power state, waiting</span>
<span class="cm"> *	for a runtime resume to occur).  The state of the device at the time its</span>
<span class="cm"> *	driver&#39;s @resume() callback is run depends on the platform and subsystem</span>
<span class="cm"> *	the device belongs to.  On most platforms, there are no restrictions on</span>
<span class="cm"> *	availability of resources like clocks during @resume().</span>
<span class="cm"> *	Subsystem-level @resume() is executed for all devices after invoking</span>
<span class="cm"> *	subsystem-level @resume_noirq() for all of them.</span>
<span class="cm"> *</span>
<span class="cm"> * @resume_early: Prepare to execute @resume().  For a number of devices</span>
<span class="cm"> *	@resume_early() may point to the same callback routine as the runtime</span>
<span class="cm"> *	resume callback.</span>
<span class="cm"> *</span>
<span class="cm"> * @freeze: Hibernation-specific, executed before creating a hibernation image.</span>
<span class="cm"> *	Analogous to @suspend(), but it should not enable the device to signal</span>
<span class="cm"> *	wakeup events or change its power state.  The majority of subsystems</span>
<span class="cm"> *	(with the notable exception of the PCI bus type) expect the driver-level</span>
<span class="cm"> *	@freeze() to save the device settings in memory to be used by @restore()</span>
<span class="cm"> *	during the subsequent resume from hibernation.</span>
<span class="cm"> *	Subsystem-level @freeze() is executed for all devices after invoking</span>
<span class="cm"> *	subsystem-level @prepare() for all of them.</span>
<span class="cm"> *</span>
<span class="cm"> * @freeze_late: Continue operations started by @freeze().  Analogous to</span>
<span class="cm"> *	@suspend_late(), but it should not enable the device to signal wakeup</span>
<span class="cm"> *	events or change its power state.</span>
<span class="cm"> *</span>
<span class="cm"> * @thaw: Hibernation-specific, executed after creating a hibernation image OR</span>
<span class="cm"> *	if the creation of an image has failed.  Also executed after a failing</span>
<span class="cm"> *	attempt to restore the contents of main memory from such an image.</span>
<span class="cm"> *	Undo the changes made by the preceding @freeze(), so the device can be</span>
<span class="cm"> *	operated in the same way as immediately before the call to @freeze().</span>
<span class="cm"> *	Subsystem-level @thaw() is executed for all devices after invoking</span>
<span class="cm"> *	subsystem-level @thaw_noirq() for all of them.  It also may be executed</span>
<span class="cm"> *	directly after @freeze() in case of a transition error.</span>
<span class="cm"> *</span>
<span class="cm"> * @thaw_early: Prepare to execute @thaw().  Undo the changes made by the</span>
<span class="cm"> *	preceding @freeze_late().</span>
<span class="cm"> *</span>
<span class="cm"> * @poweroff: Hibernation-specific, executed after saving a hibernation image.</span>
<span class="cm"> *	Analogous to @suspend(), but it need not save the device&#39;s settings in</span>
<span class="cm"> *	memory.</span>
<span class="cm"> *	Subsystem-level @poweroff() is executed for all devices after invoking</span>
<span class="cm"> *	subsystem-level @prepare() for all of them.</span>
<span class="cm"> *</span>
<span class="cm"> * @poweroff_late: Continue operations started by @poweroff().  Analogous to</span>
<span class="cm"> *	@suspend_late(), but it need not save the device&#39;s settings in memory.</span>
<span class="cm"> *</span>
<span class="cm"> * @restore: Hibernation-specific, executed after restoring the contents of main</span>
<span class="cm"> *	memory from a hibernation image, analogous to @resume().</span>
<span class="cm"> *</span>
<span class="cm"> * @restore_early: Prepare to execute @restore(), analogous to @resume_early().</span>
<span class="cm"> *</span>
<span class="cm"> * @suspend_noirq: Complete the actions started by @suspend().  Carry out any</span>
<span class="cm"> *	additional operations required for suspending the device that might be</span>
<span class="cm"> *	racing with its driver&#39;s interrupt handler, which is guaranteed not to</span>
<span class="cm"> *	run while @suspend_noirq() is being executed.</span>
<span class="cm"> *	It generally is expected that the device will be in a low-power state</span>
<span class="cm"> *	(appropriate for the target system sleep state) after subsystem-level</span>
<span class="cm"> *	@suspend_noirq() has returned successfully.  If the device can generate</span>
<span class="cm"> *	system wakeup signals and is enabled to wake up the system, it should be</span>
<span class="cm"> *	configured to do so at that time.  However, depending on the platform</span>
<span class="cm"> *	and device&#39;s subsystem, @suspend() or @suspend_late() may be allowed to</span>
<span class="cm"> *	put the device into the low-power state and configure it to generate</span>
<span class="cm"> *	wakeup signals, in which case it generally is not necessary to define</span>
<span class="cm"> *	@suspend_noirq().</span>
<span class="cm"> *</span>
<span class="cm"> * @resume_noirq: Prepare for the execution of @resume() by carrying out any</span>
<span class="cm"> *	operations required for resuming the device that might be racing with</span>
<span class="cm"> *	its driver&#39;s interrupt handler, which is guaranteed not to run while</span>
<span class="cm"> *	@resume_noirq() is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * @freeze_noirq: Complete the actions started by @freeze().  Carry out any</span>
<span class="cm"> *	additional operations required for freezing the device that might be</span>
<span class="cm"> *	racing with its driver&#39;s interrupt handler, which is guaranteed not to</span>
<span class="cm"> *	run while @freeze_noirq() is being executed.</span>
<span class="cm"> *	The power state of the device should not be changed by either @freeze(),</span>
<span class="cm"> *	or @freeze_late(), or @freeze_noirq() and it should not be configured to</span>
<span class="cm"> *	signal system wakeup by any of these callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * @thaw_noirq: Prepare for the execution of @thaw() by carrying out any</span>
<span class="cm"> *	operations required for thawing the device that might be racing with its</span>
<span class="cm"> *	driver&#39;s interrupt handler, which is guaranteed not to run while</span>
<span class="cm"> *	@thaw_noirq() is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * @poweroff_noirq: Complete the actions started by @poweroff().  Analogous to</span>
<span class="cm"> *	@suspend_noirq(), but it need not save the device&#39;s settings in memory.</span>
<span class="cm"> *</span>
<span class="cm"> * @restore_noirq: Prepare for the execution of @restore() by carrying out any</span>
<span class="cm"> *	operations required for thawing the device that might be racing with its</span>
<span class="cm"> *	driver&#39;s interrupt handler, which is guaranteed not to run while</span>
<span class="cm"> *	@restore_noirq() is being executed.  Analogous to @resume_noirq().</span>
<span class="cm"> *</span>
<span class="cm"> * All of the above callbacks, except for @complete(), return error codes.</span>
<span class="cm"> * However, the error codes returned by the resume operations, @resume(),</span>
<span class="cm"> * @thaw(), @restore(), @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do</span>
<span class="cm"> * not cause the PM core to abort the resume transition during which they are</span>
<span class="cm"> * returned.  The error codes returned in those cases are only printed by the PM</span>
<span class="cm"> * core to the system logs for debugging purposes.  Still, it is recommended</span>
<span class="cm"> * that drivers only return error codes from their resume methods in case of an</span>
<span class="cm"> * unrecoverable failure (i.e. when the device being handled refuses to resume</span>
<span class="cm"> * and becomes unusable) to allow us to modify the PM core in the future, so</span>
<span class="cm"> * that it can avoid attempting to handle devices that failed to resume and</span>
<span class="cm"> * their children.</span>
<span class="cm"> *</span>
<span class="cm"> * It is allowed to unregister devices while the above callbacks are being</span>
<span class="cm"> * executed.  However, a callback routine must NOT try to unregister the device</span>
<span class="cm"> * it was called for, although it may unregister children of that device (for</span>
<span class="cm"> * example, if it detects that a child was unplugged while the system was</span>
<span class="cm"> * asleep).</span>
<span class="cm"> *</span>
<span class="cm"> * Refer to Documentation/power/devices.txt for more information about the role</span>
<span class="cm"> * of the above callbacks in the system suspend process.</span>
<span class="cm"> *</span>
<span class="cm"> * There also are callbacks related to runtime power management of devices.</span>
<span class="cm"> * Again, these callbacks are executed by the PM core only for subsystems</span>
<span class="cm"> * (PM domains, device types, classes and bus types) and the subsystem-level</span>
<span class="cm"> * callbacks are supposed to invoke the driver callbacks.  Moreover, the exact</span>
<span class="cm"> * actions to be performed by a device driver&#39;s callbacks generally depend on</span>
<span class="cm"> * the platform and subsystem the device belongs to.</span>
<span class="cm"> *</span>
<span class="cm"> * @runtime_suspend: Prepare the device for a condition in which it won&#39;t be</span>
<span class="cm"> *	able to communicate with the CPU(s) and RAM due to power management.</span>
<span class="cm"> *	This need not mean that the device should be put into a low-power state.</span>
<span class="cm"> *	For example, if the device is behind a link which is about to be turned</span>
<span class="cm"> *	off, the device may remain at full power.  If the device does go to low</span>
<span class="cm"> *	power and is capable of generating runtime wakeup events, remote wakeup</span>
<span class="cm"> *	(i.e., a hardware mechanism allowing the device to request a change of</span>
<span class="cm"> *	its power state via an interrupt) should be enabled for it.</span>
<span class="cm"> *</span>
<span class="cm"> * @runtime_resume: Put the device into the fully active state in response to a</span>
<span class="cm"> *	wakeup event generated by hardware or at the request of software.  If</span>
<span class="cm"> *	necessary, put the device into the full-power state and restore its</span>
<span class="cm"> *	registers, so that it is fully operational.</span>
<span class="cm"> *</span>
<span class="cm"> * @runtime_idle: Device appears to be inactive and it might be put into a</span>
<span class="cm"> *	low-power state if all of the necessary conditions are satisfied.  Check</span>
<span class="cm"> *	these conditions and handle the device as appropriate, possibly queueing</span>
<span class="cm"> *	a suspend request for it.  The return value is ignored by the PM core.</span>
<span class="cm"> *</span>
<span class="cm"> * Refer to Documentation/power/runtime_pm.txt for more information about the</span>
<span class="cm"> * role of the above callbacks in device runtime power management.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">freeze</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">thaw</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poweroff</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">restore</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend_late</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume_early</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">freeze_late</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">thaw_early</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poweroff_late</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">restore_early</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend_noirq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume_noirq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">freeze_noirq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">thaw_noirq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poweroff_noirq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">restore_noirq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">runtime_suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">runtime_resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">runtime_idle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="cp">#define SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \</span>
<span class="cp">	.suspend = suspend_fn, \</span>
<span class="cp">	.resume = resume_fn, \</span>
<span class="cp">	.freeze = suspend_fn, \</span>
<span class="cp">	.thaw = resume_fn, \</span>
<span class="cp">	.poweroff = suspend_fn, \</span>
<span class="cp">	.restore = resume_fn,</span>
<span class="cp">#else</span>
<span class="cp">#define SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="cp">#define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \</span>
<span class="cp">	.runtime_suspend = suspend_fn, \</span>
<span class="cp">	.runtime_resume = resume_fn, \</span>
<span class="cp">	.runtime_idle = idle_fn,</span>
<span class="cp">#else</span>
<span class="cp">#define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Use this if you want to use the same suspend and resume callbacks for suspend</span>
<span class="cm"> * to RAM and hibernation.</span>
<span class="cm"> */</span>
<span class="cp">#define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \</span>
<span class="cp">const struct dev_pm_ops name = { \</span>
<span class="cp">	SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use this for defining a set of PM operations to be used in all situations</span>
<span class="cm"> * (sustem suspend, hibernation or runtime PM).</span>
<span class="cm"> * NOTE: In general, system suspend callbacks, .suspend() and .resume(), should</span>
<span class="cm"> * be different from the corresponding runtime PM callbacks, .runtime_suspend(),</span>
<span class="cm"> * and .runtime_resume(), because .runtime_suspend() always works on an already</span>
<span class="cm"> * quiescent device, while .suspend() should assume that the device may be doing</span>
<span class="cm"> * something when it is called (it should ensure that the device will be</span>
<span class="cm"> * quiescent after it has returned).  Therefore it&#39;s better to point the &quot;late&quot;</span>
<span class="cm"> * suspend and &quot;early&quot; resume callback pointers, .suspend_late() and</span>
<span class="cm"> * .resume_early(), to the same routines as .runtime_suspend() and</span>
<span class="cm"> * .runtime_resume(), respectively (and analogously for hibernation).</span>
<span class="cm"> */</span>
<span class="cp">#define UNIVERSAL_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn) \</span>
<span class="cp">const struct dev_pm_ops name = { \</span>
<span class="cp">	SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \</span>
<span class="cp">	SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * PM_EVENT_ messages</span>
<span class="cm"> *</span>
<span class="cm"> * The following PM_EVENT_ messages are defined for the internal use of the PM</span>
<span class="cm"> * core, in order to provide a mechanism allowing the high level suspend and</span>
<span class="cm"> * hibernation code to convey the necessary information to the device PM core</span>
<span class="cm"> * code:</span>
<span class="cm"> *</span>
<span class="cm"> * ON		No transition.</span>
<span class="cm"> *</span>
<span class="cm"> * FREEZE 	System is going to hibernate, call -&gt;prepare() and -&gt;freeze()</span>
<span class="cm"> *		for all devices.</span>
<span class="cm"> *</span>
<span class="cm"> * SUSPEND	System is going to suspend, call -&gt;prepare() and -&gt;suspend()</span>
<span class="cm"> *		for all devices.</span>
<span class="cm"> *</span>
<span class="cm"> * HIBERNATE	Hibernation image has been saved, call -&gt;prepare() and</span>
<span class="cm"> *		-&gt;poweroff() for all devices.</span>
<span class="cm"> *</span>
<span class="cm"> * QUIESCE	Contents of main memory are going to be restored from a (loaded)</span>
<span class="cm"> *		hibernation image, call -&gt;prepare() and -&gt;freeze() for all</span>
<span class="cm"> *		devices.</span>
<span class="cm"> *</span>
<span class="cm"> * RESUME	System is resuming, call -&gt;resume() and -&gt;complete() for all</span>
<span class="cm"> *		devices.</span>
<span class="cm"> *</span>
<span class="cm"> * THAW		Hibernation image has been created, call -&gt;thaw() and</span>
<span class="cm"> *		-&gt;complete() for all devices.</span>
<span class="cm"> *</span>
<span class="cm"> * RESTORE	Contents of main memory have been restored from a hibernation</span>
<span class="cm"> *		image, call -&gt;restore() and -&gt;complete() for all devices.</span>
<span class="cm"> *</span>
<span class="cm"> * RECOVER	Creation of a hibernation image or restoration of the main</span>
<span class="cm"> *		memory contents from a hibernation image has failed, call</span>
<span class="cm"> *		-&gt;thaw() and -&gt;complete() for all devices.</span>
<span class="cm"> *</span>
<span class="cm"> * The following PM_EVENT_ messages are defined for internal use by</span>
<span class="cm"> * kernel subsystems.  They are never issued by the PM core.</span>
<span class="cm"> *</span>
<span class="cm"> * USER_SUSPEND		Manual selective suspend was issued by userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * USER_RESUME		Manual selective resume was issued by userspace.</span>
<span class="cm"> *</span>
<span class="cm"> * REMOTE_WAKEUP	Remote-wakeup request was received from the device.</span>
<span class="cm"> *</span>
<span class="cm"> * AUTO_SUSPEND		Automatic (device idle) runtime suspend was</span>
<span class="cm"> *			initiated by the subsystem.</span>
<span class="cm"> *</span>
<span class="cm"> * AUTO_RESUME		Automatic (device needed) runtime resume was</span>
<span class="cm"> *			requested by a driver.</span>
<span class="cm"> */</span>

<span class="cp">#define PM_EVENT_INVALID	(-1)</span>
<span class="cp">#define PM_EVENT_ON		0x0000</span>
<span class="cp">#define PM_EVENT_FREEZE 	0x0001</span>
<span class="cp">#define PM_EVENT_SUSPEND	0x0002</span>
<span class="cp">#define PM_EVENT_HIBERNATE	0x0004</span>
<span class="cp">#define PM_EVENT_QUIESCE	0x0008</span>
<span class="cp">#define PM_EVENT_RESUME		0x0010</span>
<span class="cp">#define PM_EVENT_THAW		0x0020</span>
<span class="cp">#define PM_EVENT_RESTORE	0x0040</span>
<span class="cp">#define PM_EVENT_RECOVER	0x0080</span>
<span class="cp">#define PM_EVENT_USER		0x0100</span>
<span class="cp">#define PM_EVENT_REMOTE		0x0200</span>
<span class="cp">#define PM_EVENT_AUTO		0x0400</span>

<span class="cp">#define PM_EVENT_SLEEP		(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)</span>
<span class="cp">#define PM_EVENT_USER_SUSPEND	(PM_EVENT_USER | PM_EVENT_SUSPEND)</span>
<span class="cp">#define PM_EVENT_USER_RESUME	(PM_EVENT_USER | PM_EVENT_RESUME)</span>
<span class="cp">#define PM_EVENT_REMOTE_RESUME	(PM_EVENT_REMOTE | PM_EVENT_RESUME)</span>
<span class="cp">#define PM_EVENT_AUTO_SUSPEND	(PM_EVENT_AUTO | PM_EVENT_SUSPEND)</span>
<span class="cp">#define PM_EVENT_AUTO_RESUME	(PM_EVENT_AUTO | PM_EVENT_RESUME)</span>

<span class="cp">#define PMSG_INVALID	((struct pm_message){ .event = PM_EVENT_INVALID, })</span>
<span class="cp">#define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })</span>
<span class="cp">#define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })</span>
<span class="cp">#define PMSG_QUIESCE	((struct pm_message){ .event = PM_EVENT_QUIESCE, })</span>
<span class="cp">#define PMSG_SUSPEND	((struct pm_message){ .event = PM_EVENT_SUSPEND, })</span>
<span class="cp">#define PMSG_HIBERNATE	((struct pm_message){ .event = PM_EVENT_HIBERNATE, })</span>
<span class="cp">#define PMSG_RESUME	((struct pm_message){ .event = PM_EVENT_RESUME, })</span>
<span class="cp">#define PMSG_THAW	((struct pm_message){ .event = PM_EVENT_THAW, })</span>
<span class="cp">#define PMSG_RESTORE	((struct pm_message){ .event = PM_EVENT_RESTORE, })</span>
<span class="cp">#define PMSG_RECOVER	((struct pm_message){ .event = PM_EVENT_RECOVER, })</span>
<span class="cp">#define PMSG_USER_SUSPEND	((struct pm_message) \</span>
<span class="cp">					{ .event = PM_EVENT_USER_SUSPEND, })</span>
<span class="cp">#define PMSG_USER_RESUME	((struct pm_message) \</span>
<span class="cp">					{ .event = PM_EVENT_USER_RESUME, })</span>
<span class="cp">#define PMSG_REMOTE_RESUME	((struct pm_message) \</span>
<span class="cp">					{ .event = PM_EVENT_REMOTE_RESUME, })</span>
<span class="cp">#define PMSG_AUTO_SUSPEND	((struct pm_message) \</span>
<span class="cp">					{ .event = PM_EVENT_AUTO_SUSPEND, })</span>
<span class="cp">#define PMSG_AUTO_RESUME	((struct pm_message) \</span>
<span class="cp">					{ .event = PM_EVENT_AUTO_RESUME, })</span>

<span class="cp">#define PMSG_IS_AUTO(msg)	(((msg).event &amp; PM_EVENT_AUTO) != 0)</span>

<span class="cm">/**</span>
<span class="cm"> * Device run-time power management status.</span>
<span class="cm"> *</span>
<span class="cm"> * These status labels are used internally by the PM core to indicate the</span>
<span class="cm"> * current status of a device with respect to the PM core operations.  They do</span>
<span class="cm"> * not reflect the actual power state of the device or its status as seen by the</span>
<span class="cm"> * driver.</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_ACTIVE		Device is fully operational.  Indicates that the device</span>
<span class="cm"> *			bus type&#39;s -&gt;runtime_resume() callback has completed</span>
<span class="cm"> *			successfully.</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_SUSPENDED	Device bus type&#39;s -&gt;runtime_suspend() callback has</span>
<span class="cm"> *			completed successfully.  The device is regarded as</span>
<span class="cm"> *			suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_RESUMING		Device bus type&#39;s -&gt;runtime_resume() callback is being</span>
<span class="cm"> *			executed.</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_SUSPENDING	Device bus type&#39;s -&gt;runtime_suspend() callback is being</span>
<span class="cm"> *			executed.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">rpm_status</span> <span class="p">{</span>
	<span class="n">RPM_ACTIVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPM_RESUMING</span><span class="p">,</span>
	<span class="n">RPM_SUSPENDED</span><span class="p">,</span>
	<span class="n">RPM_SUSPENDING</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Device run-time power management request types.</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_REQ_NONE		Do nothing.</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_REQ_IDLE		Run the device bus type&#39;s -&gt;runtime_idle() callback</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_REQ_SUSPEND	Run the device bus type&#39;s -&gt;runtime_suspend() callback</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_REQ_AUTOSUSPEND	Same as RPM_REQ_SUSPEND, but not until the device has</span>
<span class="cm"> *			been inactive for as long as power.autosuspend_delay</span>
<span class="cm"> *</span>
<span class="cm"> * RPM_REQ_RESUME	Run the device bus type&#39;s -&gt;runtime_resume() callback</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">rpm_request</span> <span class="p">{</span>
	<span class="n">RPM_REQ_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPM_REQ_IDLE</span><span class="p">,</span>
	<span class="n">RPM_REQ_SUSPEND</span><span class="p">,</span>
	<span class="n">RPM_REQ_AUTOSUSPEND</span><span class="p">,</span>
	<span class="n">RPM_REQ_RESUME</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">wakeup_source</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">pm_domain_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pm_subsys_data</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PM_CLK</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">clock_list</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PM_GENERIC_DOMAINS</span>
	<span class="k">struct</span> <span class="n">pm_domain_data</span> <span class="o">*</span><span class="n">domain_data</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dev_pm_info</span> <span class="p">{</span>
	<span class="n">pm_message_t</span>		<span class="n">power_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">can_wakeup</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">async_suspend</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">is_prepared</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Owned by the PM core */</span>
	<span class="n">bool</span>			<span class="n">is_suspended</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Ditto */</span>
	<span class="n">bool</span>			<span class="n">ignore_children</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">completion</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wakeup_source</span>	<span class="o">*</span><span class="n">wakeup</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">wakeup_path</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">should_wakeup</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">suspend_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">timer_expires</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wait_queue</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">usage_count</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">child_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">disable_depth</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">idle_notification</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">request_pending</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">deferred_resume</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">run_wake</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">runtime_auto</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">no_callbacks</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">irq_safe</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">use_autosuspend</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">timer_autosuspends</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">rpm_request</span>	<span class="n">request</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">rpm_status</span>		<span class="n">runtime_status</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">runtime_error</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">autosuspend_delay</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">last_busy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">active_jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">suspended_jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">accounting_timestamp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dev_pm_qos_request</span> <span class="o">*</span><span class="n">pq_req</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">pm_subsys_data</span>	<span class="o">*</span><span class="n">subsys_data</span><span class="p">;</span>  <span class="cm">/* Owned by the subsystem. */</span>
	<span class="k">struct</span> <span class="n">pm_qos_constraints</span> <span class="o">*</span><span class="n">constraints</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">update_pm_runtime_accounting</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_pm_get_subsys_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dev_pm_put_subsys_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Power domains provide callbacks that are executed during system suspend,</span>
<span class="cm"> * hibernation, system resume and during runtime PM transitions along with</span>
<span class="cm"> * subsystem-level and driver-level callbacks.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dev_pm_domain</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_pm_ops</span>	<span class="n">ops</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The PM_EVENT_ messages are also used by drivers implementing the legacy</span>
<span class="cm"> * suspend framework, based on the -&gt;suspend() and -&gt;resume() callbacks common</span>
<span class="cm"> * for suspend and hibernation transitions, according to the rules below.</span>
<span class="cm"> */</span>

<span class="cm">/* Necessary, because several drivers use PM_EVENT_PRETHAW */</span>
<span class="cp">#define PM_EVENT_PRETHAW PM_EVENT_QUIESCE</span>

<span class="cm">/*</span>
<span class="cm"> * One transition is triggered by resume(), after a suspend() call; the</span>
<span class="cm"> * message is implicit:</span>
<span class="cm"> *</span>
<span class="cm"> * ON		Driver starts working again, responding to hardware events</span>
<span class="cm"> * 		and software requests.  The hardware may have gone through</span>
<span class="cm"> * 		a power-off reset, or it may have maintained state from the</span>
<span class="cm"> * 		previous suspend() which the driver will rely on while</span>
<span class="cm"> * 		resuming.  On most platforms, there are no restrictions on</span>
<span class="cm"> * 		availability of resources like clocks during resume().</span>
<span class="cm"> *</span>
<span class="cm"> * Other transitions are triggered by messages sent using suspend().  All</span>
<span class="cm"> * these transitions quiesce the driver, so that I/O queues are inactive.</span>
<span class="cm"> * That commonly entails turning off IRQs and DMA; there may be rules</span>
<span class="cm"> * about how to quiesce that are specific to the bus or the device&#39;s type.</span>
<span class="cm"> * (For example, network drivers mark the link state.)  Other details may</span>
<span class="cm"> * differ according to the message:</span>
<span class="cm"> *</span>
<span class="cm"> * SUSPEND	Quiesce, enter a low power device state appropriate for</span>
<span class="cm"> * 		the upcoming system state (such as PCI_D3hot), and enable</span>
<span class="cm"> * 		wakeup events as appropriate.</span>
<span class="cm"> *</span>
<span class="cm"> * HIBERNATE	Enter a low power device state appropriate for the hibernation</span>
<span class="cm"> * 		state (eg. ACPI S4) and enable wakeup events as appropriate.</span>
<span class="cm"> *</span>
<span class="cm"> * FREEZE	Quiesce operations so that a consistent image can be saved;</span>
<span class="cm"> * 		but do NOT otherwise enter a low power device state, and do</span>
<span class="cm"> * 		NOT emit system wakeup events.</span>
<span class="cm"> *</span>
<span class="cm"> * PRETHAW	Quiesce as if for FREEZE; additionally, prepare for restoring</span>
<span class="cm"> * 		the system from a snapshot taken after an earlier FREEZE.</span>
<span class="cm"> * 		Some drivers will need to reset their hardware state instead</span>
<span class="cm"> * 		of preserving it, to ensure that it&#39;s never mistaken for the</span>
<span class="cm"> * 		state which that earlier snapshot had set up.</span>
<span class="cm"> *</span>
<span class="cm"> * A minimally power-aware driver treats all messages as SUSPEND, fully</span>
<span class="cm"> * reinitializes its device during resume() -- whether or not it was reset</span>
<span class="cm"> * during the suspend/resume cycle -- and can&#39;t issue wakeup events.</span>
<span class="cm"> *</span>
<span class="cm"> * More power-aware drivers may also use low power states at runtime as</span>
<span class="cm"> * well as during system sleep states like PM_SUSPEND_STANDBY.  They may</span>
<span class="cm"> * be able to use wakeup events to exit from runtime low-power states,</span>
<span class="cm"> * or from system low-power states such as standby or suspend-to-RAM.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_pm_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dpm_resume_start</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dpm_resume_end</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dpm_resume</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">dpm_complete</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">device_pm_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dpm_suspend_end</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dpm_suspend_start</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dpm_suspend</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">dpm_prepare</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__suspend_report_result</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">);</span>

<span class="cp">#define suspend_report_result(fn, ret)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		__suspend_report_result(__func__, fn, ret);		\</span>
<span class="cp">	} while (0)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">device_pm_wait_for_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">sub</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_suspend_late</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_suspend_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_resume_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_resume_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_freeze_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_freeze_late</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_thaw_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_thaw_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_restore_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_restore_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_poweroff_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_poweroff_late</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_generic_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pm_generic_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cp">#define device_pm_lock() do {} while (0)</span>
<span class="cp">#define device_pm_unlock() do {} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dpm_suspend_start</span><span class="p">(</span><span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define suspend_report_result(fn, ret)		do {} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">device_pm_wait_for_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define pm_generic_prepare	NULL</span>
<span class="cp">#define pm_generic_suspend	NULL</span>
<span class="cp">#define pm_generic_resume	NULL</span>
<span class="cp">#define pm_generic_freeze	NULL</span>
<span class="cp">#define pm_generic_thaw		NULL</span>
<span class="cp">#define pm_generic_restore	NULL</span>
<span class="cp">#define pm_generic_poweroff	NULL</span>
<span class="cp">#define pm_generic_complete	NULL</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cm">/* How to reorder dpm_list after device_move() */</span>
<span class="k">enum</span> <span class="n">dpm_order</span> <span class="p">{</span>
	<span class="n">DPM_ORDER_NONE</span><span class="p">,</span>
	<span class="n">DPM_ORDER_DEV_AFTER_PARENT</span><span class="p">,</span>
	<span class="n">DPM_ORDER_PARENT_BEFORE_DEV</span><span class="p">,</span>
	<span class="n">DPM_ORDER_DEV_LAST</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_PM_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
