<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › suspend.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>suspend.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_SUSPEND_H</span>
<span class="cp">#define _LINUX_SUSPEND_H</span>

<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;asm/errno.h&gt;</span>

<span class="cp">#ifdef CONFIG_VT</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pm_set_vt_switch</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pm_set_vt_switch</span><span class="p">(</span><span class="kt">int</span> <span class="n">do_switch</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_VT_CONSOLE_SLEEP</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_prepare_console</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pm_restore_console</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pm_prepare_console</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pm_restore_console</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">__bitwise</span> <span class="n">suspend_state_t</span><span class="p">;</span>

<span class="cp">#define PM_SUSPEND_ON		((__force suspend_state_t) 0)</span>
<span class="cp">#define PM_SUSPEND_STANDBY	((__force suspend_state_t) 1)</span>
<span class="cp">#define PM_SUSPEND_MEM		((__force suspend_state_t) 3)</span>
<span class="cp">#define PM_SUSPEND_MAX		((__force suspend_state_t) 4)</span>

<span class="k">enum</span> <span class="n">suspend_stat_step</span> <span class="p">{</span>
	<span class="n">SUSPEND_FREEZE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SUSPEND_PREPARE</span><span class="p">,</span>
	<span class="n">SUSPEND_SUSPEND</span><span class="p">,</span>
	<span class="n">SUSPEND_SUSPEND_LATE</span><span class="p">,</span>
	<span class="n">SUSPEND_SUSPEND_NOIRQ</span><span class="p">,</span>
	<span class="n">SUSPEND_RESUME_NOIRQ</span><span class="p">,</span>
	<span class="n">SUSPEND_RESUME_EARLY</span><span class="p">,</span>
	<span class="n">SUSPEND_RESUME</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">suspend_stats</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">success</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">fail</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">failed_freeze</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">failed_prepare</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">failed_suspend</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">failed_suspend_late</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">failed_suspend_noirq</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">failed_resume</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">failed_resume_early</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">failed_resume_noirq</span><span class="p">;</span>
<span class="cp">#define	REC_FAILED_NUM	2</span>
	<span class="kt">int</span>	<span class="n">last_failed_dev</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">failed_devs</span><span class="p">[</span><span class="n">REC_FAILED_NUM</span><span class="p">][</span><span class="mi">40</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">last_failed_errno</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">errno</span><span class="p">[</span><span class="n">REC_FAILED_NUM</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">last_failed_step</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">suspend_stat_step</span>	<span class="n">failed_steps</span><span class="p">[</span><span class="n">REC_FAILED_NUM</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">suspend_stats</span> <span class="n">suspend_stats</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dpm_save_failed_dev</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_devs</span><span class="p">[</span><span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_dev</span><span class="p">],</span>
		<span class="n">name</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_devs</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_dev</span><span class="o">++</span><span class="p">;</span>
	<span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_dev</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dpm_save_failed_errno</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">suspend_stats</span><span class="p">.</span><span class="n">errno</span><span class="p">[</span><span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_errno</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_errno</span><span class="o">++</span><span class="p">;</span>
	<span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_errno</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dpm_save_failed_step</span><span class="p">(</span><span class="k">enum</span> <span class="n">suspend_stat_step</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">suspend_stats</span><span class="p">.</span><span class="n">failed_steps</span><span class="p">[</span><span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_step</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span><span class="p">;</span>
	<span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_step</span><span class="o">++</span><span class="p">;</span>
	<span class="n">suspend_stats</span><span class="p">.</span><span class="n">last_failed_step</span> <span class="o">%=</span> <span class="n">REC_FAILED_NUM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct platform_suspend_ops - Callbacks for managing platform dependent</span>
<span class="cm"> *	system sleep states.</span>
<span class="cm"> *</span>
<span class="cm"> * @valid: Callback to determine if given system sleep state is supported by</span>
<span class="cm"> *	the platform.</span>
<span class="cm"> *	Valid (ie. supported) states are advertised in /sys/power/state.  Note</span>
<span class="cm"> *	that it still may be impossible to enter given system sleep state if the</span>
<span class="cm"> *	conditions aren&#39;t right.</span>
<span class="cm"> *	There is the %suspend_valid_only_mem function available that can be</span>
<span class="cm"> *	assigned to this if the platform only supports mem sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @begin: Initialise a transition to given system sleep state.</span>
<span class="cm"> *	@begin() is executed right prior to suspending devices.  The information</span>
<span class="cm"> *	conveyed to the platform code by @begin() should be disregarded by it as</span>
<span class="cm"> *	soon as @end() is executed.  If @begin() fails (ie. returns nonzero),</span>
<span class="cm"> *	@prepare(), @enter() and @finish() will not be called by the PM core.</span>
<span class="cm"> *	This callback is optional.  However, if it is implemented, the argument</span>
<span class="cm"> *	passed to @enter() is redundant and should be ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * @prepare: Prepare the platform for entering the system sleep state indicated</span>
<span class="cm"> *	by @begin().</span>
<span class="cm"> *	@prepare() is called right after devices have been suspended (ie. the</span>
<span class="cm"> *	appropriate .suspend() method has been executed for each device) and</span>
<span class="cm"> *	before device drivers&#39; late suspend callbacks are executed.  It returns</span>
<span class="cm"> *	0 on success or a negative error code otherwise, in which case the</span>
<span class="cm"> *	system cannot enter the desired sleep state (@prepare_late(), @enter(),</span>
<span class="cm"> *	and @wake() will not be called in that case).</span>
<span class="cm"> *</span>
<span class="cm"> * @prepare_late: Finish preparing the platform for entering the system sleep</span>
<span class="cm"> *	state indicated by @begin().</span>
<span class="cm"> *	@prepare_late is called before disabling nonboot CPUs and after</span>
<span class="cm"> *	device drivers&#39; late suspend callbacks have been executed.  It returns</span>
<span class="cm"> *	0 on success or a negative error code otherwise, in which case the</span>
<span class="cm"> *	system cannot enter the desired sleep state (@enter() will not be</span>
<span class="cm"> *	executed).</span>
<span class="cm"> *</span>
<span class="cm"> * @enter: Enter the system sleep state indicated by @begin() or represented by</span>
<span class="cm"> *	the argument if @begin() is not implemented.</span>
<span class="cm"> *	This callback is mandatory.  It returns 0 on success or a negative</span>
<span class="cm"> *	error code otherwise, in which case the system cannot enter the desired</span>
<span class="cm"> *	sleep state.</span>
<span class="cm"> *</span>
<span class="cm"> * @wake: Called when the system has just left a sleep state, right after</span>
<span class="cm"> *	the nonboot CPUs have been enabled and before device drivers&#39; early</span>
<span class="cm"> *	resume callbacks are executed.</span>
<span class="cm"> *	This callback is optional, but should be implemented by the platforms</span>
<span class="cm"> *	that implement @prepare_late().  If implemented, it is always called</span>
<span class="cm"> *	after @prepare_late and @enter(), even if one of them fails.</span>
<span class="cm"> *</span>
<span class="cm"> * @finish: Finish wake-up of the platform.</span>
<span class="cm"> *	@finish is called right prior to calling device drivers&#39; regular suspend</span>
<span class="cm"> *	callbacks.</span>
<span class="cm"> *	This callback is optional, but should be implemented by the platforms</span>
<span class="cm"> *	that implement @prepare().  If implemented, it is always called after</span>
<span class="cm"> *	@enter() and @wake(), even if any of them fails.  It is executed after</span>
<span class="cm"> *	a failing @prepare.</span>
<span class="cm"> *</span>
<span class="cm"> * @suspend_again: Returns whether the system should suspend again (true) or</span>
<span class="cm"> *	not (false). If the platform wants to poll sensors or execute some</span>
<span class="cm"> *	code during suspended without invoking userspace and most of devices,</span>
<span class="cm"> *	suspend_again callback is the place assuming that periodic-wakeup or</span>
<span class="cm"> *	alarm-wakeup is already setup. This allows to execute some codes while</span>
<span class="cm"> *	being kept suspended in the view of userland and devices.</span>
<span class="cm"> *</span>
<span class="cm"> * @end: Called by the PM core right after resuming devices, to indicate to</span>
<span class="cm"> *	the platform that the system has returned to the working state or</span>
<span class="cm"> *	the transition to the sleep state has been aborted.</span>
<span class="cm"> *	This callback is optional, but should be implemented by the platforms</span>
<span class="cm"> *	that implement @begin().  Accordingly, platforms implementing @begin()</span>
<span class="cm"> *	should also provide a @end() which cleans up transitions aborted before</span>
<span class="cm"> *	@enter().</span>
<span class="cm"> *</span>
<span class="cm"> * @recover: Recover the platform from a suspend failure.</span>
<span class="cm"> *	Called by the PM core if the suspending of devices fails.</span>
<span class="cm"> *	This callback is optional and should only be implemented by platforms</span>
<span class="cm"> *	which require special recovery actions in that situation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">platform_suspend_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">valid</span><span class="p">)(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">)(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare_late</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enter</span><span class="p">)(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wake</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">finish</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend_again</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">recover</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_SUSPEND</span>
<span class="cm">/**</span>
<span class="cm"> * suspend_set_ops - set platform dependent suspend operations</span>
<span class="cm"> * @ops: The new suspend operations to set.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">suspend_set_ops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">platform_suspend_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">suspend_valid_only_mem</span><span class="p">(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * arch_suspend_disable_irqs - disable IRQs for suspend</span>
<span class="cm"> *</span>
<span class="cm"> * Disables IRQs (in the default case). This is a weak symbol in the common</span>
<span class="cm"> * code and thus allows architectures to override it if more needs to be</span>
<span class="cm"> * done. Not called for suspend to disk.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">arch_suspend_disable_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * arch_suspend_enable_irqs - enable IRQs after suspend</span>
<span class="cm"> *</span>
<span class="cm"> * Enables IRQs (in the default case). This is a weak symbol in the common</span>
<span class="cm"> * code and thus allows architectures to override it if more needs to be</span>
<span class="cm"> * done. Not called for suspend to disk.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">arch_suspend_enable_irqs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pm_suspend</span><span class="p">(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_SUSPEND */</span><span class="cp"></span>
<span class="cp">#define suspend_valid_only_mem	NULL</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_set_ops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">platform_suspend_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pm_suspend</span><span class="p">(</span><span class="n">suspend_state_t</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_SUSPEND */</span><span class="cp"></span>

<span class="cm">/* struct pbe is used for creating lists of pages that should be restored</span>
<span class="cm"> * atomically during the resume from disk, because the page frames they have</span>
<span class="cm"> * occupied before the suspend are in use.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pbe</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">;</span>		<span class="cm">/* address of the copy */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">orig_address</span><span class="p">;</span>	<span class="cm">/* original address of a page */</span>
	<span class="k">struct</span> <span class="n">pbe</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* mm/page_alloc.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mark_free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct platform_hibernation_ops - hibernation platform support</span>
<span class="cm"> *</span>
<span class="cm"> * The methods in this structure allow a platform to carry out special</span>
<span class="cm"> * operations required by it during a hibernation transition.</span>
<span class="cm"> *</span>
<span class="cm"> * All the methods below, except for @recover(), must be implemented.</span>
<span class="cm"> *</span>
<span class="cm"> * @begin: Tell the platform driver that we&#39;re starting hibernation.</span>
<span class="cm"> *	Called right after shrinking memory and before freezing devices.</span>
<span class="cm"> *</span>
<span class="cm"> * @end: Called by the PM core right after resuming devices, to indicate to</span>
<span class="cm"> *	the platform that the system has returned to the working state.</span>
<span class="cm"> *</span>
<span class="cm"> * @pre_snapshot: Prepare the platform for creating the hibernation image.</span>
<span class="cm"> *	Called right after devices have been frozen and before the nonboot</span>
<span class="cm"> *	CPUs are disabled (runs with IRQs on).</span>
<span class="cm"> *</span>
<span class="cm"> * @finish: Restore the previous state of the platform after the hibernation</span>
<span class="cm"> *	image has been created *or* put the platform into the normal operation</span>
<span class="cm"> *	mode after the hibernation (the same method is executed in both cases).</span>
<span class="cm"> *	Called right after the nonboot CPUs have been enabled and before</span>
<span class="cm"> *	thawing devices (runs with IRQs on).</span>
<span class="cm"> *</span>
<span class="cm"> * @prepare: Prepare the platform for entering the low power state.</span>
<span class="cm"> *	Called right after the hibernation image has been saved and before</span>
<span class="cm"> *	devices are prepared for entering the low power state.</span>
<span class="cm"> *</span>
<span class="cm"> * @enter: Put the system into the low power state after the hibernation image</span>
<span class="cm"> *	has been saved to disk.</span>
<span class="cm"> *	Called after the nonboot CPUs have been disabled and all of the low</span>
<span class="cm"> *	level devices have been shut down (runs with IRQs off).</span>
<span class="cm"> *</span>
<span class="cm"> * @leave: Perform the first stage of the cleanup after the system sleep state</span>
<span class="cm"> *	indicated by @set_target() has been left.</span>
<span class="cm"> *	Called right after the control has been passed from the boot kernel to</span>
<span class="cm"> *	the image kernel, before the nonboot CPUs are enabled and before devices</span>
<span class="cm"> *	are resumed.  Executed with interrupts disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * @pre_restore: Prepare system for the restoration from a hibernation image.</span>
<span class="cm"> *	Called right after devices have been frozen and before the nonboot</span>
<span class="cm"> *	CPUs are disabled (runs with IRQs on).</span>
<span class="cm"> *</span>
<span class="cm"> * @restore_cleanup: Clean up after a failing image restoration.</span>
<span class="cm"> *	Called right after the nonboot CPUs have been enabled and before</span>
<span class="cm"> *	thawing devices (runs with IRQs on).</span>
<span class="cm"> *</span>
<span class="cm"> * @recover: Recover the platform from a failure to suspend devices.</span>
<span class="cm"> *	Called by the PM core if the suspending of devices during hibernation</span>
<span class="cm"> *	fails.  This callback is optional and should only be implemented by</span>
<span class="cm"> *	platforms which require special recovery actions in that situation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">platform_hibernation_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_snapshot</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">finish</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prepare</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enter</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">leave</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pre_restore</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">restore_cleanup</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">recover</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_HIBERNATION</span>
<span class="cm">/* kernel/power/snapshot.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__register_nosave_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">km</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">register_nosave_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__register_nosave_region</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">register_nosave_region_late</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__register_nosave_region</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">swsusp_page_is_forbidden</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swsusp_set_page_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">swsusp_unset_page_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_safe_page</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">hibernation_set_ops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">platform_hibernation_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hibernate</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">system_entering_hibernation</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_HIBERNATION */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">register_nosave_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">register_nosave_region_late</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">e</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">swsusp_page_is_forbidden</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swsusp_set_page_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swsusp_unset_page_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hibernation_set_ops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">platform_hibernation_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hibernate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">system_entering_hibernation</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIBERNATION */</span><span class="cp"></span>

<span class="cm">/* Hibernation and suspend events */</span>
<span class="cp">#define PM_HIBERNATION_PREPARE	0x0001 </span><span class="cm">/* Going to hibernate */</span><span class="cp"></span>
<span class="cp">#define PM_POST_HIBERNATION	0x0002 </span><span class="cm">/* Hibernation finished */</span><span class="cp"></span>
<span class="cp">#define PM_SUSPEND_PREPARE	0x0003 </span><span class="cm">/* Going to suspend the system */</span><span class="cp"></span>
<span class="cp">#define PM_POST_SUSPEND		0x0004 </span><span class="cm">/* Suspend finished */</span><span class="cp"></span>
<span class="cp">#define PM_RESTORE_PREPARE	0x0005 </span><span class="cm">/* Going to restore a saved image */</span><span class="cp"></span>
<span class="cp">#define PM_POST_RESTORE		0x0006 </span><span class="cm">/* Restore failed */</span><span class="cp"></span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">pm_mutex</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="kt">void</span> <span class="n">save_processor_state</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">restore_processor_state</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* kernel/power/main.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">register_pm_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">unregister_pm_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cp">#define pm_notifier(fn, pri) {				\</span>
<span class="cp">	static struct notifier_block fn##_nb =			\</span>
<span class="cp">		{ .notifier_call = fn, .priority = pri };	\</span>
<span class="cp">	register_pm_notifier(&amp;fn##_nb);			\</span>
<span class="cp">}</span>

<span class="cm">/* drivers/base/power/wakeup.c */</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">events_check_enabled</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">pm_wakeup_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">pm_get_wakeup_count</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="n">bool</span> <span class="n">block</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">pm_save_wakeup_count</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pm_wakep_autosleep_enabled</span><span class="p">(</span><span class="n">bool</span> <span class="n">set</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_system_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_FREEZER_SKIP</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_system_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t use freezer_count() because we don&#39;t want the call to</span>
<span class="cm">	 * try_to_freeze() here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Reason:</span>
<span class="cm">	 * Fundamentally, we just don&#39;t need it, because freezing condition</span>
<span class="cm">	 * doesn&#39;t come into effect until we release the pm_mutex lock,</span>
<span class="cm">	 * since the freezer always works with pm_mutex held.</span>
<span class="cm">	 *</span>
<span class="cm">	 * More importantly, in the case of hibernation,</span>
<span class="cm">	 * unlock_system_sleep() gets called in snapshot_read() and</span>
<span class="cm">	 * snapshot_write() when the freezing condition is still in effect.</span>
<span class="cm">	 * Which means, if we use try_to_freeze() here, it would make them</span>
<span class="cm">	 * enter the refrigerator, thus causing hibernation to lockup.</span>
<span class="cm">	 */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_FREEZER_SKIP</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pm_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">register_pm_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unregister_pm_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define pm_notifier(fn, pri)	do { (void)(fn); } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pm_wakeup_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lock_system_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_system_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM_AUTOSLEEP</span>

<span class="cm">/* kernel/power/autosleep.c */</span>
<span class="kt">void</span> <span class="n">queue_up_suspend_work</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_AUTOSLEEP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue_up_suspend_work</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_AUTOSLEEP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_ARCH_SAVE_PAGE_KEYS</span>
<span class="cm">/*</span>
<span class="cm"> * The ARCH_SAVE_PAGE_KEYS functions can be used by an architecture</span>
<span class="cm"> * to save/restore additional information to/from the array of page</span>
<span class="cm"> * frame numbers in the hibernation image. For s390 this is used to</span>
<span class="cm"> * save and restore the storage key for each page that is included</span>
<span class="cm"> * in the hibernation image.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_key_additional_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">page_key_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_key_free</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_key_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_key_memorize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">page_key_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_ARCH_SAVE_PAGE_KEYS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">page_key_additional_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>  <span class="nf">page_key_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">page_key_free</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">page_key_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">page_key_memorize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">page_key_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_ARCH_SAVE_PAGE_KEYS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_SUSPEND_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
