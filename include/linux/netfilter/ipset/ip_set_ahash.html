<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › netfilter › ipset › ip_set_ahash.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ip_set_ahash.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _IP_SET_AHASH_H</span>
<span class="cp">#define _IP_SET_AHASH_H</span>

<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter/ipset/ip_set_timeout.h&gt;</span>

<span class="cp">#define CONCAT(a, b, c)		a##b##c</span>
<span class="cp">#define TOKEN(a, b, c)		CONCAT(a, b, c)</span>

<span class="cp">#define type_pf_next		TOKEN(TYPE, PF, _elem)</span>

<span class="cm">/* Hashing which uses arrays to resolve clashing. The hash table is resized</span>
<span class="cm"> * (doubled) when searching becomes too long.</span>
<span class="cm"> * Internally jhash is used with the assumption that the size of the</span>
<span class="cm"> * stored data is a multiple of sizeof(u32). If storage supports timeout,</span>
<span class="cm"> * the timeout field must be the last one in the data structure - that field</span>
<span class="cm"> * is ignored when computing the hash key.</span>
<span class="cm"> *</span>
<span class="cm"> * Readers and resizing</span>
<span class="cm"> *</span>
<span class="cm"> * Resizing can be triggered by userspace command only, and those</span>
<span class="cm"> * are serialized by the nfnl mutex. During resizing the set is</span>
<span class="cm"> * read-locked, so the only possible concurrent operations are</span>
<span class="cm"> * the kernel side readers. Those must be protected by proper RCU locking.</span>
<span class="cm"> */</span>

<span class="cm">/* Number of elements to store in an initial array block */</span>
<span class="cp">#define AHASH_INIT_SIZE			4</span>
<span class="cm">/* Max number of elements to store in an array block */</span>
<span class="cp">#define AHASH_MAX_SIZE			(3*AHASH_INIT_SIZE)</span>

<span class="cm">/* Max number of elements can be tuned */</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_MULTI</span>
<span class="cp">#define AHASH_MAX(h)			((h)-&gt;ahash_max)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span>
<span class="nf">tune_ahash_max</span><span class="p">(</span><span class="n">u8</span> <span class="n">curr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">multi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">multi</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">curr</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">+</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">;</span>
	<span class="cm">/* Currently, at listing one hash bucket must fit into a message.</span>
<span class="cm">	 * Therefore we have a hard limit here.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">64</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define TUNE_AHASH_MAX(h, multi)	\</span>
<span class="cp">	((h)-&gt;ahash_max = tune_ahash_max((h)-&gt;ahash_max, multi))</span>
<span class="cp">#else</span>
<span class="cp">#define AHASH_MAX(h)			AHASH_MAX_SIZE</span>
<span class="cp">#define TUNE_AHASH_MAX(h, multi)</span>
<span class="cp">#endif</span>

<span class="cm">/* A hash bucket */</span>
<span class="k">struct</span> <span class="n">hbucket</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>		<span class="cm">/* the array of the values */</span>
	<span class="n">u8</span> <span class="n">size</span><span class="p">;</span>		<span class="cm">/* size of the array */</span>
	<span class="n">u8</span> <span class="n">pos</span><span class="p">;</span>			<span class="cm">/* position of the first free entry */</span>
<span class="p">};</span>

<span class="cm">/* The hash table: the table size stored here in order to make resizing easy */</span>
<span class="k">struct</span> <span class="n">htable</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">htable_bits</span><span class="p">;</span>		<span class="cm">/* size of hash table == 2^htable_bits */</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="n">bucket</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* hashtable buckets */</span>
<span class="p">};</span>

<span class="cp">#define hbucket(h, i)		(&amp;((h)-&gt;bucket[i]))</span>

<span class="cm">/* Book-keeping of the prefixes added to the set */</span>
<span class="k">struct</span> <span class="n">ip_set_hash_nets</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">cidr</span><span class="p">;</span>		<span class="cm">/* the different cidr values in the set */</span>
	<span class="n">u32</span> <span class="n">nets</span><span class="p">;</span>		<span class="cm">/* number of elements per cidr */</span>
<span class="p">};</span>

<span class="cm">/* The generic ip_set hash structure */</span>
<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>	<span class="cm">/* the hash table */</span>
	<span class="n">u32</span> <span class="n">maxelem</span><span class="p">;</span>		<span class="cm">/* max elements in the hash */</span>
	<span class="n">u32</span> <span class="n">elements</span><span class="p">;</span>		<span class="cm">/* current element (vs timeout) */</span>
	<span class="n">u32</span> <span class="n">initval</span><span class="p">;</span>		<span class="cm">/* random jhash init value */</span>
	<span class="n">u32</span> <span class="n">timeout</span><span class="p">;</span>		<span class="cm">/* timeout value, if enabled */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">gc</span><span class="p">;</span>	<span class="cm">/* garbage collection when timeout enabled */</span>
	<span class="k">struct</span> <span class="n">type_pf_next</span> <span class="n">next</span><span class="p">;</span> <span class="cm">/* temporary storage for uadd */</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_MULTI</span>
	<span class="n">u8</span> <span class="n">ahash_max</span><span class="p">;</span>		<span class="cm">/* max elements in an array block */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETMASK</span>
	<span class="n">u8</span> <span class="n">netmask</span><span class="p">;</span>		<span class="cm">/* netmask value for subnets to store */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_RBTREE</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rbtree</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
	<span class="k">struct</span> <span class="n">ip_set_hash_nets</span> <span class="n">nets</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* book-keeping of prefixes */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">size_t</span>
<span class="nf">htable_size</span><span class="p">(</span><span class="n">u8</span> <span class="n">hbits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">hsize</span><span class="p">;</span>

	<span class="cm">/* We must fit both into u32 in jhash and size_t */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hbits</span> <span class="o">&gt;</span> <span class="mi">31</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hsize</span> <span class="o">=</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">hbits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((((</span><span class="kt">size_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">htable</span><span class="p">))</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hbucket</span><span class="p">)</span>
	    <span class="o">&lt;</span> <span class="n">hsize</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hsize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hbucket</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">htable</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Compute htable_bits from the user input parameter hashsize */</span>
<span class="k">static</span> <span class="n">u8</span>
<span class="nf">htable_bits</span><span class="p">(</span><span class="n">u32</span> <span class="n">hashsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Assume that hashsize == 2^htable_bits */</span>
	<span class="n">u8</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">hashsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jhash_size</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">!=</span> <span class="n">hashsize</span><span class="p">)</span>
		<span class="cm">/* Round up to the first 2^n value */</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">hashsize</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS_PACKED</span>
<span class="cm">/* When cidr is packed with nomatch, cidr - 1 is stored in the entry */</span>
<span class="cp">#define CIDR(cidr)	(cidr + 1)</span>
<span class="cp">#else</span>
<span class="cp">#define CIDR(cidr)	(cidr)</span>
<span class="cp">#endif</span>

<span class="cp">#define SET_HOST_MASK(family)	(family == AF_INET ? 32 : 128)</span>

<span class="cm">/* Network cidr size book keeping when the hash stores different</span>
<span class="cm"> * sized networks */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">add_cidr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cidr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">host_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>

	<span class="o">++</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">cidr</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nets</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;add_cidr added %u: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cidr</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">cidr</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nets</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">cidr</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nets</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* New cidr size */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host_mask</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cidr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add in increasing prefix order, so larger cidr first */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cidr</span> <span class="o">&lt;</span> <span class="n">cidr</span><span class="p">)</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cidr</span><span class="p">,</span> <span class="n">cidr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">host_mask</span><span class="p">)</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cidr</span> <span class="o">=</span> <span class="n">cidr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">del_cidr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cidr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">host_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>

	<span class="o">--</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">cidr</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nets</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;del_cidr deleted %u: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cidr</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">cidr</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nets</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">cidr</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nets</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* All entries with this cidr size deleted, so cleanup h-&gt;cidr[] */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host_mask</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cidr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cidr</span> <span class="o">==</span> <span class="n">cidr</span><span class="p">)</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cidr</span> <span class="o">=</span> <span class="n">cidr</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">cidr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">cidr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Destroy the hashtable part of the set */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ahash_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="cm">/* FIXME: use slab cache */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ip_set_free</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Calculate the actual memory size of the set data */</span>
<span class="k">static</span> <span class="kt">size_t</span>
<span class="nf">ahash_memsize</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dsize</span><span class="p">,</span> <span class="n">u8</span> <span class="n">host_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">memsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
			 <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
			 <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set_hash_nets</span><span class="p">)</span> <span class="o">*</span> <span class="n">host_mask</span>
<span class="cp">#endif</span>
			 <span class="o">+</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hbucket</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">memsize</span> <span class="o">+=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">*</span> <span class="n">dsize</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">memsize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Flush a hash type of set: destroy all elements */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ip_set_hash_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* FIXME: use slab cache */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set_hash_nets</span><span class="p">)</span>
			   <span class="o">*</span> <span class="n">SET_HOST_MASK</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Destroy a hash type of set */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ip_set_hash_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">with_timeout</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">);</span>

	<span class="n">ahash_destroy</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_RBTREE</span>
	<span class="n">rbtree_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">rbtree</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* _IP_SET_AHASH_H */</span><span class="cp"></span>

<span class="cp">#ifndef HKEY_DATALEN</span>
<span class="cp">#define HKEY_DATALEN	sizeof(struct type_pf_elem)</span>
<span class="cp">#endif</span>

<span class="cp">#define HKEY(data, initval, htable_bits)			\</span>
<span class="cp">(jhash2((u32 *)(data), HKEY_DATALEN/sizeof(u32), initval)	\</span>
<span class="cp">	&amp; jhash_mask(htable_bits))</span>

<span class="cp">#define CONCAT(a, b, c)		a##b##c</span>
<span class="cp">#define TOKEN(a, b, c)		CONCAT(a, b, c)</span>

<span class="cm">/* Type/family dependent function prototypes */</span>

<span class="cp">#define type_pf_data_equal	TOKEN(TYPE, PF, _data_equal)</span>
<span class="cp">#define type_pf_data_isnull	TOKEN(TYPE, PF, _data_isnull)</span>
<span class="cp">#define type_pf_data_copy	TOKEN(TYPE, PF, _data_copy)</span>
<span class="cp">#define type_pf_data_zero_out	TOKEN(TYPE, PF, _data_zero_out)</span>
<span class="cp">#define type_pf_data_netmask	TOKEN(TYPE, PF, _data_netmask)</span>
<span class="cp">#define type_pf_data_list	TOKEN(TYPE, PF, _data_list)</span>
<span class="cp">#define type_pf_data_tlist	TOKEN(TYPE, PF, _data_tlist)</span>
<span class="cp">#define type_pf_data_next	TOKEN(TYPE, PF, _data_next)</span>
<span class="cp">#define type_pf_data_flags	TOKEN(TYPE, PF, _data_flags)</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
<span class="cp">#define type_pf_data_match	TOKEN(TYPE, PF, _data_match)</span>
<span class="cp">#else</span>
<span class="cp">#define type_pf_data_match(d)	1</span>
<span class="cp">#endif</span>

<span class="cp">#define type_pf_elem		TOKEN(TYPE, PF, _elem)</span>
<span class="cp">#define type_pf_telem		TOKEN(TYPE, PF, _telem)</span>
<span class="cp">#define type_pf_data_timeout	TOKEN(TYPE, PF, _data_timeout)</span>
<span class="cp">#define type_pf_data_expired	TOKEN(TYPE, PF, _data_expired)</span>
<span class="cp">#define type_pf_data_timeout_set TOKEN(TYPE, PF, _data_timeout_set)</span>

<span class="cp">#define type_pf_elem_add	TOKEN(TYPE, PF, _elem_add)</span>
<span class="cp">#define type_pf_add		TOKEN(TYPE, PF, _add)</span>
<span class="cp">#define type_pf_del		TOKEN(TYPE, PF, _del)</span>
<span class="cp">#define type_pf_test_cidrs	TOKEN(TYPE, PF, _test_cidrs)</span>
<span class="cp">#define type_pf_test		TOKEN(TYPE, PF, _test)</span>

<span class="cp">#define type_pf_elem_tadd	TOKEN(TYPE, PF, _elem_tadd)</span>
<span class="cp">#define type_pf_del_telem	TOKEN(TYPE, PF, _ahash_del_telem)</span>
<span class="cp">#define type_pf_expire		TOKEN(TYPE, PF, _expire)</span>
<span class="cp">#define type_pf_tadd		TOKEN(TYPE, PF, _tadd)</span>
<span class="cp">#define type_pf_tdel		TOKEN(TYPE, PF, _tdel)</span>
<span class="cp">#define type_pf_ttest_cidrs	TOKEN(TYPE, PF, _ahash_ttest_cidrs)</span>
<span class="cp">#define type_pf_ttest		TOKEN(TYPE, PF, _ahash_ttest)</span>

<span class="cp">#define type_pf_resize		TOKEN(TYPE, PF, _resize)</span>
<span class="cp">#define type_pf_tresize		TOKEN(TYPE, PF, _tresize)</span>
<span class="cp">#define type_pf_flush		ip_set_hash_flush</span>
<span class="cp">#define type_pf_destroy		ip_set_hash_destroy</span>
<span class="cp">#define type_pf_head		TOKEN(TYPE, PF, _head)</span>
<span class="cp">#define type_pf_list		TOKEN(TYPE, PF, _list)</span>
<span class="cp">#define type_pf_tlist		TOKEN(TYPE, PF, _tlist)</span>
<span class="cp">#define type_pf_same_set	TOKEN(TYPE, PF, _same_set)</span>
<span class="cp">#define type_pf_kadt		TOKEN(TYPE, PF, _kadt)</span>
<span class="cp">#define type_pf_uadt		TOKEN(TYPE, PF, _uadt)</span>
<span class="cp">#define type_pf_gc		TOKEN(TYPE, PF, _gc)</span>
<span class="cp">#define type_pf_gc_init		TOKEN(TYPE, PF, _gc_init)</span>
<span class="cp">#define type_pf_variant		TOKEN(TYPE, PF, _variant)</span>
<span class="cp">#define type_pf_tvariant	TOKEN(TYPE, PF, _tvariant)</span>

<span class="cm">/* Flavour without timeout */</span>

<span class="cm">/* Get the ith element from the array block n */</span>
<span class="cp">#define ahash_data(n, i)	\</span>
<span class="cp">	((struct type_pf_elem *)((n)-&gt;value) + (i))</span>

<span class="cm">/* Add an element to the hash table when resizing the set:</span>
<span class="cm"> * we spare the maintenance of the internal counters. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_elem_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
		 <span class="n">u8</span> <span class="n">ahash_max</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cadt_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">ahash_max</span><span class="p">)</span>
			<span class="cm">/* Trigger rehashing */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">)</span>
			      <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_elem</span><span class="p">),</span>
			      <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_elem</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">++</span><span class="p">);</span>
	<span class="n">type_pf_data_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
	<span class="cm">/* Resizing won&#39;t overwrite stored flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cadt_flags</span><span class="p">)</span>
		<span class="n">type_pf_data_flags</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cadt_flags</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Resize a hash: create a new hash table with doubling the hashsize</span>
<span class="cm"> * and inserting the elements to it. Repeat until we succeed or</span>
<span class="cm"> * fail due to memory pressures. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">bool</span> <span class="n">retried</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">orig</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">htable_bits</span> <span class="o">=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">htable_bits</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;attempt to resize set %s from %u to %u, t %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">,</span> <span class="n">htable_bits</span><span class="p">,</span> <span class="n">orig</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">htable_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In case we have plenty of memory :-) */</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Cannot increase the hashsize of set %s further</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">IPSET_ERR_HASH_FULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">ip_set_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
			 <span class="o">+</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">htable_bits</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hbucket</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span> <span class="o">=</span> <span class="n">htable_bits</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">htable_bits</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">type_pf_elem_add</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">ahash_destroy</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Give time to other readers of the set */</span>
	<span class="n">synchronize_rcu_bh</span><span class="p">();</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set %s resized from %u (%p) to %u (%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		 <span class="n">orig</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="n">ahash_destroy</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="n">type_pf_data_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">d</span><span class="p">);</span>

<span class="cm">/* Add an element to a hash and update the internal counters when succeeded,</span>
<span class="cm"> * otherwise report the proper error code. */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cadt_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxelem</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Set %s is full, maxelem %u reached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxelem</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">IPSET_ERR_HASH_FULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IPSET_FLAG_EXIST</span><span class="p">)</span>
				<span class="cm">/* Support overwriting just the flags */</span>
				<span class="n">type_pf_data_flags</span><span class="p">(</span><span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
						   <span class="n">cadt_flags</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">IPSET_ERR_EXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">TUNE_AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">multi</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">type_pf_elem_add</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">cadt_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="n">type_pf_data_next</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
	<span class="n">add_cidr</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">CIDR</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">),</span> <span class="n">HOST_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span><span class="o">++</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Delete an element from the hash: swap it with the last element</span>
<span class="cm"> * and free up space if possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* Not last one */</span>
			<span class="n">type_pf_data_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

		<span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">--</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
		<span class="n">del_cidr</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">CIDR</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">),</span> <span class="n">HOST_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">AHASH_INIT_SIZE</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">)</span>
					    <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_elem</span><span class="p">),</span>
					    <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
			       <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_elem</span><span class="p">));</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
			<span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">IPSET_ERR_EXIST</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>

<span class="cm">/* Special test function which takes into account the different network</span>
<span class="cm"> * sizes added to the set */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_test_cidrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">host_mask</span> <span class="o">=</span> <span class="n">SET_HOST_MASK</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;test by nets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">host_mask</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cidr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">multi</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type_pf_data_netmask</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cidr</span><span class="p">);</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">type_pf_data_match</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Test whether the element is added to the set */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
	<span class="cm">/* If we test an IP address and not a network address,</span>
<span class="cm">	 * try all possible network sizes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CIDR</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SET_HOST_MASK</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">type_pf_test_cidrs</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">type_pf_data_match</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reply a HEADER request: fill out the header part of the set */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nested</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">memsize</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memsize</span> <span class="o">=</span> <span class="n">ahash_memsize</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">with_timeout</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span>
					<span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_telem</span><span class="p">)</span>
					<span class="o">:</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_elem</span><span class="p">),</span>
				<span class="n">set</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET</span> <span class="o">?</span> <span class="mi">32</span> <span class="o">:</span> <span class="mi">128</span><span class="p">);</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">nested</span> <span class="o">=</span> <span class="n">ipset_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_net32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_HASHSIZE</span><span class="p">,</span>
			  <span class="n">htonl</span><span class="p">(</span><span class="n">jhash_size</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">)))</span> <span class="o">||</span>
	    <span class="n">nla_put_net32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_MAXELEM</span><span class="p">,</span> <span class="n">htonl</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">maxelem</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETMASK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">netmask</span> <span class="o">!=</span> <span class="n">HOST_MASK</span> <span class="o">&amp;&amp;</span>
	    <span class="n">nla_put_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_NETMASK</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">netmask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put_net32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_REFERENCES</span><span class="p">,</span> <span class="n">htonl</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">nla_put_net32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_MEMSIZE</span><span class="p">,</span> <span class="n">htonl</span><span class="p">(</span><span class="n">memsize</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">with_timeout</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">nla_put_net32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_TIMEOUT</span><span class="p">,</span> <span class="n">htonl</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nested</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">nla_put_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reply a LIST/SAVE request: dump the elements of the specified set */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_list</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">atd</span><span class="p">,</span> <span class="o">*</span><span class="n">nested</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="cm">/* We assume that one hash bucket fills into one page */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">incomplete</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">atd</span> <span class="o">=</span> <span class="n">ipset_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_ADT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;list hash set %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">incomplete</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cb-&gt;args[2]: %lu, t %p n %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_data</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;list hash %lu hbucket %p i %u, data %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="n">nested</span> <span class="o">=</span> <span class="n">ipset_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_DATA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">first</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">nla_nest_cancel</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">atd</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_list</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
			<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nested</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">atd</span><span class="p">);</span>
	<span class="cm">/* Set listing finished */</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">nlmsg_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">incomplete</span><span class="p">);</span>
	<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">atd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Can&#39;t list set %s: one bucket does not fit into &quot;</span>
			   <span class="s">&quot;a message. Please report it!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">type_pf_kadt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">,</span>
	     <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_action_param</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
	     <span class="k">enum</span> <span class="n">ipset_adt</span> <span class="n">adt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_adt_opt</span> <span class="o">*</span><span class="n">opt</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">type_pf_uadt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span>
	     <span class="k">enum</span> <span class="n">ipset_adt</span> <span class="n">adt</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">lineno</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">bool</span> <span class="n">retried</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_type_variant</span> <span class="n">type_pf_variant</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kadt</span>	<span class="o">=</span> <span class="n">type_pf_kadt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uadt</span>	<span class="o">=</span> <span class="n">type_pf_uadt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">adt</span>	<span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">IPSET_ADD</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_pf_add</span><span class="p">,</span>
		<span class="p">[</span><span class="n">IPSET_DEL</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_pf_del</span><span class="p">,</span>
		<span class="p">[</span><span class="n">IPSET_TEST</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_pf_test</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">type_pf_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span>	<span class="o">=</span> <span class="n">type_pf_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">head</span>	<span class="o">=</span> <span class="n">type_pf_head</span><span class="p">,</span>
	<span class="p">.</span><span class="n">list</span>	<span class="o">=</span> <span class="n">type_pf_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resize</span>	<span class="o">=</span> <span class="n">type_pf_resize</span><span class="p">,</span>
	<span class="p">.</span><span class="n">same_set</span> <span class="o">=</span> <span class="n">type_pf_same_set</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Flavour with timeout support */</span>

<span class="cp">#define ahash_tdata(n, i) \</span>
<span class="cp">	(struct type_pf_elem *)((struct type_pf_telem *)((n)-&gt;value) + (i))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">type_pf_data_timeout</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_telem</span> <span class="o">*</span><span class="n">tdata</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_telem</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tdata</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">type_pf_data_expired</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_telem</span> <span class="o">*</span><span class="n">tdata</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_telem</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ip_set_timeout_expired</span><span class="p">(</span><span class="n">tdata</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">type_pf_data_timeout_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">type_pf_telem</span> <span class="o">*</span><span class="n">tdata</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_telem</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">tdata</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">ip_set_timeout_set</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_elem_tadd</span><span class="p">(</span><span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
		  <span class="n">u8</span> <span class="n">ahash_max</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cadt_flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">ahash_max</span><span class="p">)</span>
			<span class="cm">/* Trigger rehashing */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">)</span>
			      <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_telem</span><span class="p">),</span>
			      <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_telem</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">++</span><span class="p">);</span>
	<span class="n">type_pf_data_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">type_pf_data_timeout_set</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
	<span class="cm">/* Resizing won&#39;t overwrite stored flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cadt_flags</span><span class="p">)</span>
		<span class="n">type_pf_data_flags</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cadt_flags</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Delete expired elements from the hashtable */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">type_pf_expire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_expired</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;expired %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
				<span class="n">del_cidr</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">CIDR</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">),</span> <span class="n">HOST_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="cm">/* Not last one */</span>
					<span class="n">type_pf_data_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
						<span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
				<span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">--</span><span class="p">;</span>
				<span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">AHASH_INIT_SIZE</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">)</span>
					    <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_telem</span><span class="p">),</span>
					    <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
				<span class="cm">/* Still try to delete expired elements */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
			       <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_telem</span><span class="p">));</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
			<span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_tresize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">bool</span> <span class="n">retried</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">orig</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">htable_bits</span> <span class="o">=</span> <span class="n">orig</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Try to cleanup once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retried</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">;</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">type_pf_expire</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span> <span class="o">&lt;</span>  <span class="n">i</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">htable_bits</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">htable_bits</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In case we have plenty of memory :-) */</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Cannot increase the hashsize of set %s further</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">IPSET_ERR_HASH_FULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">ip_set_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
			 <span class="o">+</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">htable_bits</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hbucket</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span> <span class="o">=</span> <span class="n">htable_bits</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">htable_bits</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">type_pf_elem_tadd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">type_pf_data_timeout</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">ahash_destroy</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Give time to other readers of the set */</span>
	<span class="n">synchronize_rcu_bh</span><span class="p">();</span>

	<span class="n">ahash_destroy</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_tadd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">flag_exist</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IPSET_FLAG_EXIST</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cadt_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxelem</span><span class="p">)</span>
		<span class="cm">/* FIXME: when set is full, we slow down here */</span>
		<span class="n">type_pf_expire</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxelem</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Set %s is full, maxelem %u reached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">maxelem</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">IPSET_ERR_HASH_FULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_expired</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">||</span> <span class="n">flag_exist</span><span class="p">)</span>
				<span class="cm">/* Just timeout value may be updated */</span>
				<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">IPSET_ERR_EXIST</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			   <span class="n">type_pf_data_expired</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
		<span class="n">del_cidr</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">CIDR</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">),</span> <span class="n">HOST_MASK</span><span class="p">);</span>
		<span class="n">add_cidr</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">CIDR</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">),</span> <span class="n">HOST_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">type_pf_data_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="n">type_pf_data_timeout_set</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
		<span class="n">type_pf_data_flags</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cadt_flags</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">TUNE_AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">multi</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">type_pf_elem_tadd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">AHASH_MAX</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">cadt_flags</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="n">type_pf_data_next</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
	<span class="n">add_cidr</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">CIDR</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">),</span> <span class="n">HOST_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span><span class="o">++</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_tdel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_expired</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">IPSET_ERR_EXIST</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* Not last one */</span>
			<span class="n">type_pf_data_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

		<span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">--</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">elements</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
		<span class="n">del_cidr</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">CIDR</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">),</span> <span class="n">HOST_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">AHASH_INIT_SIZE</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">)</span>
					    <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_telem</span><span class="p">),</span>
					    <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">AHASH_INIT_SIZE</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
			       <span class="n">n</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">type_pf_telem</span><span class="p">));</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
			<span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">IPSET_ERR_EXIST</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_ttest_cidrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">host_mask</span> <span class="o">=</span> <span class="n">SET_HOST_MASK</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">host_mask</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cidr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">multi</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">type_pf_data_netmask</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">cidr</span><span class="p">);</span>
		<span class="n">key</span> <span class="o">=</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#ifdef IP_SET_HASH_WITH_MULTI</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type_pf_data_expired</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">type_pf_data_match</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
				<span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">type_pf_data_expired</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">type_pf_data_match</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_ttest</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef IP_SET_HASH_WITH_NETS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CIDR</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">cidr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SET_HOST_MASK</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">type_pf_ttest_cidrs</span><span class="p">(</span><span class="n">set</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">key</span> <span class="o">=</span> <span class="n">HKEY</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">initval</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_equal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">type_pf_data_expired</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">type_pf_data_match</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">type_pf_tlist</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">htable</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">atd</span><span class="p">,</span> <span class="o">*</span><span class="n">nested</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">hbucket</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">type_pf_elem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="cm">/* We assume that one hash bucket fills into one page */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">incomplete</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">atd</span> <span class="o">=</span> <span class="n">ipset_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_ADT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">jhash_size</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">htable_bits</span><span class="p">);</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">incomplete</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">hbucket</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">ahash_tdata</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;list %p %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_expired</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;do list %p %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">nested</span> <span class="o">=</span> <span class="n">ipset_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_DATA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nested</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">first</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">nla_nest_cancel</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">atd</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type_pf_data_tlist</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
			<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nested</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">atd</span><span class="p">);</span>
	<span class="cm">/* Set listing finished */</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">nlmsg_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">incomplete</span><span class="p">);</span>
	<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">atd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Can&#39;t list set %s: one bucket does not fit into &quot;</span>
			   <span class="s">&quot;a message. Please report it!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_type_variant</span> <span class="n">type_pf_tvariant</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kadt</span>	<span class="o">=</span> <span class="n">type_pf_kadt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uadt</span>	<span class="o">=</span> <span class="n">type_pf_uadt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">adt</span>	<span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">IPSET_ADD</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_pf_tadd</span><span class="p">,</span>
		<span class="p">[</span><span class="n">IPSET_DEL</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_pf_tdel</span><span class="p">,</span>
		<span class="p">[</span><span class="n">IPSET_TEST</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_pf_ttest</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">type_pf_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span>	<span class="o">=</span> <span class="n">type_pf_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">head</span>	<span class="o">=</span> <span class="n">type_pf_head</span><span class="p">,</span>
	<span class="p">.</span><span class="n">list</span>	<span class="o">=</span> <span class="n">type_pf_tlist</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resize</span>	<span class="o">=</span> <span class="n">type_pf_tresize</span><span class="p">,</span>
	<span class="p">.</span><span class="n">same_set</span> <span class="o">=</span> <span class="n">type_pf_same_set</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">type_pf_gc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ul_set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="p">)</span> <span class="n">ul_set</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">type_pf_expire</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">IPSET_GC_PERIOD</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">type_pf_gc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ip_set_hash</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">set</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">type_pf_gc</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">IPSET_GC_PERIOD</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;gc initialized, run in every %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">IPSET_GC_PERIOD</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#undef HKEY_DATALEN</span>
<span class="cp">#undef HKEY</span>
<span class="cp">#undef type_pf_data_equal</span>
<span class="cp">#undef type_pf_data_isnull</span>
<span class="cp">#undef type_pf_data_copy</span>
<span class="cp">#undef type_pf_data_zero_out</span>
<span class="cp">#undef type_pf_data_netmask</span>
<span class="cp">#undef type_pf_data_list</span>
<span class="cp">#undef type_pf_data_tlist</span>
<span class="cp">#undef type_pf_data_next</span>
<span class="cp">#undef type_pf_data_flags</span>
<span class="cp">#undef type_pf_data_match</span>

<span class="cp">#undef type_pf_elem</span>
<span class="cp">#undef type_pf_telem</span>
<span class="cp">#undef type_pf_data_timeout</span>
<span class="cp">#undef type_pf_data_expired</span>
<span class="cp">#undef type_pf_data_timeout_set</span>

<span class="cp">#undef type_pf_elem_add</span>
<span class="cp">#undef type_pf_add</span>
<span class="cp">#undef type_pf_del</span>
<span class="cp">#undef type_pf_test_cidrs</span>
<span class="cp">#undef type_pf_test</span>

<span class="cp">#undef type_pf_elem_tadd</span>
<span class="cp">#undef type_pf_del_telem</span>
<span class="cp">#undef type_pf_expire</span>
<span class="cp">#undef type_pf_tadd</span>
<span class="cp">#undef type_pf_tdel</span>
<span class="cp">#undef type_pf_ttest_cidrs</span>
<span class="cp">#undef type_pf_ttest</span>

<span class="cp">#undef type_pf_resize</span>
<span class="cp">#undef type_pf_tresize</span>
<span class="cp">#undef type_pf_flush</span>
<span class="cp">#undef type_pf_destroy</span>
<span class="cp">#undef type_pf_head</span>
<span class="cp">#undef type_pf_list</span>
<span class="cp">#undef type_pf_tlist</span>
<span class="cp">#undef type_pf_same_set</span>
<span class="cp">#undef type_pf_kadt</span>
<span class="cp">#undef type_pf_uadt</span>
<span class="cp">#undef type_pf_gc</span>
<span class="cp">#undef type_pf_gc_init</span>
<span class="cp">#undef type_pf_variant</span>
<span class="cp">#undef type_pf_tvariant</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
