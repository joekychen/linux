<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › netfilter › ipset › ip_set.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ip_set.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _IP_SET_H</span>
<span class="cp">#define _IP_SET_H</span>

<span class="cm">/* Copyright (C) 2000-2002 Joakim Axelsson &lt;gozem@linux.nu&gt;</span>
<span class="cm"> *                         Patrick Schaaf &lt;bof@bof.de&gt;</span>
<span class="cm"> *                         Martin Josefsson &lt;gandalf@wlug.westbo.se&gt;</span>
<span class="cm"> * Copyright (C) 2003-2011 Jozsef Kadlecsik &lt;kadlec@blackhole.kfki.hu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/* The protocol version */</span>
<span class="cp">#define IPSET_PROTOCOL		6</span>

<span class="cm">/* The max length of strings including NUL: set and type identifiers */</span>
<span class="cp">#define IPSET_MAXNAMELEN	32</span>

<span class="cm">/* Message types and commands */</span>
<span class="k">enum</span> <span class="n">ipset_cmd</span> <span class="p">{</span>
	<span class="n">IPSET_CMD_NONE</span><span class="p">,</span>
	<span class="n">IPSET_CMD_PROTOCOL</span><span class="p">,</span>	<span class="cm">/* 1: Return protocol version */</span>
	<span class="n">IPSET_CMD_CREATE</span><span class="p">,</span>	<span class="cm">/* 2: Create a new (empty) set */</span>
	<span class="n">IPSET_CMD_DESTROY</span><span class="p">,</span>	<span class="cm">/* 3: Destroy a (empty) set */</span>
	<span class="n">IPSET_CMD_FLUSH</span><span class="p">,</span>	<span class="cm">/* 4: Remove all elements from a set */</span>
	<span class="n">IPSET_CMD_RENAME</span><span class="p">,</span>	<span class="cm">/* 5: Rename a set */</span>
	<span class="n">IPSET_CMD_SWAP</span><span class="p">,</span>		<span class="cm">/* 6: Swap two sets */</span>
	<span class="n">IPSET_CMD_LIST</span><span class="p">,</span>		<span class="cm">/* 7: List sets */</span>
	<span class="n">IPSET_CMD_SAVE</span><span class="p">,</span>		<span class="cm">/* 8: Save sets */</span>
	<span class="n">IPSET_CMD_ADD</span><span class="p">,</span>		<span class="cm">/* 9: Add an element to a set */</span>
	<span class="n">IPSET_CMD_DEL</span><span class="p">,</span>		<span class="cm">/* 10: Delete an element from a set */</span>
	<span class="n">IPSET_CMD_TEST</span><span class="p">,</span>		<span class="cm">/* 11: Test an element in a set */</span>
	<span class="n">IPSET_CMD_HEADER</span><span class="p">,</span>	<span class="cm">/* 12: Get set header data only */</span>
	<span class="n">IPSET_CMD_TYPE</span><span class="p">,</span>		<span class="cm">/* 13: Get set type */</span>
	<span class="n">IPSET_MSG_MAX</span><span class="p">,</span>		<span class="cm">/* Netlink message commands */</span>

	<span class="cm">/* Commands in userspace: */</span>
	<span class="n">IPSET_CMD_RESTORE</span> <span class="o">=</span> <span class="n">IPSET_MSG_MAX</span><span class="p">,</span> <span class="cm">/* 14: Enter restore mode */</span>
	<span class="n">IPSET_CMD_HELP</span><span class="p">,</span>		<span class="cm">/* 15: Get help */</span>
	<span class="n">IPSET_CMD_VERSION</span><span class="p">,</span>	<span class="cm">/* 16: Get program version */</span>
	<span class="n">IPSET_CMD_QUIT</span><span class="p">,</span>		<span class="cm">/* 17: Quit from interactive mode */</span>

	<span class="n">IPSET_CMD_MAX</span><span class="p">,</span>

	<span class="n">IPSET_CMD_COMMIT</span> <span class="o">=</span> <span class="n">IPSET_CMD_MAX</span><span class="p">,</span> <span class="cm">/* 18: Commit buffered commands */</span>
<span class="p">};</span>

<span class="cm">/* Attributes at command level */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IPSET_ATTR_UNSPEC</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_PROTOCOL</span><span class="p">,</span>	<span class="cm">/* 1: Protocol version */</span>
	<span class="n">IPSET_ATTR_SETNAME</span><span class="p">,</span>	<span class="cm">/* 2: Name of the set */</span>
	<span class="n">IPSET_ATTR_TYPENAME</span><span class="p">,</span>	<span class="cm">/* 3: Typename */</span>
	<span class="n">IPSET_ATTR_SETNAME2</span> <span class="o">=</span> <span class="n">IPSET_ATTR_TYPENAME</span><span class="p">,</span> <span class="cm">/* Setname at rename/swap */</span>
	<span class="n">IPSET_ATTR_REVISION</span><span class="p">,</span>	<span class="cm">/* 4: Settype revision */</span>
	<span class="n">IPSET_ATTR_FAMILY</span><span class="p">,</span>	<span class="cm">/* 5: Settype family */</span>
	<span class="n">IPSET_ATTR_FLAGS</span><span class="p">,</span>	<span class="cm">/* 6: Flags at command level */</span>
	<span class="n">IPSET_ATTR_DATA</span><span class="p">,</span>	<span class="cm">/* 7: Nested attributes */</span>
	<span class="n">IPSET_ATTR_ADT</span><span class="p">,</span>		<span class="cm">/* 8: Multiple data containers */</span>
	<span class="n">IPSET_ATTR_LINENO</span><span class="p">,</span>	<span class="cm">/* 9: Restore lineno */</span>
	<span class="n">IPSET_ATTR_PROTOCOL_MIN</span><span class="p">,</span> <span class="cm">/* 10: Minimal supported version number */</span>
	<span class="n">IPSET_ATTR_REVISION_MIN</span>	<span class="o">=</span> <span class="n">IPSET_ATTR_PROTOCOL_MIN</span><span class="p">,</span> <span class="cm">/* type rev min */</span>
	<span class="n">__IPSET_ATTR_CMD_MAX</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define IPSET_ATTR_CMD_MAX	(__IPSET_ATTR_CMD_MAX - 1)</span>

<span class="cm">/* CADT specific attributes */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IPSET_ATTR_IP</span> <span class="o">=</span> <span class="n">IPSET_ATTR_UNSPEC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_IP_FROM</span> <span class="o">=</span> <span class="n">IPSET_ATTR_IP</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_IP_TO</span><span class="p">,</span>	<span class="cm">/* 2 */</span>
	<span class="n">IPSET_ATTR_CIDR</span><span class="p">,</span>	<span class="cm">/* 3 */</span>
	<span class="n">IPSET_ATTR_PORT</span><span class="p">,</span>	<span class="cm">/* 4 */</span>
	<span class="n">IPSET_ATTR_PORT_FROM</span> <span class="o">=</span> <span class="n">IPSET_ATTR_PORT</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_PORT_TO</span><span class="p">,</span>	<span class="cm">/* 5 */</span>
	<span class="n">IPSET_ATTR_TIMEOUT</span><span class="p">,</span>	<span class="cm">/* 6 */</span>
	<span class="n">IPSET_ATTR_PROTO</span><span class="p">,</span>	<span class="cm">/* 7 */</span>
	<span class="n">IPSET_ATTR_CADT_FLAGS</span><span class="p">,</span>	<span class="cm">/* 8 */</span>
	<span class="n">IPSET_ATTR_CADT_LINENO</span> <span class="o">=</span> <span class="n">IPSET_ATTR_LINENO</span><span class="p">,</span>	<span class="cm">/* 9 */</span>
	<span class="cm">/* Reserve empty slots */</span>
	<span class="n">IPSET_ATTR_CADT_MAX</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="cm">/* Create-only specific attributes */</span>
	<span class="n">IPSET_ATTR_GC</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_HASHSIZE</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_MAXELEM</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_NETMASK</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_PROBES</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_RESIZE</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_SIZE</span><span class="p">,</span>
	<span class="cm">/* Kernel-only */</span>
	<span class="n">IPSET_ATTR_ELEMENTS</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_REFERENCES</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_MEMSIZE</span><span class="p">,</span>

	<span class="n">__IPSET_ATTR_CREATE_MAX</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define IPSET_ATTR_CREATE_MAX	(__IPSET_ATTR_CREATE_MAX - 1)</span>

<span class="cm">/* ADT specific attributes */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IPSET_ATTR_ETHER</span> <span class="o">=</span> <span class="n">IPSET_ATTR_CADT_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_NAME</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_NAMEREF</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_IP2</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_CIDR2</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_IP2_TO</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_IFACE</span><span class="p">,</span>
	<span class="n">__IPSET_ATTR_ADT_MAX</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define IPSET_ATTR_ADT_MAX	(__IPSET_ATTR_ADT_MAX - 1)</span>

<span class="cm">/* IP specific attributes */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IPSET_ATTR_IPADDR_IPV4</span> <span class="o">=</span> <span class="n">IPSET_ATTR_UNSPEC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IPSET_ATTR_IPADDR_IPV6</span><span class="p">,</span>
	<span class="n">__IPSET_ATTR_IPADDR_MAX</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define IPSET_ATTR_IPADDR_MAX	(__IPSET_ATTR_IPADDR_MAX - 1)</span>

<span class="cm">/* Error codes */</span>
<span class="k">enum</span> <span class="n">ipset_errno</span> <span class="p">{</span>
	<span class="n">IPSET_ERR_PRIVATE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span>
	<span class="n">IPSET_ERR_PROTOCOL</span><span class="p">,</span>
	<span class="n">IPSET_ERR_FIND_TYPE</span><span class="p">,</span>
	<span class="n">IPSET_ERR_MAX_SETS</span><span class="p">,</span>
	<span class="n">IPSET_ERR_BUSY</span><span class="p">,</span>
	<span class="n">IPSET_ERR_EXIST_SETNAME2</span><span class="p">,</span>
	<span class="n">IPSET_ERR_TYPE_MISMATCH</span><span class="p">,</span>
	<span class="n">IPSET_ERR_EXIST</span><span class="p">,</span>
	<span class="n">IPSET_ERR_INVALID_CIDR</span><span class="p">,</span>
	<span class="n">IPSET_ERR_INVALID_NETMASK</span><span class="p">,</span>
	<span class="n">IPSET_ERR_INVALID_FAMILY</span><span class="p">,</span>
	<span class="n">IPSET_ERR_TIMEOUT</span><span class="p">,</span>
	<span class="n">IPSET_ERR_REFERENCED</span><span class="p">,</span>
	<span class="n">IPSET_ERR_IPADDR_IPV4</span><span class="p">,</span>
	<span class="n">IPSET_ERR_IPADDR_IPV6</span><span class="p">,</span>

	<span class="cm">/* Type specific error codes */</span>
	<span class="n">IPSET_ERR_TYPE_SPECIFIC</span> <span class="o">=</span> <span class="mi">4352</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Flags at command level */</span>
<span class="k">enum</span> <span class="n">ipset_cmd_flags</span> <span class="p">{</span>
	<span class="n">IPSET_FLAG_BIT_EXIST</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IPSET_FLAG_EXIST</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_FLAG_BIT_EXIST</span><span class="p">),</span>
	<span class="n">IPSET_FLAG_BIT_LIST_SETNAME</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IPSET_FLAG_LIST_SETNAME</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_FLAG_BIT_LIST_SETNAME</span><span class="p">),</span>
	<span class="n">IPSET_FLAG_BIT_LIST_HEADER</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IPSET_FLAG_LIST_HEADER</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_FLAG_BIT_LIST_HEADER</span><span class="p">),</span>
	<span class="n">IPSET_FLAG_CMD_MAX</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>	<span class="cm">/* Lower half */</span>
<span class="p">};</span>

<span class="cm">/* Flags at CADT attribute level */</span>
<span class="k">enum</span> <span class="n">ipset_cadt_flags</span> <span class="p">{</span>
	<span class="n">IPSET_FLAG_BIT_BEFORE</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IPSET_FLAG_BEFORE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_FLAG_BIT_BEFORE</span><span class="p">),</span>
	<span class="n">IPSET_FLAG_BIT_PHYSDEV</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IPSET_FLAG_PHYSDEV</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_FLAG_BIT_PHYSDEV</span><span class="p">),</span>
	<span class="n">IPSET_FLAG_BIT_NOMATCH</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IPSET_FLAG_NOMATCH</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_FLAG_BIT_NOMATCH</span><span class="p">),</span>
	<span class="n">IPSET_FLAG_CADT_MAX</span>	<span class="o">=</span> <span class="mi">15</span><span class="p">,</span>	<span class="cm">/* Upper half */</span>
<span class="p">};</span>

<span class="cm">/* Commands with settype-specific attributes */</span>
<span class="k">enum</span> <span class="n">ipset_adt</span> <span class="p">{</span>
	<span class="n">IPSET_ADD</span><span class="p">,</span>
	<span class="n">IPSET_DEL</span><span class="p">,</span>
	<span class="n">IPSET_TEST</span><span class="p">,</span>
	<span class="n">IPSET_ADT_MAX</span><span class="p">,</span>
	<span class="n">IPSET_CREATE</span> <span class="o">=</span> <span class="n">IPSET_ADT_MAX</span><span class="p">,</span>
	<span class="n">IPSET_CADT_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Sets are identified by an index in kernel space. Tweak with ip_set_id_t</span>
<span class="cm"> * and IPSET_INVALID_ID if you want to increase the max number of sets.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">__u16</span> <span class="n">ip_set_id_t</span><span class="p">;</span>

<span class="cp">#define IPSET_INVALID_ID		65535</span>

<span class="k">enum</span> <span class="n">ip_set_dim</span> <span class="p">{</span>
	<span class="n">IPSET_DIM_ZERO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IPSET_DIM_ONE</span><span class="p">,</span>
	<span class="n">IPSET_DIM_TWO</span><span class="p">,</span>
	<span class="n">IPSET_DIM_THREE</span><span class="p">,</span>
	<span class="cm">/* Max dimension in elements.</span>
<span class="cm">	 * If changed, new revision of iptables match/target is required.</span>
<span class="cm">	 */</span>
	<span class="n">IPSET_DIM_MAX</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Option flags for kernel operations */</span>
<span class="k">enum</span> <span class="n">ip_set_kopt</span> <span class="p">{</span>
	<span class="n">IPSET_INV_MATCH</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_DIM_ZERO</span><span class="p">),</span>
	<span class="n">IPSET_DIM_ONE_SRC</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_DIM_ONE</span><span class="p">),</span>
	<span class="n">IPSET_DIM_TWO_SRC</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_DIM_TWO</span><span class="p">),</span>
	<span class="n">IPSET_DIM_THREE_SRC</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_DIM_THREE</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter/x_tables.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;net/netlink.h&gt;</span>

<span class="cm">/* Set features */</span>
<span class="k">enum</span> <span class="n">ip_set_feature</span> <span class="p">{</span>
	<span class="n">IPSET_TYPE_IP_FLAG</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IPSET_TYPE_IP</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_TYPE_IP_FLAG</span><span class="p">),</span>
	<span class="n">IPSET_TYPE_PORT_FLAG</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IPSET_TYPE_PORT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_TYPE_PORT_FLAG</span><span class="p">),</span>
	<span class="n">IPSET_TYPE_MAC_FLAG</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IPSET_TYPE_MAC</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_TYPE_MAC_FLAG</span><span class="p">),</span>
	<span class="n">IPSET_TYPE_IP2_FLAG</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">IPSET_TYPE_IP2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_TYPE_IP2_FLAG</span><span class="p">),</span>
	<span class="n">IPSET_TYPE_NAME_FLAG</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">IPSET_TYPE_NAME</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_TYPE_NAME_FLAG</span><span class="p">),</span>
	<span class="n">IPSET_TYPE_IFACE_FLAG</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">IPSET_TYPE_IFACE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_TYPE_IFACE_FLAG</span><span class="p">),</span>
	<span class="cm">/* Strictly speaking not a feature, but a flag for dumping:</span>
<span class="cm">	 * this settype must be dumped last */</span>
	<span class="n">IPSET_DUMP_LAST_FLAG</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="n">IPSET_DUMP_LAST</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IPSET_DUMP_LAST_FLAG</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ip_set</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipset_adtfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Kernel API function options */</span>
<span class="k">struct</span> <span class="n">ip_set_adt_opt</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">family</span><span class="p">;</span>		<span class="cm">/* Actual protocol family */</span>
	<span class="n">u8</span> <span class="n">dim</span><span class="p">;</span>			<span class="cm">/* Dimension of match/target */</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Direction and negation flags */</span>
	<span class="n">u32</span> <span class="n">cmdflags</span><span class="p">;</span>		<span class="cm">/* Command-like flags */</span>
	<span class="n">u32</span> <span class="n">timeout</span><span class="p">;</span>		<span class="cm">/* Timeout value */</span>
<span class="p">};</span>

<span class="cm">/* Set type, variant-specific part */</span>
<span class="k">struct</span> <span class="n">ip_set_type_variant</span> <span class="p">{</span>
	<span class="cm">/* Kernelspace: test/add/del entries</span>
<span class="cm">	 *		returns negative error code,</span>
<span class="cm">	 *			zero for no match/success to add/delete</span>
<span class="cm">	 *			positive for matching element */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">kadt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_action_param</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
		    <span class="k">enum</span> <span class="n">ipset_adt</span> <span class="n">adt</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_adt_opt</span> <span class="o">*</span><span class="n">opt</span><span class="p">);</span>

	<span class="cm">/* Userspace: test/add/del entries</span>
<span class="cm">	 *		returns negative error code,</span>
<span class="cm">	 *			zero for no match/success to add/delete</span>
<span class="cm">	 *			positive for matching element */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">uadt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span>
		    <span class="k">enum</span> <span class="n">ipset_adt</span> <span class="n">adt</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">lineno</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">bool</span> <span class="n">retried</span><span class="p">);</span>

	<span class="cm">/* Low level add/del/test functions */</span>
	<span class="n">ipset_adtfn</span> <span class="n">adt</span><span class="p">[</span><span class="n">IPSET_ADT_MAX</span><span class="p">];</span>

	<span class="cm">/* When adding entries and set is full, try to resize the set */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resize</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">bool</span> <span class="n">retried</span><span class="p">);</span>
	<span class="cm">/* Destroy the set */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
	<span class="cm">/* Flush the elements */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
	<span class="cm">/* Expire entries before listing */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">expire</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
	<span class="cm">/* List set header data */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
	<span class="cm">/* List elements */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">list</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">);</span>

	<span class="cm">/* Return true if &quot;b&quot; set is the same as &quot;a&quot;</span>
<span class="cm">	 * according to the create set parameters */</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">same_set</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* The core set type structure */</span>
<span class="k">struct</span> <span class="n">ip_set_type</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* Typename */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IPSET_MAXNAMELEN</span><span class="p">];</span>
	<span class="cm">/* Protocol version */</span>
	<span class="n">u8</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="cm">/* Set features to control swapping */</span>
	<span class="n">u8</span> <span class="n">features</span><span class="p">;</span>
	<span class="cm">/* Set type dimension */</span>
	<span class="n">u8</span> <span class="n">dimension</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Supported family: may be NFPROTO_UNSPEC for both</span>
<span class="cm">	 * NFPROTO_IPV4/NFPROTO_IPV6.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">family</span><span class="p">;</span>
	<span class="cm">/* Type revisions */</span>
	<span class="n">u8</span> <span class="n">revision_min</span><span class="p">,</span> <span class="n">revision_max</span><span class="p">;</span>

	<span class="cm">/* Create set */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ip_set</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Attribute policies */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">create_policy</span><span class="p">[</span><span class="n">IPSET_ATTR_CREATE_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">adt_policy</span><span class="p">[</span><span class="n">IPSET_ATTR_ADT_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Set this to THIS_MODULE if you are a module, otherwise NULL */</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* register and unregister set type */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_set_type_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set_type</span> <span class="o">*</span><span class="n">set_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_set_type_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">ip_set_type</span> <span class="o">*</span><span class="n">set_type</span><span class="p">);</span>

<span class="cm">/* A generic IP set */</span>
<span class="k">struct</span> <span class="n">ip_set</span> <span class="p">{</span>
	<span class="cm">/* The name of the set */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IPSET_MAXNAMELEN</span><span class="p">];</span>
	<span class="cm">/* Lock protecting the set data */</span>
	<span class="n">rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="cm">/* References to the set */</span>
	<span class="n">u32</span> <span class="n">ref</span><span class="p">;</span>
	<span class="cm">/* The core set type */</span>
	<span class="k">struct</span> <span class="n">ip_set_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="cm">/* The type variant doing the real job */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_type_variant</span> <span class="o">*</span><span class="n">variant</span><span class="p">;</span>
	<span class="cm">/* The actual INET family of the set */</span>
	<span class="n">u8</span> <span class="n">family</span><span class="p">;</span>
	<span class="cm">/* The type revision */</span>
	<span class="n">u8</span> <span class="n">revision</span><span class="p">;</span>
	<span class="cm">/* The type specific data */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* register and unregister set references */</span>
<span class="k">extern</span> <span class="n">ip_set_id_t</span> <span class="n">ip_set_get_byname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ip_set</span> <span class="o">**</span><span class="n">set</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_set_put_byindex</span><span class="p">(</span><span class="n">ip_set_id_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip_set_name_byindex</span><span class="p">(</span><span class="n">ip_set_id_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ip_set_id_t</span> <span class="n">ip_set_nfnl_get</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ip_set_id_t</span> <span class="n">ip_set_nfnl_get_byindex</span><span class="p">(</span><span class="n">ip_set_id_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_set_nfnl_put</span><span class="p">(</span><span class="n">ip_set_id_t</span> <span class="n">index</span><span class="p">);</span>

<span class="cm">/* API for iptables set match, and SET target */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_set_add</span><span class="p">(</span><span class="n">ip_set_id_t</span> <span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_action_param</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_adt_opt</span> <span class="o">*</span><span class="n">opt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_set_del</span><span class="p">(</span><span class="n">ip_set_id_t</span> <span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_action_param</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_adt_opt</span> <span class="o">*</span><span class="n">opt</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_set_test</span><span class="p">(</span><span class="n">ip_set_id_t</span> <span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_action_param</span> <span class="o">*</span><span class="n">par</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">ip_set_adt_opt</span> <span class="o">*</span><span class="n">opt</span><span class="p">);</span>

<span class="cm">/* Utility functions */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ip_set_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ip_set_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">members</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_set_get_ipaddr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span>  <span class="n">__be32</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ip_set_get_ipaddr6</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span> <span class="k">union</span> <span class="n">nf_inet_addr</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ip_set_get_hostipaddr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="n">ip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ip_set_get_ipaddr4</span><span class="p">(</span><span class="n">nla</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ipaddr</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Ignore IPSET_ERR_EXIST errors if asked to do so? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">ip_set_eexist</span><span class="p">(</span><span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">IPSET_ERR_EXIST</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IPSET_FLAG_EXIST</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check the NLA_F_NET_BYTEORDER flag */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">ip_set_attr_netorder</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tb</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">nla_type</span> <span class="o">&amp;</span> <span class="n">NLA_F_NET_BYTEORDER</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">ip_set_optattr_netorder</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">nla_type</span> <span class="o">&amp;</span> <span class="n">NLA_F_NET_BYTEORDER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Useful converters */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">ip_set_get_h32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">nla_get_be32</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span>
<span class="nf">ip_set_get_h16</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">nla_get_be16</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define ipset_nest_start(skb, attr) nla_nest_start(skb, attr | NLA_F_NESTED)</span>
<span class="cp">#define ipset_nest_end(skb, start)  nla_nest_end(skb, start)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_ipaddr4</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">ipaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">__nested</span> <span class="o">=</span> <span class="n">ipset_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__nested</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nla_put_net32</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_IPADDR_IPV4</span><span class="p">,</span> <span class="n">ipaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">__nested</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">nla_put_ipaddr6</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">ipaddrptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">__nested</span> <span class="o">=</span> <span class="n">ipset_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__nested</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IPSET_ATTR_IPADDR_IPV6</span><span class="p">,</span>
		      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">),</span> <span class="n">ipaddrptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ipset_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">__nested</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get address from skbuff */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be32</span>
<span class="nf">ip4addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">src</span> <span class="o">?</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">:</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ip4addrptr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">src</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">src</span> <span class="o">?</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">:</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ip6addrptr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">src</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Calculate the bytes required to store the inclusive range of a-b */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">bitmap_bytes</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">,</span> <span class="n">u32</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">((((</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/* Interface to iptables/ip6tables */</span>

<span class="cp">#define SO_IP_SET		83</span>

<span class="k">union</span> <span class="n">ip_set_name_index</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IPSET_MAXNAMELEN</span><span class="p">];</span>
	<span class="n">ip_set_id_t</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IP_SET_OP_GET_BYNAME	0x00000006	</span><span class="cm">/* Get set index by name */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">ip_set_req_get_set</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ip_set_name_index</span> <span class="n">set</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IP_SET_OP_GET_BYINDEX	0x00000007	</span><span class="cm">/* Get set name by index */</span><span class="cp"></span>
<span class="cm">/* Uses ip_set_req_get_set */</span>

<span class="cp">#define IP_SET_OP_VERSION	0x00000100	</span><span class="cm">/* Ask kernel version */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">ip_set_req_version</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/*_IP_SET_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
