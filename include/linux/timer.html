<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › timer.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>timer.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_TIMER_H</span>
<span class="cp">#define _LINUX_TIMER_H</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/debugobjects.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>

<span class="k">struct</span> <span class="n">tvec_base</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">timer_list</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * All fields that change during normal runtime grouped to the</span>
<span class="cm">	 * same cacheline</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tvec_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">slack</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TIMER_STATS</span>
	<span class="kt">int</span> <span class="n">start_pid</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">start_site</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">start_comm</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">lockdep_map</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tvec_base</span> <span class="n">boot_tvec_bases</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="cm">/*</span>
<span class="cm"> * NB: because we have to copy the lockdep_map, setting the lockdep_map key</span>
<span class="cm"> * (second argument) here is required, otherwise it could be initialised to</span>
<span class="cm"> * the copy of the lockdep_map later! We use the pointer to and the string</span>
<span class="cm"> * &quot;&lt;file&gt;:&lt;line&gt;&quot; as the key resp. the name of the lockdep_map.</span>
<span class="cm"> */</span>
<span class="cp">#define __TIMER_LOCKDEP_MAP_INITIALIZER(_kn)				\</span>
<span class="cp">	.lockdep_map = STATIC_LOCKDEP_MAP_INIT(_kn, &amp;_kn),</span>
<span class="cp">#else</span>
<span class="cp">#define __TIMER_LOCKDEP_MAP_INITIALIZER(_kn)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Note that all tvec_bases are 2 byte aligned and lower bit of</span>
<span class="cm"> * base in timer_list is guaranteed to be zero. Use the LSB to</span>
<span class="cm"> * indicate whether the timer is deferrable.</span>
<span class="cm"> *</span>
<span class="cm"> * A deferrable timer will work normally when the system is busy, but</span>
<span class="cm"> * will not cause a CPU to come out of idle just to service it; instead,</span>
<span class="cm"> * the timer will be serviced when the CPU eventually wakes up with a</span>
<span class="cm"> * subsequent non-deferrable timer.</span>
<span class="cm"> */</span>
<span class="cp">#define TBASE_DEFERRABLE_FLAG		(0x1)</span>

<span class="cp">#define TIMER_INITIALIZER(_function, _expires, _data) {		\</span>
<span class="cp">		.entry = { .prev = TIMER_ENTRY_STATIC },	\</span>
<span class="cp">		.function = (_function),			\</span>
<span class="cp">		.expires = (_expires),				\</span>
<span class="cp">		.data = (_data),				\</span>
<span class="cp">		.base = &amp;boot_tvec_bases,			\</span>
<span class="cp">		.slack = -1,					\</span>
<span class="cp">		__TIMER_LOCKDEP_MAP_INITIALIZER(		\</span>
<span class="cp">			__FILE__ &quot;:&quot; __stringify(__LINE__))	\</span>
<span class="cp">	}</span>

<span class="cp">#define TBASE_MAKE_DEFERRED(ptr) ((struct tvec_base *)		\</span>
<span class="cp">		  ((unsigned char *)(ptr) + TBASE_DEFERRABLE_FLAG))</span>

<span class="cp">#define TIMER_DEFERRED_INITIALIZER(_function, _expires, _data) {\</span>
<span class="cp">		.entry = { .prev = TIMER_ENTRY_STATIC },	\</span>
<span class="cp">		.function = (_function),			\</span>
<span class="cp">		.expires = (_expires),				\</span>
<span class="cp">		.data = (_data),				\</span>
<span class="cp">		.base = TBASE_MAKE_DEFERRED(&amp;boot_tvec_bases),	\</span>
<span class="cp">		__TIMER_LOCKDEP_MAP_INITIALIZER(		\</span>
<span class="cp">			__FILE__ &quot;:&quot; __stringify(__LINE__))	\</span>
<span class="cp">	}</span>

<span class="cp">#define DEFINE_TIMER(_name, _function, _expires, _data)		\</span>
<span class="cp">	struct timer_list _name =				\</span>
<span class="cp">		TIMER_INITIALIZER(_function, _expires, _data)</span>

<span class="kt">void</span> <span class="n">init_timer_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">init_timer_deferrable_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="cp">#define init_timer(timer)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		static struct lock_class_key __key;			\</span>
<span class="cp">		init_timer_key((timer), #timer, &amp;__key);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define init_timer_deferrable(timer)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		static struct lock_class_key __key;			\</span>
<span class="cp">		init_timer_deferrable_key((timer), #timer, &amp;__key);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define init_timer_on_stack(timer)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		static struct lock_class_key __key;			\</span>
<span class="cp">		init_timer_on_stack_key((timer), #timer, &amp;__key);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define setup_timer(timer, fn, data)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		static struct lock_class_key __key;			\</span>
<span class="cp">		setup_timer_key((timer), #timer, &amp;__key, (fn), (data));\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define setup_timer_on_stack(timer, fn, data)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		static struct lock_class_key __key;			\</span>
<span class="cp">		setup_timer_on_stack_key((timer), #timer, &amp;__key,	\</span>
<span class="cp">					 (fn), (data));			\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#define setup_deferrable_timer_on_stack(timer, fn, data)		\</span>
<span class="cp">	do {								\</span>
<span class="cp">		static struct lock_class_key __key;			\</span>
<span class="cp">		setup_deferrable_timer_on_stack_key((timer), #timer,	\</span>
<span class="cp">						    &amp;__key, (fn),	\</span>
<span class="cp">						    (data));		\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define init_timer(timer)\</span>
<span class="cp">	init_timer_key((timer), NULL, NULL)</span>
<span class="cp">#define init_timer_deferrable(timer)\</span>
<span class="cp">	init_timer_deferrable_key((timer), NULL, NULL)</span>
<span class="cp">#define init_timer_on_stack(timer)\</span>
<span class="cp">	init_timer_on_stack_key((timer), NULL, NULL)</span>
<span class="cp">#define setup_timer(timer, fn, data)\</span>
<span class="cp">	setup_timer_key((timer), NULL, NULL, (fn), (data))</span>
<span class="cp">#define setup_timer_on_stack(timer, fn, data)\</span>
<span class="cp">	setup_timer_on_stack_key((timer), NULL, NULL, (fn), (data))</span>
<span class="cp">#define setup_deferrable_timer_on_stack(timer, fn, data)\</span>
<span class="cp">	setup_deferrable_timer_on_stack_key((timer), NULL, NULL, (fn), (data))</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_TIMERS</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_timer_on_stack_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">destroy_timer_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">destroy_timer_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_timer_on_stack_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_timer_key</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_timer_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span> <span class="n">timer</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">init_timer_key</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_timer_on_stack_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
					<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="p">;</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">init_timer_on_stack_key</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">setup_deferrable_timer_on_stack_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
						<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * timer_pending - is a timer pending?</span>
<span class="cm"> * @timer: the timer in question</span>
<span class="cm"> *</span>
<span class="cm"> * timer_pending will tell whether a given timer is currently pending,</span>
<span class="cm"> * or not. Callers must ensure serialization wrt. other operations done</span>
<span class="cm"> * to this timer, eg. interrupt contexts, or other CPUs on SMP.</span>
<span class="cm"> *</span>
<span class="cm"> * return value: 1 if the timer is pending, 0 if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">timer_pending</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span> <span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">add_timer_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">del_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span> <span class="n">timer</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mod_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mod_timer_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mod_timer_pinned</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">set_timer_slack</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slack_hz</span><span class="p">);</span>

<span class="cp">#define TIMER_NOT_PINNED	0</span>
<span class="cp">#define TIMER_PINNED		1</span>
<span class="cm">/*</span>
<span class="cm"> * The jiffies value which is added to now, when there is no timer</span>
<span class="cm"> * in the timer wheel:</span>
<span class="cm"> */</span>
<span class="cp">#define NEXT_TIMER_MAX_DELTA	((1UL &lt;&lt; 30) - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Return when the next timer-wheel timeout occurs (in absolute jiffies),</span>
<span class="cm"> * locks the timer base and does the comparison against the given</span>
<span class="cm"> * jiffie.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_next_timer_interrupt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Timer-statistics info:</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_TIMER_STATS</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">timer_stats_active</span><span class="p">;</span>

<span class="cp">#define TIMER_STATS_FLAG_DEFERRABLE	0x1</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_timer_stats</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">timer_stats_update_stats</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">startf</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">timerf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comm</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timer_flag</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__timer_stats_timer_set_start_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
					       <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_stats_timer_set_start_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">timer_stats_active</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__timer_stats_timer_set_start_info</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_stats_timer_clear_start_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timer</span><span class="o">-&gt;</span><span class="n">start_site</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_timer_stats</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_stats_timer_set_start_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">timer_stats_timer_clear_start_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">add_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">try_to_del_timer_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">del_timer_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp"># define del_timer_sync(t)		del_timer(t)</span>
<span class="cp">#endif</span>

<span class="cp">#define del_singleshot_timer_sync(t) del_timer_sync(t)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">init_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">run_local_timers</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">hrtimer</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="n">it_real_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__round_jiffies</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__round_jiffies_relative</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">round_jiffies</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">round_jiffies_relative</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__round_jiffies_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__round_jiffies_up_relative</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">round_jiffies_up</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">round_jiffies_up_relative</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">j</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
