<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mod_devicetable.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>mod_devicetable.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Device tables which are exported to userspace via</span>
<span class="cm"> * scripts/mod/file2alias.c.  You must keep that file in sync with this</span>
<span class="cm"> * header.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef LINUX_MOD_DEVICETABLE_H</span>
<span class="cp">#define LINUX_MOD_DEVICETABLE_H</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_ulong_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#define PCI_ANY_ID (~0)</span>

<span class="k">struct</span> <span class="n">pci_device_id</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">device</span><span class="p">;</span>		<span class="cm">/* Vendor and device ID or PCI_ANY_ID*/</span>
	<span class="n">__u32</span> <span class="n">subvendor</span><span class="p">,</span> <span class="n">subdevice</span><span class="p">;</span>	<span class="cm">/* Subsystem ID&#39;s or PCI_ANY_ID */</span>
	<span class="n">__u32</span> <span class="n">class</span><span class="p">,</span> <span class="n">class_mask</span><span class="p">;</span>	<span class="cm">/* (class,subclass,prog-if) triplet */</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>	<span class="cm">/* Data private to the driver */</span>
<span class="p">};</span>


<span class="cp">#define IEEE1394_MATCH_VENDOR_ID	0x0001</span>
<span class="cp">#define IEEE1394_MATCH_MODEL_ID		0x0002</span>
<span class="cp">#define IEEE1394_MATCH_SPECIFIER_ID	0x0004</span>
<span class="cp">#define IEEE1394_MATCH_VERSION		0x0008</span>

<span class="k">struct</span> <span class="n">ieee1394_device_id</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">match_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vendor_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">model_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">specifier_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span>
		<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Device table entry for &quot;new style&quot; table-driven USB drivers.</span>
<span class="cm"> * User mode code can read these tables to choose which modules to load.</span>
<span class="cm"> * Declare the table as a MODULE_DEVICE_TABLE.</span>
<span class="cm"> *</span>
<span class="cm"> * A probe() parameter will point to a matching entry from this table.</span>
<span class="cm"> * Use the driver_info field for each match to hold information tied</span>
<span class="cm"> * to that match:  device quirks, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Terminate the driver&#39;s table with an all-zeroes entry.</span>
<span class="cm"> * Use the flag values to control which fields are compared.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct usb_device_id - identifies USB devices for probing and hotplugging</span>
<span class="cm"> * @match_flags: Bit mask controlling of the other fields are used to match</span>
<span class="cm"> *	against new devices.  Any field except for driver_info may be used,</span>
<span class="cm"> *	although some only make sense in conjunction with other fields.</span>
<span class="cm"> *	This is usually set by a USB_DEVICE_*() macro, which sets all</span>
<span class="cm"> *	other fields in this structure except for driver_info.</span>
<span class="cm"> * @idVendor: USB vendor ID for a device; numbers are assigned</span>
<span class="cm"> *	by the USB forum to its members.</span>
<span class="cm"> * @idProduct: Vendor-assigned product ID.</span>
<span class="cm"> * @bcdDevice_lo: Low end of range of vendor-assigned product version numbers.</span>
<span class="cm"> *	This is also used to identify individual product versions, for</span>
<span class="cm"> *	a range consisting of a single device.</span>
<span class="cm"> * @bcdDevice_hi: High end of version number range.  The range of product</span>
<span class="cm"> *	versions is inclusive.</span>
<span class="cm"> * @bDeviceClass: Class of device; numbers are assigned</span>
<span class="cm"> *	by the USB forum.  Products may choose to implement classes,</span>
<span class="cm"> *	or be vendor-specific.  Device classes specify behavior of all</span>
<span class="cm"> *	the interfaces on a devices.</span>
<span class="cm"> * @bDeviceSubClass: Subclass of device; associated with bDeviceClass.</span>
<span class="cm"> * @bDeviceProtocol: Protocol of device; associated with bDeviceClass.</span>
<span class="cm"> * @bInterfaceClass: Class of interface; numbers are assigned</span>
<span class="cm"> *	by the USB forum.  Products may choose to implement classes,</span>
<span class="cm"> *	or be vendor-specific.  Interface classes specify behavior only</span>
<span class="cm"> *	of a given interface; other interfaces may support other classes.</span>
<span class="cm"> * @bInterfaceSubClass: Subclass of interface; associated with bInterfaceClass.</span>
<span class="cm"> * @bInterfaceProtocol: Protocol of interface; associated with bInterfaceClass.</span>
<span class="cm"> * @driver_info: Holds information used by the driver.  Usually it holds</span>
<span class="cm"> *	a pointer to a descriptor understood by the driver, or perhaps</span>
<span class="cm"> *	device flags.</span>
<span class="cm"> *</span>
<span class="cm"> * In most cases, drivers will create a table of device IDs by using</span>
<span class="cm"> * USB_DEVICE(), or similar macros designed for that purpose.</span>
<span class="cm"> * They will then export it to userspace using MODULE_DEVICE_TABLE(),</span>
<span class="cm"> * and provide it to the USB core through their usb_driver structure.</span>
<span class="cm"> *</span>
<span class="cm"> * See the usb_match_id() function for information about how matches are</span>
<span class="cm"> * performed.  Briefly, you will normally use one of several macros to help</span>
<span class="cm"> * construct these entries.  Each entry you provide will either identify</span>
<span class="cm"> * one or more specific products, or will identify a class of products</span>
<span class="cm"> * which have agreed to behave the same.  You should put the more specific</span>
<span class="cm"> * matches towards the beginning of your table, so that driver_info can</span>
<span class="cm"> * record quirks of specific products.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">usb_device_id</span> <span class="p">{</span>
	<span class="cm">/* which fields to match against? */</span>
	<span class="n">__u16</span>		<span class="n">match_flags</span><span class="p">;</span>

	<span class="cm">/* Used for product specific matches; range is inclusive */</span>
	<span class="n">__u16</span>		<span class="n">idVendor</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">idProduct</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">bcdDevice_lo</span><span class="p">;</span>
	<span class="n">__u16</span>		<span class="n">bcdDevice_hi</span><span class="p">;</span>

	<span class="cm">/* Used for device class matches */</span>
	<span class="n">__u8</span>		<span class="n">bDeviceClass</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">bDeviceSubClass</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">bDeviceProtocol</span><span class="p">;</span>

	<span class="cm">/* Used for interface class matches */</span>
	<span class="n">__u8</span>		<span class="n">bInterfaceClass</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">bInterfaceSubClass</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">bInterfaceProtocol</span><span class="p">;</span>

	<span class="cm">/* not matched against */</span>
	<span class="n">kernel_ulong_t</span>	<span class="n">driver_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Some useful macros to use to create struct usb_device_id */</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_VENDOR		0x0001</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_PRODUCT		0x0002</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_DEV_LO		0x0004</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_DEV_HI		0x0008</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_DEV_CLASS		0x0010</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_DEV_SUBCLASS	0x0020</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_DEV_PROTOCOL	0x0040</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_INT_CLASS		0x0080</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_INT_SUBCLASS	0x0100</span>
<span class="cp">#define USB_DEVICE_ID_MATCH_INT_PROTOCOL	0x0200</span>

<span class="cp">#define HID_ANY_ID				(~0)</span>
<span class="cp">#define HID_BUS_ANY				0xffff</span>
<span class="cp">#define HID_GROUP_ANY				0x0000</span>

<span class="k">struct</span> <span class="n">hid_device_id</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">bus</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">group</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vendor</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">product</span><span class="p">;</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span>
		<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/* s390 CCW devices */</span>
<span class="k">struct</span> <span class="n">ccw_device_id</span> <span class="p">{</span>
	<span class="n">__u16</span>	<span class="n">match_flags</span><span class="p">;</span>	<span class="cm">/* which fields to match against */</span>

	<span class="n">__u16</span>	<span class="n">cu_type</span><span class="p">;</span>	<span class="cm">/* control unit type     */</span>
	<span class="n">__u16</span>	<span class="n">dev_type</span><span class="p">;</span>	<span class="cm">/* device type           */</span>
	<span class="n">__u8</span>	<span class="n">cu_model</span><span class="p">;</span>	<span class="cm">/* control unit model    */</span>
	<span class="n">__u8</span>	<span class="n">dev_model</span><span class="p">;</span>	<span class="cm">/* device model          */</span>

	<span class="n">kernel_ulong_t</span> <span class="n">driver_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define CCW_DEVICE_ID_MATCH_CU_TYPE		0x01</span>
<span class="cp">#define CCW_DEVICE_ID_MATCH_CU_MODEL		0x02</span>
<span class="cp">#define CCW_DEVICE_ID_MATCH_DEVICE_TYPE		0x04</span>
<span class="cp">#define CCW_DEVICE_ID_MATCH_DEVICE_MODEL	0x08</span>

<span class="cm">/* s390 AP bus devices */</span>
<span class="k">struct</span> <span class="n">ap_device_id</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">match_flags</span><span class="p">;</span>	<span class="cm">/* which fields to match against */</span>
	<span class="n">__u8</span> <span class="n">dev_type</span><span class="p">;</span>		<span class="cm">/* device type */</span>
	<span class="n">__u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad2</span><span class="p">;</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define AP_DEVICE_ID_MATCH_DEVICE_TYPE		0x01</span>

<span class="cm">/* s390 css bus devices (subchannels) */</span>
<span class="k">struct</span> <span class="n">css_device_id</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">match_flags</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">type</span><span class="p">;</span> <span class="cm">/* subchannel type */</span>
	<span class="n">__u16</span> <span class="n">pad2</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pad3</span><span class="p">;</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define ACPI_ID_LEN	16 </span><span class="cm">/* only 9 bytes needed here, 16 bytes are used */</span><span class="cp"></span>
			   <span class="cm">/* to workaround crosscompile issues */</span>

<span class="k">struct</span> <span class="n">acpi_device_id</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">id</span><span class="p">[</span><span class="n">ACPI_ID_LEN</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PNP_ID_LEN	8</span>
<span class="cp">#define PNP_MAX_DEVICES	8</span>

<span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">id</span><span class="p">[</span><span class="n">PNP_ID_LEN</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pnp_card_device_id</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">id</span><span class="p">[</span><span class="n">PNP_ID_LEN</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__u8</span> <span class="n">id</span><span class="p">[</span><span class="n">PNP_ID_LEN</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">devs</span><span class="p">[</span><span class="n">PNP_MAX_DEVICES</span><span class="p">];</span>
<span class="p">};</span>


<span class="cp">#define SERIO_ANY	0xff</span>

<span class="k">struct</span> <span class="n">serio_device_id</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">extra</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">proto</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Struct used for matching a device</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">of_device_id</span>
<span class="p">{</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">type</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">compatible</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="cp">#ifdef __KERNEL__</span>
	<span class="kt">void</span>	<span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">kernel_ulong_t</span> <span class="n">data</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* VIO */</span>
<span class="k">struct</span> <span class="n">vio_device_id</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">type</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">compat</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* PCMCIA */</span>

<span class="k">struct</span> <span class="n">pcmcia_device_id</span> <span class="p">{</span>
	<span class="n">__u16</span>		<span class="n">match_flags</span><span class="p">;</span>

	<span class="n">__u16</span>		<span class="n">manf_id</span><span class="p">;</span>
	<span class="n">__u16</span> 		<span class="n">card_id</span><span class="p">;</span>

	<span class="n">__u8</span>  		<span class="n">func_id</span><span class="p">;</span>

	<span class="cm">/* for real multi-function devices */</span>
	<span class="n">__u8</span>  		<span class="n">function</span><span class="p">;</span>

	<span class="cm">/* for pseudo multi-function devices */</span>
	<span class="n">__u8</span>  		<span class="n">device_no</span><span class="p">;</span>

	<span class="n">__u32</span> 		<span class="n">prod_id_hash</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
		<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">))));</span>

	<span class="cm">/* not matched against in kernelspace*/</span>
<span class="cp">#ifdef __KERNEL__</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>	<span class="n">prod_id</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">kernel_ulong_t</span>	<span class="n">prod_id</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
		<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="cp">#endif</span>

	<span class="cm">/* not matched against */</span>
	<span class="n">kernel_ulong_t</span>	<span class="n">driver_info</span><span class="p">;</span>
<span class="cp">#ifdef __KERNEL__</span>
	<span class="kt">char</span> <span class="o">*</span>		<span class="n">cisfile</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">kernel_ulong_t</span>	<span class="n">cisfile</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define PCMCIA_DEV_ID_MATCH_MANF_ID	0x0001</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_CARD_ID	0x0002</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_FUNC_ID	0x0004</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_FUNCTION	0x0008</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_PROD_ID1	0x0010</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_PROD_ID2	0x0020</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_PROD_ID3	0x0040</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_PROD_ID4	0x0080</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_DEVICE_NO	0x0100</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_FAKE_CIS	0x0200</span>
<span class="cp">#define PCMCIA_DEV_ID_MATCH_ANONYMOUS	0x0400</span>

<span class="cm">/* Input */</span>
<span class="cp">#define INPUT_DEVICE_ID_EV_MAX		0x1f</span>
<span class="cp">#define INPUT_DEVICE_ID_KEY_MIN_INTERESTING	0x71</span>
<span class="cp">#define INPUT_DEVICE_ID_KEY_MAX		0x2ff</span>
<span class="cp">#define INPUT_DEVICE_ID_REL_MAX		0x0f</span>
<span class="cp">#define INPUT_DEVICE_ID_ABS_MAX		0x3f</span>
<span class="cp">#define INPUT_DEVICE_ID_MSC_MAX		0x07</span>
<span class="cp">#define INPUT_DEVICE_ID_LED_MAX		0x0f</span>
<span class="cp">#define INPUT_DEVICE_ID_SND_MAX		0x07</span>
<span class="cp">#define INPUT_DEVICE_ID_FF_MAX		0x7f</span>
<span class="cp">#define INPUT_DEVICE_ID_SW_MAX		0x0f</span>

<span class="cp">#define INPUT_DEVICE_ID_MATCH_BUS	1</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_VENDOR	2</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_PRODUCT	4</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_VERSION	8</span>

<span class="cp">#define INPUT_DEVICE_ID_MATCH_EVBIT	0x0010</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_KEYBIT	0x0020</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_RELBIT	0x0040</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_ABSBIT	0x0080</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_MSCIT	0x0100</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_LEDBIT	0x0200</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_SNDBIT	0x0400</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_FFBIT	0x0800</span>
<span class="cp">#define INPUT_DEVICE_ID_MATCH_SWBIT	0x1000</span>

<span class="k">struct</span> <span class="n">input_device_id</span> <span class="p">{</span>

	<span class="n">kernel_ulong_t</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">__u16</span> <span class="n">bustype</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">vendor</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">product</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">version</span><span class="p">;</span>

	<span class="n">kernel_ulong_t</span> <span class="n">evbit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_EV_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">keybit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_KEY_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">relbit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_REL_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">absbit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_ABS_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">mscbit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_MSC_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">ledbit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_LED_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">sndbit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_SND_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">ffbit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_FF_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">swbit</span><span class="p">[</span><span class="n">INPUT_DEVICE_ID_SW_MAX</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="n">kernel_ulong_t</span> <span class="n">driver_info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* EISA */</span>

<span class="cp">#define EISA_SIG_LEN   8</span>

<span class="cm">/* The EISA signature, in ASCII form, null terminated */</span>
<span class="k">struct</span> <span class="n">eisa_device_id</span> <span class="p">{</span>
	<span class="kt">char</span>          <span class="n">sig</span><span class="p">[</span><span class="n">EISA_SIG_LEN</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define EISA_DEVICE_MODALIAS_FMT &quot;eisa:s%s&quot;</span>

<span class="k">struct</span> <span class="n">parisc_device_id</span> <span class="p">{</span>
	<span class="n">__u8</span>	<span class="n">hw_type</span><span class="p">;</span>	<span class="cm">/* 5 bits used */</span>
	<span class="n">__u8</span>	<span class="n">hversion_rev</span><span class="p">;</span>	<span class="cm">/* 4 bits */</span>
	<span class="n">__u16</span>	<span class="n">hversion</span><span class="p">;</span>	<span class="cm">/* 12 bits */</span>
	<span class="n">__u32</span>	<span class="n">sversion</span><span class="p">;</span>	<span class="cm">/* 20 bits */</span>
<span class="p">};</span>

<span class="cp">#define PA_HWTYPE_ANY_ID	0xff</span>
<span class="cp">#define PA_HVERSION_REV_ANY_ID	0xff</span>
<span class="cp">#define PA_HVERSION_ANY_ID	0xffff</span>
<span class="cp">#define PA_SVERSION_ANY_ID	0xffffffff</span>

<span class="cm">/* SDIO */</span>

<span class="cp">#define SDIO_ANY_ID (~0)</span>

<span class="k">struct</span> <span class="n">sdio_device_id</span> <span class="p">{</span>
	<span class="n">__u8</span>	<span class="n">class</span><span class="p">;</span>			<span class="cm">/* Standard interface or SDIO_ANY_ID */</span>
	<span class="n">__u16</span>	<span class="n">vendor</span><span class="p">;</span>			<span class="cm">/* Vendor or SDIO_ANY_ID */</span>
	<span class="n">__u16</span>	<span class="n">device</span><span class="p">;</span>			<span class="cm">/* Device ID or SDIO_ANY_ID */</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span>	<span class="cm">/* Data private to the driver */</span>
		<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/* SSB core, see drivers/ssb/ */</span>
<span class="k">struct</span> <span class="n">ssb_device_id</span> <span class="p">{</span>
	<span class="n">__u16</span>	<span class="n">vendor</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">coreid</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">revision</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define SSB_DEVICE(_vendor, _coreid, _revision)  \</span>
<span class="cp">	{ .vendor = _vendor, .coreid = _coreid, .revision = _revision, }</span>
<span class="cp">#define SSB_DEVTABLE_END  \</span>
<span class="cp">	{ 0, },</span>

<span class="cp">#define SSB_ANY_VENDOR		0xFFFF</span>
<span class="cp">#define SSB_ANY_ID		0xFFFF</span>
<span class="cp">#define SSB_ANY_REV		0xFF</span>

<span class="cm">/* Broadcom&#39;s specific AMBA core, see drivers/bcma/ */</span>
<span class="k">struct</span> <span class="n">bcma_device_id</span> <span class="p">{</span>
	<span class="n">__u16</span>	<span class="n">manuf</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">id</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">rev</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">class</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define BCMA_CORE(_manuf, _id, _rev, _class)  \</span>
<span class="cp">	{ .manuf = _manuf, .id = _id, .rev = _rev, .class = _class, }</span>
<span class="cp">#define BCMA_CORETABLE_END  \</span>
<span class="cp">	{ 0, },</span>

<span class="cp">#define BCMA_ANY_MANUF		0xFFFF</span>
<span class="cp">#define BCMA_ANY_ID		0xFFFF</span>
<span class="cp">#define BCMA_ANY_REV		0xFF</span>
<span class="cp">#define BCMA_ANY_CLASS		0xFF</span>

<span class="k">struct</span> <span class="n">virtio_device_id</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vendor</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define VIRTIO_DEV_ANY_ID	0xffffffff</span>

<span class="cm">/*</span>
<span class="cm"> * For Hyper-V devices we use the device guid as the id.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hv_vmbus_device_id</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">guid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span>	<span class="cm">/* Data private to the driver */</span>
			<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/* rpmsg */</span>

<span class="cp">#define RPMSG_NAME_SIZE			32</span>
<span class="cp">#define RPMSG_DEVICE_MODALIAS_FMT	&quot;rpmsg:%s&quot;</span>

<span class="k">struct</span> <span class="n">rpmsg_device_id</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">RPMSG_NAME_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* i2c */</span>

<span class="cp">#define I2C_NAME_SIZE	20</span>
<span class="cp">#define I2C_MODULE_PREFIX &quot;i2c:&quot;</span>

<span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">I2C_NAME_SIZE</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span>	<span class="cm">/* Data private to the driver */</span>
			<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/* spi */</span>

<span class="cp">#define SPI_NAME_SIZE	32</span>
<span class="cp">#define SPI_MODULE_PREFIX &quot;spi:&quot;</span>

<span class="k">struct</span> <span class="n">spi_device_id</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">SPI_NAME_SIZE</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span>	<span class="cm">/* Data private to the driver */</span>
			<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/* dmi */</span>
<span class="k">enum</span> <span class="n">dmi_field</span> <span class="p">{</span>
	<span class="n">DMI_NONE</span><span class="p">,</span>
	<span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span>
	<span class="n">DMI_BIOS_VERSION</span><span class="p">,</span>
	<span class="n">DMI_BIOS_DATE</span><span class="p">,</span>
	<span class="n">DMI_SYS_VENDOR</span><span class="p">,</span>
	<span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span>
	<span class="n">DMI_PRODUCT_VERSION</span><span class="p">,</span>
	<span class="n">DMI_PRODUCT_SERIAL</span><span class="p">,</span>
	<span class="n">DMI_PRODUCT_UUID</span><span class="p">,</span>
	<span class="n">DMI_BOARD_VENDOR</span><span class="p">,</span>
	<span class="n">DMI_BOARD_NAME</span><span class="p">,</span>
	<span class="n">DMI_BOARD_VERSION</span><span class="p">,</span>
	<span class="n">DMI_BOARD_SERIAL</span><span class="p">,</span>
	<span class="n">DMI_BOARD_ASSET_TAG</span><span class="p">,</span>
	<span class="n">DMI_CHASSIS_VENDOR</span><span class="p">,</span>
	<span class="n">DMI_CHASSIS_TYPE</span><span class="p">,</span>
	<span class="n">DMI_CHASSIS_VERSION</span><span class="p">,</span>
	<span class="n">DMI_CHASSIS_SERIAL</span><span class="p">,</span>
	<span class="n">DMI_CHASSIS_ASSET_TAG</span><span class="p">,</span>
	<span class="n">DMI_STRING_MAX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dmi_strmatch</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">substr</span><span class="p">[</span><span class="mi">79</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="p">{</span>
	<span class="n">kernel_ulong_t</span> <span class="n">callback</span><span class="p">;</span>
	<span class="n">kernel_ulong_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmi_strmatch</span> <span class="n">matches</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span>
			<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ident</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dmi_strmatch</span> <span class="n">matches</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * struct dmi_device_id appears during expansion of</span>
<span class="cm"> * &quot;MODULE_DEVICE_TABLE(dmi, x)&quot;. Compiler doesn&#39;t look inside it</span>
<span class="cm"> * but this is enough for gcc 3.4.6 to error out:</span>
<span class="cm"> *	error: storage size of &#39;__mod_dmi_device_table&#39; isn&#39;t known</span>
<span class="cm"> */</span>
<span class="cp">#define dmi_device_id dmi_system_id</span>
<span class="cp">#endif</span>

<span class="cp">#define DMI_MATCH(a, b)	{ a, b }</span>

<span class="cp">#define PLATFORM_NAME_SIZE	20</span>
<span class="cp">#define PLATFORM_MODULE_PREFIX	&quot;platform:&quot;</span>

<span class="k">struct</span> <span class="n">platform_device_id</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">PLATFORM_NAME_SIZE</span><span class="p">];</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span>
			<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_ulong_t</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cp">#define MDIO_MODULE_PREFIX	&quot;mdio:&quot;</span>

<span class="cp">#define MDIO_ID_FMT &quot;%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d&quot;</span>
<span class="cp">#define MDIO_ID_ARGS(_id) \</span>
<span class="cp">	(_id)&gt;&gt;31, ((_id)&gt;&gt;30) &amp; 1, ((_id)&gt;&gt;29) &amp; 1, ((_id)&gt;&gt;28) &amp; 1,	\</span>
<span class="cp">	((_id)&gt;&gt;27) &amp; 1, ((_id)&gt;&gt;26) &amp; 1, ((_id)&gt;&gt;25) &amp; 1, ((_id)&gt;&gt;24) &amp; 1, \</span>
<span class="cp">	((_id)&gt;&gt;23) &amp; 1, ((_id)&gt;&gt;22) &amp; 1, ((_id)&gt;&gt;21) &amp; 1, ((_id)&gt;&gt;20) &amp; 1, \</span>
<span class="cp">	((_id)&gt;&gt;19) &amp; 1, ((_id)&gt;&gt;18) &amp; 1, ((_id)&gt;&gt;17) &amp; 1, ((_id)&gt;&gt;16) &amp; 1, \</span>
<span class="cp">	((_id)&gt;&gt;15) &amp; 1, ((_id)&gt;&gt;14) &amp; 1, ((_id)&gt;&gt;13) &amp; 1, ((_id)&gt;&gt;12) &amp; 1, \</span>
<span class="cp">	((_id)&gt;&gt;11) &amp; 1, ((_id)&gt;&gt;10) &amp; 1, ((_id)&gt;&gt;9) &amp; 1, ((_id)&gt;&gt;8) &amp; 1, \</span>
<span class="cp">	((_id)&gt;&gt;7) &amp; 1, ((_id)&gt;&gt;6) &amp; 1, ((_id)&gt;&gt;5) &amp; 1, ((_id)&gt;&gt;4) &amp; 1, \</span>
<span class="cp">	((_id)&gt;&gt;3) &amp; 1, ((_id)&gt;&gt;2) &amp; 1, ((_id)&gt;&gt;1) &amp; 1, (_id) &amp; 1</span>

<span class="cm">/**</span>
<span class="cm"> * struct mdio_device_id - identifies PHY devices on an MDIO/MII bus</span>
<span class="cm"> * @phy_id: The result of</span>
<span class="cm"> *     (mdio_read(&amp;MII_PHYSID1) &lt;&lt; 16 | mdio_read(&amp;PHYSID2)) &amp; @phy_id_mask</span>
<span class="cm"> *     for this PHY type</span>
<span class="cm"> * @phy_id_mask: Defines the significant bits of @phy_id.  A value of 0</span>
<span class="cm"> *     is used to terminate an array of struct mdio_device_id.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mdio_device_id</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">phy_id</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">phy_id_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">zorro_device_id</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">id</span><span class="p">;</span>			<span class="cm">/* Device ID or ZORRO_WILDCARD */</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>	<span class="cm">/* Data private to the driver */</span>
<span class="p">};</span>

<span class="cp">#define ZORRO_WILDCARD			(0xffffffff)	</span><span class="cm">/* not official */</span><span class="cp"></span>

<span class="cp">#define ZORRO_DEVICE_MODALIAS_FMT	&quot;zorro:i%08X&quot;</span>

<span class="cp">#define ISAPNP_ANY_ID		0xffff</span>
<span class="k">struct</span> <span class="n">isapnp_device_id</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">card_vendor</span><span class="p">,</span> <span class="n">card_device</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">function</span><span class="p">;</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>	<span class="cm">/* data private to the driver */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct amba_id - identifies a device on an AMBA bus</span>
<span class="cm"> * @id: The significant bits if the hardware device ID</span>
<span class="cm"> * @mask: Bitmask specifying which bits of the id field are significant when</span>
<span class="cm"> *	matching.  A driver binds to a device when ((hardware device ID) &amp; mask)</span>
<span class="cm"> *	== id.</span>
<span class="cm"> * @data: Private data used by the driver.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">amba_id</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">mask</span><span class="p">;</span>
<span class="cp">#ifndef __KERNEL__</span>
	<span class="n">kernel_ulong_t</span>		<span class="n">data</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Match x86 CPUs for CPU specific drivers.</span>
<span class="cm"> * See documentation of &quot;x86_match_cpu&quot; for details.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">x86_cpu_id</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">vendor</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">family</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">model</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">feature</span><span class="p">;</span>	<span class="cm">/* bit index */</span>
	<span class="n">kernel_ulong_t</span> <span class="n">driver_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define X86_FEATURE_MATCH(x) \</span>
<span class="cp">	{ X86_VENDOR_ANY, X86_FAMILY_ANY, X86_MODEL_ANY, x }</span>

<span class="cp">#define X86_VENDOR_ANY 0xffff</span>
<span class="cp">#define X86_FAMILY_ANY 0</span>
<span class="cp">#define X86_MODEL_ANY  0</span>
<span class="cp">#define X86_FEATURE_ANY 0	</span><span class="cm">/* Same as FPU, you can&#39;t test for that */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* LINUX_MOD_DEVICETABLE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
