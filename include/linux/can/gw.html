<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › can › gw.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>gw.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/can/gw.h</span>
<span class="cm"> *</span>
<span class="cm"> * Definitions for CAN frame Gateway/Router/Bridge</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Oliver Hartkopp &lt;oliver.hartkopp@volkswagen.de&gt;</span>
<span class="cm"> * Copyright (c) 2011 Volkswagen Group Electronic Research</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef CAN_GW_H</span>
<span class="cp">#define CAN_GW_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/can.h&gt;</span>

<span class="k">struct</span> <span class="n">rtcanmsg</span> <span class="p">{</span>
	<span class="n">__u8</span>  <span class="n">can_family</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">gwtype</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* CAN gateway types */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CGW_TYPE_UNSPEC</span><span class="p">,</span>
	<span class="n">CGW_TYPE_CAN_CAN</span><span class="p">,</span>	<span class="cm">/* CAN-&gt;CAN routing */</span>
	<span class="n">__CGW_TYPE_MAX</span>
<span class="p">};</span>

<span class="cp">#define CGW_TYPE_MAX (__CGW_TYPE_MAX - 1)</span>

<span class="cm">/* CAN rtnetlink attribute definitions */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CGW_UNSPEC</span><span class="p">,</span>
	<span class="n">CGW_MOD_AND</span><span class="p">,</span>	<span class="cm">/* CAN frame modification binary AND */</span>
	<span class="n">CGW_MOD_OR</span><span class="p">,</span>	<span class="cm">/* CAN frame modification binary OR */</span>
	<span class="n">CGW_MOD_XOR</span><span class="p">,</span>	<span class="cm">/* CAN frame modification binary XOR */</span>
	<span class="n">CGW_MOD_SET</span><span class="p">,</span>	<span class="cm">/* CAN frame modification set alternate values */</span>
	<span class="n">CGW_CS_XOR</span><span class="p">,</span>	<span class="cm">/* set data[] XOR checksum into data[index] */</span>
	<span class="n">CGW_CS_CRC8</span><span class="p">,</span>	<span class="cm">/* set data[] CRC8 checksum into data[index] */</span>
	<span class="n">CGW_HANDLED</span><span class="p">,</span>	<span class="cm">/* number of handled CAN frames */</span>
	<span class="n">CGW_DROPPED</span><span class="p">,</span>	<span class="cm">/* number of dropped CAN frames */</span>
	<span class="n">CGW_SRC_IF</span><span class="p">,</span>	<span class="cm">/* ifindex of source network interface */</span>
	<span class="n">CGW_DST_IF</span><span class="p">,</span>	<span class="cm">/* ifindex of destination network interface */</span>
	<span class="n">CGW_FILTER</span><span class="p">,</span>	<span class="cm">/* specify struct can_filter on source CAN device */</span>
	<span class="n">__CGW_MAX</span>
<span class="p">};</span>

<span class="cp">#define CGW_MAX (__CGW_MAX - 1)</span>

<span class="cp">#define CGW_FLAGS_CAN_ECHO 0x01</span>
<span class="cp">#define CGW_FLAGS_CAN_SRC_TSTAMP 0x02</span>

<span class="cp">#define CGW_MOD_FUNCS 4 </span><span class="cm">/* AND OR XOR SET */</span><span class="cp"></span>

<span class="cm">/* CAN frame elements that are affected by curr. 3 CAN frame modifications */</span>
<span class="cp">#define CGW_MOD_ID	0x01</span>
<span class="cp">#define CGW_MOD_DLC	0x02</span>
<span class="cp">#define CGW_MOD_DATA	0x04</span>

<span class="cp">#define CGW_FRAME_MODS 3 </span><span class="cm">/* ID DLC DATA */</span><span class="cp"></span>

<span class="cp">#define MAX_MODFUNCTIONS (CGW_MOD_FUNCS * CGW_FRAME_MODS)</span>

<span class="k">struct</span> <span class="n">cgw_frame_mod</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="n">cf</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">modtype</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cp">#define CGW_MODATTR_LEN sizeof(struct cgw_frame_mod)</span>

<span class="k">struct</span> <span class="n">cgw_csum_xor</span> <span class="p">{</span>
	<span class="n">__s8</span> <span class="n">from_idx</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">to_idx</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">result_idx</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">init_xor_val</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">cgw_csum_crc8</span> <span class="p">{</span>
	<span class="n">__s8</span> <span class="n">from_idx</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">to_idx</span><span class="p">;</span>
	<span class="n">__s8</span> <span class="n">result_idx</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">init_crc_val</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">final_xor_val</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">crctab</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">profile</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">profile_data</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* length of checksum operation parameters. idx = index in CAN frame data[] */</span>
<span class="cp">#define CGW_CS_XOR_LEN  sizeof(struct cgw_csum_xor)</span>
<span class="cp">#define CGW_CS_CRC8_LEN  sizeof(struct cgw_csum_crc8)</span>

<span class="cm">/* CRC8 profiles (compute CRC for additional data elements - see below) */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CGW_CRC8PRF_UNSPEC</span><span class="p">,</span>
	<span class="n">CGW_CRC8PRF_1U8</span><span class="p">,</span>	<span class="cm">/* compute one additional u8 value */</span>
	<span class="n">CGW_CRC8PRF_16U8</span><span class="p">,</span>	<span class="cm">/* u8 value table indexed by data[1] &amp; 0xF */</span>
	<span class="n">CGW_CRC8PRF_SFFID_XOR</span><span class="p">,</span>	<span class="cm">/* (can_id &amp; 0xFF) ^ (can_id &gt;&gt; 8 &amp; 0xFF) */</span>
	<span class="n">__CGW_CRC8PRF_MAX</span>
<span class="p">};</span>

<span class="cp">#define CGW_CRC8PRF_MAX (__CGW_CRC8PRF_MAX - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * CAN rtnetlink attribute contents in detail</span>
<span class="cm"> *</span>
<span class="cm"> * CGW_XXX_IF (length 4 bytes):</span>
<span class="cm"> * Sets an interface index for source/destination network interfaces.</span>
<span class="cm"> * For the CAN-&gt;CAN gwtype the indices of _two_ CAN interfaces are mandatory.</span>
<span class="cm"> *</span>
<span class="cm"> * CGW_FILTER (length 8 bytes):</span>
<span class="cm"> * Sets a CAN receive filter for the gateway job specified by the</span>
<span class="cm"> * struct can_filter described in include/linux/can.h</span>
<span class="cm"> *</span>
<span class="cm"> * CGW_MOD_XXX (length 17 bytes):</span>
<span class="cm"> * Specifies a modification that&#39;s done to a received CAN frame before it is</span>
<span class="cm"> * send out to the destination interface.</span>
<span class="cm"> *</span>
<span class="cm"> * &lt;struct can_frame&gt; data used as operator</span>
<span class="cm"> * &lt;u8&gt; affected CAN frame elements</span>
<span class="cm"> *</span>
<span class="cm"> * CGW_CS_XOR (length 4 bytes):</span>
<span class="cm"> * Set a simple XOR checksum starting with an initial value into</span>
<span class="cm"> * data[result-idx] using data[start-idx] .. data[end-idx]</span>
<span class="cm"> *</span>
<span class="cm"> * The XOR checksum is calculated like this:</span>
<span class="cm"> *</span>
<span class="cm"> * xor = init_xor_val</span>
<span class="cm"> *</span>
<span class="cm"> * for (i = from_idx .. to_idx)</span>
<span class="cm"> *      xor ^= can_frame.data[i]</span>
<span class="cm"> *</span>
<span class="cm"> * can_frame.data[ result_idx ] = xor</span>
<span class="cm"> *</span>
<span class="cm"> * CGW_CS_CRC8 (length 282 bytes):</span>
<span class="cm"> * Set a CRC8 value into data[result-idx] using a given 256 byte CRC8 table,</span>
<span class="cm"> * a given initial value and a defined input data[start-idx] .. data[end-idx].</span>
<span class="cm"> * Finally the result value is XOR&#39;ed with the final_xor_val.</span>
<span class="cm"> *</span>
<span class="cm"> * The CRC8 checksum is calculated like this:</span>
<span class="cm"> *</span>
<span class="cm"> * crc = init_crc_val</span>
<span class="cm"> *</span>
<span class="cm"> * for (i = from_idx .. to_idx)</span>
<span class="cm"> *      crc = crctab[ crc ^ can_frame.data[i] ]</span>
<span class="cm"> *</span>
<span class="cm"> * can_frame.data[ result_idx ] = crc ^ final_xor_val</span>
<span class="cm"> *</span>
<span class="cm"> * The calculated CRC may contain additional source data elements that can be</span>
<span class="cm"> * defined in the handling of &#39;checksum profiles&#39; e.g. shown in AUTOSAR specs</span>
<span class="cm"> * like http://www.autosar.org/download/R4.0/AUTOSAR_SWS_E2ELibrary.pdf</span>
<span class="cm"> * E.g. the profile_data[] may contain additional u8 values (called DATA_IDs)</span>
<span class="cm"> * that are used depending on counter values inside the CAN frame data[].</span>
<span class="cm"> * So far only three profiles have been implemented for illustration.</span>
<span class="cm"> *</span>
<span class="cm"> * Remark: In general the attribute data is a linear buffer.</span>
<span class="cm"> *         Beware of sending unpacked or aligned structs!</span>
<span class="cm"> */</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
