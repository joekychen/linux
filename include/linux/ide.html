<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ide.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ide.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _IDE_H</span>
<span class="cp">#define _IDE_H</span>
<span class="cm">/*</span>
<span class="cm"> *  linux/include/linux/ide.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1994-2002  Linus Torvalds &amp; authors</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/ata.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_IDEACPI</span>
<span class="cp">#include &lt;acpi/acpi.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cm">/* for request_sense */</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>

<span class="cp">#if defined(CONFIG_CRIS) || defined(CONFIG_FRV) || defined(CONFIG_MN10300)</span>
<span class="cp"># define SUPPORT_VLB_SYNC 0</span>
<span class="cp">#else</span>
<span class="cp"># define SUPPORT_VLB_SYNC 1</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Probably not wise to fiddle with these</span>
<span class="cm"> */</span>
<span class="cp">#define IDE_DEFAULT_MAX_FAILURES	1</span>
<span class="cp">#define ERROR_MAX	8	</span><span class="cm">/* Max read/write errors per sector */</span><span class="cp"></span>
<span class="cp">#define ERROR_RESET	3	</span><span class="cm">/* Reset controller every 4th retry */</span><span class="cp"></span>
<span class="cp">#define ERROR_RECAL	1	</span><span class="cm">/* Recalibrate every 2nd retry */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cm">/* Error codes returned in rq-&gt;errors to the higher part of the driver. */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_DRV_ERROR_GENERAL</span>	<span class="o">=</span> <span class="mi">101</span><span class="p">,</span>
	<span class="n">IDE_DRV_ERROR_FILEMARK</span>	<span class="o">=</span> <span class="mi">102</span><span class="p">,</span>
	<span class="n">IDE_DRV_ERROR_EOD</span>	<span class="o">=</span> <span class="mi">103</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for accessing IDE controller registers</span>
<span class="cm"> */</span>
<span class="cp">#define IDE_NR_PORTS		(10)</span>

<span class="k">struct</span> <span class="n">ide_io_ports</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">data_addr</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_addr</span><span class="p">;</span>	<span class="cm">/*   read:  error */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">feature_addr</span><span class="p">;</span>	<span class="cm">/*  write: feature */</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">nsect_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">lbal_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">lbam_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">lbah_addr</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">device_addr</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status_addr</span><span class="p">;</span>	<span class="cm">/*  read: status  */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">command_addr</span><span class="p">;</span>	<span class="cm">/* write: command */</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">ctl_addr</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">irq_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define OK_STAT(stat,good,bad)	(((stat)&amp;((good)|(bad)))==(good))</span>

<span class="cp">#define BAD_R_STAT	(ATA_BUSY | ATA_ERR)</span>
<span class="cp">#define BAD_W_STAT	(BAD_R_STAT | ATA_DF)</span>
<span class="cp">#define BAD_STAT	(BAD_R_STAT | ATA_DRQ)</span>
<span class="cp">#define DRIVE_READY	(ATA_DRDY | ATA_DSC)</span>

<span class="cp">#define BAD_CRC		(ATA_ABORTED | ATA_ICRC)</span>

<span class="cp">#define SATA_NR_PORTS		(3)	</span><span class="cm">/* 16 possible ?? */</span><span class="cp"></span>

<span class="cp">#define SATA_STATUS_OFFSET	(0)</span>
<span class="cp">#define SATA_ERROR_OFFSET	(1)</span>
<span class="cp">#define SATA_CONTROL_OFFSET	(2)</span>

<span class="cm">/*</span>
<span class="cm"> * Our Physical Region Descriptor (PRD) table should be large enough</span>
<span class="cm"> * to handle the biggest I/O request we are likely to see.  Since requests</span>
<span class="cm"> * can have no more than 256 sectors, and since the typical blocksize is</span>
<span class="cm"> * two or more sectors, we could get by with a limit of 128 entries here for</span>
<span class="cm"> * the usual worst case.  Most requests seem to include some contiguous blocks,</span>
<span class="cm"> * further reducing the number of table entries required.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver reverts to PIO mode for individual requests that exceed</span>
<span class="cm"> * this limit (possible with 512 byte blocksizes, eg. MSDOS f/s), so handling</span>
<span class="cm"> * 100% of all crazy scenarios here is not necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * As it turns out though, we must allocate a full 4KB page for this,</span>
<span class="cm"> * so the two PRD tables (ide0 &amp; ide1) will each get half of that,</span>
<span class="cm"> * allowing each to have about 256 entries (8 bytes each) from this.</span>
<span class="cm"> */</span>
<span class="cp">#define PRD_BYTES       8</span>
<span class="cp">#define PRD_ENTRIES	256</span>

<span class="cm">/*</span>
<span class="cm"> * Some more useful definitions</span>
<span class="cm"> */</span>
<span class="cp">#define PARTN_BITS	6	</span><span class="cm">/* number of minor dev bits for partitions */</span><span class="cp"></span>
<span class="cp">#define MAX_DRIVES	2	</span><span class="cm">/* per interface; 2 assumed by lots of code */</span><span class="cp"></span>
<span class="cp">#define SECTOR_SIZE	512</span>

<span class="cm">/*</span>
<span class="cm"> * Timeouts for various operations:</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* spec allows up to 20ms, but CF cards and SSD drives need more */</span>
	<span class="n">WAIT_DRQ</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>	<span class="cm">/* 1s */</span>
	<span class="cm">/* some laptops are very slow */</span>
	<span class="n">WAIT_READY</span>	<span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>	<span class="cm">/* 5s */</span>
	<span class="cm">/* should be less than 3ms (?), if all ATAPI CD is closed at boot */</span>
	<span class="n">WAIT_PIDENTIFY</span>	<span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>	<span class="cm">/* 10s */</span>
	<span class="cm">/* worst case when spinning up */</span>
	<span class="n">WAIT_WORSTCASE</span>	<span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>	<span class="cm">/* 30s */</span>
	<span class="cm">/* maximum wait for an IRQ to happen */</span>
	<span class="n">WAIT_CMD</span>	<span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>	<span class="cm">/* 10s */</span>
	<span class="cm">/* Some drives require a longer IRQ timeout. */</span>
	<span class="n">WAIT_FLOPPY_CMD</span>	<span class="o">=</span> <span class="mi">50</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>	<span class="cm">/* 50s */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Some drives (for example, Seagate STT3401A Travan) require a very</span>
<span class="cm">	 * long timeout, because they don&#39;t return an interrupt or clear their</span>
<span class="cm">	 * BSY bit until after the command completes (even retension commands).</span>
<span class="cm">	 */</span>
	<span class="n">WAIT_TAPE_CMD</span>	<span class="o">=</span> <span class="mi">900</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>	<span class="cm">/* 900s */</span>
	<span class="cm">/* minimum sleep time */</span>
	<span class="n">WAIT_MIN_SLEEP</span>	<span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">50</span><span class="p">,</span>	<span class="cm">/* 20ms */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Op codes for special requests to be handled by ide_special_rq().</span>
<span class="cm"> * Values should be in the range of 0x20 to 0x3f.</span>
<span class="cm"> */</span>
<span class="cp">#define REQ_DRIVE_RESET		0x20</span>
<span class="cp">#define REQ_DEVSET_EXEC		0x21</span>
<span class="cp">#define REQ_PARK_HEADS		0x22</span>
<span class="cp">#define REQ_UNPARK_HEADS	0x23</span>

<span class="cm">/*</span>
<span class="cm"> * hwif_chipset_t is used to keep track of the specific hardware</span>
<span class="cm"> * chipset used by each IDE interface, if known.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>		<span class="n">ide_unknown</span><span class="p">,</span>	<span class="n">ide_generic</span><span class="p">,</span>	<span class="n">ide_pci</span><span class="p">,</span>
		<span class="n">ide_cmd640</span><span class="p">,</span>	<span class="n">ide_dtc2278</span><span class="p">,</span>	<span class="n">ide_ali14xx</span><span class="p">,</span>
		<span class="n">ide_qd65xx</span><span class="p">,</span>	<span class="n">ide_umc8672</span><span class="p">,</span>	<span class="n">ide_ht6560b</span><span class="p">,</span>
		<span class="n">ide_4drives</span><span class="p">,</span>	<span class="n">ide_pmac</span><span class="p">,</span>	<span class="n">ide_acorn</span><span class="p">,</span>
		<span class="n">ide_au1xxx</span><span class="p">,</span>	<span class="n">ide_palm3710</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">u8</span> <span class="n">hwif_chipset_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Structure to hold all information about the location of this port</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ide_hw</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ide_io_ports</span>	<span class="n">io_ports</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">io_ports_array</span><span class="p">[</span><span class="n">IDE_NR_PORTS</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>			<span class="cm">/* our irq number */</span>
	<span class="k">struct</span> <span class="n">device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">config</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_std_init_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_addr</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ctl_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">io_ports_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">io_addr</span><span class="o">++</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">io_ports</span><span class="p">.</span><span class="n">ctl_addr</span> <span class="o">=</span> <span class="n">ctl_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MAX_HWIFS	10</span>

<span class="cm">/*</span>
<span class="cm"> * Now for the data we need to maintain per-drive:  ide_drive_t</span>
<span class="cm"> */</span>

<span class="cp">#define ide_scsi	0x21</span>
<span class="cp">#define ide_disk	0x20</span>
<span class="cp">#define ide_optical	0x7</span>
<span class="cp">#define ide_cdrom	0x5</span>
<span class="cp">#define ide_tape	0x1</span>
<span class="cp">#define ide_floppy	0x0</span>

<span class="cm">/*</span>
<span class="cm"> * Special Driver Flags</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_SFLAG_SET_GEOMETRY</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">IDE_SFLAG_RECALIBRATE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">IDE_SFLAG_SET_MULTMODE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Status returned from various ide_ functions</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">ide_stopped</span><span class="p">,</span>	<span class="cm">/* no drive operation was started */</span>
	<span class="n">ide_started</span><span class="p">,</span>	<span class="cm">/* a drive operation was started, handler was set */</span>
<span class="p">}</span> <span class="n">ide_startstop_t</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_VALID_ERROR</span> 		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">IDE_VALID_FEATURE</span>		<span class="o">=</span> <span class="n">IDE_VALID_ERROR</span><span class="p">,</span>
	<span class="n">IDE_VALID_NSECT</span> 		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">IDE_VALID_LBAL</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">IDE_VALID_LBAM</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="n">IDE_VALID_LBAH</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="n">IDE_VALID_DEVICE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
	<span class="n">IDE_VALID_LBA</span>			<span class="o">=</span> <span class="n">IDE_VALID_LBAL</span> <span class="o">|</span>
					  <span class="n">IDE_VALID_LBAM</span> <span class="o">|</span>
					  <span class="n">IDE_VALID_LBAH</span><span class="p">,</span>
	<span class="n">IDE_VALID_OUT_TF</span>		<span class="o">=</span> <span class="n">IDE_VALID_FEATURE</span> <span class="o">|</span>
					  <span class="n">IDE_VALID_NSECT</span> <span class="o">|</span>
					  <span class="n">IDE_VALID_LBA</span><span class="p">,</span>
	<span class="n">IDE_VALID_IN_TF</span> 		<span class="o">=</span> <span class="n">IDE_VALID_NSECT</span> <span class="o">|</span>
					  <span class="n">IDE_VALID_LBA</span><span class="p">,</span>
	<span class="n">IDE_VALID_OUT_HOB</span>		<span class="o">=</span> <span class="n">IDE_VALID_OUT_TF</span><span class="p">,</span>
	<span class="n">IDE_VALID_IN_HOB</span>		<span class="o">=</span> <span class="n">IDE_VALID_ERROR</span> <span class="o">|</span>
					  <span class="n">IDE_VALID_NSECT</span> <span class="o">|</span>
					  <span class="n">IDE_VALID_LBA</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_TFLAG_LBA48</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">IDE_TFLAG_WRITE</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">IDE_TFLAG_CUSTOM_HANDLER</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">IDE_TFLAG_DMA_PIO_FALLBACK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="cm">/* force 16-bit I/O operations */</span>
	<span class="n">IDE_TFLAG_IO_16BIT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="cm">/* struct ide_cmd was allocated using kmalloc() */</span>
	<span class="n">IDE_TFLAG_DYN</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="n">IDE_TFLAG_FS</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
	<span class="n">IDE_TFLAG_MULTI_PIO</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
	<span class="n">IDE_TFLAG_SET_XFER</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_FTFLAG_FLAGGED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">IDE_FTFLAG_SET_IN_FLAGS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">IDE_FTFLAG_OUT_DATA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">IDE_FTFLAG_IN_DATA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">data</span><span class="p">;</span>		<span class="cm">/* 0: data byte (for TASKFILE ioctl) */</span>
	<span class="k">union</span> <span class="p">{</span>			<span class="cm">/* 1: */</span>
		<span class="n">u8</span> <span class="n">error</span><span class="p">;</span>	<span class="cm">/*  read: error */</span>
		<span class="n">u8</span> <span class="n">feature</span><span class="p">;</span>	<span class="cm">/* write: feature */</span>
	<span class="p">};</span>
	<span class="n">u8</span>	<span class="n">nsect</span><span class="p">;</span>		<span class="cm">/* 2: number of sectors */</span>
	<span class="n">u8</span>	<span class="n">lbal</span><span class="p">;</span>		<span class="cm">/* 3: LBA low */</span>
	<span class="n">u8</span>	<span class="n">lbam</span><span class="p">;</span>		<span class="cm">/* 4: LBA mid */</span>
	<span class="n">u8</span>	<span class="n">lbah</span><span class="p">;</span>		<span class="cm">/* 5: LBA high */</span>
	<span class="n">u8</span>	<span class="n">device</span><span class="p">;</span>		<span class="cm">/* 6: device select */</span>
	<span class="k">union</span> <span class="p">{</span>			<span class="cm">/* 7: */</span>
		<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/*  read: status */</span>
		<span class="n">u8</span> <span class="n">command</span><span class="p">;</span>	<span class="cm">/* write: command */</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ide_cmd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ide_taskfile</span>	<span class="n">tf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ide_taskfile</span>	<span class="n">hob</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">u8</span>		<span class="n">tf</span><span class="p">;</span>
			<span class="n">u8</span>		<span class="n">hob</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">valid</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">tf_flags</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">ftf_flags</span><span class="p">;</span>	<span class="cm">/* for TASKFILE ioctl */</span>
	<span class="kt">int</span>			<span class="n">protocol</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">sg_nents</span><span class="p">;</span>	  <span class="cm">/* number of sg entries */</span>
	<span class="kt">int</span>			<span class="n">orig_sg_nents</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">sg_dma_direction</span><span class="p">;</span> <span class="cm">/* DMA transfer direction */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nbytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">nleft</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">last_xfer_len</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">cursg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">cursg_ofs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">request</span>		<span class="o">*</span><span class="n">rq</span><span class="p">;</span>		<span class="cm">/* copy of request */</span>
<span class="p">};</span>

<span class="cm">/* ATAPI packet command flags */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* set when an error is considered normal - no retry (ide-tape) */</span>
	<span class="n">PC_FLAG_ABORT</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">PC_FLAG_SUPPRESS_ERROR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">PC_FLAG_WAIT_FOR_DSC</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">PC_FLAG_DMA_OK</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">PC_FLAG_DMA_IN_PROGRESS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="n">PC_FLAG_DMA_ERROR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="n">PC_FLAG_WRITING</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#define ATAPI_WAIT_PC		(60 * HZ)</span>

<span class="k">struct</span> <span class="n">ide_atapi_pc</span> <span class="p">{</span>
	<span class="cm">/* actual packet bytes */</span>
	<span class="n">u8</span> <span class="n">c</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="cm">/* incremented on each retry */</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* bytes to transfer */</span>
	<span class="kt">int</span> <span class="n">req_xfer</span><span class="p">;</span>

	<span class="cm">/* the corresponding request */</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * those are more or less driver-specific and some of them are subject</span>
<span class="cm">	 * to change/removal later.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ide_devset</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ide_driver</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_IDEACPI</span>
<span class="k">struct</span> <span class="n">ide_acpi_drive_link</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ide_acpi_hwif_link</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">ide_drive_s</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ide_disk_ops</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">check</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">get_capacity</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">unlock_native_capacity</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">init_media</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">set_doorlock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span>
					<span class="kt">int</span><span class="p">);</span>
	<span class="n">ide_startstop_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">do_request</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span>
				      <span class="n">sector_t</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span>
				 <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/* ATAPI device flags */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_AFLAG_DRQ_INTERRUPT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>

	<span class="cm">/* ide-cd */</span>
	<span class="cm">/* Drive cannot eject the disc. */</span>
	<span class="n">IDE_AFLAG_NO_EJECT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="cm">/* Drive is a pre ATAPI 1.2 drive. */</span>
	<span class="n">IDE_AFLAG_PRE_ATAPI12</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="cm">/* TOC addresses are in BCD. */</span>
	<span class="n">IDE_AFLAG_TOCADDR_AS_BCD</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="cm">/* TOC track numbers are in BCD. */</span>
	<span class="n">IDE_AFLAG_TOCTRACKS_AS_BCD</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="cm">/* Saved TOC information is current. */</span>
	<span class="n">IDE_AFLAG_TOC_VALID</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
	<span class="cm">/* We think that the drive door is locked. */</span>
	<span class="n">IDE_AFLAG_DOOR_LOCKED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
	<span class="cm">/* SET_CD_SPEED command is unsupported. */</span>
	<span class="n">IDE_AFLAG_NO_SPEED_SELECT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	<span class="n">IDE_AFLAG_VERTOS_300_SSD</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
	<span class="n">IDE_AFLAG_VERTOS_600_ESD</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
	<span class="n">IDE_AFLAG_SANYO_3CD</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>
	<span class="n">IDE_AFLAG_FULL_CAPS_PAGE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
	<span class="n">IDE_AFLAG_PLAY_AUDIO_OK</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>
	<span class="n">IDE_AFLAG_LE_SPEED_FIELDS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span>

	<span class="cm">/* ide-floppy */</span>
	<span class="cm">/* Avoid commands not supported in Clik drive */</span>
	<span class="n">IDE_AFLAG_CLIK_DRIVE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>
	<span class="cm">/* Requires BH algorithm for packets */</span>
	<span class="n">IDE_AFLAG_ZIP_DRIVE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>
	<span class="cm">/* Supports format progress report */</span>
	<span class="n">IDE_AFLAG_SRFP</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span>

	<span class="cm">/* ide-tape */</span>
	<span class="n">IDE_AFLAG_IGNORE_DSC</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span>
	<span class="cm">/* 0 When the tape position is unknown */</span>
	<span class="n">IDE_AFLAG_ADDRESS_VALID</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span>	<span class="mi">19</span><span class="p">),</span>
	<span class="cm">/* Device already opened */</span>
	<span class="n">IDE_AFLAG_BUSY</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">),</span>
	<span class="cm">/* Attempt to auto-detect the current user block size */</span>
	<span class="n">IDE_AFLAG_DETECT_BS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span>
	<span class="cm">/* Currently on a filemark */</span>
	<span class="n">IDE_AFLAG_FILEMARK</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">),</span>
	<span class="cm">/* 0 = no tape is loaded, so we don&#39;t rewind after ejecting */</span>
	<span class="n">IDE_AFLAG_MEDIUM_PRESENT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">),</span>

	<span class="n">IDE_AFLAG_NO_AUTOCLOSE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* device flags */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* restore settings after device reset */</span>
	<span class="n">IDE_DFLAG_KEEP_SETTINGS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="cm">/* device is using DMA for read/write */</span>
	<span class="n">IDE_DFLAG_USING_DMA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="cm">/* okay to unmask other IRQs */</span>
	<span class="n">IDE_DFLAG_UNMASK</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="cm">/* don&#39;t attempt flushes */</span>
	<span class="n">IDE_DFLAG_NOFLUSH</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="cm">/* DSC overlap */</span>
	<span class="n">IDE_DFLAG_DSC_OVERLAP</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="cm">/* give potential excess bandwidth */</span>
	<span class="n">IDE_DFLAG_NICE1</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="cm">/* device is physically present */</span>
	<span class="n">IDE_DFLAG_PRESENT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
	<span class="cm">/* disable Host Protected Area */</span>
	<span class="n">IDE_DFLAG_NOHPA</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
	<span class="cm">/* id read from device (synthetic if not set) */</span>
	<span class="n">IDE_DFLAG_ID_READ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_NOPROBE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
	<span class="cm">/* need to do check_media_change() */</span>
	<span class="n">IDE_DFLAG_REMOVABLE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
	<span class="cm">/* needed for removable devices */</span>
	<span class="n">IDE_DFLAG_ATTACH</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_FORCED_GEOM</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
	<span class="cm">/* disallow setting unmask bit */</span>
	<span class="n">IDE_DFLAG_NO_UNMASK</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>
	<span class="cm">/* disallow enabling 32-bit I/O */</span>
	<span class="n">IDE_DFLAG_NO_IO_32BIT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span>
	<span class="cm">/* for removable only: door lock/unlock works */</span>
	<span class="n">IDE_DFLAG_DOORLOCKING</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>
	<span class="cm">/* disallow DMA */</span>
	<span class="n">IDE_DFLAG_NODMA</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>
	<span class="cm">/* powermanagement told us not to do anything, so sleep nicely */</span>
	<span class="n">IDE_DFLAG_BLOCKED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span>
	<span class="cm">/* sleeping &amp; sleep field valid */</span>
	<span class="n">IDE_DFLAG_SLEEPING</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_POST_RESET</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_UDMA33_WARNED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_LBA48</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span>
	<span class="cm">/* status of write cache */</span>
	<span class="n">IDE_DFLAG_WCACHE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">),</span>
	<span class="cm">/* used for ignoring ATA_DF */</span>
	<span class="n">IDE_DFLAG_NOWERR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">),</span>
	<span class="cm">/* retrying in PIO */</span>
	<span class="n">IDE_DFLAG_DMA_PIO_RETRY</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_LBA</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">),</span>
	<span class="cm">/* don&#39;t unload heads */</span>
	<span class="n">IDE_DFLAG_NO_UNLOAD</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">),</span>
	<span class="cm">/* heads unloaded, please don&#39;t reset port */</span>
	<span class="n">IDE_DFLAG_PARKED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_MEDIA_CHANGED</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">),</span>
	<span class="cm">/* write protect */</span>
	<span class="n">IDE_DFLAG_WP</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_FORMAT_IN_PROGRESS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">),</span>
	<span class="n">IDE_DFLAG_NIEN_QUIRK</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* drive name, such as &quot;hda&quot; */</span>
        <span class="kt">char</span>            <span class="n">driver_req</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="cm">/* requests specific driver */</span>

	<span class="k">struct</span> <span class="n">request_queue</span>	<span class="o">*</span><span class="n">queue</span><span class="p">;</span>	<span class="cm">/* request queue */</span>

	<span class="k">struct</span> <span class="n">request</span>		<span class="o">*</span><span class="n">rq</span><span class="p">;</span>	<span class="cm">/* current request */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>	<span class="cm">/* extra driver data */</span>
	<span class="n">u16</span>			<span class="o">*</span><span class="n">id</span><span class="p">;</span>	<span class="cm">/* identification info */</span>
<span class="cp">#ifdef CONFIG_IDE_PROC_FS</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc</span><span class="p">;</span>	<span class="cm">/* /proc/ide/ directory entry */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_proc_devset</span> <span class="o">*</span><span class="n">settings</span><span class="p">;</span> <span class="cm">/* /proc/ide/ drive settings */</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">hwif_s</span>		<span class="o">*</span><span class="n">hwif</span><span class="p">;</span>	<span class="cm">/* actually (ide_hwif_t *) */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_disk_ops</span> <span class="o">*</span><span class="n">disk_ops</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_flags</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sleep</span><span class="p">;</span>		<span class="cm">/* sleep until this time */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>		<span class="cm">/* max time to wait for irq */</span>

	<span class="n">u8</span>	<span class="n">special_flags</span><span class="p">;</span>		<span class="cm">/* special action flags */</span>

	<span class="n">u8</span>	<span class="n">select</span><span class="p">;</span>			<span class="cm">/* basic drive/head select reg value */</span>
	<span class="n">u8</span>	<span class="n">retry_pio</span><span class="p">;</span>		<span class="cm">/* retrying dma capable host in pio */</span>
	<span class="n">u8</span>	<span class="n">waiting_for_dma</span><span class="p">;</span>	<span class="cm">/* dma currently in progress */</span>
	<span class="n">u8</span>	<span class="n">dma</span><span class="p">;</span>			<span class="cm">/* atapi dma flag */</span>

        <span class="n">u8</span>	<span class="n">init_speed</span><span class="p">;</span>	<span class="cm">/* transfer rate set at boot */</span>
        <span class="n">u8</span>	<span class="n">current_speed</span><span class="p">;</span>	<span class="cm">/* current transfer rate set */</span>
	<span class="n">u8</span>	<span class="n">desired_speed</span><span class="p">;</span>	<span class="cm">/* desired transfer rate set */</span>
	<span class="n">u8</span>	<span class="n">pio_mode</span><span class="p">;</span>	<span class="cm">/* for -&gt;set_pio_mode _only_ */</span>
	<span class="n">u8</span>	<span class="n">dma_mode</span><span class="p">;</span>	<span class="cm">/* for -&gt;set_dma_mode _only_ */</span>
	<span class="n">u8</span>	<span class="n">dn</span><span class="p">;</span>		<span class="cm">/* now wide spread use */</span>
	<span class="n">u8</span>	<span class="n">acoustic</span><span class="p">;</span>	<span class="cm">/* acoustic management */</span>
	<span class="n">u8</span>	<span class="n">media</span><span class="p">;</span>		<span class="cm">/* disk, cdrom, tape, floppy, ... */</span>
	<span class="n">u8</span>	<span class="n">ready_stat</span><span class="p">;</span>	<span class="cm">/* min status value for drive ready */</span>
	<span class="n">u8</span>	<span class="n">mult_count</span><span class="p">;</span>	<span class="cm">/* current multiple sector setting */</span>
	<span class="n">u8</span>	<span class="n">mult_req</span><span class="p">;</span>	<span class="cm">/* requested multiple sector setting */</span>
	<span class="n">u8</span>	<span class="n">io_32bit</span><span class="p">;</span>	<span class="cm">/* 0=16-bit, 1=32-bit, 2/3=32bit+sync */</span>
	<span class="n">u8</span>	<span class="n">bad_wstat</span><span class="p">;</span>	<span class="cm">/* used for ignoring ATA_DF */</span>
	<span class="n">u8</span>	<span class="n">head</span><span class="p">;</span>		<span class="cm">/* &quot;real&quot; number of heads */</span>
	<span class="n">u8</span>	<span class="n">sect</span><span class="p">;</span>		<span class="cm">/* &quot;real&quot; sectors per track */</span>
	<span class="n">u8</span>	<span class="n">bios_head</span><span class="p">;</span>	<span class="cm">/* BIOS/fdisk/LILO number of heads */</span>
	<span class="n">u8</span>	<span class="n">bios_sect</span><span class="p">;</span>	<span class="cm">/* BIOS/fdisk/LILO sectors per track */</span>

	<span class="cm">/* delay this long before sending packet command */</span>
	<span class="n">u8</span> <span class="n">pc_delay</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">bios_cyl</span><span class="p">;</span>	<span class="cm">/* BIOS/fdisk/LILO number of cyls */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cyl</span><span class="p">;</span>		<span class="cm">/* &quot;real&quot; number of cyls */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">drive_data</span><span class="p">;</span>	<span class="cm">/* used by set_pio_mode/dev_select() */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">failures</span><span class="p">;</span>	<span class="cm">/* current failure count */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">max_failures</span><span class="p">;</span>	<span class="cm">/* maximum allowed failure count */</span>
	<span class="n">u64</span>		<span class="n">probed_capacity</span><span class="p">;</span><span class="cm">/* initial/native media capacity */</span>
	<span class="n">u64</span>		<span class="n">capacity64</span><span class="p">;</span>	<span class="cm">/* total number of sectors */</span>

	<span class="kt">int</span>		<span class="n">lun</span><span class="p">;</span>		<span class="cm">/* logical unit */</span>
	<span class="kt">int</span>		<span class="n">crc_count</span><span class="p">;</span>	<span class="cm">/* crc counter to reduce drive speed */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">debug_mask</span><span class="p">;</span>	<span class="cm">/* debugging levels switch */</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_IDEACPI</span>
	<span class="k">struct</span> <span class="n">ide_acpi_drive_link</span> <span class="o">*</span><span class="n">acpidata</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>	<span class="n">gendev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">gendev_rel_comp</span><span class="p">;</span>	<span class="cm">/* to deal with device release() */</span>

	<span class="cm">/* current packet command */</span>
	<span class="k">struct</span> <span class="n">ide_atapi_pc</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

	<span class="cm">/* last failed packet command */</span>
	<span class="k">struct</span> <span class="n">ide_atapi_pc</span> <span class="o">*</span><span class="n">failed_pc</span><span class="p">;</span>

	<span class="cm">/* callback for packet commands */</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">pc_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="n">ide_startstop_t</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">atapi_flags</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ide_atapi_pc</span> <span class="n">request_sense_pc</span><span class="p">;</span>

	<span class="cm">/* current sense rq and buffer */</span>
	<span class="n">bool</span> <span class="n">sense_rq_armed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="n">sense_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_sense</span> <span class="n">sense_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="n">ide_drive_t</span><span class="p">;</span>

<span class="cp">#define to_ide_device(dev)		container_of(dev, ide_drive_t, gendev)</span>

<span class="cp">#define to_ide_drv(obj, cont_type)	\</span>
<span class="cp">	container_of(obj, struct cont_type, dev)</span>

<span class="cp">#define ide_drv_g(disk, cont_type)	\</span>
<span class="cp">	container_of((disk)-&gt;private_data, struct cont_type, driver)</span>

<span class="k">struct</span> <span class="n">ide_port_info</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ide_tp_ops</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">exec_command</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
	<span class="n">u8</span>	<span class="p">(</span><span class="o">*</span><span class="n">read_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u8</span>	<span class="p">(</span><span class="o">*</span><span class="n">read_altstatus</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">write_devctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">dev_select</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">tf_load</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">tf_read</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">input_data</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">output_data</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_tp_ops</span> <span class="n">default_tp_ops</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ide_port_ops - IDE port operations</span>
<span class="cm"> *</span>
<span class="cm"> * @init_dev:		host specific initialization of a device</span>
<span class="cm"> * @set_pio_mode:	routine to program host for PIO mode</span>
<span class="cm"> * @set_dma_mode:	routine to program host for DMA mode</span>
<span class="cm"> * @reset_poll:		chipset polling based on hba specifics</span>
<span class="cm"> * @pre_reset:		chipset specific changes to default for device-hba resets</span>
<span class="cm"> * @resetproc:		routine to reset controller after a disk reset</span>
<span class="cm"> * @maskproc:		special host masking for drive selection</span>
<span class="cm"> * @quirkproc:		check host&#39;s drive quirk list</span>
<span class="cm"> * @clear_irq:		clear IRQ</span>
<span class="cm"> *</span>
<span class="cm"> * @mdma_filter:	filter MDMA modes</span>
<span class="cm"> * @udma_filter:	filter UDMA modes</span>
<span class="cm"> *</span>
<span class="cm"> * @cable_detect:	detect cable type</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ide_port_ops</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">init_dev</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_pio_mode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">,</span> <span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_dma_mode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">,</span> <span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">reset_poll</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">pre_reset</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">resetproc</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">maskproc</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">quirkproc</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">clear_irq</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">test_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">u8</span>	<span class="p">(</span><span class="o">*</span><span class="n">mdma_filter</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u8</span>	<span class="p">(</span><span class="o">*</span><span class="n">udma_filter</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">u8</span>	<span class="p">(</span><span class="o">*</span><span class="n">cable_detect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ide_dma_ops</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_host_set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_end</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_test_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_lost_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* below ones are optional */</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_check</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_timer_expiry</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_clear</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ide_drive_s</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The following method is optional and only required to be</span>
<span class="cm">	 * implemented for the SFF-8038i compatible controllers.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span>	<span class="p">(</span><span class="o">*</span><span class="n">dma_sff_read_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_PFLAG_PROBING</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ide_host</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">hwif_s</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwif_s</span> <span class="o">*</span><span class="n">mate</span><span class="p">;</span>		<span class="cm">/* other hwif from same PCI chip */</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc</span><span class="p">;</span>	<span class="cm">/* /proc/ide/ directory entry */</span>

	<span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>			<span class="cm">/* name of interface, eg. &quot;ide0&quot; */</span>

	<span class="k">struct</span> <span class="n">ide_io_ports</span>	<span class="n">io_ports</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">sata_scr</span><span class="p">[</span><span class="n">SATA_NR_PORTS</span><span class="p">];</span>

	<span class="n">ide_drive_t</span>	<span class="o">*</span><span class="n">devices</span><span class="p">[</span><span class="n">MAX_DRIVES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">port_flags</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">major</span><span class="p">;</span>	<span class="cm">/* our major number */</span>
	<span class="n">u8</span> <span class="n">index</span><span class="p">;</span>	<span class="cm">/* 0 for ide0; 1 for ide1; ... */</span>
	<span class="n">u8</span> <span class="n">channel</span><span class="p">;</span>	<span class="cm">/* for dual-port chips: 0=primary, 1=secondary */</span>

	<span class="n">u32</span> <span class="n">host_flags</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">pio_mask</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">ultra_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mwdma_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">swdma_mask</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">cbl</span><span class="p">;</span>		<span class="cm">/* cable type */</span>

	<span class="n">hwif_chipset_t</span> <span class="n">chipset</span><span class="p">;</span>	<span class="cm">/* sub-module for tuning.. */</span>

	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rw_disk</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_tp_ops</span>		<span class="o">*</span><span class="n">tp_ops</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_ops</span>	<span class="o">*</span><span class="n">port_ops</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_dma_ops</span>	<span class="o">*</span><span class="n">dma_ops</span><span class="p">;</span>

	<span class="cm">/* dma physical region descriptor table (cpu view) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="o">*</span><span class="n">dmatable_cpu</span><span class="p">;</span>
	<span class="cm">/* dma physical region descriptor table (dma view) */</span>
	<span class="n">dma_addr_t</span>	<span class="n">dmatable_dma</span><span class="p">;</span>

	<span class="cm">/* maximum number of PRD table entries */</span>
	<span class="kt">int</span> <span class="n">prd_max_nents</span><span class="p">;</span>
	<span class="cm">/* PRD entry size in bytes */</span>
	<span class="kt">int</span> <span class="n">prd_ent_size</span><span class="p">;</span>

	<span class="cm">/* Scatter-gather list used to build the above */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg_table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_max_nents</span><span class="p">;</span>		<span class="cm">/* Maximum number of entries in it */</span>

	<span class="k">struct</span> <span class="n">ide_cmd</span> <span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* current command */</span>

	<span class="kt">int</span>		<span class="n">rqsize</span><span class="p">;</span>		<span class="cm">/* max sectors per request */</span>
	<span class="kt">int</span>		<span class="n">irq</span><span class="p">;</span>		<span class="cm">/* our irq number */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">dma_base</span><span class="p">;</span>	<span class="cm">/* base addr for dma ports */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">config_data</span><span class="p">;</span>	<span class="cm">/* for use by chipset-specific code */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">select_data</span><span class="p">;</span>	<span class="cm">/* for use by chipset-specific code */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">extra_base</span><span class="p">;</span>	<span class="cm">/* extra addr for dma ports */</span>
	<span class="kt">unsigned</span>	<span class="n">extra_ports</span><span class="p">;</span>	<span class="cm">/* number of extra dma ports */</span>

	<span class="kt">unsigned</span>	<span class="n">present</span>    <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* this interface exists */</span>
	<span class="kt">unsigned</span>	<span class="n">busy</span>	   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* serializes devices on a port */</span>

	<span class="k">struct</span> <span class="n">device</span>		<span class="n">gendev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">portdev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">completion</span> <span class="n">gendev_rel_comp</span><span class="p">;</span> <span class="cm">/* To deal with device release() */</span>

	<span class="kt">void</span>		<span class="o">*</span><span class="n">hwif_data</span><span class="p">;</span>	<span class="cm">/* extra hwif data */</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_IDEACPI</span>
	<span class="k">struct</span> <span class="n">ide_acpi_hwif_link</span> <span class="o">*</span><span class="n">acpidata</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* IRQ handler, if active */</span>
	<span class="n">ide_startstop_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* BOOL: polling active &amp; poll_timeout field valid */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">polling</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* current drive */</span>
	<span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">cur_dev</span><span class="p">;</span>

	<span class="cm">/* current request */</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>

	<span class="cm">/* failsafe timer */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="cm">/* timeout value during long polls */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">poll_timeout</span><span class="p">;</span>
	<span class="cm">/* queried upon timeouts */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">expiry</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">req_gen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">req_gen_timer</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_internodealigned_in_smp</span> <span class="n">ide_hwif_t</span><span class="p">;</span>

<span class="cp">#define MAX_HOST_PORTS 4</span>

<span class="k">struct</span> <span class="n">ide_host</span> <span class="p">{</span>
	<span class="n">ide_hwif_t</span>	<span class="o">*</span><span class="n">ports</span><span class="p">[</span><span class="n">MAX_HOST_PORTS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">n_ports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">init_chipset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">get_lock</span><span class="p">)(</span><span class="n">irq_handler_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">release_lock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="n">irq_handler_t</span>	<span class="n">irq_handler</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">host_flags</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="n">irq_flags</span><span class="p">;</span>

	<span class="kt">void</span>		<span class="o">*</span><span class="n">host_priv</span><span class="p">;</span>
	<span class="n">ide_hwif_t</span>	<span class="o">*</span><span class="n">cur_port</span><span class="p">;</span>	<span class="cm">/* for hosts requiring serialization */</span>

	<span class="cm">/* used for hosts requiring serialization */</span>
	<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">host_busy</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IDE_HOST_BUSY 0</span>

<span class="cm">/*</span>
<span class="cm"> *  internal ide interrupt handler type</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="n">ide_startstop_t</span> <span class="p">(</span><span class="n">ide_handler_t</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">ide_expiry_t</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* used by ide-cd, ide-floppy, etc. */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">xfer_func_t</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">ide_setting_mtx</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * configurable drive settings</span>
<span class="cm"> */</span>

<span class="cp">#define DS_SYNC	(1 &lt;&lt; 0)</span>

<span class="k">struct</span> <span class="n">ide_devset</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">get</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define __DEVSET(_flags, _get, _set) { \</span>
<span class="cp">	.flags	= _flags, \</span>
<span class="cp">	.get	= _get,	\</span>
<span class="cp">	.set	= _set,	\</span>
<span class="cp">}</span>

<span class="cp">#define ide_devset_get(name, field) \</span>
<span class="cp">static int get_##name(ide_drive_t *drive) \</span>
<span class="cp">{ \</span>
<span class="cp">	return drive-&gt;field; \</span>
<span class="cp">}</span>

<span class="cp">#define ide_devset_set(name, field) \</span>
<span class="cp">static int set_##name(ide_drive_t *drive, int arg) \</span>
<span class="cp">{ \</span>
<span class="cp">	drive-&gt;field = arg; \</span>
<span class="cp">	return 0; \</span>
<span class="cp">}</span>

<span class="cp">#define ide_devset_get_flag(name, flag) \</span>
<span class="cp">static int get_##name(ide_drive_t *drive) \</span>
<span class="cp">{ \</span>
<span class="cp">	return !!(drive-&gt;dev_flags &amp; flag); \</span>
<span class="cp">}</span>

<span class="cp">#define ide_devset_set_flag(name, flag) \</span>
<span class="cp">static int set_##name(ide_drive_t *drive, int arg) \</span>
<span class="cp">{ \</span>
<span class="cp">	if (arg) \</span>
<span class="cp">		drive-&gt;dev_flags |= flag; \</span>
<span class="cp">	else \</span>
<span class="cp">		drive-&gt;dev_flags &amp;= ~flag; \</span>
<span class="cp">	return 0; \</span>
<span class="cp">}</span>

<span class="cp">#define __IDE_DEVSET(_name, _flags, _get, _set) \</span>
<span class="cp">const struct ide_devset ide_devset_##_name = \</span>
<span class="cp">	__DEVSET(_flags, _get, _set)</span>

<span class="cp">#define IDE_DEVSET(_name, _flags, _get, _set) \</span>
<span class="cp">static __IDE_DEVSET(_name, _flags, _get, _set)</span>

<span class="cp">#define ide_devset_rw(_name, _func) \</span>
<span class="cp">IDE_DEVSET(_name, 0, get_##_func, set_##_func)</span>

<span class="cp">#define ide_devset_w(_name, _func) \</span>
<span class="cp">IDE_DEVSET(_name, 0, NULL, set_##_func)</span>

<span class="cp">#define ide_ext_devset_rw(_name, _func) \</span>
<span class="cp">__IDE_DEVSET(_name, 0, get_##_func, set_##_func)</span>

<span class="cp">#define ide_ext_devset_rw_sync(_name, _func) \</span>
<span class="cp">__IDE_DEVSET(_name, DS_SYNC, get_##_func, set_##_func)</span>

<span class="cp">#define ide_decl_devset(_name) \</span>
<span class="cp">extern const struct ide_devset ide_devset_##_name</span>

<span class="n">ide_decl_devset</span><span class="p">(</span><span class="n">io_32bit</span><span class="p">);</span>
<span class="n">ide_decl_devset</span><span class="p">(</span><span class="n">keepsettings</span><span class="p">);</span>
<span class="n">ide_decl_devset</span><span class="p">(</span><span class="n">pio_mode</span><span class="p">);</span>
<span class="n">ide_decl_devset</span><span class="p">(</span><span class="n">unmaskirq</span><span class="p">);</span>
<span class="n">ide_decl_devset</span><span class="p">(</span><span class="n">using_dma</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IDE_PROC_FS</span>
<span class="cm">/*</span>
<span class="cm"> * /proc/ide interface</span>
<span class="cm"> */</span>

<span class="cp">#define ide_devset_rw_field(_name, _field) \</span>
<span class="cp">ide_devset_get(_name, _field); \</span>
<span class="cp">ide_devset_set(_name, _field); \</span>
<span class="cp">IDE_DEVSET(_name, DS_SYNC, get_##_name, set_##_name)</span>

<span class="cp">#define ide_devset_rw_flag(_name, _field) \</span>
<span class="cp">ide_devset_get_flag(_name, _field); \</span>
<span class="cp">ide_devset_set_flag(_name, _field); \</span>
<span class="cp">IDE_DEVSET(_name, DS_SYNC, get_##_name, set_##_name)</span>

<span class="k">struct</span> <span class="n">ide_proc_devset</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_devset</span>	<span class="o">*</span><span class="n">setting</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">mulf</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">divf</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define __IDE_PROC_DEVSET(_name, _min, _max, _mulf, _divf) { \</span>
<span class="cp">	.name = __stringify(_name), \</span>
<span class="cp">	.setting = &amp;ide_devset_##_name, \</span>
<span class="cp">	.min = _min, \</span>
<span class="cp">	.max = _max, \</span>
<span class="cp">	.mulf = _mulf, \</span>
<span class="cp">	.divf = _divf, \</span>
<span class="cp">}</span>

<span class="cp">#define IDE_PROC_DEVSET(_name, _min, _max) \</span>
<span class="cp">__IDE_PROC_DEVSET(_name, _min, _max, NULL, NULL)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">umode_t</span>		<span class="n">mode</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">proc_fops</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ide_proc_entry_t</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">proc_ide_create</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">proc_ide_destroy</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_proc_register_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_proc_port_register_devices</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_proc_unregister_device</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_proc_unregister_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_proc_register_driver</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_proc_unregister_driver</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_driver</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ide_capacity_proc_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ide_geometry_proc_fops</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">proc_ide_create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">proc_ide_destroy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_proc_register_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_proc_port_register_devices</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_proc_unregister_device</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_proc_unregister_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_proc_register_driver</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">ide_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_proc_unregister_driver</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ide_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* enter/exit functions */</span>
	<span class="n">IDE_DBG_FUNC</span> <span class="o">=</span>			<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="cm">/* sense key/asc handling */</span>
	<span class="n">IDE_DBG_SENSE</span> <span class="o">=</span>			<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="cm">/* packet commands handling */</span>
	<span class="n">IDE_DBG_PC</span> <span class="o">=</span>			<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="cm">/* request handling */</span>
	<span class="n">IDE_DBG_RQ</span> <span class="o">=</span>			<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="cm">/* driver probing/setup */</span>
	<span class="n">IDE_DBG_PROBE</span> <span class="o">=</span>			<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* DRV_NAME has to be defined in the driver before using the macro below */</span>
<span class="cp">#define __ide_debug_log(lvl, fmt, args...)				\</span>
<span class="cp">{									\</span>
<span class="cp">	if (unlikely(drive-&gt;debug_mask &amp; lvl))				\</span>
<span class="cp">		printk(KERN_INFO DRV_NAME &quot;: %s: &quot; fmt &quot;\n&quot;,		\</span>
<span class="cp">					  __func__, ## args);		\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Power Management state machine (rq-&gt;pm-&gt;pm_step).</span>
<span class="cm"> *</span>
<span class="cm"> * For each step, the core calls ide_start_power_step() first.</span>
<span class="cm"> * This can return:</span>
<span class="cm"> *	- ide_stopped :	In this case, the core calls us back again unless</span>
<span class="cm"> *			step have been set to ide_power_state_completed.</span>
<span class="cm"> *	- ide_started :	In this case, the channel is left busy until an</span>
<span class="cm"> *			async event (interrupt) occurs.</span>
<span class="cm"> * Typically, ide_start_power_step() will issue a taskfile request with</span>
<span class="cm"> * do_rw_taskfile().</span>
<span class="cm"> *</span>
<span class="cm"> * Upon reception of the interrupt, the core will call ide_complete_power_step()</span>
<span class="cm"> * with the error code if any. This routine should update the step value</span>
<span class="cm"> * and return. It should not start a new request. The core will call</span>
<span class="cm"> * ide_start_power_step() for the new step value, unless step have been</span>
<span class="cm"> * set to IDE_PM_COMPLETED.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_PM_START_SUSPEND</span><span class="p">,</span>
	<span class="n">IDE_PM_FLUSH_CACHE</span>	<span class="o">=</span> <span class="n">IDE_PM_START_SUSPEND</span><span class="p">,</span>
	<span class="n">IDE_PM_STANDBY</span><span class="p">,</span>

	<span class="n">IDE_PM_START_RESUME</span><span class="p">,</span>
	<span class="n">IDE_PM_RESTORE_PIO</span>	<span class="o">=</span> <span class="n">IDE_PM_START_RESUME</span><span class="p">,</span>
	<span class="n">IDE_PM_IDLE</span><span class="p">,</span>
	<span class="n">IDE_PM_RESTORE_DMA</span><span class="p">,</span>

	<span class="n">IDE_PM_COMPLETED</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">generic_ide_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">pm_message_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">generic_ide_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_complete_power_step</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="n">ide_startstop_t</span> <span class="n">ide_start_power_step</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_complete_pm_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_check_pm_state</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Subdrivers support.</span>
<span class="cm"> *</span>
<span class="cm"> * The gendriver.owner field should be set to the module owner of this driver.</span>
<span class="cm"> * The gendriver.name field should be set to the name of this driver</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ide_driver</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>			<span class="o">*</span><span class="n">version</span><span class="p">;</span>
	<span class="n">ide_startstop_t</span>	<span class="p">(</span><span class="o">*</span><span class="n">do_request</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_driver</span>	<span class="n">gen_driver</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>		<span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IDE_PROC_FS</span>
	<span class="n">ide_proc_entry_t</span> <span class="o">*</span>		<span class="p">(</span><span class="o">*</span><span class="n">proc_entries</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_proc_devset</span> <span class="o">*</span>	<span class="p">(</span><span class="o">*</span><span class="n">proc_devsets</span><span class="p">)(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define to_ide_driver(drv) container_of(drv, struct ide_driver, gen_driver)</span>

<span class="kt">int</span> <span class="n">ide_device_get</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_device_put</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ide_ioctl_devset</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">get_ioctl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">set_ioctl</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_devset</span> <span class="o">*</span><span class="n">setting</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">ide_setting_ioctl</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_ioctl_devset</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">generic_ide_ioctl</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ide_vlb_clk</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ide_pci_clk</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">ide_end_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_kill_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__ide_set_handler</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">ide_handler_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_set_handler</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">ide_handler_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_execute_command</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="n">ide_handler_t</span> <span class="o">*</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_pad_transfer</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="n">ide_startstop_t</span> <span class="n">ide_error</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_fix_driveid</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_fixstring</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_busy_sleep</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__ide_wait_stat</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_wait_stat</span><span class="p">(</span><span class="n">ide_startstop_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="n">ide_startstop_t</span> <span class="n">ide_do_park_unpark</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>
<span class="n">ide_startstop_t</span> <span class="n">ide_do_devset</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">ide_startstop_t</span> <span class="n">ide_do_reset</span> <span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ide_devset_execute</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_devset</span> <span class="o">*</span><span class="n">setting</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_complete_cmd</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_complete_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_tf_readback</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_tf_dump</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_exec_command</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">ide_read_status</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">ide_read_altstatus</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_write_devctl</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_dev_select</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_tf_load</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_tf_read</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_taskfile</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_input_data</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_output_data</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">SELECT_MASK</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="n">u8</span> <span class="n">ide_read_error</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_read_bcount_and_ireason</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_check_ireason</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_check_atapi_device</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_init_pc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_atapi_pc</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Disk head parking */</span>
<span class="k">extern</span> <span class="n">wait_queue_head_t</span> <span class="n">ide_park_wq</span><span class="p">;</span>
<span class="kt">ssize_t</span> <span class="n">ide_park_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">ide_park_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Special requests for ide-tape block device strategy routine.</span>
<span class="cm"> *</span>
<span class="cm"> * In order to service a character device command, we add special requests to</span>
<span class="cm"> * the tail of our block device request queue and wait for their completion.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">REQ_IDETAPE_PC1</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* packet command (first stage) */</span>
	<span class="n">REQ_IDETAPE_PC2</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* packet command (second stage) */</span>
	<span class="n">REQ_IDETAPE_READ</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">REQ_IDETAPE_WRITE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">ide_queue_pc_tail</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_atapi_pc</span> <span class="o">*</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_do_test_unit_ready</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_do_start_stop</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_set_media_lock</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_create_request_sense_cmd</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_atapi_pc</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_retry_pc</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_prep_sense</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_queue_sense_rq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">special</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_cd_expiry</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_cd_get_xferlen</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="p">);</span>

<span class="n">ide_startstop_t</span> <span class="n">ide_issue_pc</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>

<span class="n">ide_startstop_t</span> <span class="n">do_rw_taskfile</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_pio_bytes</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_finish_cmd</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_raw_taskfile</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_no_data_taskfile</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_taskfile_ioctl</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_dev_read_id</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ide_driveid_update</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ide_config_drive_speed</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">eighty_ninty_three</span> <span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">taskfile_lib_get_identify</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ide_wait_not_busy</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_stall_queue</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_timer_expiry</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">irqreturn_t</span> <span class="n">ide_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">do_ide_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_requeue_and_plug</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_init_disk</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IDEPCI_PCIBUS_ORDER</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ide_pci_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">);</span>
<span class="cp">#define ide_pci_register_driver(d) __ide_pci_register_driver(d, THIS_MODULE, KBUILD_MODNAME)</span>
<span class="cp">#else</span>
<span class="cp">#define ide_pci_register_driver(d) pci_register_driver(d)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_pci_is_in_compatibility_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_CLASS_STORAGE_IDE</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ide_pci_setup_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ide_hw</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_hw</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_setup_pci_noise</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_IDEDMA_PCI</span>
<span class="kt">int</span> <span class="n">ide_pci_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ide_pci_dma_base</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_pci_check_simplex</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_hwif_setup_dma</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_hwif_setup_dma</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">ide_pci_enablebit</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">reg</span><span class="p">;</span>	<span class="cm">/* byte pci reg holding the enable-bit */</span>
	<span class="n">u8</span>	<span class="n">mask</span><span class="p">;</span>	<span class="cm">/* mask to isolate the enable-bit */</span>
	<span class="n">u8</span>	<span class="n">val</span><span class="p">;</span>	<span class="cm">/* value of masked reg when &quot;enabled&quot; */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Uses ISA control ports not PCI ones. */</span>
	<span class="n">IDE_HFLAG_ISA_PORTS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="cm">/* single port device */</span>
	<span class="n">IDE_HFLAG_SINGLE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="cm">/* don&#39;t use legacy PIO blacklist */</span>
	<span class="n">IDE_HFLAG_PIO_NO_BLACKLIST</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="cm">/* set for the second port of QD65xx */</span>
	<span class="n">IDE_HFLAG_QD_2ND_PORT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="cm">/* use PIO8/9 for prefetch off/on */</span>
	<span class="n">IDE_HFLAG_ABUSE_PREFETCH</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="cm">/* use PIO6/7 for fast-devsel off/on */</span>
	<span class="n">IDE_HFLAG_ABUSE_FAST_DEVSEL</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="cm">/* use 100-102 and 200-202 PIO values to set DMA modes */</span>
	<span class="n">IDE_HFLAG_ABUSE_DMA_MODES</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 * keep DMA setting when programming PIO mode, may be used only</span>
<span class="cm">	 * for hosts which have separate PIO and DMA timings (ie. PMAC)</span>
<span class="cm">	 */</span>
	<span class="n">IDE_HFLAG_SET_PIO_MODE_KEEP_DMA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
	<span class="cm">/* program host for the transfer mode after programming device */</span>
	<span class="n">IDE_HFLAG_POST_SET_MODE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
	<span class="cm">/* don&#39;t program host/device for the transfer mode (&quot;smart&quot; hosts) */</span>
	<span class="n">IDE_HFLAG_NO_SET_MODE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
	<span class="cm">/* trust BIOS for programming chipset/device for DMA */</span>
	<span class="n">IDE_HFLAG_TRUST_BIOS_FOR_DMA</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
	<span class="cm">/* host is CS5510/CS5520 */</span>
	<span class="n">IDE_HFLAG_CS5520</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>
	<span class="cm">/* ATAPI DMA is unsupported */</span>
	<span class="n">IDE_HFLAG_NO_ATAPI_DMA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
	<span class="cm">/* set if host is a &quot;non-bootable&quot; controller */</span>
	<span class="n">IDE_HFLAG_NON_BOOTABLE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>
	<span class="cm">/* host doesn&#39;t support DMA */</span>
	<span class="n">IDE_HFLAG_NO_DMA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span>
	<span class="cm">/* check if host is PCI IDE device before allowing DMA */</span>
	<span class="n">IDE_HFLAG_NO_AUTODMA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>
	<span class="cm">/* host uses MMIO */</span>
	<span class="n">IDE_HFLAG_MMIO</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>
	<span class="cm">/* no LBA48 */</span>
	<span class="n">IDE_HFLAG_NO_LBA48</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span>
	<span class="cm">/* no LBA48 DMA */</span>
	<span class="n">IDE_HFLAG_NO_LBA48_DMA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span>
	<span class="cm">/* data FIFO is cleared by an error */</span>
	<span class="n">IDE_HFLAG_ERROR_STOPS_FIFO</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span>
	<span class="cm">/* serialize ports */</span>
	<span class="n">IDE_HFLAG_SERIALIZE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">),</span>
	<span class="cm">/* host is DTC2278 */</span>
	<span class="n">IDE_HFLAG_DTC2278</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span>
	<span class="cm">/* 4 devices on a single set of I/O ports */</span>
	<span class="n">IDE_HFLAG_4DRIVES</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">),</span>
	<span class="cm">/* host is TRM290 */</span>
	<span class="n">IDE_HFLAG_TRM290</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">),</span>
	<span class="cm">/* use 32-bit I/O ops */</span>
	<span class="n">IDE_HFLAG_IO_32BIT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
	<span class="cm">/* unmask IRQs */</span>
	<span class="n">IDE_HFLAG_UNMASK_IRQS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">),</span>
	<span class="n">IDE_HFLAG_BROKEN_ALTSTATUS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">),</span>
	<span class="cm">/* serialize ports if DMA is possible (for sl82c105) */</span>
	<span class="n">IDE_HFLAG_SERIALIZE_DMA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">),</span>
	<span class="cm">/* force host out of &quot;simplex&quot; mode */</span>
	<span class="n">IDE_HFLAG_CLEAR_SIMPLEX</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">),</span>
	<span class="cm">/* DSC overlap is unsupported */</span>
	<span class="n">IDE_HFLAG_NO_DSC</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">),</span>
	<span class="cm">/* never use 32-bit I/O ops */</span>
	<span class="n">IDE_HFLAG_NO_IO_32BIT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">),</span>
	<span class="cm">/* never unmask IRQs */</span>
	<span class="n">IDE_HFLAG_NO_UNMASK_IRQS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">),</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_OFFBOARD</span>
<span class="cp"># define IDE_HFLAG_OFF_BOARD	0</span>
<span class="cp">#else</span>
<span class="cp"># define IDE_HFLAG_OFF_BOARD	IDE_HFLAG_NON_BOOTABLE</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">ide_port_info</span> <span class="p">{</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_chipset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">get_lock</span><span class="p">)(</span><span class="n">irq_handler_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">release_lock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_iops</span><span class="p">)(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">init_hwif</span><span class="p">)(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">init_dma</span><span class="p">)(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_tp_ops</span>		<span class="o">*</span><span class="n">tp_ops</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_ops</span>	<span class="o">*</span><span class="n">port_ops</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ide_dma_ops</span>	<span class="o">*</span><span class="n">dma_ops</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ide_pci_enablebit</span>	<span class="n">enablebits</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">hwif_chipset_t</span>		<span class="n">chipset</span><span class="p">;</span>

	<span class="n">u16</span>			<span class="n">max_sectors</span><span class="p">;</span>	<span class="cm">/* if &lt; than the default one */</span>

	<span class="n">u32</span>			<span class="n">host_flags</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">u8</span>			<span class="n">pio_mask</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">swdma_mask</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">mwdma_mask</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="n">udma_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">ide_pci_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_pci_init_two</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">int</span> <span class="n">ide_pci_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="n">pm_message_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_pci_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define ide_pci_suspend NULL</span>
<span class="cp">#define ide_pci_resume NULL</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">ide_map_sg</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_init_sg_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="cp">#define BAD_DMA_DRIVE		0</span>
<span class="cp">#define GOOD_DMA_DRIVE		1</span>

<span class="k">struct</span> <span class="n">drive_list_entry</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id_model</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id_firmware</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">ide_in_drive_list</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">drive_list_entry</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_IDEDMA</span>
<span class="kt">int</span> <span class="n">ide_dma_good_drive</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__ide_dma_bad_drive</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="n">u8</span> <span class="n">ide_find_dma_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ide_max_dma_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ide_find_dma_mode</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="n">XFER_UDMA_6</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ide_dma_off_quietly</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_dma_off</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_dma_on</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_set_dma</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_check_dma_crc</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">ide_startstop_t</span> <span class="n">ide_dma_intr</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_allocate_dma_engine</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_release_dma_engine</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ide_dma_prepare</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_dma_unmap_sg</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_IDEDMA_SFF</span>
<span class="kt">int</span> <span class="n">config_drive_for_dma</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_build_dmatable</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_dma_host_set</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_dma_setup</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_dma_start</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_dma_end</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_dma_test_irq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_dma_sff_timer_expiry</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">ide_dma_sff_read_status</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_dma_ops</span> <span class="n">sff_dma_ops</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">config_drive_for_dma</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_IDEDMA_SFF */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">ide_dma_lost_irq</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="n">ide_startstop_t</span> <span class="n">ide_dma_timeout_retry</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ide_find_dma_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="n">u8</span> <span class="n">speed</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ide_max_dma_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_dma_off_quietly</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_dma_off</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_dma_on</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_dma_verbose</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_set_dma</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_check_dma_crc</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ide_startstop_t</span> <span class="nf">ide_dma_intr</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ide_stopped</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ide_startstop_t</span> <span class="nf">ide_dma_timeout_retry</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ide_stopped</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_release_dma_engine</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_dma_prepare</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_dma_unmap_sg</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_DEV_IDEDMA */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_BLK_DEV_IDEACPI</span>
<span class="kt">int</span> <span class="n">ide_acpi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">bool</span> <span class="n">ide_port_acpi</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ide_acpi_exec_tfs</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_acpi_get_timing</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_acpi_push_timing</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_acpi_init_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_acpi_port_init_devices</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_acpi_set_state</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_acpi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ide_port_acpi</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_acpi_exec_tfs</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_acpi_get_timing</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_acpi_push_timing</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_acpi_init_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_acpi_port_init_devices</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_acpi_set_state</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">ide_register_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_unregister_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_check_nien_quirk_list</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_undecoded_slave</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ide_port_apply_params</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_sysfs_register_port</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="n">ide_host_alloc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_hw</span> <span class="o">**</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_host_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_host_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ide_hw</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_host_add</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_hw</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">ide_host</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_host_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_host</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_legacy_device_add</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ide_port_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_port_unregister_devices</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_port_scan</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ide_get_hwifdata</span> <span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span> <span class="n">hwif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">hwif_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_set_hwifdata</span> <span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span> <span class="n">hwif</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hwif</span><span class="o">-&gt;</span><span class="n">hwif_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ide_toggle_bounce</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>

<span class="n">u64</span> <span class="n">ide_get_lba_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_cmd</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">u8</span> <span class="n">ide_dump_status</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ide_timing</span> <span class="p">{</span>
	<span class="n">u8</span>  <span class="n">mode</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">setup</span><span class="p">;</span>	<span class="cm">/* t1 */</span>
	<span class="n">u16</span> <span class="n">act8b</span><span class="p">;</span>	<span class="cm">/* t2 for 8-bit io */</span>
	<span class="n">u16</span> <span class="n">rec8b</span><span class="p">;</span>	<span class="cm">/* t2i for 8-bit io */</span>
	<span class="n">u16</span> <span class="n">cyc8b</span><span class="p">;</span>	<span class="cm">/* t0 for 8-bit io */</span>
	<span class="n">u16</span> <span class="n">active</span><span class="p">;</span>	<span class="cm">/* t2 or tD */</span>
	<span class="n">u16</span> <span class="n">recover</span><span class="p">;</span>	<span class="cm">/* t2i or tK */</span>
	<span class="n">u16</span> <span class="n">cycle</span><span class="p">;</span>	<span class="cm">/* t0 */</span>
	<span class="n">u16</span> <span class="n">udma</span><span class="p">;</span>	<span class="cm">/* t2CYCTYP/2 */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">IDE_TIMING_SETUP</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">IDE_TIMING_ACT8B</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">IDE_TIMING_REC8B</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">IDE_TIMING_CYC8B</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">IDE_TIMING_8BIT</span>		<span class="o">=</span> <span class="n">IDE_TIMING_ACT8B</span> <span class="o">|</span> <span class="n">IDE_TIMING_REC8B</span> <span class="o">|</span>
				  <span class="n">IDE_TIMING_CYC8B</span><span class="p">,</span>
	<span class="n">IDE_TIMING_ACTIVE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="n">IDE_TIMING_RECOVER</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="n">IDE_TIMING_CYCLE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
	<span class="n">IDE_TIMING_UDMA</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
	<span class="n">IDE_TIMING_ALL</span>		<span class="o">=</span> <span class="n">IDE_TIMING_SETUP</span> <span class="o">|</span> <span class="n">IDE_TIMING_8BIT</span> <span class="o">|</span>
				  <span class="n">IDE_TIMING_ACTIVE</span> <span class="o">|</span> <span class="n">IDE_TIMING_RECOVER</span> <span class="o">|</span>
				  <span class="n">IDE_TIMING_CYCLE</span> <span class="o">|</span> <span class="n">IDE_TIMING_UDMA</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ide_timing</span> <span class="o">*</span><span class="n">ide_timing_find_mode</span><span class="p">(</span><span class="n">u8</span><span class="p">);</span>
<span class="n">u16</span> <span class="n">ide_pio_cycle_time</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_timing_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">ide_timing</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_timing</span> <span class="o">*</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ide_timing</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_timing_compute</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ide_timing</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_IDE_XFER_MODE</span>
<span class="kt">int</span> <span class="n">ide_scan_pio_blacklist</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ide_xfer_verbose</span><span class="p">(</span><span class="n">u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_pio_need_iordy</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_set_pio_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_set_dma_mode</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ide_set_pio</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ide_set_xfer_rate</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_set_pio</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pio</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ide_set_xfer_rate</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="n">u8</span> <span class="n">rate</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_set_max_pio</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_set_pio</span><span class="p">(</span><span class="n">drive</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">ide_media_string</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">ide_dev_attrs</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bus_type</span> <span class="n">ide_bus_type</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">ide_port_class</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_dump_identify</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_NONE</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hwif_to_node</span><span class="p">(</span><span class="n">ide_hwif_t</span> <span class="o">*</span><span class="n">hwif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hwif</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">dev_to_node</span><span class="p">(</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ide_drive_t</span> <span class="o">*</span><span class="nf">ide_get_pair_dev</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">peer</span> <span class="o">=</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">hwif</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">[(</span><span class="n">drive</span><span class="o">-&gt;</span><span class="n">dn</span> <span class="o">^</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">peer</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">IDE_DFLAG_PRESENT</span><span class="p">)</span> <span class="o">?</span> <span class="n">peer</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ide_get_drivedata</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">drive</span><span class="o">-&gt;</span><span class="n">drive_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ide_set_drivedata</span><span class="p">(</span><span class="n">ide_drive_t</span> <span class="o">*</span><span class="n">drive</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">drive</span><span class="o">-&gt;</span><span class="n">drive_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ide_port_for_each_dev(i, dev, port) \</span>
<span class="cp">	for ((i) = 0; ((dev) = (port)-&gt;devices[i]) || (i) &lt; MAX_DRIVES; (i)++)</span>

<span class="cp">#define ide_port_for_each_present_dev(i, dev, port) \</span>
<span class="cp">	for ((i) = 0; ((dev) = (port)-&gt;devices[i]) || (i) &lt; MAX_DRIVES; (i)++) \</span>
<span class="cp">		if ((dev)-&gt;dev_flags &amp; IDE_DFLAG_PRESENT)</span>

<span class="cp">#define ide_host_for_each_port(i, port, host) \</span>
<span class="cp">	for ((i) = 0; ((port) = (host)-&gt;ports[i]) || (i) &lt; MAX_HOST_PORTS; (i)++)</span>

<span class="cp">#endif </span><span class="cm">/* _IDE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
