f | packed_struct.h | s | 1.0K | 37 | Andrew Morton | akpm@linux-foundation.org | 1294934588 |  | include/linux/unaligned/packed_struct.h: use __packed  Cc: Will Newton <will.newton@gmail.com> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | be_byteshift.h | s | 1.4K | 56 | Albin Tonnerre | albin.tonnerre@free-electrons.com | 1253802065 |  | include/linux/unaligned/{l,b}e_byteshift.h: fix usage for compressed kernels  When unaligned accesses are required for uncompressing a kernel (such as for LZO decompression on ARM in a patch that follows), including <linux/kernel.h> causes issues as it brings in a lot of things that are not available in the decompression environment.  linux/kernel.h brings at least: extern int console_printk[]; extern const char hex_asc[]; which causes errors at link-time as they are not available when compiling the pre-boot environement. There are also a few others:    arch/arm/boot/compressed/misc.o: In function `valid_user_regs':    arch/arm/include/asm/ptrace.h:158: undefined reference to `elf_hwcap'   arch/arm/boot/compressed/misc.o: In function `console_silent':    include/linux/kernel.h:292: undefined reference to `console_printk'   arch/arm/boot/compressed/misc.o: In function `console_verbose':    include/linux/kernel.h:297: undefined reference to `console_printk'   arch/arm/boot/compressed/misc.o: In function `pack_hex_byte':    include/linux/kernel.h:360: undefined reference to `hex_asc'   arch/arm/boot/compressed/misc.o: In function `hweight_long':    include/linux/bitops.h:45: undefined reference to `hweight32'   arch/arm/boot/compressed/misc.o: In function `__cmpxchg_local_generic':    include/asm-generic/cmpxchg-local.h:21: undefined reference to `wrong_size_cmpxchg'    include/asm-generic/cmpxchg-local.h:42: undefined reference to `wrong_size_cmpxchg'   arch/arm/boot/compressed/misc.o: In function `__xchg':    arch/arm/include/asm/system.h:309: undefined reference to `__bad_xchg'  However, those files apparently use nothing from <linux/kernel.h>, all they need is the declaration of types such as u32 or u64, so <linux/types.h> should be enough  Signed-off-by: Albin Tonnerre <albin.tonnerre@free-electrons.com> Cc: Sam Ravnborg <sam@ravnborg.org> Cc: Russell King <rmk@arm.linux.org.uk> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: "H. Peter Anvin" <hpa@zytor.com> Cc: Phillip Lougher <phillip@lougher.demon.co.uk> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | be_struct.h | s | 749B | 28 | Harvey Harrison | harvey.harrison@gmail.com | 1209481587 |  | kernel: add common infrastructure for unaligned access  Create a linux/unaligned directory similar in spirit to the linux/byteorder folder to hold generic implementations collected from various arches.  Currently there are five implementations: 1) packed_struct.h: C-struct based, from asm-generic/unaligned.h 2) le_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 3) be_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 4) memmove.h: taken from multiple implementations in tree 5) access_ok.h: taken from x86 and others, unaligned access is ok.  All of the new implementations checks for sizes not equal to 1,2,4,8 and will fail to link.  API additions:  get_unaligned_{le16||le32||le64||be16||be32||be64}(p) which is meant to replace code of the form: le16_to_cpu(get_unaligned((__le16 *)p));  put_unaligned_{le16||le32||le64||be16||be32||be64}(val, pointer) which is meant to replace code of the form: put_unaligned(cpu_to_le16(val), (__le16 *)p);  The headers that arches should include from their asm/unaligned.h:  access_ok.h : Wrappers of the byteswapping functions in asm/byteorder  Choose a particular implementation for little-endian access: le_byteshift.h le_memmove.h (arch must be LE) le_struct.h (arch must be LE)  Choose a particular implementation for big-endian access: be_byteshift.h be_memmove.h (arch must be BE) be_struct.h (arch must be BE)  After including as needed from the above, include unaligned/generic.h and define your arch's get/put_unaligned as (for LE):  Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com> Cc: <linux-arch@vger.kernel.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | memmove.h | s | 829B | 36 | Harvey Harrison | harvey.harrison@gmail.com | 1209481587 |  | kernel: add common infrastructure for unaligned access  Create a linux/unaligned directory similar in spirit to the linux/byteorder folder to hold generic implementations collected from various arches.  Currently there are five implementations: 1) packed_struct.h: C-struct based, from asm-generic/unaligned.h 2) le_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 3) be_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 4) memmove.h: taken from multiple implementations in tree 5) access_ok.h: taken from x86 and others, unaligned access is ok.  All of the new implementations checks for sizes not equal to 1,2,4,8 and will fail to link.  API additions:  get_unaligned_{le16||le32||le64||be16||be32||be64}(p) which is meant to replace code of the form: le16_to_cpu(get_unaligned((__le16 *)p));  put_unaligned_{le16||le32||le64||be16||be32||be64}(val, pointer) which is meant to replace code of the form: put_unaligned(cpu_to_le16(val), (__le16 *)p);  The headers that arches should include from their asm/unaligned.h:  access_ok.h : Wrappers of the byteswapping functions in asm/byteorder  Choose a particular implementation for little-endian access: le_byteshift.h le_memmove.h (arch must be LE) le_struct.h (arch must be LE)  Choose a particular implementation for big-endian access: be_byteshift.h be_memmove.h (arch must be BE) be_struct.h (arch must be BE)  After including as needed from the above, include unaligned/generic.h and define your arch's get/put_unaligned as (for LE):  Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com> Cc: <linux-arch@vger.kernel.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | be_memmove.h | s | 770B | 28 | Harvey Harrison | harvey.harrison@gmail.com | 1209481587 |  | kernel: add common infrastructure for unaligned access  Create a linux/unaligned directory similar in spirit to the linux/byteorder folder to hold generic implementations collected from various arches.  Currently there are five implementations: 1) packed_struct.h: C-struct based, from asm-generic/unaligned.h 2) le_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 3) be_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 4) memmove.h: taken from multiple implementations in tree 5) access_ok.h: taken from x86 and others, unaligned access is ok.  All of the new implementations checks for sizes not equal to 1,2,4,8 and will fail to link.  API additions:  get_unaligned_{le16||le32||le64||be16||be32||be64}(p) which is meant to replace code of the form: le16_to_cpu(get_unaligned((__le16 *)p));  put_unaligned_{le16||le32||le64||be16||be32||be64}(val, pointer) which is meant to replace code of the form: put_unaligned(cpu_to_le16(val), (__le16 *)p);  The headers that arches should include from their asm/unaligned.h:  access_ok.h : Wrappers of the byteswapping functions in asm/byteorder  Choose a particular implementation for little-endian access: le_byteshift.h le_memmove.h (arch must be LE) le_struct.h (arch must be LE)  Choose a particular implementation for big-endian access: be_byteshift.h be_memmove.h (arch must be BE) be_struct.h (arch must be BE)  After including as needed from the above, include unaligned/generic.h and define your arch's get/put_unaligned as (for LE):  Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com> Cc: <linux-arch@vger.kernel.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | access_ok.h | s | 1.3K | 53 | Harvey Harrison | harvey.harrison@gmail.com | 1209481587 |  | kernel: add common infrastructure for unaligned access  Create a linux/unaligned directory similar in spirit to the linux/byteorder folder to hold generic implementations collected from various arches.  Currently there are five implementations: 1) packed_struct.h: C-struct based, from asm-generic/unaligned.h 2) le_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 3) be_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 4) memmove.h: taken from multiple implementations in tree 5) access_ok.h: taken from x86 and others, unaligned access is ok.  All of the new implementations checks for sizes not equal to 1,2,4,8 and will fail to link.  API additions:  get_unaligned_{le16||le32||le64||be16||be32||be64}(p) which is meant to replace code of the form: le16_to_cpu(get_unaligned((__le16 *)p));  put_unaligned_{le16||le32||le64||be16||be32||be64}(val, pointer) which is meant to replace code of the form: put_unaligned(cpu_to_le16(val), (__le16 *)p);  The headers that arches should include from their asm/unaligned.h:  access_ok.h : Wrappers of the byteswapping functions in asm/byteorder  Choose a particular implementation for little-endian access: le_byteshift.h le_memmove.h (arch must be LE) le_struct.h (arch must be LE)  Choose a particular implementation for big-endian access: be_byteshift.h be_memmove.h (arch must be BE) be_struct.h (arch must be BE)  After including as needed from the above, include unaligned/generic.h and define your arch's get/put_unaligned as (for LE):  Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com> Cc: <linux-arch@vger.kernel.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | le_struct.h | s | 749B | 28 | Harvey Harrison | harvey.harrison@gmail.com | 1209481587 |  | kernel: add common infrastructure for unaligned access  Create a linux/unaligned directory similar in spirit to the linux/byteorder folder to hold generic implementations collected from various arches.  Currently there are five implementations: 1) packed_struct.h: C-struct based, from asm-generic/unaligned.h 2) le_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 3) be_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 4) memmove.h: taken from multiple implementations in tree 5) access_ok.h: taken from x86 and others, unaligned access is ok.  All of the new implementations checks for sizes not equal to 1,2,4,8 and will fail to link.  API additions:  get_unaligned_{le16||le32||le64||be16||be32||be64}(p) which is meant to replace code of the form: le16_to_cpu(get_unaligned((__le16 *)p));  put_unaligned_{le16||le32||le64||be16||be32||be64}(val, pointer) which is meant to replace code of the form: put_unaligned(cpu_to_le16(val), (__le16 *)p);  The headers that arches should include from their asm/unaligned.h:  access_ok.h : Wrappers of the byteswapping functions in asm/byteorder  Choose a particular implementation for little-endian access: le_byteshift.h le_memmove.h (arch must be LE) le_struct.h (arch must be LE)  Choose a particular implementation for big-endian access: be_byteshift.h be_memmove.h (arch must be BE) be_struct.h (arch must be BE)  After including as needed from the above, include unaligned/generic.h and define your arch's get/put_unaligned as (for LE):  Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com> Cc: <linux-arch@vger.kernel.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | generic.h | s | 2.1K | 62 | Harvey Harrison | harvey.harrison@gmail.com | 1209481587 |  | kernel: add common infrastructure for unaligned access  Create a linux/unaligned directory similar in spirit to the linux/byteorder folder to hold generic implementations collected from various arches.  Currently there are five implementations: 1) packed_struct.h: C-struct based, from asm-generic/unaligned.h 2) le_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 3) be_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 4) memmove.h: taken from multiple implementations in tree 5) access_ok.h: taken from x86 and others, unaligned access is ok.  All of the new implementations checks for sizes not equal to 1,2,4,8 and will fail to link.  API additions:  get_unaligned_{le16||le32||le64||be16||be32||be64}(p) which is meant to replace code of the form: le16_to_cpu(get_unaligned((__le16 *)p));  put_unaligned_{le16||le32||le64||be16||be32||be64}(val, pointer) which is meant to replace code of the form: put_unaligned(cpu_to_le16(val), (__le16 *)p);  The headers that arches should include from their asm/unaligned.h:  access_ok.h : Wrappers of the byteswapping functions in asm/byteorder  Choose a particular implementation for little-endian access: le_byteshift.h le_memmove.h (arch must be LE) le_struct.h (arch must be LE)  Choose a particular implementation for big-endian access: be_byteshift.h be_memmove.h (arch must be BE) be_struct.h (arch must be BE)  After including as needed from the above, include unaligned/generic.h and define your arch's get/put_unaligned as (for LE):  Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com> Cc: <linux-arch@vger.kernel.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | le_byteshift.h | s | 1.4K | 56 | Albin Tonnerre | albin.tonnerre@free-electrons.com | 1253802065 |  | include/linux/unaligned/{l,b}e_byteshift.h: fix usage for compressed kernels  When unaligned accesses are required for uncompressing a kernel (such as for LZO decompression on ARM in a patch that follows), including <linux/kernel.h> causes issues as it brings in a lot of things that are not available in the decompression environment.  linux/kernel.h brings at least: extern int console_printk[]; extern const char hex_asc[]; which causes errors at link-time as they are not available when compiling the pre-boot environement. There are also a few others:    arch/arm/boot/compressed/misc.o: In function `valid_user_regs':    arch/arm/include/asm/ptrace.h:158: undefined reference to `elf_hwcap'   arch/arm/boot/compressed/misc.o: In function `console_silent':    include/linux/kernel.h:292: undefined reference to `console_printk'   arch/arm/boot/compressed/misc.o: In function `console_verbose':    include/linux/kernel.h:297: undefined reference to `console_printk'   arch/arm/boot/compressed/misc.o: In function `pack_hex_byte':    include/linux/kernel.h:360: undefined reference to `hex_asc'   arch/arm/boot/compressed/misc.o: In function `hweight_long':    include/linux/bitops.h:45: undefined reference to `hweight32'   arch/arm/boot/compressed/misc.o: In function `__cmpxchg_local_generic':    include/asm-generic/cmpxchg-local.h:21: undefined reference to `wrong_size_cmpxchg'    include/asm-generic/cmpxchg-local.h:42: undefined reference to `wrong_size_cmpxchg'   arch/arm/boot/compressed/misc.o: In function `__xchg':    arch/arm/include/asm/system.h:309: undefined reference to `__bad_xchg'  However, those files apparently use nothing from <linux/kernel.h>, all they need is the declaration of types such as u32 or u64, so <linux/types.h> should be enough  Signed-off-by: Albin Tonnerre <albin.tonnerre@free-electrons.com> Cc: Sam Ravnborg <sam@ravnborg.org> Cc: Russell King <rmk@arm.linux.org.uk> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: "H. Peter Anvin" <hpa@zytor.com> Cc: Phillip Lougher <phillip@lougher.demon.co.uk> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | le_memmove.h | s | 770B | 28 | Harvey Harrison | harvey.harrison@gmail.com | 1209481587 |  | kernel: add common infrastructure for unaligned access  Create a linux/unaligned directory similar in spirit to the linux/byteorder folder to hold generic implementations collected from various arches.  Currently there are five implementations: 1) packed_struct.h: C-struct based, from asm-generic/unaligned.h 2) le_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 3) be_byteshift.h: Open coded byte-swapping, heavily based on asm-arm 4) memmove.h: taken from multiple implementations in tree 5) access_ok.h: taken from x86 and others, unaligned access is ok.  All of the new implementations checks for sizes not equal to 1,2,4,8 and will fail to link.  API additions:  get_unaligned_{le16||le32||le64||be16||be32||be64}(p) which is meant to replace code of the form: le16_to_cpu(get_unaligned((__le16 *)p));  put_unaligned_{le16||le32||le64||be16||be32||be64}(val, pointer) which is meant to replace code of the form: put_unaligned(cpu_to_le16(val), (__le16 *)p);  The headers that arches should include from their asm/unaligned.h:  access_ok.h : Wrappers of the byteswapping functions in asm/byteorder  Choose a particular implementation for little-endian access: le_byteshift.h le_memmove.h (arch must be LE) le_struct.h (arch must be LE)  Choose a particular implementation for big-endian access: be_byteshift.h be_memmove.h (arch must be BE) be_struct.h (arch must be BE)  After including as needed from the above, include unaligned/generic.h and define your arch's get/put_unaligned as (for LE):  Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com> Cc: <linux-arch@vger.kernel.org> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
