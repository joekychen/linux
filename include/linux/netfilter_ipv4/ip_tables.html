<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › netfilter_ipv4 › ip_tables.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ip_tables.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * 25-Jul-1998 Major changes to allow for ip chain table</span>
<span class="cm"> *</span>
<span class="cm"> * 3-Jan-2000 Named tables to allow packet selection for different uses.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * 	Format of an IP firewall descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * 	src, dst, src_mask, dst_mask are always stored in network byte order.</span>
<span class="cm"> * 	flags are stored in host byte order (of course).</span>
<span class="cm"> * 	Port numbers are stored in HOST byte order.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _IPTABLES_H</span>
<span class="cp">#define _IPTABLES_H</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_ipv4.h&gt;</span>

<span class="cp">#include &lt;linux/netfilter/x_tables.h&gt;</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="cp">#define IPT_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN</span>
<span class="cp">#define IPT_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN</span>
<span class="cp">#define ipt_match xt_match</span>
<span class="cp">#define ipt_target xt_target</span>
<span class="cp">#define ipt_table xt_table</span>
<span class="cp">#define ipt_get_revision xt_get_revision</span>
<span class="cp">#define ipt_entry_match xt_entry_match</span>
<span class="cp">#define ipt_entry_target xt_entry_target</span>
<span class="cp">#define ipt_standard_target xt_standard_target</span>
<span class="cp">#define ipt_error_target xt_error_target</span>
<span class="cp">#define ipt_counters xt_counters</span>
<span class="cp">#define IPT_CONTINUE XT_CONTINUE</span>
<span class="cp">#define IPT_RETURN XT_RETURN</span>

<span class="cm">/* This group is older than old (iptables &lt; v1.4.0-rc1~89) */</span>
<span class="cp">#include &lt;linux/netfilter/xt_tcpudp.h&gt;</span>
<span class="cp">#define ipt_udp xt_udp</span>
<span class="cp">#define ipt_tcp xt_tcp</span>
<span class="cp">#define IPT_TCP_INV_SRCPT	XT_TCP_INV_SRCPT</span>
<span class="cp">#define IPT_TCP_INV_DSTPT	XT_TCP_INV_DSTPT</span>
<span class="cp">#define IPT_TCP_INV_FLAGS	XT_TCP_INV_FLAGS</span>
<span class="cp">#define IPT_TCP_INV_OPTION	XT_TCP_INV_OPTION</span>
<span class="cp">#define IPT_TCP_INV_MASK	XT_TCP_INV_MASK</span>
<span class="cp">#define IPT_UDP_INV_SRCPT	XT_UDP_INV_SRCPT</span>
<span class="cp">#define IPT_UDP_INV_DSTPT	XT_UDP_INV_DSTPT</span>
<span class="cp">#define IPT_UDP_INV_MASK	XT_UDP_INV_MASK</span>

<span class="cm">/* The argument to IPT_SO_ADD_COUNTERS. */</span>
<span class="cp">#define ipt_counters_info xt_counters_info</span>
<span class="cm">/* Standard return verdict, or do jump. */</span>
<span class="cp">#define IPT_STANDARD_TARGET XT_STANDARD_TARGET</span>
<span class="cm">/* Error verdict. */</span>
<span class="cp">#define IPT_ERROR_TARGET XT_ERROR_TARGET</span>

<span class="cm">/* fn returns 0 to continue iteration */</span>
<span class="cp">#define IPT_MATCH_ITERATE(e, fn, args...) \</span>
<span class="cp">	XT_MATCH_ITERATE(struct ipt_entry, e, fn, ## args)</span>

<span class="cm">/* fn returns 0 to continue iteration */</span>
<span class="cp">#define IPT_ENTRY_ITERATE(entries, size, fn, args...) \</span>
<span class="cp">	XT_ENTRY_ITERATE(struct ipt_entry, entries, size, fn, ## args)</span>
<span class="cp">#endif</span>

<span class="cm">/* Yes, Virginia, you have to zero the padding. */</span>
<span class="k">struct</span> <span class="n">ipt_ip</span> <span class="p">{</span>
	<span class="cm">/* Source and destination IP addr */</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">;</span>
	<span class="cm">/* Mask for src and dest IP addr */</span>
	<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">smsk</span><span class="p">,</span> <span class="n">dmsk</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">iniface</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">],</span> <span class="n">outiface</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">iniface_mask</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">],</span> <span class="n">outiface_mask</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>

	<span class="cm">/* Protocol, 0 = ANY */</span>
	<span class="n">__u16</span> <span class="n">proto</span><span class="p">;</span>

	<span class="cm">/* Flags word */</span>
	<span class="n">__u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* Inverse flags */</span>
	<span class="n">__u8</span> <span class="n">invflags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Values for &quot;flag&quot; field in struct ipt_ip (general ip structure). */</span>
<span class="cp">#define IPT_F_FRAG		0x01	</span><span class="cm">/* Set if rule is a fragment rule */</span><span class="cp"></span>
<span class="cp">#define IPT_F_GOTO		0x02	</span><span class="cm">/* Set if jump is a goto */</span><span class="cp"></span>
<span class="cp">#define IPT_F_MASK		0x03	</span><span class="cm">/* All possible flag bits mask. */</span><span class="cp"></span>

<span class="cm">/* Values for &quot;inv&quot; field in struct ipt_ip. */</span>
<span class="cp">#define IPT_INV_VIA_IN		0x01	</span><span class="cm">/* Invert the sense of IN IFACE. */</span><span class="cp"></span>
<span class="cp">#define IPT_INV_VIA_OUT		0x02	</span><span class="cm">/* Invert the sense of OUT IFACE */</span><span class="cp"></span>
<span class="cp">#define IPT_INV_TOS		0x04	</span><span class="cm">/* Invert the sense of TOS. */</span><span class="cp"></span>
<span class="cp">#define IPT_INV_SRCIP		0x08	</span><span class="cm">/* Invert the sense of SRC IP. */</span><span class="cp"></span>
<span class="cp">#define IPT_INV_DSTIP		0x10	</span><span class="cm">/* Invert the sense of DST OP. */</span><span class="cp"></span>
<span class="cp">#define IPT_INV_FRAG		0x20	</span><span class="cm">/* Invert the sense of FRAG. */</span><span class="cp"></span>
<span class="cp">#define IPT_INV_PROTO		XT_INV_PROTO</span>
<span class="cp">#define IPT_INV_MASK		0x7F	</span><span class="cm">/* All possible flag bits mask. */</span><span class="cp"></span>

<span class="cm">/* This structure defines each of the firewall rules.  Consists of 3</span>
<span class="cm">   parts which are 1) general IP header stuff 2) match specific</span>
<span class="cm">   stuff 3) the target to perform if the rule matches */</span>
<span class="k">struct</span> <span class="n">ipt_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipt_ip</span> <span class="n">ip</span><span class="p">;</span>

	<span class="cm">/* Mark with fields that we care about. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfcache</span><span class="p">;</span>

	<span class="cm">/* Size of ipt_entry + matches */</span>
	<span class="n">__u16</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="cm">/* Size of ipt_entry + matches + target */</span>
	<span class="n">__u16</span> <span class="n">next_offset</span><span class="p">;</span>

	<span class="cm">/* Back pointer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comefrom</span><span class="p">;</span>

	<span class="cm">/* Packet and byte counters. */</span>
	<span class="k">struct</span> <span class="n">xt_counters</span> <span class="n">counters</span><span class="p">;</span>

	<span class="cm">/* The matches (if any), then the target. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * New IP firewall options for [gs]etsockopt at the RAW IP level.</span>
<span class="cm"> * Unlike BSD Linux inherits IP options so you don&#39;t have to use a raw</span>
<span class="cm"> * socket for this. Instead we check rights in the calls.</span>
<span class="cm"> *</span>
<span class="cm"> * ATTENTION: check linux/in.h before adding new number here.</span>
<span class="cm"> */</span>
<span class="cp">#define IPT_BASE_CTL		64</span>

<span class="cp">#define IPT_SO_SET_REPLACE	(IPT_BASE_CTL)</span>
<span class="cp">#define IPT_SO_SET_ADD_COUNTERS	(IPT_BASE_CTL + 1)</span>
<span class="cp">#define IPT_SO_SET_MAX		IPT_SO_SET_ADD_COUNTERS</span>

<span class="cp">#define IPT_SO_GET_INFO			(IPT_BASE_CTL)</span>
<span class="cp">#define IPT_SO_GET_ENTRIES		(IPT_BASE_CTL + 1)</span>
<span class="cp">#define IPT_SO_GET_REVISION_MATCH	(IPT_BASE_CTL + 2)</span>
<span class="cp">#define IPT_SO_GET_REVISION_TARGET	(IPT_BASE_CTL + 3)</span>
<span class="cp">#define IPT_SO_GET_MAX			IPT_SO_GET_REVISION_TARGET</span>

<span class="cm">/* ICMP matching stuff */</span>
<span class="k">struct</span> <span class="n">ipt_icmp</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="n">type</span><span class="p">;</span>				<span class="cm">/* type to match */</span>
	<span class="n">__u8</span> <span class="n">code</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>				<span class="cm">/* range of code */</span>
	<span class="n">__u8</span> <span class="n">invflags</span><span class="p">;</span>				<span class="cm">/* Inverse flags */</span>
<span class="p">};</span>

<span class="cm">/* Values for &quot;inv&quot; field for struct ipt_icmp. */</span>
<span class="cp">#define IPT_ICMP_INV	0x01	</span><span class="cm">/* Invert the sense of type/code test */</span><span class="cp"></span>

<span class="cm">/* The argument to IPT_SO_GET_INFO */</span>
<span class="k">struct</span> <span class="n">ipt_getinfo</span> <span class="p">{</span>
	<span class="cm">/* Which table: caller fills this in. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* Kernel fills these in. */</span>
	<span class="cm">/* Which hook entry points are valid: bitmask */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>

	<span class="cm">/* Hook entry points: one per netfilter hook. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_INET_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Underflow points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">underflow</span><span class="p">[</span><span class="n">NF_INET_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Number of entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>

	<span class="cm">/* Size of entries. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The argument to IPT_SO_SET_REPLACE. */</span>
<span class="k">struct</span> <span class="n">ipt_replace</span> <span class="p">{</span>
	<span class="cm">/* Which table. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* Which hook entry points are valid: bitmask.  You can&#39;t</span>
<span class="cm">           change this. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>

	<span class="cm">/* Number of entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>

	<span class="cm">/* Total size of new entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Hook entry points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_INET_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Underflow points. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">underflow</span><span class="p">[</span><span class="n">NF_INET_NUMHOOKS</span><span class="p">];</span>

	<span class="cm">/* Information about old entries: */</span>
	<span class="cm">/* Number of counters (must be equal to current number of entries). */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="p">;</span>
	<span class="cm">/* The old entries&#39; counters. */</span>
	<span class="k">struct</span> <span class="n">xt_counters</span> <span class="n">__user</span> <span class="o">*</span><span class="n">counters</span><span class="p">;</span>

	<span class="cm">/* The entries (hang off end: not really an array). */</span>
	<span class="k">struct</span> <span class="n">ipt_entry</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* The argument to IPT_SO_GET_ENTRIES. */</span>
<span class="k">struct</span> <span class="n">ipt_get_entries</span> <span class="p">{</span>
	<span class="cm">/* Which table: user fills this in. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">XT_TABLE_MAXNAMELEN</span><span class="p">];</span>

	<span class="cm">/* User fills this in: total entry size. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* The entries. */</span>
	<span class="k">struct</span> <span class="n">ipt_entry</span> <span class="n">entrytable</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Helper functions */</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="k">struct</span> <span class="n">xt_entry_target</span> <span class="o">*</span>
<span class="nf">ipt_get_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Main firewall chains definitions and global var&#39;s definitions.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ipt_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__init</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">ipt_register_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">ipt_replace</span> <span class="o">*</span><span class="n">repl</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ipt_unregister_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>

<span class="cm">/* Standard entry. */</span>
<span class="k">struct</span> <span class="n">ipt_standard</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipt_entry</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_standard_target</span> <span class="n">target</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipt_error</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipt_entry</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xt_error_target</span> <span class="n">target</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define IPT_ENTRY_INIT(__size)						       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.target_offset	= sizeof(struct ipt_entry),			       \</span>
<span class="cp">	.next_offset	= (__size),					       \</span>
<span class="cp">}</span>

<span class="cp">#define IPT_STANDARD_INIT(__verdict)					       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.entry		= IPT_ENTRY_INIT(sizeof(struct ipt_standard)),	       \</span>
<span class="cp">	.target		= XT_TARGET_INIT(XT_STANDARD_TARGET,		       \</span>
<span class="cp">					 sizeof(struct xt_standard_target)),   \</span>
<span class="cp">	.target.verdict	= -(__verdict) - 1,				       \</span>
<span class="cp">}</span>

<span class="cp">#define IPT_ERROR_INIT							       \</span>
<span class="cp">{									       \</span>
<span class="cp">	.entry		= IPT_ENTRY_INIT(sizeof(struct ipt_error)),	       \</span>
<span class="cp">	.target		= XT_TARGET_INIT(XT_ERROR_TARGET,		       \</span>
<span class="cp">					 sizeof(struct xt_error_target)),      \</span>
<span class="cp">	.target.errorname = &quot;ERROR&quot;,					       \</span>
<span class="cp">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ipt_alloc_initial_table</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ipt_do_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">xt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="cp">#include &lt;net/compat.h&gt;</span>

<span class="k">struct</span> <span class="n">compat_ipt_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipt_ip</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">nfcache</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">next_offset</span><span class="p">;</span>
	<span class="n">compat_uint_t</span> <span class="n">comefrom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_xt_counters</span> <span class="n">counters</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Helper functions */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">xt_entry_target</span> <span class="o">*</span>
<span class="nf">compat_ipt_get_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ipt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">target_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_COMPAT */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/*__KERNEL__*/</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _IPTABLES_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
