<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › etherdevice.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>etherdevice.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  NET  is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Definitions for the Ethernet handlers.</span>
<span class="cm"> *</span>
<span class="cm"> * Version:	@(#)eth.h	1.0.4	05/13/93</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *		Relocated to include/linux where it belongs by Alan Cox </span>
<span class="cm"> *							&lt;gw4pts@gw4pts.ampr.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _LINUX_ETHERDEVICE_H</span>
<span class="cp">#define _LINUX_ETHERDEVICE_H</span>

<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="k">extern</span> <span class="n">__be16</span>		<span class="n">eth_type_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">header_ops</span> <span class="n">eth_header_ops</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">eth_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">eth_rebuild_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">eth_header_parse</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">haddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">eth_header_cache</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hh_cache</span> <span class="o">*</span><span class="n">hh</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">eth_header_cache_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">hh_cache</span> <span class="o">*</span><span class="n">hh</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">haddr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">eth_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">eth_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">eth_validate_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>



<span class="k">extern</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">alloc_etherdev_mqs</span><span class="p">(</span><span class="kt">int</span> <span class="n">sizeof_priv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txqs</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxqs</span><span class="p">);</span>
<span class="cp">#define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)</span>
<span class="cp">#define alloc_etherdev_mq(sizeof_priv, count) alloc_etherdev_mqs(sizeof_priv, count, count)</span>

<span class="cm">/**</span>
<span class="cm"> * is_zero_ether_addr - Determine if give Ethernet address is all zeros.</span>
<span class="cm"> * @addr: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the address is all zeroes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_zero_ether_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_multicast_ether_addr - Determine if the Ethernet address is a multicast.</span>
<span class="cm"> * @addr: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the address is a multicast address.</span>
<span class="cm"> * By definition the broadcast address is also a multicast address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_multicast_ether_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mh">0x01</span> <span class="o">&amp;</span> <span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_local_ether_addr - Determine if the Ethernet address is locally-assigned one (IEEE 802).</span>
<span class="cm"> * @addr: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the address is a local address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_local_ether_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mh">0x02</span> <span class="o">&amp;</span> <span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_broadcast_ether_addr - Determine if the Ethernet address is broadcast</span>
<span class="cm"> * @addr: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the address is the broadcast address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_broadcast_ether_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_unicast_ether_addr - Determine if the Ethernet address is unicast</span>
<span class="cm"> * @addr: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the address is a unicast address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_unicast_ether_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_valid_ether_addr - Determine if the given Ethernet address is valid</span>
<span class="cm"> * @addr: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not</span>
<span class="cm"> * a multicast address, and is not FF:FF:FF:FF:FF:FF.</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the address is valid.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_valid_ether_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FF:FF:FF:FF:FF:FF is a multicast address so we don&#39;t need to</span>
<span class="cm">	 * explicitly check for it here. */</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * random_ether_addr - Generate software assigned random Ethernet address</span>
<span class="cm"> * @addr: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Generate a random Ethernet address (MAC) that is not multicast</span>
<span class="cm"> * and has the local assigned bit set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">random_ether_addr</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_random_bytes</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">addr</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0xfe</span><span class="p">;</span>	<span class="cm">/* clear multicast bit */</span>
	<span class="n">addr</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x02</span><span class="p">;</span>	<span class="cm">/* set local assignment bit (IEEE802) */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * eth_hw_addr_random - Generate software assigned random Ethernet and</span>
<span class="cm"> * set device flag</span>
<span class="cm"> * @dev: pointer to net_device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Generate a random Ethernet address (MAC) to be used by a net device</span>
<span class="cm"> * and set addr_assign_type so the state can be read by sysfs and be</span>
<span class="cm"> * used by userspace.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">eth_hw_addr_random</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_assign_type</span> <span class="o">|=</span> <span class="n">NET_ADDR_RANDOM</span><span class="p">;</span>
	<span class="n">random_ether_addr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * compare_ether_addr - Compare two Ethernet addresses</span>
<span class="cm"> * @addr1: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> * @addr2: Pointer other six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Compare two Ethernet addresses, returns 0 if equal, non-zero otherwise.</span>
<span class="cm"> * Unlike memcmp(), it doesn&#39;t return a value suitable for sorting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">compare_ether_addr</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr1</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr2</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">ETH_ALEN</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ether_addr_equal - Compare two Ethernet addresses</span>
<span class="cm"> * @addr1: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> * @addr2: Pointer other six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Compare two Ethernet addresses, returns true if equal</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ether_addr_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr1</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">compare_ether_addr</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span> <span class="n">addr2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">zap_last_2bytes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
	<span class="k">return</span> <span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ether_addr_equal_64bits - Compare two Ethernet addresses</span>
<span class="cm"> * @addr1: Pointer to an array of 8 bytes</span>
<span class="cm"> * @addr2: Pointer to an other array of 8 bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Compare two Ethernet addresses, returns true if equal, false otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * The function doesn&#39;t need any conditional branches and possibly uses</span>
<span class="cm"> * word memory accesses on CPU allowing cheap unaligned memory reads.</span>
<span class="cm"> * arrays = { byte1, byte2, byte3, byte4, byte5, byte6, pad1, pad2 }</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that alignment of addr1 &amp; addr2 are only guaranteed to be 16 bits.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ether_addr_equal_64bits</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="n">addr1</span><span class="p">[</span><span class="mi">6</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span>
					   <span class="k">const</span> <span class="n">u8</span> <span class="n">addr2</span><span class="p">[</span><span class="mi">6</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fold</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">addr1</span><span class="p">)</span> <span class="o">^</span>
			      <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">addr2</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">zap_last_2bytes</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fold</span> <span class="o">|=</span> <span class="n">zap_last_2bytes</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="o">^</span>
				<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr2</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)));</span>
	<span class="k">return</span> <span class="n">fold</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span> <span class="n">addr2</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_etherdev_addr - Tell if given Ethernet address belongs to the device.</span>
<span class="cm"> * @dev: Pointer to a device structure</span>
<span class="cm"> * @addr: Pointer to a six-byte array containing the Ethernet address</span>
<span class="cm"> *</span>
<span class="cm"> * Compare passed address with all addresses of the device. Return true if the</span>
<span class="cm"> * address if one of the device addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function calls ether_addr_equal_64bits() so take care of</span>
<span class="cm"> * the right padding.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_etherdev_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">res</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_dev_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ha</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * compare_ether_header - Compare two Ethernet headers</span>
<span class="cm"> * @a: Pointer to Ethernet header</span>
<span class="cm"> * @b: Pointer to Ethernet header</span>
<span class="cm"> *</span>
<span class="cm"> * Compare two Ethernet headers, returns 0 if equal.</span>
<span class="cm"> * This assumes that the network header (i.e., IP header) is 4-byte</span>
<span class="cm"> * aligned OR the platform can handle unaligned access.  This is the</span>
<span class="cm"> * case for all packets coming into netif_receive_skb or similar</span>
<span class="cm"> * entry points.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">compare_ether_header</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &amp;&amp; BITS_PER_LONG == 64</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fold</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want to compare 14 bytes:</span>
<span class="cm">	 *  [a0 ... a13] ^ [b0 ... b13]</span>
<span class="cm">	 * Use two long XOR, ORed together, with an overlap of two bytes.</span>
<span class="cm">	 *  [a0  a1  a2  a3  a4  a5  a6  a7 ] ^ [b0  b1  b2  b3  b4  b5  b6  b7 ] |</span>
<span class="cm">	 *  [a6  a7  a8  a9  a10 a11 a12 a13] ^ [b6  b7  b8  b9  b10 b11 b12 b13]</span>
<span class="cm">	 * This means the [a6 a7] ^ [b6 b7] part is done two times.</span>
<span class="cm">	*/</span>
	<span class="n">fold</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">^</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
	<span class="n">fold</span> <span class="o">|=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="o">^</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fold</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">a32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">b32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">^</span> <span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">b32</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span>
	       <span class="p">(</span><span class="n">a32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">b32</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">a32</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^</span> <span class="n">b32</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* _LINUX_ETHERDEVICE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
