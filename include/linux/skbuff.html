<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › skbuff.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>skbuff.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Definitions for the &#39;struct sk_buff&#39; memory handlers.</span>
<span class="cm"> *</span>
<span class="cm"> *	Authors:</span>
<span class="cm"> *		Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;</span>
<span class="cm"> *		Florian La Roche, &lt;rzsfl@rz.uni-sb.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_SKBUFF_H</span>
<span class="cp">#define _LINUX_SKBUFF_H</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kmemcheck.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/textsearch.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/dmaengine.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/netdev_features.h&gt;</span>

<span class="cm">/* Don&#39;t change this without changing skb_csum_unnecessary! */</span>
<span class="cp">#define CHECKSUM_NONE 0</span>
<span class="cp">#define CHECKSUM_UNNECESSARY 1</span>
<span class="cp">#define CHECKSUM_COMPLETE 2</span>
<span class="cp">#define CHECKSUM_PARTIAL 3</span>

<span class="cp">#define SKB_DATA_ALIGN(X)	(((X) + (SMP_CACHE_BYTES - 1)) &amp; \</span>
<span class="cp">				 ~(SMP_CACHE_BYTES - 1))</span>
<span class="cp">#define SKB_WITH_OVERHEAD(X)	\</span>
<span class="cp">	((X) - SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))</span>
<span class="cp">#define SKB_MAX_ORDER(X, ORDER) \</span>
<span class="cp">	SKB_WITH_OVERHEAD((PAGE_SIZE &lt;&lt; (ORDER)) - (X))</span>
<span class="cp">#define SKB_MAX_HEAD(X)		(SKB_MAX_ORDER((X), 0))</span>
<span class="cp">#define SKB_MAX_ALLOC		(SKB_MAX_ORDER(0, 2))</span>

<span class="cm">/* return minimum truesize of one skb containing X bytes of data */</span>
<span class="cp">#define SKB_TRUESIZE(X) ((X) +						\</span>
<span class="cp">			 SKB_DATA_ALIGN(sizeof(struct sk_buff)) +	\</span>
<span class="cp">			 SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))</span>

<span class="cm">/* A. Checksumming of received packets by device.</span>
<span class="cm"> *</span>
<span class="cm"> *	NONE: device failed to checksum this packet.</span>
<span class="cm"> *		skb-&gt;csum is undefined.</span>
<span class="cm"> *</span>
<span class="cm"> *	UNNECESSARY: device parsed packet and wouldbe verified checksum.</span>
<span class="cm"> *		skb-&gt;csum is undefined.</span>
<span class="cm"> *	      It is bad option, but, unfortunately, many of vendors do this.</span>
<span class="cm"> *	      Apparently with secret goal to sell you new device, when you</span>
<span class="cm"> *	      will add new protocol to your host. F.e. IPv6. 8)</span>
<span class="cm"> *</span>
<span class="cm"> *	COMPLETE: the most generic way. Device supplied checksum of _all_</span>
<span class="cm"> *	    the packet as seen by netif_rx in skb-&gt;csum.</span>
<span class="cm"> *	    NOTE: Even if device supports only some protocols, but</span>
<span class="cm"> *	    is able to produce some skb-&gt;csum, it MUST use COMPLETE,</span>
<span class="cm"> *	    not UNNECESSARY.</span>
<span class="cm"> *</span>
<span class="cm"> *	PARTIAL: identical to the case for output below.  This may occur</span>
<span class="cm"> *	    on a packet received directly from another Linux OS, e.g.,</span>
<span class="cm"> *	    a virtualised Linux kernel on the same host.  The packet can</span>
<span class="cm"> *	    be treated in the same way as UNNECESSARY except that on</span>
<span class="cm"> *	    output (i.e., forwarding) the checksum must be filled in</span>
<span class="cm"> *	    by the OS or the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * B. Checksumming on output.</span>
<span class="cm"> *</span>
<span class="cm"> *	NONE: skb is checksummed by protocol or csum is not required.</span>
<span class="cm"> *</span>
<span class="cm"> *	PARTIAL: device is required to csum packet as seen by hard_start_xmit</span>
<span class="cm"> *	from skb-&gt;csum_start to the end and to record the checksum</span>
<span class="cm"> *	at skb-&gt;csum_start + skb-&gt;csum_offset.</span>
<span class="cm"> *</span>
<span class="cm"> *	Device must show its capabilities in dev-&gt;features, set</span>
<span class="cm"> *	at device setup time.</span>
<span class="cm"> *	NETIF_F_HW_CSUM	- it is clever device, it is able to checksum</span>
<span class="cm"> *			  everything.</span>
<span class="cm"> *	NETIF_F_IP_CSUM - device is dumb. It is able to csum only</span>
<span class="cm"> *			  TCP/UDP over IPv4. Sigh. Vendors like this</span>
<span class="cm"> *			  way by an unknown reason. Though, see comment above</span>
<span class="cm"> *			  about CHECKSUM_UNNECESSARY. 8)</span>
<span class="cm"> *	NETIF_F_IPV6_CSUM about as dumb as the last one but does IPv6 instead.</span>
<span class="cm"> *</span>
<span class="cm"> *	UNNECESSARY: device will do per protocol specific csum. Protocol drivers</span>
<span class="cm"> *	that do not want net to perform the checksum calculation should use</span>
<span class="cm"> *	this flag in their outgoing skbs.</span>
<span class="cm"> *	NETIF_F_FCOE_CRC  this indicates the device can do FCoE FC CRC</span>
<span class="cm"> *			  offload. Correspondingly, the FCoE protocol driver</span>
<span class="cm"> *			  stack should use CHECKSUM_UNNECESSARY.</span>
<span class="cm"> *</span>
<span class="cm"> *	Any questions? No questions, good. 		--ANK</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scatterlist</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pipe_inode_info</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
<span class="k">struct</span> <span class="n">nf_conntrack</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">use</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_BRIDGE_NETFILTER</span>
<span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="p">{</span>
	<span class="n">atomic_t</span>		<span class="n">use</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">physindev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">physoutdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">data</span><span class="p">[</span><span class="mi">32</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)];</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="p">{</span>
	<span class="cm">/* These two members must be first. */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">__u32</span>		<span class="n">qlen</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	<span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sk_buff</span><span class="p">;</span>

<span class="cm">/* To allow 64K frame to be packed as single skb without frag_list we</span>
<span class="cm"> * require 64K/PAGE_SIZE pages plus 1 additional page to allow for</span>
<span class="cm"> * buffers which do not start on a page boundary.</span>
<span class="cm"> *</span>
<span class="cm"> * Since GRO uses frags we allocate at least 16 regardless of page</span>
<span class="cm"> * size.</span>
<span class="cm"> */</span>
<span class="cp">#if (65536/PAGE_SIZE + 1) &lt; 16</span>
<span class="cp">#define MAX_SKB_FRAGS 16UL</span>
<span class="cp">#else</span>
<span class="cp">#define MAX_SKB_FRAGS (65536/PAGE_SIZE + 1)</span>
<span class="cp">#endif</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="n">skb_frag_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">page</span><span class="p">;</span>
<span class="cp">#if (BITS_PER_LONG &gt; 32) || (PAGE_SIZE &gt;= 65536)</span>
	<span class="n">__u32</span> <span class="n">page_offset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">size</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">__u16</span> <span class="n">page_offset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">size</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_frag_size</span><span class="p">(</span><span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_frag_size_set</span><span class="p">(</span><span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_frag_size_add</span><span class="p">(</span><span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_frag_size_sub</span><span class="p">(</span><span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define HAVE_HW_TIME_STAMP</span>

<span class="cm">/**</span>
<span class="cm"> * struct skb_shared_hwtstamps - hardware time stamps</span>
<span class="cm"> * @hwtstamp:	hardware time stamp transformed into duration</span>
<span class="cm"> *		since arbitrary point in time</span>
<span class="cm"> * @syststamp:	hwtstamp transformed to system time base</span>
<span class="cm"> *</span>
<span class="cm"> * Software time stamps generated by ktime_get_real() are stored in</span>
<span class="cm"> * skb-&gt;tstamp. The relation between the different kinds of time</span>
<span class="cm"> * stamps is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * syststamp and tstamp can be compared against each other in</span>
<span class="cm"> * arbitrary combinations.  The accuracy of a</span>
<span class="cm"> * syststamp/tstamp/&quot;syststamp from other device&quot; comparison is</span>
<span class="cm"> * limited by the accuracy of the transformation into system time</span>
<span class="cm"> * base. This depends on the device driver and its underlying</span>
<span class="cm"> * hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * hwtstamps can only be compared against other hwtstamps from</span>
<span class="cm"> * the same device.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is attached to packets as part of the</span>
<span class="cm"> * &amp;skb_shared_info. Use skb_hwtstamps() to get a pointer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="p">{</span>
	<span class="n">ktime_t</span>	<span class="n">hwtstamp</span><span class="p">;</span>
	<span class="n">ktime_t</span>	<span class="n">syststamp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Definitions for tx_flags in struct skb_shared_info */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* generate hardware time stamp */</span>
	<span class="n">SKBTX_HW_TSTAMP</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>

	<span class="cm">/* generate software time stamp */</span>
	<span class="n">SKBTX_SW_TSTAMP</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* device driver is going to provide hardware time stamp */</span>
	<span class="n">SKBTX_IN_PROGRESS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/* device driver supports TX zero-copy buffers */</span>
	<span class="n">SKBTX_DEV_ZEROCOPY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>

	<span class="cm">/* generate wifi status information (where possible) */</span>
	<span class="n">SKBTX_WIFI_STATUS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The callback notifies userspace to release buffers when skb DMA is done in</span>
<span class="cm"> * lower device, the skb last reference should be 0 when calling this.</span>
<span class="cm"> * The ctx field is used to track device context.</span>
<span class="cm"> * The desc field is used to track userspace buffer index.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubuf_info</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ubuf_info</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">desc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This data is invariant across clones and lives at</span>
<span class="cm"> * the end of the header data, ie. at skb-&gt;end.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">nr_frags</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="n">tx_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">gso_size</span><span class="p">;</span>
	<span class="cm">/* Warning: this field is not always filled in (UFO)! */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">gso_segs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">gso_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">frag_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="n">hwtstamps</span><span class="p">;</span>
	<span class="n">__be32</span>          <span class="n">ip6_frag_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Warning : all fields before dataref are cleared in __alloc_skb()</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span>	<span class="n">dataref</span><span class="p">;</span>

	<span class="cm">/* Intermediate layers must ensure that destructor_arg</span>
<span class="cm">	 * remains valid until skb destructor */</span>
	<span class="kt">void</span> <span class="o">*</span>		<span class="n">destructor_arg</span><span class="p">;</span>

	<span class="cm">/* must be last field, see pskb_expand_head() */</span>
	<span class="n">skb_frag_t</span>	<span class="n">frags</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* We divide dataref into two halves.  The higher 16 bits hold references</span>
<span class="cm"> * to the payload part of skb-&gt;data.  The lower 16 bits hold references to</span>
<span class="cm"> * the entire skb-&gt;data.  A clone of a headerless skb holds the length of</span>
<span class="cm"> * the header in skb-&gt;hdr_len.</span>
<span class="cm"> *</span>
<span class="cm"> * All users must obey the rule that the skb-&gt;data reference count must be</span>
<span class="cm"> * greater than or equal to the payload reference count.</span>
<span class="cm"> *</span>
<span class="cm"> * Holding a reference to the payload part means that the user does not</span>
<span class="cm"> * care about modifications to the header part of skb-&gt;data.</span>
<span class="cm"> */</span>
<span class="cp">#define SKB_DATAREF_SHIFT 16</span>
<span class="cp">#define SKB_DATAREF_MASK ((1 &lt;&lt; SKB_DATAREF_SHIFT) - 1)</span>


<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SKB_FCLONE_UNAVAILABLE</span><span class="p">,</span>
	<span class="n">SKB_FCLONE_ORIG</span><span class="p">,</span>
	<span class="n">SKB_FCLONE_CLONE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SKB_GSO_TCPV4</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SKB_GSO_UDP</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* This indicates the skb is from an untrusted source. */</span>
	<span class="n">SKB_GSO_DODGY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>

	<span class="cm">/* This indicates the tcp segment has CWR set. */</span>
	<span class="n">SKB_GSO_TCP_ECN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">SKB_GSO_TCPV6</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>

	<span class="n">SKB_GSO_FCOE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#if BITS_PER_LONG &gt; 32</span>
<span class="cp">#define NET_SKBUFF_DATA_USES_OFFSET 1</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef NET_SKBUFF_DATA_USES_OFFSET</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sk_buff_data_t</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sk_buff_data_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_NF_DEFRAG_IPV4) || defined(CONFIG_NF_DEFRAG_IPV4_MODULE) || \</span>
<span class="cp">    defined(CONFIG_NF_DEFRAG_IPV6) || defined(CONFIG_NF_DEFRAG_IPV6_MODULE)</span>
<span class="cp">#define NET_SKBUFF_NF_DEFRAG_NEEDED 1</span>
<span class="cp">#endif</span>

<span class="cm">/** </span>
<span class="cm"> *	struct sk_buff - socket buffer</span>
<span class="cm"> *	@next: Next buffer in list</span>
<span class="cm"> *	@prev: Previous buffer in list</span>
<span class="cm"> *	@tstamp: Time we arrived</span>
<span class="cm"> *	@sk: Socket we are owned by</span>
<span class="cm"> *	@dev: Device we arrived on/are leaving by</span>
<span class="cm"> *	@cb: Control buffer. Free for use by every layer. Put private vars here</span>
<span class="cm"> *	@_skb_refdst: destination entry (with norefcount bit)</span>
<span class="cm"> *	@sp: the security path, used for xfrm</span>
<span class="cm"> *	@len: Length of actual data</span>
<span class="cm"> *	@data_len: Data length</span>
<span class="cm"> *	@mac_len: Length of link layer header</span>
<span class="cm"> *	@hdr_len: writable header length of cloned skb</span>
<span class="cm"> *	@csum: Checksum (must include start/offset pair)</span>
<span class="cm"> *	@csum_start: Offset from skb-&gt;head where checksumming should start</span>
<span class="cm"> *	@csum_offset: Offset from csum_start where checksum should be stored</span>
<span class="cm"> *	@priority: Packet queueing priority</span>
<span class="cm"> *	@local_df: allow local fragmentation</span>
<span class="cm"> *	@cloned: Head may be cloned (check refcnt to be sure)</span>
<span class="cm"> *	@ip_summed: Driver fed us an IP checksum</span>
<span class="cm"> *	@nohdr: Payload reference only, must not modify header</span>
<span class="cm"> *	@nfctinfo: Relationship of this skb to the connection</span>
<span class="cm"> *	@pkt_type: Packet class</span>
<span class="cm"> *	@fclone: skbuff clone status</span>
<span class="cm"> *	@ipvs_property: skbuff is owned by ipvs</span>
<span class="cm"> *	@peeked: this packet has been seen already, so stats have been</span>
<span class="cm"> *		done for it, don&#39;t do them again</span>
<span class="cm"> *	@nf_trace: netfilter packet trace flag</span>
<span class="cm"> *	@protocol: Packet protocol from driver</span>
<span class="cm"> *	@destructor: Destruct function</span>
<span class="cm"> *	@nfct: Associated connection, if any</span>
<span class="cm"> *	@nfct_reasm: netfilter conntrack re-assembly pointer</span>
<span class="cm"> *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c</span>
<span class="cm"> *	@skb_iif: ifindex of device we arrived on</span>
<span class="cm"> *	@tc_index: Traffic control index</span>
<span class="cm"> *	@tc_verd: traffic control verdict</span>
<span class="cm"> *	@rxhash: the packet hash computed on receive</span>
<span class="cm"> *	@queue_mapping: Queue mapping for multiqueue devices</span>
<span class="cm"> *	@ndisc_nodetype: router type (from link layer)</span>
<span class="cm"> *	@ooo_okay: allow the mapping of a socket to a queue to be changed</span>
<span class="cm"> *	@l4_rxhash: indicate rxhash is a canonical 4-tuple hash over transport</span>
<span class="cm"> *		ports.</span>
<span class="cm"> *	@wifi_acked_valid: wifi_acked was set</span>
<span class="cm"> *	@wifi_acked: whether frame was acked on wifi or not</span>
<span class="cm"> *	@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS</span>
<span class="cm"> *	@dma_cookie: a cookie to one of several possible DMA operations</span>
<span class="cm"> *		done by skb DMA functions</span>
<span class="cm"> *	@secmark: security marking</span>
<span class="cm"> *	@mark: Generic packet mark</span>
<span class="cm"> *	@dropcount: total number of sk_receive_queue overflows</span>
<span class="cm"> *	@vlan_tci: vlan tag control information</span>
<span class="cm"> *	@transport_header: Transport layer header</span>
<span class="cm"> *	@network_header: Network layer header</span>
<span class="cm"> *	@mac_header: Link layer header</span>
<span class="cm"> *	@tail: Tail pointer</span>
<span class="cm"> *	@end: End pointer</span>
<span class="cm"> *	@head: Head of buffer</span>
<span class="cm"> *	@data: Data head pointer</span>
<span class="cm"> *	@truesize: Buffer size</span>
<span class="cm"> *	@users: User count - see {datagram,tcp}.c</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="p">{</span>
	<span class="cm">/* These two members must be first. */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">ktime_t</span>			<span class="n">tstamp</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sock</span>		<span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is the control buffer. It is free to use for every</span>
<span class="cm">	 * layer. Please put your private variables there. If you</span>
<span class="cm">	 * want to keep them across layers you have to do a skb_clone()</span>
<span class="cm">	 * first. This is owned by whoever has the skb queued ATM.</span>
<span class="cm">	 */</span>
	<span class="kt">char</span>			<span class="n">cb</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">_skb_refdst</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
	<span class="k">struct</span>	<span class="n">sec_path</span>	<span class="o">*</span><span class="n">sp</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">len</span><span class="p">,</span>
				<span class="n">data_len</span><span class="p">;</span>
	<span class="n">__u16</span>			<span class="n">mac_len</span><span class="p">,</span>
				<span class="n">hdr_len</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__wsum</span>		<span class="n">csum</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u16</span>	<span class="n">csum_start</span><span class="p">;</span>
			<span class="n">__u16</span>	<span class="n">csum_offset</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">};</span>
	<span class="n">__u32</span>			<span class="n">priority</span><span class="p">;</span>
	<span class="n">kmemcheck_bitfield_begin</span><span class="p">(</span><span class="n">flags1</span><span class="p">);</span>
	<span class="n">__u8</span>			<span class="n">local_df</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
				<span class="nl">cloned:</span><span class="mi">1</span><span class="p">,</span>
				<span class="nl">ip_summed:</span><span class="mi">2</span><span class="p">,</span>
				<span class="nl">nohdr:</span><span class="mi">1</span><span class="p">,</span>
				<span class="nl">nfctinfo:</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">pkt_type</span><span class="o">:</span><span class="mi">3</span><span class="p">,</span>
				<span class="nl">fclone:</span><span class="mi">2</span><span class="p">,</span>
				<span class="nl">ipvs_property:</span><span class="mi">1</span><span class="p">,</span>
				<span class="nl">peeked:</span><span class="mi">1</span><span class="p">,</span>
				<span class="nl">nf_trace:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">kmemcheck_bitfield_end</span><span class="p">(</span><span class="n">flags1</span><span class="p">);</span>
	<span class="n">__be16</span>			<span class="n">protocol</span><span class="p">;</span>

	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
	<span class="k">struct</span> <span class="n">nf_conntrack</span>	<span class="o">*</span><span class="n">nfct</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">nfct_reasm</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BRIDGE_NETFILTER</span>
	<span class="k">struct</span> <span class="n">nf_bridge_info</span>	<span class="o">*</span><span class="n">nf_bridge</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="kt">int</span>			<span class="n">skb_iif</span><span class="p">;</span>

	<span class="n">__u32</span>			<span class="n">rxhash</span><span class="p">;</span>

	<span class="n">__u16</span>			<span class="n">vlan_tci</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NET_SCHED</span>
	<span class="n">__u16</span>			<span class="n">tc_index</span><span class="p">;</span>	<span class="cm">/* traffic control index */</span>
<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
	<span class="n">__u16</span>			<span class="n">tc_verd</span><span class="p">;</span>	<span class="cm">/* traffic control verdict */</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="n">__u16</span>			<span class="n">queue_mapping</span><span class="p">;</span>
	<span class="n">kmemcheck_bitfield_begin</span><span class="p">(</span><span class="n">flags2</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IPV6_NDISC_NODETYPE</span>
	<span class="n">__u8</span>			<span class="n">ndisc_nodetype</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">__u8</span>			<span class="n">ooo_okay</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">l4_rxhash</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">wifi_acked_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">wifi_acked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">no_fcs</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">__u8</span>			<span class="n">head_frag</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* 8/10 bit hole (depending on ndisc_nodetype presence) */</span>
	<span class="n">kmemcheck_bitfield_end</span><span class="p">(</span><span class="n">flags2</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
	<span class="n">dma_cookie_t</span>		<span class="n">dma_cookie</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NETWORK_SECMARK</span>
	<span class="n">__u32</span>			<span class="n">secmark</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__u32</span>		<span class="n">mark</span><span class="p">;</span>
		<span class="n">__u32</span>		<span class="n">dropcount</span><span class="p">;</span>
		<span class="n">__u32</span>		<span class="n">avail_size</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">sk_buff_data_t</span>		<span class="n">transport_header</span><span class="p">;</span>
	<span class="n">sk_buff_data_t</span>		<span class="n">network_header</span><span class="p">;</span>
	<span class="n">sk_buff_data_t</span>		<span class="n">mac_header</span><span class="p">;</span>
	<span class="cm">/* These elements must be at the end, see alloc_skb() for details.  */</span>
	<span class="n">sk_buff_data_t</span>		<span class="n">tail</span><span class="p">;</span>
	<span class="n">sk_buff_data_t</span>		<span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">head</span><span class="p">,</span>
				<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">truesize</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">users</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/*</span>
<span class="cm"> *	Handling routines are only of interest to the kernel</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * skb might have a dst pointer attached, refcounted or not.</span>
<span class="cm"> * _skb_refdst low order bit is set if refcount was _not_ taken</span>
<span class="cm"> */</span>
<span class="cp">#define SKB_DST_NOREF	1UL</span>
<span class="cp">#define SKB_DST_PTRMASK	~(SKB_DST_NOREF)</span>

<span class="cm">/**</span>
<span class="cm"> * skb_dst - returns skb dst_entry</span>
<span class="cm"> * @skb: buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns skb dst_entry, regardless of reference taken or not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="nf">skb_dst</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If refdst was not refcounted, check we still are in a </span>
<span class="cm">	 * rcu_read_lock section</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">_skb_refdst</span> <span class="o">&amp;</span> <span class="n">SKB_DST_NOREF</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">rcu_read_lock_held</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">rcu_read_lock_bh_held</span><span class="p">());</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">_skb_refdst</span> <span class="o">&amp;</span> <span class="n">SKB_DST_PTRMASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_dst_set - sets skb dst</span>
<span class="cm"> * @skb: buffer</span>
<span class="cm"> * @dst: dst entry</span>
<span class="cm"> *</span>
<span class="cm"> * Sets skb dst, assuming a reference was taken on dst and should</span>
<span class="cm"> * be released by skb_dst_drop()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_dst_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">_skb_refdst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_dst_set_noref</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * skb_dst_is_noref - Test if skb dst isn&#39;t refcounted</span>
<span class="cm"> * @skb: buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_dst_is_noref</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">_skb_refdst</span> <span class="o">&amp;</span> <span class="n">SKB_DST_NOREF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="nf">skb_rtable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">kfree_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">consume_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	       <span class="n">__kfree_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">skbuff_head_cache</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">kfree_skb_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">head_stolen</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">skb_try_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="o">*</span><span class="n">fragstolen</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_truesize</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">__alloc_skb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				   <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fclone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">build_skb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">alloc_skb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">alloc_skb_fclone</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
					       <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_recycle</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">skb_recycle_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">skb_size</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_morph</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">skb_copy_ubufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_copy</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">__pskb_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">headroom</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">pskb_expand_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">nhead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ntail</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_realloc_headroom</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headroom</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_copy_expand</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">newheadroom</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newtailroom</span><span class="p">,</span>
				       <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_to_sgvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_cow_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tailbits</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">trailer</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">);</span>
<span class="cp">#define dev_kfree_skb(a)	consume_skb(a)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">skb_append_datato_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">getfrag</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">odd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">skb_seq_state</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">lower_offset</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">upper_offset</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">frag_idx</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">stepped_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">root_skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">cur_skb</span><span class="p">;</span>
	<span class="n">__u8</span>		<span class="o">*</span><span class="n">frag_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span>	      <span class="n">skb_prepare_seq_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">skb_seq_state</span> <span class="o">*</span><span class="n">st</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">skb_seq_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">consumed</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">**</span><span class="n">data</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">skb_seq_state</span> <span class="o">*</span><span class="n">st</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	      <span class="n">skb_abort_seq_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_seq_state</span> <span class="o">*</span><span class="n">st</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">skb_find_text</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ts_config</span> <span class="o">*</span><span class="n">config</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ts_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__skb_get_rxhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">skb_get_rxhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span><span class="p">)</span>
		<span class="n">__skb_get_rxhash</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef NET_SKBUFF_DATA_USES_OFFSET</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_end_pointer</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_end_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_end_pointer</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_end_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Internal */</span>
<span class="cp">#define skb_shinfo(SKB)	((struct skb_shared_info *)(skb_end_pointer(SKB)))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="nf">skb_hwtstamps</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hwtstamps</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_empty - check if a queue is empty</span>
<span class="cm"> *	@list: queue head</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if the queue is empty, false otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_queue_empty</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_is_last - check if skb is the last entry in the queue</span>
<span class="cm"> *	@list: queue head</span>
<span class="cm"> *	@skb: buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if @skb is the last buffer on the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_queue_is_last</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_is_first - check if skb is the first entry in the queue</span>
<span class="cm"> *	@list: queue head</span>
<span class="cm"> *	@skb: buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if @skb is the first buffer on the list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_queue_is_first</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_next - return the next packet in the queue</span>
<span class="cm"> *	@list: queue head</span>
<span class="cm"> *	@skb: current buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the next packet in @list after @skb.  It is only valid to</span>
<span class="cm"> *	call this if skb_queue_is_last() evaluates to false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_queue_next</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This BUG_ON may seem severe, but if we just return then we</span>
<span class="cm">	 * are going to dereference garbage.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb_queue_is_last</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_prev - return the prev packet in the queue</span>
<span class="cm"> *	@list: queue head</span>
<span class="cm"> *	@skb: current buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the prev packet in @list before @skb.  It is only valid to</span>
<span class="cm"> *	call this if skb_queue_is_first() evaluates to false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_queue_prev</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					     <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This BUG_ON may seem severe, but if we just return then we</span>
<span class="cm">	 * are going to dereference garbage.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb_queue_is_first</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_get - reference buffer</span>
<span class="cm"> *	@skb: buffer to reference</span>
<span class="cm"> *</span>
<span class="cm"> *	Makes another reference to a socket buffer and returns a pointer</span>
<span class="cm"> *	to the buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If users == 1, we are the only owner and are can avoid redundant</span>
<span class="cm"> * atomic change.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_cloned - is the buffer a clone</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if the buffer was generated with skb_clone() and is</span>
<span class="cm"> *	one of multiple shared copies of the buffer. Cloned buffers are</span>
<span class="cm"> *	shared data so must not be written to under normal circumstances.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_cloned</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cloned</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SKB_DATAREF_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_header_cloned - is the header a clone</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if modifying the header part of the buffer requires</span>
<span class="cm"> *	the data to be copied.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_header_cloned</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dataref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cloned</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dataref</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">);</span>
	<span class="n">dataref</span> <span class="o">=</span> <span class="p">(</span><span class="n">dataref</span> <span class="o">&amp;</span> <span class="n">SKB_DATAREF_MASK</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">dataref</span> <span class="o">&gt;&gt;</span> <span class="n">SKB_DATAREF_SHIFT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dataref</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_header_release - release reference to header</span>
<span class="cm"> *	@skb: buffer to operate on</span>
<span class="cm"> *</span>
<span class="cm"> *	Drop a reference to the header part of the buffer.  This is done</span>
<span class="cm"> *	by acquiring a payload reference.  You must not read from the header</span>
<span class="cm"> *	part of skb-&gt;data after this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_header_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nohdr</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nohdr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SKB_DATAREF_SHIFT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_shared - is the buffer shared</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if more than one person has a reference to this</span>
<span class="cm"> *	buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_shared</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_share_check - check if buffer is shared and if so clone it</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *	@pri: priority for memory allocation</span>
<span class="cm"> *</span>
<span class="cm"> *	If the buffer is shared the buffer is cloned and the old copy</span>
<span class="cm"> *	drops a reference. A new clone with a single reference is returned.</span>
<span class="cm"> *	If the buffer is not shared the original buffer is returned. When</span>
<span class="cm"> *	being called from interrupt status or with spinlocks held pri must</span>
<span class="cm"> *	be GFP_ATOMIC.</span>
<span class="cm"> *</span>
<span class="cm"> *	NULL is returned on a memory allocation failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_share_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					      <span class="n">gfp_t</span> <span class="n">pri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">pri</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shared</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pri</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Copy shared buffers into a new sk_buff. We effectively do COW on</span>
<span class="cm"> *	packets to handle cases where we have a local reader and forward</span>
<span class="cm"> *	and a couple of other messy ones. The normal one is tcpdumping</span>
<span class="cm"> *	a packet thats being forwarded.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_unshare - make a copy of a shared buffer</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *	@pri: priority for memory allocation</span>
<span class="cm"> *</span>
<span class="cm"> *	If the socket buffer is a clone then this function creates a new</span>
<span class="cm"> *	copy of the data, drops a reference count on the old copy and returns</span>
<span class="cm"> *	the new copy with the reference count at 1. If the buffer is not a clone</span>
<span class="cm"> *	the original buffer is returned. When called with a spinlock held or</span>
<span class="cm"> *	from interrupt state @pri must be %GFP_ATOMIC</span>
<span class="cm"> *</span>
<span class="cm"> *	%NULL is returned on a memory allocation failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_unshare</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					  <span class="n">gfp_t</span> <span class="n">pri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">pri</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">skb_copy</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pri</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>	<span class="cm">/* Free our shared copy */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_peek - peek at the head of an &amp;sk_buff_head</span>
<span class="cm"> *	@list_: list to peek at</span>
<span class="cm"> *</span>
<span class="cm"> *	Peek an &amp;sk_buff. Unlike most other operations you _MUST_</span>
<span class="cm"> *	be careful with this one. A peek leaves the buffer on the</span>
<span class="cm"> *	list and someone else may run off with it. You must hold</span>
<span class="cm"> *	the appropriate locks or have a private queue to do this.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns %NULL for an empty list or a pointer to the head element.</span>
<span class="cm"> *	The reference count is not incremented and the reference is therefore</span>
<span class="cm"> *	volatile. Use with caution.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_peek</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list_</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">list_</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list_</span><span class="p">)</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_peek_next - peek skb following the given one from a queue</span>
<span class="cm"> *	@skb: skb to start from</span>
<span class="cm"> *	@list_: list to peek at</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns %NULL when the end of the list is met or a pointer to the</span>
<span class="cm"> *	next element. The reference count is not incremented and the</span>
<span class="cm"> *	reference is therefore volatile. Use with caution.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_peek_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list_</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list_</span><span class="p">)</span>
		<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_peek_tail - peek at the tail of an &amp;sk_buff_head</span>
<span class="cm"> *	@list_: list to peek at</span>
<span class="cm"> *</span>
<span class="cm"> *	Peek an &amp;sk_buff. Unlike most other operations you _MUST_</span>
<span class="cm"> *	be careful with this one. A peek leaves the buffer on the</span>
<span class="cm"> *	list and someone else may run off with it. You must hold</span>
<span class="cm"> *	the appropriate locks or have a private queue to do this.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns %NULL for an empty list or a pointer to the tail element.</span>
<span class="cm"> *	The reference count is not incremented and the reference is therefore</span>
<span class="cm"> *	volatile. Use with caution.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_peek_tail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list_</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">list_</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list_</span><span class="p">)</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_len	- get queue length</span>
<span class="cm"> *	@list_: list to measure</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the length of an &amp;sk_buff queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">skb_queue_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list_</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__skb_queue_head_init - initialize non-spinlock portions of sk_buff_head</span>
<span class="cm"> *	@list: queue to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	This initializes only the list and queue length aspects of</span>
<span class="cm"> *	an sk_buff_head object.  This allows to initialize the list</span>
<span class="cm"> *	aspects of an sk_buff_head without reinitializing things like</span>
<span class="cm"> *	the spinlock.  It can also be used for on-stack sk_buff_head</span>
<span class="cm"> *	objects where the spinlock is known to not be used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_queue_head_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="p">;</span>
	<span class="n">list</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function creates a split out lock class for each invocation;</span>
<span class="cm"> * this is needed for now since a whole lot of users of the skb-queue</span>
<span class="cm"> * infrastructure in drivers have different locking usage (in hardirq)</span>
<span class="cm"> * than the networking core (in softirq only). In the long run either the</span>
<span class="cm"> * network layer or drivers should need annotation to consolidate the</span>
<span class="cm"> * main types of usage into 3 classes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_queue_head_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__skb_queue_head_init</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_queue_head_init_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">class</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Insert an sk_buff on a list.</span>
<span class="cm"> *</span>
<span class="cm"> *	The &quot;__skb_xxxx()&quot; functions are the non-atomic ones that</span>
<span class="cm"> *	can only be called with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span>        <span class="n">skb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span>  <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newsk</span><span class="p">;</span>
	<span class="n">list</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_queue_splice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">first</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>

	<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_splice - join two skb lists, this is designed for stacks</span>
<span class="cm"> *	@list: the new list to add</span>
<span class="cm"> *	@head: the place to add it in the first list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_queue_splice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__skb_queue_splice</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">+=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_splice_init - join two skb lists and reinitialise the emptied list</span>
<span class="cm"> *	@list: the new list to add</span>
<span class="cm"> *	@head: the place to add it in the first list</span>
<span class="cm"> *</span>
<span class="cm"> *	The list at @list is reinitialised</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_queue_splice_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__skb_queue_splice</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">+=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="p">;</span>
		<span class="n">__skb_queue_head_init</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_splice_tail - join two skb lists, each list being a queue</span>
<span class="cm"> *	@list: the new list to add</span>
<span class="cm"> *	@head: the place to add it in the first list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_queue_splice_tail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__skb_queue_splice</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">+=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_splice_tail_init - join two skb lists and reinitialise the emptied list</span>
<span class="cm"> *	@list: the new list to add</span>
<span class="cm"> *	@head: the place to add it in the first list</span>
<span class="cm"> *</span>
<span class="cm"> *	Each of the lists is a queue.</span>
<span class="cm"> *	The list at @list is reinitialised</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_queue_splice_tail_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__skb_queue_splice</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">qlen</span> <span class="o">+=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="p">;</span>
		<span class="n">__skb_queue_head_init</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__skb_queue_after - queue a buffer at the list head</span>
<span class="cm"> *	@list: list to use</span>
<span class="cm"> *	@prev: place after this buffer</span>
<span class="cm"> *	@newsk: buffer to queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Queue a buffer int the middle of a list. This function takes no locks</span>
<span class="cm"> *	and you must therefore hold required locks before calling it.</span>
<span class="cm"> *</span>
<span class="cm"> *	A buffer cannot be placed on two lists at the same time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_queue_after</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_insert</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_queue_before</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_insert</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__skb_queue_head - queue a buffer at the list head</span>
<span class="cm"> *	@list: list to use</span>
<span class="cm"> *	@newsk: buffer to queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Queue a buffer at the start of a list. This function takes no locks</span>
<span class="cm"> *	and you must therefore hold required locks before calling it.</span>
<span class="cm"> *</span>
<span class="cm"> *	A buffer cannot be placed on two lists at the same time.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_queue_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_queue_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_queue_after</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__skb_queue_tail - queue a buffer at the list tail</span>
<span class="cm"> *	@list: list to use</span>
<span class="cm"> *	@newsk: buffer to queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Queue a buffer at the end of a list. This function takes no locks</span>
<span class="cm"> *	and you must therefore hold required locks before calling it.</span>
<span class="cm"> *</span>
<span class="cm"> *	A buffer cannot be placed on two lists at the same time.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_queue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_queue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_queue_before</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * remove sk_buff from list. _Must_ be called atomically, and with</span>
<span class="cm"> * the list known..</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">skb_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">list</span><span class="o">-&gt;</span><span class="n">qlen</span><span class="o">--</span><span class="p">;</span>
	<span class="n">next</span>	   <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">prev</span>	   <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span>  <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__skb_dequeue - remove from the head of the queue</span>
<span class="cm"> *	@list: list to dequeue from</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove the head of the list. This function does not take any locks</span>
<span class="cm"> *	so must be used with appropriate locks held only. The head item is</span>
<span class="cm"> *	returned or %NULL if the list is empty.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">__skb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__skb_dequeue_tail - remove from the tail of the queue</span>
<span class="cm"> *	@list: list to dequeue from</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove the tail of the list. This function does not take any locks</span>
<span class="cm"> *	so must be used with appropriate locks held only. The tail item is</span>
<span class="cm"> *	returned or %NULL if the list is empty.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_dequeue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">__skb_dequeue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_is_nonlinear</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_headlen</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_pagelen</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __skb_fill_page_desc - initialise a paged fragment in an skb</span>
<span class="cm"> * @skb: buffer containing fragment to be initialised</span>
<span class="cm"> * @i: paged fragment index to initialise</span>
<span class="cm"> * @page: the page to use for this fragment</span>
<span class="cm"> * @off: the offset to the data with @page</span>
<span class="cm"> * @size: the length of the data</span>
<span class="cm"> *</span>
<span class="cm"> * Initialises the @i&#39;th fragment of @skb to point to &amp;size bytes at</span>
<span class="cm"> * offset @off within @page.</span>
<span class="cm"> *</span>
<span class="cm"> * Does not take any additional reference on the fragment.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_fill_page_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">.</span><span class="n">p</span>		  <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span>	  <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_fill_page_desc - initialise a paged fragment in an skb</span>
<span class="cm"> * @skb: buffer containing fragment to be initialised</span>
<span class="cm"> * @i: paged fragment index to initialise</span>
<span class="cm"> * @page: the page to use for this fragment</span>
<span class="cm"> * @off: the offset to the data with @page</span>
<span class="cm"> * @size: the length of the data</span>
<span class="cm"> *</span>
<span class="cm"> * As per __skb_fill_page_desc() -- initialises the @i&#39;th fragment of</span>
<span class="cm"> * @skb to point to &amp;size bytes at offset @off within @page. In</span>
<span class="cm"> * addition updates @skb such that @i is the last fragment.</span>
<span class="cm"> *</span>
<span class="cm"> * Does not take any additional reference on the fragment.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_fill_page_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_add_rx_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">truesize</span><span class="p">);</span>

<span class="cp">#define SKB_PAGE_ASSERT(skb) 	BUG_ON(skb_shinfo(skb)-&gt;nr_frags)</span>
<span class="cp">#define SKB_FRAG_ASSERT(skb) 	BUG_ON(skb_has_frag_list(skb))</span>
<span class="cp">#define SKB_LINEAR_ASSERT(skb)  BUG_ON(skb_is_nonlinear(skb))</span>

<span class="cp">#ifdef NET_SKBUFF_DATA_USES_OFFSET</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_tail_pointer</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_tail_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_tail_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_reset_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* NET_SKBUFF_DATA_USES_OFFSET */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_tail_pointer</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_tail_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_tail_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* NET_SKBUFF_DATA_USES_OFFSET */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	Add data to an sk_buff</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">skb_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__skb_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">SKB_LINEAR_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">skb_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__skb_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">skb_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__skb_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_pull_inline</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__pskb_pull_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__pskb_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">__pskb_pull_tail</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">pskb_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">__pskb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pskb_may_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__pskb_pull_tail</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_headroom - bytes at buffer head</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the number of bytes of free space at the head of an &amp;sk_buff.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_headroom</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_tailroom - bytes at buffer end</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the number of bytes of free space at the tail of an sk_buff</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_tailroom</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_availroom - bytes at buffer end</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the number of bytes of free space at the tail of an sk_buff</span>
<span class="cm"> *	allocated by sk_stream_alloc()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_availroom</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">avail_size</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_reserve - adjust headroom</span>
<span class="cm"> *	@skb: buffer to alter</span>
<span class="cm"> *	@len: bytes to move</span>
<span class="cm"> *</span>
<span class="cm"> *	Increase the headroom of an empty &amp;sk_buff by reducing the tail</span>
<span class="cm"> *	room. This is only allowed for an empty buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_mac_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef NET_SKBUFF_DATA_USES_OFFSET</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_transport_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_transport_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_transport_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_network_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_network_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_network_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_mac_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_mac_header_was_set</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_mac_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_mac_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* NET_SKBUFF_DATA_USES_OFFSET */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_transport_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_transport_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_transport_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_network_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_network_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_network_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_mac_header</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_mac_header_was_set</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_reset_mac_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_mac_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* NET_SKBUFF_DATA_USES_OFFSET */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_mac_header_rebuild</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_mac_header_was_set</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_mac</span> <span class="o">=</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">skb_set_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">old_mac</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_checksum_start_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">-</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_transport_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">skb_network_header_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_network_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pskb_network_may_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CPUs often take a performance hit when accessing unaligned memory</span>
<span class="cm"> * locations. The actual performance hit varies, it can be small if the</span>
<span class="cm"> * hardware handles it or large if we have to take an exception and fix it</span>
<span class="cm"> * in software.</span>
<span class="cm"> *</span>
<span class="cm"> * Since an ethernet header is 14 bytes network drivers often end up with</span>
<span class="cm"> * the IP header at an unaligned offset. The IP header can be aligned by</span>
<span class="cm"> * shifting the start of the packet by 2 bytes. Drivers should do this</span>
<span class="cm"> * with:</span>
<span class="cm"> *</span>
<span class="cm"> * skb_reserve(skb, NET_IP_ALIGN);</span>
<span class="cm"> *</span>
<span class="cm"> * The downside to this alignment of the IP header is that the DMA is now</span>
<span class="cm"> * unaligned. On some architectures the cost of an unaligned DMA is high</span>
<span class="cm"> * and this cost outweighs the gains made by aligning the IP header.</span>
<span class="cm"> *</span>
<span class="cm"> * Since this trade off varies between architectures, we allow NET_IP_ALIGN</span>
<span class="cm"> * to be overridden.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef NET_IP_ALIGN</span>
<span class="cp">#define NET_IP_ALIGN	2</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The networking layer reserves some headroom in skb data (via</span>
<span class="cm"> * dev_alloc_skb). This is used to avoid having to reallocate skb data when</span>
<span class="cm"> * the header has to grow. In the default case, if the header has to grow</span>
<span class="cm"> * 32 bytes or less we avoid the reallocation.</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately this headroom changes the DMA alignment of the resulting</span>
<span class="cm"> * network packet. As for NET_IP_ALIGN, this unaligned DMA is expensive</span>
<span class="cm"> * on some architectures. An architecture can override this value,</span>
<span class="cm"> * perhaps setting it to a cacheline in size (since that will maintain</span>
<span class="cm"> * cacheline alignment of the DMA). It must be a power of 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Various parts of the networking layer expect at least 32 bytes of</span>
<span class="cm"> * headroom, you should not reduce this.</span>
<span class="cm"> *</span>
<span class="cm"> * Using max(32, L1_CACHE_BYTES) makes sense (especially with RPS)</span>
<span class="cm"> * to reduce average number of cache lines per packet.</span>
<span class="cm"> * get_rps_cpus() for example only access one 64 bytes aligned block :</span>
<span class="cm"> * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)</span>
<span class="cm"> */</span>
<span class="cp">#ifndef NET_SKB_PAD</span>
<span class="cp">#define NET_SKB_PAD	max(32, L1_CACHE_BYTES)</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">___pskb_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb_set_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__pskb_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">___pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">__skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pskb_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="n">__pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer</span>
<span class="cm"> *	@skb: buffer to alter</span>
<span class="cm"> *	@len: new length</span>
<span class="cm"> *</span>
<span class="cm"> *	This is identical to pskb_trim except that the caller knows that</span>
<span class="cm"> *	the skb is not cloned so we should never get an error due to out-</span>
<span class="cm"> *	of-memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pskb_trim_unique</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_orphan - orphan a buffer</span>
<span class="cm"> *	@skb: buffer to orphan</span>
<span class="cm"> *</span>
<span class="cm"> *	If a buffer currently has an owner then we call the owner&#39;s</span>
<span class="cm"> *	destructor function and make the @skb unowned. The buffer continues</span>
<span class="cm"> *	to exist but is no longer charged to its former owner.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__skb_queue_purge - empty a list</span>
<span class="cm"> *	@list: list to empty</span>
<span class="cm"> *</span>
<span class="cm"> *	Delete all buffers on an &amp;sk_buff list. Each buffer is removed from</span>
<span class="cm"> *	the list and one reference dropped. This function does not take the</span>
<span class="cm"> *	list lock and the caller must hold the relevant locks to use it.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_queue_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_queue_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">netdev_alloc_frag</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fragsz</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">__netdev_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
					  <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_alloc_skb - allocate an skbuff for rx on a specific device</span>
<span class="cm"> *	@dev: network device to receive on</span>
<span class="cm"> *	@length: length to allocate</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate a new &amp;sk_buff and assign it a usage count of one. The</span>
<span class="cm"> *	buffer has unspecified headroom built in. Users should allocate</span>
<span class="cm"> *	the headroom they think they need without accounting for the</span>
<span class="cm"> *	built in space. The built in space is used for optimisations.</span>
<span class="cm"> *</span>
<span class="cm"> *	%NULL is returned if there is no free memory. Although this function</span>
<span class="cm"> *	allocates memory it can be called from an interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">netdev_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* legacy helper around __netdev_alloc_skb() */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">__dev_alloc_skb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
					      <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__netdev_alloc_skb</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* legacy helper around netdev_alloc_skb() */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">dev_alloc_skb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">__netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__netdev_alloc_skb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NET_IP_ALIGN</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="p">)</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_frag_page - retrieve the page refered to by a paged fragment</span>
<span class="cm"> * @frag: the paged fragment</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the &amp;struct page associated with @frag.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">skb_frag_page</span><span class="p">(</span><span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __skb_frag_ref - take an addition reference on a paged fragment.</span>
<span class="cm"> * @frag: the paged fragment</span>
<span class="cm"> *</span>
<span class="cm"> * Takes an additional reference on the paged fragment @frag.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_frag_ref</span><span class="p">(</span><span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_frag_ref - take an addition reference on a paged fragment of an skb.</span>
<span class="cm"> * @skb: the buffer</span>
<span class="cm"> * @f: the fragment offset.</span>
<span class="cm"> *</span>
<span class="cm"> * Takes an additional reference on the @f&#39;th paged fragment of @skb.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_frag_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_frag_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __skb_frag_unref - release a reference on a paged fragment.</span>
<span class="cm"> * @frag: the paged fragment</span>
<span class="cm"> *</span>
<span class="cm"> * Releases a reference on the paged fragment @frag.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_frag_unref</span><span class="p">(</span><span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_frag_unref - release a reference on a paged fragment of an skb.</span>
<span class="cm"> * @skb: the buffer</span>
<span class="cm"> * @f: the fragment offset</span>
<span class="cm"> *</span>
<span class="cm"> * Releases a reference on the @f&#39;th paged fragment of @skb.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_frag_unref</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_frag_unref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_frag_address - gets the address of the data contained in a paged fragment</span>
<span class="cm"> * @frag: the paged fragment buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the data within @frag. The page must already</span>
<span class="cm"> * be mapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">skb_frag_address</span><span class="p">(</span><span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page_address</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_frag_address_safe - gets the address of the data contained in a paged fragment</span>
<span class="cm"> * @frag: the paged fragment buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the data within @frag. Checks that the page</span>
<span class="cm"> * is mapped and returns %NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">skb_frag_address_safe</span><span class="p">(</span><span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __skb_frag_set_page - sets the page contained in a paged fragment</span>
<span class="cm"> * @frag: the paged fragment</span>
<span class="cm"> * @page: the page to set</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the fragment @frag to contain @page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__skb_frag_set_page</span><span class="p">(</span><span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_frag_set_page - sets the page contained in a paged fragment of an skb</span>
<span class="cm"> * @skb: the buffer</span>
<span class="cm"> * @f: the fragment offset</span>
<span class="cm"> * @page: the page to set</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the @f&#39;th fragment of @skb to contain @page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_frag_set_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_frag_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_frag_dma_map - maps a paged fragment via the DMA API</span>
<span class="cm"> * @dev: the device to map the fragment to</span>
<span class="cm"> * @frag: the paged fragment to map</span>
<span class="cm"> * @offset: the offset within the fragment (starting at the</span>
<span class="cm"> *          fragment&#39;s own offset)</span>
<span class="cm"> * @size: the number of bytes to map</span>
<span class="cm"> * @dir: the direction of the mapping (%PCI_DMA_*)</span>
<span class="cm"> *</span>
<span class="cm"> * Maps the page associated with @frag to @device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">dma_addr_t</span> <span class="nf">skb_frag_dma_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					  <span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
					  <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span>
			    <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">pskb_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pskb_copy</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_clone_writable - is the header of a clone writable</span>
<span class="cm"> *	@skb: buffer to check</span>
<span class="cm"> *	@len: length up to which to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if modifying the header part of the cloned buffer</span>
<span class="cm"> *	does not requires the data to be copied.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_clone_writable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">hdr_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__skb_cow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headroom</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">cloned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">headroom</span> <span class="o">&gt;</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">headroom</span> <span class="o">-</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">||</span> <span class="n">cloned</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">NET_SKB_PAD</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_cow - copy header of skb when it is required</span>
<span class="cm"> *	@skb: buffer to cow</span>
<span class="cm"> *	@headroom: needed headroom</span>
<span class="cm"> *</span>
<span class="cm"> *	If the skb passed lacks sufficient headroom or its data part</span>
<span class="cm"> *	is shared, data is reallocated. If reallocation fails, an error</span>
<span class="cm"> *	is returned and original skb is not changed.</span>
<span class="cm"> *</span>
<span class="cm"> *	The result is skb with writable area skb-&gt;head...skb-&gt;tail</span>
<span class="cm"> *	and at least @headroom of space at head.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_cow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headroom</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">headroom</span><span class="p">,</span> <span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_cow_head - skb_cow but only making the head writable</span>
<span class="cm"> *	@skb: buffer to cow</span>
<span class="cm"> *	@headroom: needed headroom</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is identical to skb_cow except that we replace the</span>
<span class="cm"> *	skb_cloned check by skb_header_cloned.  It should be used when</span>
<span class="cm"> *	you only need to push on some header and do not need to modify</span>
<span class="cm"> *	the data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_cow_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headroom</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__skb_cow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">headroom</span><span class="p">,</span> <span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_padto	- pad an skbuff up to a minimal size</span>
<span class="cm"> *	@skb: buffer to pad</span>
<span class="cm"> *	@len: minimal length</span>
<span class="cm"> *</span>
<span class="cm"> *	Pads up a buffer to ensure the trailing bytes exist and are</span>
<span class="cm"> *	blanked. If the buffer already contains sufficient data it</span>
<span class="cm"> *	is untouched. Otherwise it is extended. Returns zero on</span>
<span class="cm"> *	success. The skb is freed on error.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_padto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb_pad</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_add_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__wsum</span> <span class="n">csum</span> <span class="o">=</span> <span class="n">csum_and_copy_from_user</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">copy</span><span class="p">),</span>
							    <span class="n">copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">copy</span><span class="p">),</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_can_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

		<span class="k">return</span> <span class="n">page</span> <span class="o">==</span> <span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="n">off</span> <span class="o">==</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__skb_linearize</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__pskb_pull_tail</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_linearize - convert paged skb to linear one</span>
<span class="cm"> *	@skb: buffer to linarize</span>
<span class="cm"> *</span>
<span class="cm"> *	If there is no free memory -ENOMEM is returned, otherwise zero</span>
<span class="cm"> *	is returned and the old skb data released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_linearize</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">?</span> <span class="n">__skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_linearize_cow - make sure skb is linear and writable</span>
<span class="cm"> *	@skb: buffer to process</span>
<span class="cm"> *</span>
<span class="cm"> *	If there is no free memory -ENOMEM is returned, otherwise zero</span>
<span class="cm"> *	is returned and the old skb data released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_linearize_cow</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">?</span>
	       <span class="n">__skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_postpull_rcsum - update checksum for received skb after pull</span>
<span class="cm"> *	@skb: buffer to update</span>
<span class="cm"> *	@start: start of data before pull</span>
<span class="cm"> *	@len: length of data pulled</span>
<span class="cm"> *</span>
<span class="cm"> *	After doing a pull on a received packet, you need to call this to</span>
<span class="cm"> *	update the CHECKSUM_COMPLETE checksum, or set ip_summed to</span>
<span class="cm"> *	CHECKSUM_NONE so that it can be recomputed from scratch.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_postpull_rcsum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_sub</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum_partial</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">skb_pull_rcsum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	pskb_trim_rcsum - trim received skb and update checksum</span>
<span class="cm"> *	@skb: buffer to trim</span>
<span class="cm"> *	@len: new length</span>
<span class="cm"> *</span>
<span class="cm"> *	This is exactly the same as pskb_trim except that it ensures the</span>
<span class="cm"> *	checksum of received packets are still valid after the operation.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pskb_trim_rcsum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define skb_queue_walk(queue, skb) \</span>
<span class="cp">		for (skb = (queue)-&gt;next;					\</span>
<span class="cp">		     skb != (struct sk_buff *)(queue);				\</span>
<span class="cp">		     skb = skb-&gt;next)</span>

<span class="cp">#define skb_queue_walk_safe(queue, skb, tmp)					\</span>
<span class="cp">		for (skb = (queue)-&gt;next, tmp = skb-&gt;next;			\</span>
<span class="cp">		     skb != (struct sk_buff *)(queue);				\</span>
<span class="cp">		     skb = tmp, tmp = skb-&gt;next)</span>

<span class="cp">#define skb_queue_walk_from(queue, skb)						\</span>
<span class="cp">		for (; skb != (struct sk_buff *)(queue);			\</span>
<span class="cp">		     skb = skb-&gt;next)</span>

<span class="cp">#define skb_queue_walk_from_safe(queue, skb, tmp)				\</span>
<span class="cp">		for (tmp = skb-&gt;next;						\</span>
<span class="cp">		     skb != (struct sk_buff *)(queue);				\</span>
<span class="cp">		     skb = tmp, tmp = skb-&gt;next)</span>

<span class="cp">#define skb_queue_reverse_walk(queue, skb) \</span>
<span class="cp">		for (skb = (queue)-&gt;prev;					\</span>
<span class="cp">		     skb != (struct sk_buff *)(queue);				\</span>
<span class="cp">		     skb = skb-&gt;prev)</span>

<span class="cp">#define skb_queue_reverse_walk_safe(queue, skb, tmp)				\</span>
<span class="cp">		for (skb = (queue)-&gt;prev, tmp = skb-&gt;prev;			\</span>
<span class="cp">		     skb != (struct sk_buff *)(queue);				\</span>
<span class="cp">		     skb = tmp, tmp = skb-&gt;prev)</span>

<span class="cp">#define skb_queue_reverse_walk_from_safe(queue, skb, tmp)			\</span>
<span class="cp">		for (tmp = skb-&gt;prev;						\</span>
<span class="cp">		     skb != (struct sk_buff *)(queue);				\</span>
<span class="cp">		     skb = tmp, tmp = skb-&gt;prev)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_has_frag_list</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_frag_list_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_frag_add_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="n">frag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define skb_walk_frags(skb, iter)	\</span>
<span class="cp">	for (iter = skb_shinfo(skb)-&gt;frag_list; iter; iter = iter-&gt;next)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">__skb_recv_datagram</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="o">*</span><span class="n">peeked</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_recv_datagram</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">datagram_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_copy_and_csum_datagram_iovec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
							<span class="kt">int</span> <span class="n">hlen</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_copy_datagram_from_iovec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
						    <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">from_offset</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_copy_datagram_const_iovec</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
						     <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
						     <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
						     <span class="kt">int</span> <span class="n">to_offset</span><span class="p">,</span>
						     <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	       <span class="n">skb_free_datagram</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	       <span class="n">skb_free_datagram_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_kill_datagram</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__wsum</span>	       <span class="n">skb_checksum</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">csum</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_copy_bits</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_store_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__wsum</span>	       <span class="n">skb_copy_and_csum_bits</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					      <span class="n">__wsum</span> <span class="n">csum</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>             <span class="n">skb_splice_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	       <span class="n">skb_copy_and_csum_dev</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">to</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	       <span class="n">skb_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb1</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	       <span class="n">skb_shift</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tgt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">shiftlen</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">skb_header_pointer</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hlen</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlen</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_copy_from_linear_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					     <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						    <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
						    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_copy_to_linear_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
					   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						  <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
						  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
						  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">skb_get_ktime</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_get_timestamp - get timestamp from a skb</span>
<span class="cm"> *	@skb: skb to get stamp from</span>
<span class="cm"> *	@stamp: pointer to struct timeval to store stamp in</span>
<span class="cm"> *</span>
<span class="cm"> *	Timestamps are stored in the skb as offsets to a base timestamp.</span>
<span class="cm"> *	This function converts the offset back to a struct timeval and stores</span>
<span class="cm"> *	it in stamp.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_get_timestamp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">stamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">stamp</span> <span class="o">=</span> <span class="n">ktime_to_timeval</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_get_timestampns</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">stamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">stamp</span> <span class="o">=</span> <span class="n">ktime_to_timespec</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__net_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">net_timedelta</span><span class="p">(</span><span class="n">ktime_t</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">(),</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ktime_t</span> <span class="nf">net_invalid_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_timestamping_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_clone_tx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">skb_defer_rx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_NETWORK_PHY_TIMESTAMPING */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_clone_tx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_defer_rx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_NETWORK_PHY_TIMESTAMPING */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * skb_complete_tx_timestamp() - deliver cloned skb with tx timestamps</span>
<span class="cm"> *</span>
<span class="cm"> * PHY drivers may accept clones of transmitted packets for</span>
<span class="cm"> * timestamping via their phy_driver.txtstamp method. These drivers</span>
<span class="cm"> * must call this function to return the skb back to the stack, with</span>
<span class="cm"> * or without a timestamp.</span>
<span class="cm"> *</span>
<span class="cm"> * @skb: clone of the the original outgoing packet</span>
<span class="cm"> * @hwtstamps: hardware time stamps, may be NULL if not available</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">skb_complete_tx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="n">hwtstamps</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * skb_tstamp_tx - queue clone of skb with send time stamps</span>
<span class="cm"> * @orig_skb:	the original outgoing packet</span>
<span class="cm"> * @hwtstamps:	hardware time stamps, may be NULL if not available</span>
<span class="cm"> *</span>
<span class="cm"> * If the skb has a socket associated, then this function clones the</span>
<span class="cm"> * skb (thus sharing the actual data and optional structures), stores</span>
<span class="cm"> * the optional hardware time stamping information (if non NULL) or</span>
<span class="cm"> * generates a software time stamp (otherwise), then queues the clone</span>
<span class="cm"> * to the error queue of the socket.  Errors are silently ignored.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">skb_tstamp_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">orig_skb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="n">hwtstamps</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sw_tx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_SW_TSTAMP</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_IN_PROGRESS</span><span class="p">))</span>
		<span class="n">skb_tstamp_tx</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_tx_timestamp() - Driver hook for transmit timestamping</span>
<span class="cm"> *</span>
<span class="cm"> * Ethernet MAC Drivers should call this function in their hard_xmit()</span>
<span class="cm"> * function immediately before giving the sk_buff to the MAC hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * @skb: A socket buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_tx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_clone_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">sw_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_complete_wifi_ack - deliver skb with wifi status</span>
<span class="cm"> *</span>
<span class="cm"> * @skb: the original outgoing packet</span>
<span class="cm"> * @acked: ack status</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">skb_complete_wifi_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">acked</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">__sum16</span> <span class="n">__skb_checksum_complete_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__sum16</span> <span class="n">__skb_checksum_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_csum_unnecessary</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">&amp;</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_checksum_complete - Calculate checksum of an entire packet</span>
<span class="cm"> *	@skb: packet to process</span>
<span class="cm"> *</span>
<span class="cm"> *	This function calculates the checksum over the entire packet plus</span>
<span class="cm"> *	the value of skb-&gt;csum.  The latter can be used to supply the</span>
<span class="cm"> *	checksum of a pseudo header as used by TCP/UDP.  It returns the</span>
<span class="cm"> *	checksum.</span>
<span class="cm"> *</span>
<span class="cm"> *	For protocols that contain complete checksums such as ICMP/TCP/UDP,</span>
<span class="cm"> *	this function can be used to verify that checksum on received</span>
<span class="cm"> *	packets.  In that case the function should return zero if the</span>
<span class="cm"> *	checksum is correct.  In particular, this function will return zero</span>
<span class="cm"> *	if skb-&gt;ip_summed is CHECKSUM_UNNECESSARY which indicates that the</span>
<span class="cm"> *	hardware has already verified the correctness of the checksum.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__sum16</span> <span class="nf">skb_checksum_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_csum_unnecessary</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">?</span>
	       <span class="mi">0</span> <span class="o">:</span> <span class="n">__skb_checksum_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">nf_conntrack_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack</span> <span class="o">*</span><span class="n">nfct</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_conntrack_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack</span> <span class="o">*</span><span class="n">nfct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfct</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfct</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">))</span>
		<span class="n">nf_conntrack_destroy</span><span class="p">(</span><span class="n">nfct</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_conntrack_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_conntrack</span> <span class="o">*</span><span class="n">nfct</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfct</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfct</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_conntrack_get_reasm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_conntrack_put_reasm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BRIDGE_NETFILTER</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_bridge_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nf_bridge</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nf_bridge</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_bridge_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">nf_bridge_info</span> <span class="o">*</span><span class="n">nf_bridge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nf_bridge</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nf_bridge</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_BRIDGE_NETFILTER */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
	<span class="n">nf_conntrack_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED</span>
	<span class="n">nf_conntrack_put_reasm</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct_reasm</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct_reasm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BRIDGE_NETFILTER</span>
	<span class="n">nf_bridge_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Note: This doesn&#39;t put any conntrack and bridge info in dst. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__nf_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">nfct</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">;</span>
	<span class="n">nf_conntrack_get</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">);</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">nfctinfo</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">nfctinfo</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">nfct_reasm</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">nfct_reasm</span><span class="p">;</span>
	<span class="n">nf_conntrack_get_reasm</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">nfct_reasm</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BRIDGE_NETFILTER</span>
	<span class="n">dst</span><span class="o">-&gt;</span><span class="n">nf_bridge</span>  <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">;</span>
	<span class="n">nf_bridge_get</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nf_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)</span>
	<span class="n">nf_conntrack_put</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED</span>
	<span class="n">nf_conntrack_put_reasm</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">nfct_reasm</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BRIDGE_NETFILTER</span>
	<span class="n">nf_bridge_put</span><span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">__nf_copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NETWORK_SECMARK</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_copy_secmark</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">secmark</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">secmark</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_init_secmark</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">secmark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_copy_secmark</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_init_secmark</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_set_queue_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">queue_mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span> <span class="o">=</span> <span class="n">queue_mapping</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">skb_get_queue_mapping</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_copy_queue_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">queue_mapping</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_record_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rx_queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span> <span class="o">=</span> <span class="n">rx_queue</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">skb_get_rx_queue</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_rx_queue_recorded</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="n">u16</span> <span class="n">__skb_tx_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_tx_queues</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_XFRM</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span><span class="nf">skb_sec_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sec_path</span> <span class="o">*</span><span class="nf">skb_sec_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_is_gso</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_is_gso_v6</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">&amp;</span> <span class="n">SKB_GSO_TCPV6</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">__skb_warn_lro_forwarding</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_warn_if_lro</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* LRO sets gso_size but not gso_type, whereas if GSO is really</span>
<span class="cm">	 * wanted then gso_type will be set. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">shinfo</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__skb_warn_lro_forwarding</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_forward_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Unfortunately we don&#39;t support this one.  Any brave souls? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_checksum_none_assert - make sure skb ip_summed is CHECKSUM_NONE</span>
<span class="cm"> * @skb: skb to check</span>
<span class="cm"> *</span>
<span class="cm"> * fresh skbs have their ip_summed set to CHECKSUM_NONE.</span>
<span class="cm"> * Instead of forcing ip_summed to CHECKSUM_NONE, we can</span>
<span class="cm"> * use this helper, to document places where we make this assertion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_checksum_none_assert</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_NONE</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="n">skb_partial_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">start</span><span class="p">,</span> <span class="n">u16</span> <span class="n">off</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_is_recycleable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">skb_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">!=</span> <span class="n">SKB_FCLONE_UNAVAILABLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">skb_size</span> <span class="o">=</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="n">skb_size</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_end_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">skb_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shared</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_head_is_locked - Determine if the skb-&gt;head is locked down</span>
<span class="cm"> * @skb: skb to check</span>
<span class="cm"> *</span>
<span class="cm"> * The head on skbs build around a head frag can be removed if they are</span>
<span class="cm"> * not cloned.  This function returns true if the skb head is locked down</span>
<span class="cm"> * due to either being allocated via kmalloc, or by being a clone with</span>
<span class="cm"> * multiple references to the head.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">skb_head_is_locked</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head_frag</span> <span class="o">||</span> <span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif	</span><span class="cm">/* _LINUX_SKBUFF_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
