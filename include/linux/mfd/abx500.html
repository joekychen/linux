<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mfd › abx500.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>abx500.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007-2009 ST-Ericsson AB</span>
<span class="cm"> * License terms: GNU General Public License (GPL) version 2</span>
<span class="cm"> * AB3100 core access functions</span>
<span class="cm"> * Author: Linus Walleij &lt;linus.walleij@stericsson.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * ABX500 core access functions.</span>
<span class="cm"> * The abx500 interface is used for the Analog Baseband chip</span>
<span class="cm"> * ab3100 and ab8500.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Mattias Wallin &lt;mattias.wallin@stericsson.com&gt;</span>
<span class="cm"> * Author: Mattias Nilsson &lt;mattias.i.nilsson@stericsson.com&gt;</span>
<span class="cm"> * Author: Bengt Jonsson &lt;bengt.g.jonsson@stericsson.com&gt;</span>
<span class="cm"> * Author: Rickard Andersson &lt;rickard.andersson@stericsson.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/regulator/machine.h&gt;</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cp">#ifndef MFD_ABX500_H</span>
<span class="cp">#define MFD_ABX500_H</span>

<span class="cp">#define AB3100_P1A	0xc0</span>
<span class="cp">#define AB3100_P1B	0xc1</span>
<span class="cp">#define AB3100_P1C	0xc2</span>
<span class="cp">#define AB3100_P1D	0xc3</span>
<span class="cp">#define AB3100_P1E	0xc4</span>
<span class="cp">#define AB3100_P1F	0xc5</span>
<span class="cp">#define AB3100_P1G	0xc6</span>
<span class="cp">#define AB3100_R2A	0xc7</span>
<span class="cp">#define AB3100_R2B	0xc8</span>

<span class="cm">/*</span>
<span class="cm"> * AB3100, EVENTA1, A2 and A3 event register flags</span>
<span class="cm"> * these are catenated into a single 32-bit flag in the code</span>
<span class="cm"> * for event notification broadcasts.</span>
<span class="cm"> */</span>
<span class="cp">#define AB3100_EVENTA1_ONSWA				(0x01&lt;&lt;16)</span>
<span class="cp">#define AB3100_EVENTA1_ONSWB				(0x02&lt;&lt;16)</span>
<span class="cp">#define AB3100_EVENTA1_ONSWC				(0x04&lt;&lt;16)</span>
<span class="cp">#define AB3100_EVENTA1_DCIO				(0x08&lt;&lt;16)</span>
<span class="cp">#define AB3100_EVENTA1_OVER_TEMP			(0x10&lt;&lt;16)</span>
<span class="cp">#define AB3100_EVENTA1_SIM_OFF				(0x20&lt;&lt;16)</span>
<span class="cp">#define AB3100_EVENTA1_VBUS				(0x40&lt;&lt;16)</span>
<span class="cp">#define AB3100_EVENTA1_VSET_USB				(0x80&lt;&lt;16)</span>

<span class="cp">#define AB3100_EVENTA2_READY_TX				(0x01&lt;&lt;8)</span>
<span class="cp">#define AB3100_EVENTA2_READY_RX				(0x02&lt;&lt;8)</span>
<span class="cp">#define AB3100_EVENTA2_OVERRUN_ERROR			(0x04&lt;&lt;8)</span>
<span class="cp">#define AB3100_EVENTA2_FRAMING_ERROR			(0x08&lt;&lt;8)</span>
<span class="cp">#define AB3100_EVENTA2_CHARG_OVERCURRENT		(0x10&lt;&lt;8)</span>
<span class="cp">#define AB3100_EVENTA2_MIDR				(0x20&lt;&lt;8)</span>
<span class="cp">#define AB3100_EVENTA2_BATTERY_REM			(0x40&lt;&lt;8)</span>
<span class="cp">#define AB3100_EVENTA2_ALARM				(0x80&lt;&lt;8)</span>

<span class="cp">#define AB3100_EVENTA3_ADC_TRIG5			(0x01)</span>
<span class="cp">#define AB3100_EVENTA3_ADC_TRIG4			(0x02)</span>
<span class="cp">#define AB3100_EVENTA3_ADC_TRIG3			(0x04)</span>
<span class="cp">#define AB3100_EVENTA3_ADC_TRIG2			(0x08)</span>
<span class="cp">#define AB3100_EVENTA3_ADC_TRIGVBAT			(0x10)</span>
<span class="cp">#define AB3100_EVENTA3_ADC_TRIGVTX			(0x20)</span>
<span class="cp">#define AB3100_EVENTA3_ADC_TRIG1			(0x40)</span>
<span class="cp">#define AB3100_EVENTA3_ADC_TRIG0			(0x80)</span>

<span class="cm">/* AB3100, STR register flags */</span>
<span class="cp">#define AB3100_STR_ONSWA				(0x01)</span>
<span class="cp">#define AB3100_STR_ONSWB				(0x02)</span>
<span class="cp">#define AB3100_STR_ONSWC				(0x04)</span>
<span class="cp">#define AB3100_STR_DCIO					(0x08)</span>
<span class="cp">#define AB3100_STR_BOOT_MODE				(0x10)</span>
<span class="cp">#define AB3100_STR_SIM_OFF				(0x20)</span>
<span class="cp">#define AB3100_STR_BATT_REMOVAL				(0x40)</span>
<span class="cp">#define AB3100_STR_VBUS					(0x80)</span>

<span class="cm">/*</span>
<span class="cm"> * AB3100 contains 8 regulators, one external regulator controller</span>
<span class="cm"> * and a buck converter, further the LDO E and buck converter can</span>
<span class="cm"> * have separate settings if they are in sleep mode, this is</span>
<span class="cm"> * modeled as a separate regulator.</span>
<span class="cm"> */</span>
<span class="cp">#define AB3100_NUM_REGULATORS				10</span>

<span class="cm">/**</span>
<span class="cm"> * struct ab3100</span>
<span class="cm"> * @access_mutex: lock out concurrent accesses to the AB3100 registers</span>
<span class="cm"> * @dev: pointer to the containing device</span>
<span class="cm"> * @i2c_client: I2C client for this chip</span>
<span class="cm"> * @testreg_client: secondary client for test registers</span>
<span class="cm"> * @chip_name: name of this chip variant</span>
<span class="cm"> * @chip_id: 8 bit chip ID for this chip variant</span>
<span class="cm"> * @event_subscribers: event subscribers are listed here</span>
<span class="cm"> * @startup_events: a copy of the first reading of the event registers</span>
<span class="cm"> * @startup_events_read: whether the first events have been read</span>
<span class="cm"> *</span>
<span class="cm"> * This struct is PRIVATE and devices using it should NOT</span>
<span class="cm"> * access ANY fields. It is used as a token for calling the</span>
<span class="cm"> * AB3100 functions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ab3100</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">access_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">i2c_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">testreg_client</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">chip_name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">chip_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="n">event_subscribers</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">startup_events</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">startup_events_read</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ab3100_platform_data</span>
<span class="cm"> * Data supplied to initialize board connections to the AB3100</span>
<span class="cm"> * @reg_constraints: regulator constraints for target board</span>
<span class="cm"> *     the order of these constraints are: LDO A, C, D, E,</span>
<span class="cm"> *     F, G, H, K, EXT and BUCK.</span>
<span class="cm"> * @reg_initvals: initial values for the regulator registers</span>
<span class="cm"> *     plus two sleep settings for LDO E and the BUCK converter.</span>
<span class="cm"> *     exactly AB3100_NUM_REGULATORS+2 values must be sent in.</span>
<span class="cm"> *     Order: LDO A, C, E, E sleep, F, G, H, K, EXT, BUCK,</span>
<span class="cm"> *     BUCK sleep, LDO D. (LDO D need to be initialized last.)</span>
<span class="cm"> * @external_voltage: voltage level of the external regulator.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ab3100_platform_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">regulator_init_data</span> <span class="n">reg_constraints</span><span class="p">[</span><span class="n">AB3100_NUM_REGULATORS</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">reg_initvals</span><span class="p">[</span><span class="n">AB3100_NUM_REGULATORS</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">external_voltage</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">ab3100_event_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ab3100</span> <span class="o">*</span><span class="n">ab3100</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ab3100_event_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">ab3100</span> <span class="o">*</span><span class="n">ab3100</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_init_setting</span>
<span class="cm"> * Initial value of the registers for driver to use during setup.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_init_settings</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">bank</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">setting</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Battery driver related data */</span>
<span class="cm">/*</span>
<span class="cm"> * ADC for the battery thermistor.</span>
<span class="cm"> * When using the ABx500_ADC_THERM_BATCTRL the battery ID resistor is combined</span>
<span class="cm"> * with a NTC resistor to both identify the battery and to measure its</span>
<span class="cm"> * temperature. Different phone manufactures uses different techniques to both</span>
<span class="cm"> * identify the battery and to read its temperature.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">abx500_adc_therm</span> <span class="p">{</span>
	<span class="n">ABx500_ADC_THERM_BATCTRL</span><span class="p">,</span>
	<span class="n">ABx500_ADC_THERM_BATTEMP</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_res_to_temp - defines one point in a temp to res curve. To</span>
<span class="cm"> * be used in battery packs that combines the identification resistor with a</span>
<span class="cm"> * NTC resistor.</span>
<span class="cm"> * @temp:			battery pack temperature in Celcius</span>
<span class="cm"> * @resist:			NTC resistor net total resistance</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_res_to_temp</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">resist</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_v_to_cap - Table for translating voltage to capacity</span>
<span class="cm"> * @voltage:		Voltage in mV</span>
<span class="cm"> * @capacity:		Capacity in percent</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_v_to_cap</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">voltage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Forward declaration */</span>
<span class="k">struct</span> <span class="n">abx500_fg</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_fg_parameters - Fuel gauge algorithm parameters, in seconds</span>
<span class="cm"> * if not specified</span>
<span class="cm"> * @recovery_sleep_timer:	Time between measurements while recovering</span>
<span class="cm"> * @recovery_total_time:	Total recovery time</span>
<span class="cm"> * @init_timer:			Measurement interval during startup</span>
<span class="cm"> * @init_discard_time:		Time we discard voltage measurement at startup</span>
<span class="cm"> * @init_total_time:		Total init time during startup</span>
<span class="cm"> * @high_curr_time:		Time current has to be high to go to recovery</span>
<span class="cm"> * @accu_charging:		FG accumulation time while charging</span>
<span class="cm"> * @accu_high_curr:		FG accumulation time in high current mode</span>
<span class="cm"> * @high_curr_threshold:	High current threshold, in mA</span>
<span class="cm"> * @lowbat_threshold:		Low battery threshold, in mV</span>
<span class="cm"> * @overbat_threshold:		Over battery threshold, in mV</span>
<span class="cm"> * @battok_falling_th_sel0	Threshold in mV for battOk signal sel0</span>
<span class="cm"> *				Resolution in 50 mV step.</span>
<span class="cm"> * @battok_raising_th_sel1	Threshold in mV for battOk signal sel1</span>
<span class="cm"> *				Resolution in 50 mV step.</span>
<span class="cm"> * @user_cap_limit		Capacity reported from user must be within this</span>
<span class="cm"> *				limit to be considered as sane, in percentage</span>
<span class="cm"> *				points.</span>
<span class="cm"> * @maint_thres			This is the threshold where we stop reporting</span>
<span class="cm"> *				battery full while in maintenance, in per cent</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_fg_parameters</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">recovery_sleep_timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recovery_total_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">init_timer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">init_discard_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">init_total_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">high_curr_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">accu_charging</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">accu_high_curr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">high_curr_threshold</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lowbat_threshold</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">overbat_threshold</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">battok_falling_th_sel0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">battok_raising_th_sel1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">user_cap_limit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maint_thres</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_charger_maximization - struct used by the board config.</span>
<span class="cm"> * @use_maxi:		Enable maximization for this battery type</span>
<span class="cm"> * @maxi_chg_curr:	Maximum charger current allowed</span>
<span class="cm"> * @maxi_wait_cycles:	cycles to wait before setting charger current</span>
<span class="cm"> * @charger_curr_step	delta between two charger current settings (mA)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_maxim_parameters</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">ena_maxi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chg_curr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait_cycles</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">charger_curr_step</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_battery_type - different batteries supported</span>
<span class="cm"> * @name:			battery technology</span>
<span class="cm"> * @resis_high:			battery upper resistance limit</span>
<span class="cm"> * @resis_low:			battery lower resistance limit</span>
<span class="cm"> * @charge_full_design:		Maximum battery capacity in mAh</span>
<span class="cm"> * @nominal_voltage:		Nominal voltage of the battery in mV</span>
<span class="cm"> * @termination_vol:		max voltage upto which battery can be charged</span>
<span class="cm"> * @termination_curr		battery charging termination current in mA</span>
<span class="cm"> * @recharge_vol		battery voltage limit that will trigger a new</span>
<span class="cm"> *				full charging cycle in the case where maintenan-</span>
<span class="cm"> *				-ce charging has been disabled</span>
<span class="cm"> * @normal_cur_lvl:		charger current in normal state in mA</span>
<span class="cm"> * @normal_vol_lvl:		charger voltage in normal state in mV</span>
<span class="cm"> * @maint_a_cur_lvl:		charger current in maintenance A state in mA</span>
<span class="cm"> * @maint_a_vol_lvl:		charger voltage in maintenance A state in mV</span>
<span class="cm"> * @maint_a_chg_timer_h:	charge time in maintenance A state</span>
<span class="cm"> * @maint_b_cur_lvl:		charger current in maintenance B state in mA</span>
<span class="cm"> * @maint_b_vol_lvl:		charger voltage in maintenance B state in mV</span>
<span class="cm"> * @maint_b_chg_timer_h:	charge time in maintenance B state</span>
<span class="cm"> * @low_high_cur_lvl:		charger current in temp low/high state in mA</span>
<span class="cm"> * @low_high_vol_lvl:		charger voltage in temp low/high state in mV&#39;</span>
<span class="cm"> * @battery_resistance:		battery inner resistance in mOhm.</span>
<span class="cm"> * @n_r_t_tbl_elements:		number of elements in r_to_t_tbl</span>
<span class="cm"> * @r_to_t_tbl:			table containing resistance to temp points</span>
<span class="cm"> * @n_v_cap_tbl_elements:	number of elements in v_to_cap_tbl</span>
<span class="cm"> * @v_to_cap_tbl:		Voltage to capacity (in %) table</span>
<span class="cm"> * @n_batres_tbl_elements	number of elements in the batres_tbl</span>
<span class="cm"> * @batres_tbl			battery internal resistance vs temperature table</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_battery_type</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">resis_high</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">resis_low</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">charge_full_design</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nominal_voltage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">termination_vol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">termination_curr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recharge_vol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">normal_cur_lvl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">normal_vol_lvl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maint_a_cur_lvl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maint_a_vol_lvl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maint_a_chg_timer_h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maint_b_cur_lvl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maint_b_vol_lvl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maint_b_chg_timer_h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">low_high_cur_lvl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">low_high_vol_lvl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">battery_resistance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_temp_tbl_elements</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">abx500_res_to_temp</span> <span class="o">*</span><span class="n">r_to_t_tbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_v_cap_tbl_elements</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">abx500_v_to_cap</span> <span class="o">*</span><span class="n">v_to_cap_tbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_batres_tbl_elements</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">batres_vs_temp</span> <span class="o">*</span><span class="n">batres_tbl</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_bm_capacity_levels - abx500 capacity level data</span>
<span class="cm"> * @critical:		critical capacity level in percent</span>
<span class="cm"> * @low:		low capacity level in percent</span>
<span class="cm"> * @normal:		normal capacity level in percent</span>
<span class="cm"> * @high:		high capacity level in percent</span>
<span class="cm"> * @full:		full capacity level in percent</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_bm_capacity_levels</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">critical</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">low</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">normal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">high</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">full</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_bm_charger_parameters - Charger specific parameters</span>
<span class="cm"> * @usb_volt_max:	maximum allowed USB charger voltage in mV</span>
<span class="cm"> * @usb_curr_max:	maximum allowed USB charger current in mA</span>
<span class="cm"> * @ac_volt_max:	maximum allowed AC charger voltage in mV</span>
<span class="cm"> * @ac_curr_max:	maximum allowed AC charger current in mA</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_bm_charger_parameters</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">usb_volt_max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">usb_curr_max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ac_volt_max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ac_curr_max</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct abx500_bm_data - abx500 battery management data</span>
<span class="cm"> * @temp_under		under this temp, charging is stopped</span>
<span class="cm"> * @temp_low		between this temp and temp_under charging is reduced</span>
<span class="cm"> * @temp_high		between this temp and temp_over charging is reduced</span>
<span class="cm"> * @temp_over		over this temp, charging is stopped</span>
<span class="cm"> * @temp_now		present battery temperature</span>
<span class="cm"> * @temp_interval_chg	temperature measurement interval in s when charging</span>
<span class="cm"> * @temp_interval_nochg	temperature measurement interval in s when not charging</span>
<span class="cm"> * @main_safety_tmr_h	safety timer for main charger</span>
<span class="cm"> * @usb_safety_tmr_h	safety timer for usb charger</span>
<span class="cm"> * @bkup_bat_v		voltage which we charge the backup battery with</span>
<span class="cm"> * @bkup_bat_i		current which we charge the backup battery with</span>
<span class="cm"> * @no_maintenance	indicates that maintenance charging is disabled</span>
<span class="cm"> * @abx500_adc_therm	placement of thermistor, batctrl or battemp adc</span>
<span class="cm"> * @chg_unknown_bat	flag to enable charging of unknown batteries</span>
<span class="cm"> * @enable_overshoot	flag to enable VBAT overshoot control</span>
<span class="cm"> * @auto_trig		flag to enable auto adc trigger</span>
<span class="cm"> * @fg_res		resistance of FG resistor in 0.1mOhm</span>
<span class="cm"> * @n_btypes		number of elements in array bat_type</span>
<span class="cm"> * @batt_id		index of the identified battery in array bat_type</span>
<span class="cm"> * @interval_charging	charge alg cycle period time when charging (sec)</span>
<span class="cm"> * @interval_not_charging charge alg cycle period time when not charging (sec)</span>
<span class="cm"> * @temp_hysteresis	temperature hysteresis</span>
<span class="cm"> * @gnd_lift_resistance	Battery ground to phone ground resistance (mOhm)</span>
<span class="cm"> * @maxi:		maximization parameters</span>
<span class="cm"> * @cap_levels		capacity in percent for the different capacity levels</span>
<span class="cm"> * @bat_type		table of supported battery types</span>
<span class="cm"> * @chg_params		charger parameters</span>
<span class="cm"> * @fg_params		fuel gauge parameters</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">abx500_bm_data</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">temp_under</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_low</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_high</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_over</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_interval_chg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_interval_nochg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">main_safety_tmr_h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">usb_safety_tmr_h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bkup_bat_v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bkup_bat_i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">no_maintenance</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">chg_unknown_bat</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">enable_overshoot</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">auto_trig</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">abx500_adc_therm</span> <span class="n">adc_therm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fg_res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_btypes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">batt_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">interval_charging</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">interval_not_charging</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_hysteresis</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gnd_lift_resistance</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">abx500_maxim_parameters</span> <span class="o">*</span><span class="n">maxi</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">abx500_bm_capacity_levels</span> <span class="o">*</span><span class="n">cap_levels</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">abx500_battery_type</span> <span class="o">*</span><span class="n">bat_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">abx500_bm_charger_parameters</span> <span class="o">*</span><span class="n">chg_params</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">abx500_fg_parameters</span> <span class="o">*</span><span class="n">fg_params</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">abx500_chargalg_platform_data</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">supplied_to</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">num_supplicants</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">abx500_charger_platform_data</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">supplied_to</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">num_supplicants</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">autopower_cfg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">abx500_btemp_platform_data</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">supplied_to</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">num_supplicants</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">abx500_fg_platform_data</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">supplied_to</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">num_supplicants</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">abx500_bm_plat_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">abx500_bm_data</span> <span class="o">*</span><span class="n">battery</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">abx500_charger_platform_data</span> <span class="o">*</span><span class="n">charger</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">abx500_btemp_platform_data</span> <span class="o">*</span><span class="n">btemp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">abx500_fg_platform_data</span> <span class="o">*</span><span class="n">fg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">abx500_chargalg_platform_data</span> <span class="o">*</span><span class="n">chargalg</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">abx500_set_register_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">abx500_get_register_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">abx500_get_register_page_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">first_reg</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">regvals</span><span class="p">,</span> <span class="n">u8</span> <span class="n">numregs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">abx500_set_register_page_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">first_reg</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">regvals</span><span class="p">,</span> <span class="n">u8</span> <span class="n">numregs</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * abx500_mask_and_set_register_inerruptible() - Modifies selected bits of a</span>
<span class="cm"> *	target register</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: The AB sub device.</span>
<span class="cm"> * @bank: The i2c bank number.</span>
<span class="cm"> * @bitmask: The bit mask to use.</span>
<span class="cm"> * @bitvalues: The new bit values.</span>
<span class="cm"> *</span>
<span class="cm"> * Updates the value of an AB register:</span>
<span class="cm"> * value -&gt; ((value &amp; ~bitmask) | (bitvalues &amp; bitmask))</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">abx500_mask_and_set_register_interruptible</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bank</span><span class="p">,</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">u8</span> <span class="n">bitvalues</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">abx500_get_chip_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">abx500_event_registers_startup_state_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">abx500_startup_irq_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">abx500_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_chip_id</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_register</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_register</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_register_page</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_register_page</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mask_and_set_register</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">event_registers_startup_state_get</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">startup_irq_enabled</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">abx500_register_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">core_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">abx500_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">abx500_remove_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
