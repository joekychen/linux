<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mfd › stmpe.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>stmpe.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) ST-Ericsson SA 2010</span>
<span class="cm"> *</span>
<span class="cm"> * License Terms: GNU General Public License, version 2</span>
<span class="cm"> * Author: Rabin Vincent &lt;rabin.vincent@stericsson.com&gt; for ST-Ericsson</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_MFD_STMPE_H</span>
<span class="cp">#define __LINUX_MFD_STMPE_H</span>

<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">stmpe_block</span> <span class="p">{</span>
	<span class="n">STMPE_BLOCK_GPIO</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">STMPE_BLOCK_KEYPAD</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">STMPE_BLOCK_TOUCHSCREEN</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">STMPE_BLOCK_ADC</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">STMPE_BLOCK_PWM</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">STMPE_BLOCK_ROTATOR</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">stmpe_partnum</span> <span class="p">{</span>
	<span class="n">STMPE610</span><span class="p">,</span>
	<span class="n">STMPE801</span><span class="p">,</span>
	<span class="n">STMPE811</span><span class="p">,</span>
	<span class="n">STMPE1601</span><span class="p">,</span>
	<span class="n">STMPE2401</span><span class="p">,</span>
	<span class="n">STMPE2403</span><span class="p">,</span>
	<span class="n">STMPE_NBR_PARTS</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * For registers whose locations differ on variants,  the correct address is</span>
<span class="cm"> * obtained by indexing stmpe-&gt;regs with one of the following.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">STMPE_IDX_CHIP_ID</span><span class="p">,</span>
	<span class="n">STMPE_IDX_ICR_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_IER_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_ISR_MSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_GPMR_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_GPSR_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_GPCR_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_GPDR_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_GPEDR_MSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_GPRER_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_GPFER_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_GPAFR_U_MSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_IEGPIOR_LSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_ISGPIOR_MSB</span><span class="p">,</span>
	<span class="n">STMPE_IDX_MAX</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">stmpe_variant_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">stmpe_client_info</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct stmpe - STMPE MFD structure</span>
<span class="cm"> * @lock: lock protecting I/O operations</span>
<span class="cm"> * @irq_lock: IRQ bus lock</span>
<span class="cm"> * @dev: device, mostly for dev_dbg()</span>
<span class="cm"> * @client: client - i2c or spi</span>
<span class="cm"> * @ci: client specific information</span>
<span class="cm"> * @partnum: part number</span>
<span class="cm"> * @variant: the detected STMPE model number</span>
<span class="cm"> * @regs: list of addresses of registers which are at different addresses on</span>
<span class="cm"> *	  different variants.  Indexed by one of STMPE_IDX_*.</span>
<span class="cm"> * @irq: irq number for stmpe</span>
<span class="cm"> * @irq_base: starting IRQ number for internal IRQs</span>
<span class="cm"> * @num_gpios: number of gpios, differs for variants</span>
<span class="cm"> * @ier: cache of IER registers for bus_lock</span>
<span class="cm"> * @oldier: cache of IER registers for bus_lock</span>
<span class="cm"> * @pdata: platform data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">stmpe</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">irq_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stmpe_client_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">stmpe_partnum</span> <span class="n">partnum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stmpe_variant_info</span> <span class="o">*</span><span class="n">variant</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_gpios</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ier</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">oldier</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">stmpe_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">stmpe_reg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stmpe_reg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stmpe_block_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">length</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stmpe_block_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">length</span><span class="p">,</span>
			     <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stmpe_set_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stmpe_set_altfunc</span><span class="p">(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pins</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">stmpe_block</span> <span class="n">block</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stmpe_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">stmpe_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocks</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">matrix_keymap_data</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct stmpe_keypad_platform_data - STMPE keypad platform data</span>
<span class="cm"> * @keymap_data: key map table and size</span>
<span class="cm"> * @debounce_ms: debounce interval, in ms.  Maximum is</span>
<span class="cm"> *		 %STMPE_KEYPAD_MAX_DEBOUNCE.</span>
<span class="cm"> * @scan_count: number of key scanning cycles to confirm key data.</span>
<span class="cm"> *		Maximum is %STMPE_KEYPAD_MAX_SCAN_COUNT.</span>
<span class="cm"> * @no_autorepeat: disable key autorepeat</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">stmpe_keypad_platform_data</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">matrix_keymap_data</span> <span class="o">*</span><span class="n">keymap_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">debounce_ms</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan_count</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">no_autorepeat</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define STMPE_GPIO_NOREQ_811_TOUCH	(0xf0)</span>

<span class="cm">/**</span>
<span class="cm"> * struct stmpe_gpio_platform_data - STMPE GPIO platform data</span>
<span class="cm"> * @gpio_base: first gpio number assigned.  A maximum of</span>
<span class="cm"> *	       %STMPE_NR_GPIOS GPIOs will be allocated.</span>
<span class="cm"> * @norequest_mask: bitmask specifying which GPIOs should _not_ be</span>
<span class="cm"> *		    requestable due to different usage (e.g. touch, keypad)</span>
<span class="cm"> *		    STMPE_GPIO_NOREQ_* macros can be used here.</span>
<span class="cm"> * @setup: board specific setup callback.</span>
<span class="cm"> * @remove: board specific remove callback</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">stmpe_gpio_platform_data</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">gpio_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">norequest_mask</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">gpio_base</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">stmpe</span> <span class="o">*</span><span class="n">stmpe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">gpio_base</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct stmpe_ts_platform_data - stmpe811 touch screen controller platform</span>
<span class="cm"> * data</span>
<span class="cm"> * @sample_time: ADC converstion time in number of clock.</span>
<span class="cm"> * (0 -&gt; 36 clocks, 1 -&gt; 44 clocks, 2 -&gt; 56 clocks, 3 -&gt; 64 clocks,</span>
<span class="cm"> * 4 -&gt; 80 clocks, 5 -&gt; 96 clocks, 6 -&gt; 144 clocks),</span>
<span class="cm"> * recommended is 4.</span>
<span class="cm"> * @mod_12b: ADC Bit mode (0 -&gt; 10bit ADC, 1 -&gt; 12bit ADC)</span>
<span class="cm"> * @ref_sel: ADC reference source</span>
<span class="cm"> * (0 -&gt; internal reference, 1 -&gt; external reference)</span>
<span class="cm"> * @adc_freq: ADC Clock speed</span>
<span class="cm"> * (0 -&gt; 1.625 MHz, 1 -&gt; 3.25 MHz, 2 || 3 -&gt; 6.5 MHz)</span>
<span class="cm"> * @ave_ctrl: Sample average control</span>
<span class="cm"> * (0 -&gt; 1 sample, 1 -&gt; 2 samples, 2 -&gt; 4 samples, 3 -&gt; 8 samples)</span>
<span class="cm"> * @touch_det_delay: Touch detect interrupt delay</span>
<span class="cm"> * (0 -&gt; 10 us, 1 -&gt; 50 us, 2 -&gt; 100 us, 3 -&gt; 500 us,</span>
<span class="cm"> * 4-&gt; 1 ms, 5 -&gt; 5 ms, 6 -&gt; 10 ms, 7 -&gt; 50 ms)</span>
<span class="cm"> * recommended is 3</span>
<span class="cm"> * @settling: Panel driver settling time</span>
<span class="cm"> * (0 -&gt; 10 us, 1 -&gt; 100 us, 2 -&gt; 500 us, 3 -&gt; 1 ms,</span>
<span class="cm"> * 4 -&gt; 5 ms, 5 -&gt; 10 ms, 6 for 50 ms, 7 -&gt; 100 ms)</span>
<span class="cm"> * recommended is 2</span>
<span class="cm"> * @fraction_z: Length of the fractional part in z</span>
<span class="cm"> * (fraction_z ([0..7]) = Count of the fractional part)</span>
<span class="cm"> * recommended is 7</span>
<span class="cm"> * @i_drive: current limit value of the touchscreen drivers</span>
<span class="cm"> * (0 -&gt; 20 mA typical 35 mA max, 1 -&gt; 50 mA typical 80 mA max)</span>
<span class="cm"> *</span>
<span class="cm"> * */</span>
<span class="k">struct</span> <span class="n">stmpe_ts_platform_data</span> <span class="p">{</span>
       <span class="n">u8</span> <span class="n">sample_time</span><span class="p">;</span>
       <span class="n">u8</span> <span class="n">mod_12b</span><span class="p">;</span>
       <span class="n">u8</span> <span class="n">ref_sel</span><span class="p">;</span>
       <span class="n">u8</span> <span class="n">adc_freq</span><span class="p">;</span>
       <span class="n">u8</span> <span class="n">ave_ctrl</span><span class="p">;</span>
       <span class="n">u8</span> <span class="n">touch_det_delay</span><span class="p">;</span>
       <span class="n">u8</span> <span class="n">settling</span><span class="p">;</span>
       <span class="n">u8</span> <span class="n">fraction_z</span><span class="p">;</span>
       <span class="n">u8</span> <span class="n">i_drive</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct stmpe_platform_data - STMPE platform data</span>
<span class="cm"> * @id: device id to distinguish between multiple STMPEs on the same board</span>
<span class="cm"> * @blocks: bitmask of blocks to enable (use STMPE_BLOCK_*)</span>
<span class="cm"> * @irq_trigger: IRQ trigger to use for the interrupt to the host</span>
<span class="cm"> * @irq_invert_polarity: IRQ line is connected with reversed polarity</span>
<span class="cm"> * @autosleep: bool to enable/disable stmpe autosleep</span>
<span class="cm"> * @autosleep_timeout: inactivity timeout in milliseconds for autosleep</span>
<span class="cm"> * @irq_base: base IRQ number.  %STMPE_NR_IRQS irqs will be used, or</span>
<span class="cm"> *	      %STMPE_NR_INTERNAL_IRQS if the GPIO driver is not used.</span>
<span class="cm"> * @irq_over_gpio: true if gpio is used to get irq</span>
<span class="cm"> * @irq_gpio: gpio number over which irq will be requested (significant only if</span>
<span class="cm"> *	      irq_over_gpio is true)</span>
<span class="cm"> * @gpio: GPIO-specific platform data</span>
<span class="cm"> * @keypad: keypad-specific platform data</span>
<span class="cm"> * @ts: touchscreen-specific platform data</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">stmpe_platform_data</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_trigger</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">irq_invert_polarity</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">autosleep</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">irq_over_gpio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_gpio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">autosleep_timeout</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">stmpe_gpio_platform_data</span> <span class="o">*</span><span class="n">gpio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stmpe_keypad_platform_data</span> <span class="o">*</span><span class="n">keypad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stmpe_ts_platform_data</span> <span class="o">*</span><span class="n">ts</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define STMPE_NR_INTERNAL_IRQS	9</span>
<span class="cp">#define STMPE_INT_GPIO(x)	(STMPE_NR_INTERNAL_IRQS + (x))</span>

<span class="cp">#define STMPE_NR_GPIOS		24</span>
<span class="cp">#define STMPE_NR_IRQS		STMPE_INT_GPIO(STMPE_NR_GPIOS)</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
