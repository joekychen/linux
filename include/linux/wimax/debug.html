<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › wimax › debug.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>debug.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux WiMAX</span>
<span class="cm"> * Collection of tools to manage debug operations.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2007 Intel Corporation</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Don&#39;t #include this file directly, read on!</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * EXECUTING DEBUGGING ACTIONS OR NOT</span>
<span class="cm"> *</span>
<span class="cm"> * The main thing this framework provides is decission power to take a</span>
<span class="cm"> * debug action (like printing a message) if the current debug level</span>
<span class="cm"> * allows it.</span>
<span class="cm"> *</span>
<span class="cm"> * The decission power is at two levels: at compile-time (what does</span>
<span class="cm"> * not make it is compiled out) and at run-time. The run-time</span>
<span class="cm"> * selection is done per-submodule (as they are declared by the user</span>
<span class="cm"> * of the framework).</span>
<span class="cm"> *</span>
<span class="cm"> * A call to d_test(L) (L being the target debug level) returns true</span>
<span class="cm"> * if the action should be taken because the current debug levels</span>
<span class="cm"> * allow it (both compile and run time).</span>
<span class="cm"> *</span>
<span class="cm"> * It follows that a call to d_test() that can be determined to be</span>
<span class="cm"> * always false at compile time will get the code depending on it</span>
<span class="cm"> * compiled out by optimization.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * DEBUG LEVELS</span>
<span class="cm"> *</span>
<span class="cm"> * It is up to the caller to define how much a debugging level is.</span>
<span class="cm"> *</span>
<span class="cm"> * Convention sets 0 as &quot;no debug&quot; (so an action marked as debug level 0</span>
<span class="cm"> * will always be taken). The increasing debug levels are used for</span>
<span class="cm"> * increased verbosity.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * USAGE</span>
<span class="cm"> *</span>
<span class="cm"> * Group the code in modules and submodules inside each module [which</span>
<span class="cm"> * in most cases maps to Linux modules and .c files that compose</span>
<span class="cm"> * those].</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * For each module, there is:</span>
<span class="cm"> *</span>
<span class="cm"> *  - a MODULENAME (single word, legal C identifier)</span>
<span class="cm"> *</span>
<span class="cm"> *  - a debug-levels.h header file that declares the list of</span>
<span class="cm"> *    submodules and that is included by all .c files that use</span>
<span class="cm"> *    the debugging tools. The file name can be anything.</span>
<span class="cm"> *</span>
<span class="cm"> *  - some (optional) .c code to manipulate the runtime debug levels</span>
<span class="cm"> *    through debugfs.</span>
<span class="cm"> *</span>
<span class="cm"> * The debug-levels.h file would look like:</span>
<span class="cm"> *</span>
<span class="cm"> *     #ifndef __debug_levels__h__</span>
<span class="cm"> *     #define __debug_levels__h__</span>
<span class="cm"> *</span>
<span class="cm"> *     #define D_MODULENAME modulename</span>
<span class="cm"> *     #define D_MASTER 10</span>
<span class="cm"> *</span>
<span class="cm"> *     #include &lt;linux/wimax/debug.h&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *     enum d_module {</span>
<span class="cm"> *             D_SUBMODULE_DECLARE(submodule_1),</span>
<span class="cm"> *             D_SUBMODULE_DECLARE(submodule_2),</span>
<span class="cm"> *             ...</span>
<span class="cm"> *             D_SUBMODULE_DECLARE(submodule_N)</span>
<span class="cm"> *     };</span>
<span class="cm"> *</span>
<span class="cm"> *     #endif</span>
<span class="cm"> *</span>
<span class="cm"> * D_MASTER is the maximum compile-time debug level; any debug actions</span>
<span class="cm"> * above this will be out. D_MODULENAME is the module name (legal C</span>
<span class="cm"> * identifier), which has to be unique for each module (to avoid</span>
<span class="cm"> * namespace collisions during linkage). Note those #defines need to</span>
<span class="cm"> * be done before #including debug.h</span>
<span class="cm"> *</span>
<span class="cm"> * We declare N different submodules whose debug level can be</span>
<span class="cm"> * independently controlled during runtime.</span>
<span class="cm"> *</span>
<span class="cm"> * In a .c file of the module (and only in one of them), define the</span>
<span class="cm"> * following code:</span>
<span class="cm"> *</span>
<span class="cm"> *     struct d_level D_LEVEL[] = {</span>
<span class="cm"> *             D_SUBMODULE_DEFINE(submodule_1),</span>
<span class="cm"> *             D_SUBMODULE_DEFINE(submodule_2),</span>
<span class="cm"> *             ...</span>
<span class="cm"> *             D_SUBMODULE_DEFINE(submodule_N),</span>
<span class="cm"> *     };</span>
<span class="cm"> *     size_t D_LEVEL_SIZE = ARRAY_SIZE(D_LEVEL);</span>
<span class="cm"> *</span>
<span class="cm"> * Externs for d_level_MODULENAME and d_level_size_MODULENAME are used</span>
<span class="cm"> * and declared in this file using the D_LEVEL and D_LEVEL_SIZE macros</span>
<span class="cm"> * #defined also in this file.</span>
<span class="cm"> *</span>
<span class="cm"> * To manipulate from user space the levels, create a debugfs dentry</span>
<span class="cm"> * and then register each submodule with:</span>
<span class="cm"> *</span>
<span class="cm"> *     result = d_level_register_debugfs(&quot;PREFIX_&quot;, submodule_X, parent);</span>
<span class="cm"> *     if (result &lt; 0)</span>
<span class="cm"> *            goto error;</span>
<span class="cm"> *</span>
<span class="cm"> * Where PREFIX_ is a name of your chosing. This will create debugfs</span>
<span class="cm"> * file with a single numeric value that can be use to tweak it. To</span>
<span class="cm"> * remove the entires, just use debugfs_remove_recursive() on &#39;parent&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: remember that even if this will show attached to some</span>
<span class="cm"> *     particular instance of a device, the settings are *global*.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * On each submodule (for example, .c files), the debug infrastructure</span>
<span class="cm"> * should be included like this:</span>
<span class="cm"> *</span>
<span class="cm"> *     #define D_SUBMODULE submodule_x     // matches one in debug-levels.h</span>
<span class="cm"> *     #include &quot;debug-levels.h&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * after #including all your include files.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Now you can use the d_*() macros below [d_test(), d_fnstart(),</span>
<span class="cm"> * d_fnend(), d_printf(), d_dump()].</span>
<span class="cm"> *</span>
<span class="cm"> * If their debug level is greater than D_MASTER, they will be</span>
<span class="cm"> * compiled out.</span>
<span class="cm"> *</span>
<span class="cm"> * If their debug level is lower or equal than D_MASTER but greater</span>
<span class="cm"> * than the current debug level of their submodule, they&#39;ll be</span>
<span class="cm"> * ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, the action will be performed.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __debug__h__</span>
<span class="cp">#define __debug__h__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>

<span class="cm">/* Backend stuff */</span>

<span class="cm">/*</span>
<span class="cm"> * Debug backend: generate a message header from a &#39;struct device&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * @head: buffer where to place the header</span>
<span class="cm"> * @head_size: length of @head</span>
<span class="cm"> * @dev: pointer to device used to generate a header from. If NULL,</span>
<span class="cm"> *     an empty (&quot;&quot;) header is generated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">__d_head</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">head_size</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;E: Corrupt dev %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">head_size</span><span class="p">,</span> <span class="s">&quot;%s %s: &quot;</span><span class="p">,</span>
			 <span class="n">dev_driver_string</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Debug backend: log some message if debugging is enabled</span>
<span class="cm"> *</span>
<span class="cm"> * @l: intended debug level</span>
<span class="cm"> * @tag: tag to prefix the message with</span>
<span class="cm"> * @dev: &#39;struct device&#39; associated to this message</span>
<span class="cm"> * @f: printf-like format and arguments</span>
<span class="cm"> *</span>
<span class="cm"> * Note this is optimized out if it doesn&#39;t pass the compile-time</span>
<span class="cm"> * check; however, it is *always* compiled. This is useful to make</span>
<span class="cm"> * sure the printf-like formats and variables are always checked and</span>
<span class="cm"> * they don&#39;t get bit rot if you have all the debugging disabled.</span>
<span class="cm"> */</span>
<span class="cp">#define _d_printf(l, tag, dev, f, a...)					\</span>
<span class="cp">do {									\</span>
<span class="cp">	char head[64];							\</span>
<span class="cp">	if (!d_test(l))							\</span>
<span class="cp">		break;							\</span>
<span class="cp">	__d_head(head, sizeof(head), dev);				\</span>
<span class="cp">	printk(KERN_ERR &quot;%s%s%s: &quot; f, head, __func__, tag, ##a);	\</span>
<span class="cp">} while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * CPP sintatic sugar to generate A_B like symbol names when one of</span>
<span class="cm"> * the arguments is a a preprocessor #define.</span>
<span class="cm"> */</span>
<span class="cp">#define __D_PASTE__(varname, modulename) varname##_##modulename</span>
<span class="cp">#define __D_PASTE(varname, modulename) (__D_PASTE__(varname, modulename))</span>
<span class="cp">#define _D_SUBMODULE_INDEX(_name) (D_SUBMODULE_DECLARE(_name))</span>


<span class="cm">/*</span>
<span class="cm"> * Store a submodule&#39;s runtime debug level and name</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">d_level</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * List of available submodules and their debug levels</span>
<span class="cm"> *</span>
<span class="cm"> * We call them d_level_MODULENAME and d_level_size_MODULENAME; the</span>
<span class="cm"> * macros D_LEVEL and D_LEVEL_SIZE contain the name already for</span>
<span class="cm"> * convenience.</span>
<span class="cm"> *</span>
<span class="cm"> * This array and the size are defined on some .c file that is part of</span>
<span class="cm"> * the current module.</span>
<span class="cm"> */</span>
<span class="cp">#define D_LEVEL __D_PASTE(d_level, D_MODULENAME)</span>
<span class="cp">#define D_LEVEL_SIZE __D_PASTE(d_level_size, D_MODULENAME)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">d_level</span> <span class="n">D_LEVEL</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">size_t</span> <span class="n">D_LEVEL_SIZE</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * Frontend stuff</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Stuff you need to declare prior to using the actual &quot;debug&quot; actions</span>
<span class="cm"> * (defined below).</span>
<span class="cm"> */</span>

<span class="cp">#ifndef D_MODULENAME</span>
<span class="cp">#error D_MODULENAME is not defined in your debug-levels.h file</span>
<span class="cm">/**</span>
<span class="cm"> * D_MODULE - Name of the current module</span>
<span class="cm"> *</span>
<span class="cm"> * #define in your module&#39;s debug-levels.h, making sure it is</span>
<span class="cm"> * unique. This has to be a legal C identifier.</span>
<span class="cm"> */</span>
<span class="cp">#define D_MODULENAME undefined_modulename</span>
<span class="cp">#endif</span>


<span class="cp">#ifndef D_MASTER</span>
<span class="cp">#warning D_MASTER not defined, but debug.h included! [see docs]</span>
<span class="cm">/**</span>
<span class="cm"> * D_MASTER - Compile time maximum debug level</span>
<span class="cm"> *</span>
<span class="cm"> * #define in your debug-levels.h file to the maximum debug level the</span>
<span class="cm"> * runtime code will be allowed to have. This allows you to provide a</span>
<span class="cm"> * main knob.</span>
<span class="cm"> *</span>
<span class="cm"> * Anything above that level will be optimized out of the compile.</span>
<span class="cm"> *</span>
<span class="cm"> * Defaults to zero (no debug code compiled in).</span>
<span class="cm"> *</span>
<span class="cm"> * Maximum one definition per module (at the debug-levels.h file).</span>
<span class="cm"> */</span>
<span class="cp">#define D_MASTER 0</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef D_SUBMODULE</span>
<span class="cp">#error D_SUBMODULE not defined, but debug.h included! [see docs]</span>
<span class="cm">/**</span>
<span class="cm"> * D_SUBMODULE - Name of the current submodule</span>
<span class="cm"> *</span>
<span class="cm"> * #define in your submodule .c file before #including debug-levels.h</span>
<span class="cm"> * to the name of the current submodule as previously declared and</span>
<span class="cm"> * defined with D_SUBMODULE_DECLARE() (in your module&#39;s</span>
<span class="cm"> * debug-levels.h) and D_SUBMODULE_DEFINE().</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to provide runtime-control over the debug levels.</span>
<span class="cm"> *</span>
<span class="cm"> * Maximum one per .c file! Can be shared among different .c files</span>
<span class="cm"> * (meaning they belong to the same submodule categorization).</span>
<span class="cm"> */</span>
<span class="cp">#define D_SUBMODULE undefined_module</span>
<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> * D_SUBMODULE_DECLARE - Declare a submodule for runtime debug level control</span>
<span class="cm"> *</span>
<span class="cm"> * @_name: name of the submodule, restricted to the chars that make up a</span>
<span class="cm"> *     valid C identifier ([a-zA-Z0-9_]).</span>
<span class="cm"> *</span>
<span class="cm"> * Declare in the module&#39;s debug-levels.h header file as:</span>
<span class="cm"> *</span>
<span class="cm"> * enum d_module {</span>
<span class="cm"> *         D_SUBMODULE_DECLARE(submodule_1),</span>
<span class="cm"> *         D_SUBMODULE_DECLARE(submodule_2),</span>
<span class="cm"> *         D_SUBMODULE_DECLARE(submodule_3),</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * Some corresponding .c file needs to have a matching</span>
<span class="cm"> * D_SUBMODULE_DEFINE().</span>
<span class="cm"> */</span>
<span class="cp">#define D_SUBMODULE_DECLARE(_name) __D_SUBMODULE_##_name</span>


<span class="cm">/**</span>
<span class="cm"> * D_SUBMODULE_DEFINE - Define a submodule for runtime debug level control</span>
<span class="cm"> *</span>
<span class="cm"> * @_name: name of the submodule, restricted to the chars that make up a</span>
<span class="cm"> *     valid C identifier ([a-zA-Z0-9_]).</span>
<span class="cm"> *</span>
<span class="cm"> * Use once per module (in some .c file) as:</span>
<span class="cm"> *</span>
<span class="cm"> * static</span>
<span class="cm"> * struct d_level d_level_SUBMODULENAME[] = {</span>
<span class="cm"> *         D_SUBMODULE_DEFINE(submodule_1),</span>
<span class="cm"> *         D_SUBMODULE_DEFINE(submodule_2),</span>
<span class="cm"> *         D_SUBMODULE_DEFINE(submodule_3),</span>
<span class="cm"> * };</span>
<span class="cm"> * size_t d_level_size_SUBDMODULENAME = ARRAY_SIZE(d_level_SUBDMODULENAME);</span>
<span class="cm"> *</span>
<span class="cm"> * Matching D_SUBMODULE_DECLARE()s have to be present in a</span>
<span class="cm"> * debug-levels.h header file.</span>
<span class="cm"> */</span>
<span class="cp">#define D_SUBMODULE_DEFINE(_name)		\</span>
<span class="cp">[__D_SUBMODULE_##_name] = {			\</span>
<span class="cp">	.level = 0,				\</span>
<span class="cp">	.name = #_name				\</span>
<span class="cp">}</span>



<span class="cm">/* The actual &quot;debug&quot; operations */</span>


<span class="cm">/**</span>
<span class="cm"> * d_test - Returns true if debugging should be enabled</span>
<span class="cm"> *</span>
<span class="cm"> * @l: intended debug level (unsigned)</span>
<span class="cm"> *</span>
<span class="cm"> * If the master debug switch is enabled and the current settings are</span>
<span class="cm"> * higher or equal to the requested level, then debugging</span>
<span class="cm"> * output/actions should be enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:</span>
<span class="cm"> *</span>
<span class="cm"> * This needs to be coded so that it can be evaluated in compile</span>
<span class="cm"> * time; this is why the ugly BUG_ON() is placed in there, so the</span>
<span class="cm"> * D_MASTER evaluation compiles all out if it is compile-time false.</span>
<span class="cm"> */</span>
<span class="cp">#define d_test(l)							\</span>
<span class="cp">({									\</span>
<span class="cp">	unsigned __l = l;	</span><span class="cm">/* type enforcer */</span><span class="cp">			\</span>
<span class="cp">	(D_MASTER) &gt;= __l						\</span>
<span class="cp">	&amp;&amp; ({								\</span>
<span class="cp">		BUG_ON(_D_SUBMODULE_INDEX(D_SUBMODULE) &gt;= D_LEVEL_SIZE);\</span>
<span class="cp">		D_LEVEL[_D_SUBMODULE_INDEX(D_SUBMODULE)].level &gt;= __l;	\</span>
<span class="cp">	});								\</span>
<span class="cp">})</span>


<span class="cm">/**</span>
<span class="cm"> * d_fnstart - log message at function start if debugging enabled</span>
<span class="cm"> *</span>
<span class="cm"> * @l: intended debug level</span>
<span class="cm"> * @_dev: &#39;struct device&#39; pointer, NULL if none (for context)</span>
<span class="cm"> * @f: printf-like format and arguments</span>
<span class="cm"> */</span>
<span class="cp">#define d_fnstart(l, _dev, f, a...) _d_printf(l, &quot; FNSTART&quot;, _dev, f, ## a)</span>


<span class="cm">/**</span>
<span class="cm"> * d_fnend - log message at function end if debugging enabled</span>
<span class="cm"> *</span>
<span class="cm"> * @l: intended debug level</span>
<span class="cm"> * @_dev: &#39;struct device&#39; pointer, NULL if none (for context)</span>
<span class="cm"> * @f: printf-like format and arguments</span>
<span class="cm"> */</span>
<span class="cp">#define d_fnend(l, _dev, f, a...) _d_printf(l, &quot; FNEND&quot;, _dev, f, ## a)</span>


<span class="cm">/**</span>
<span class="cm"> * d_printf - log message if debugging enabled</span>
<span class="cm"> *</span>
<span class="cm"> * @l: intended debug level</span>
<span class="cm"> * @_dev: &#39;struct device&#39; pointer, NULL if none (for context)</span>
<span class="cm"> * @f: printf-like format and arguments</span>
<span class="cm"> */</span>
<span class="cp">#define d_printf(l, _dev, f, a...) _d_printf(l, &quot;&quot;, _dev, f, ## a)</span>


<span class="cm">/**</span>
<span class="cm"> * d_dump - log buffer hex dump if debugging enabled</span>
<span class="cm"> *</span>
<span class="cm"> * @l: intended debug level</span>
<span class="cm"> * @_dev: &#39;struct device&#39; pointer, NULL if none (for context)</span>
<span class="cm"> * @f: printf-like format and arguments</span>
<span class="cm"> */</span>
<span class="cp">#define d_dump(l, dev, ptr, size)			\</span>
<span class="cp">do {							\</span>
<span class="cp">	char head[64];					\</span>
<span class="cp">	if (!d_test(l))					\</span>
<span class="cp">		break;					\</span>
<span class="cp">	__d_head(head, sizeof(head), dev);		\</span>
<span class="cp">	print_hex_dump(KERN_ERR, head, 0, 16, 1,	\</span>
<span class="cp">		       ((void *) ptr), (size), 0);	\</span>
<span class="cp">} while (0)</span>


<span class="cm">/**</span>
<span class="cm"> * Export a submodule&#39;s debug level over debugfs as PREFIXSUBMODULE</span>
<span class="cm"> *</span>
<span class="cm"> * @prefix: string to prefix the name with</span>
<span class="cm"> * @submodule: name of submodule (not a string, just the name)</span>
<span class="cm"> * @dentry: debugfs parent dentry</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if ok, &lt; 0 errno on error.</span>
<span class="cm"> *</span>
<span class="cm"> * For removing, just use debugfs_remove_recursive() on the parent.</span>
<span class="cm"> */</span>
<span class="cp">#define d_level_register_debugfs(prefix, name, parent)			\</span>
<span class="cp">({									\</span>
<span class="cp">	int rc;								\</span>
<span class="cp">	struct dentry *fd;						\</span>
<span class="cp">	struct dentry *verify_parent_type = parent;			\</span>
<span class="cp">	fd = debugfs_create_u8(						\</span>
<span class="cp">		prefix #name, 0600, verify_parent_type,			\</span>
<span class="cp">		&amp;(D_LEVEL[__D_SUBMODULE_ ## name].level));		\</span>
<span class="cp">	rc = PTR_ERR(fd);						\</span>
<span class="cp">	if (IS_ERR(fd) &amp;&amp; rc != -ENODEV)				\</span>
<span class="cp">		printk(KERN_ERR &quot;%s: Can&#39;t create debugfs entry %s: &quot;	\</span>
<span class="cp">		       &quot;%d\n&quot;, __func__, prefix #name, rc);		\</span>
<span class="cp">	else								\</span>
<span class="cp">		rc = 0;							\</span>
<span class="cp">	rc;								\</span>
<span class="cp">})</span>


<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">d_submodule_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">d_level</span> <span class="o">*</span><span class="n">d_level</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">d_level_size</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">submodule</span><span class="p">,</span> <span class="n">u8</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">d_level</span> <span class="o">*</span><span class="n">itr</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">itr</span> <span class="o">=</span> <span class="n">d_level</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="n">itr</span> <span class="o">+</span> <span class="n">d_level_size</span><span class="p">;</span> <span class="n">itr</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">;</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">itr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: itr-&gt;name NULL?? (%p, #%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">tag</span><span class="p">,</span> <span class="n">itr</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">itr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">submodule</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">itr</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unknown submodule %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">submodule</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * d_parse_params - Parse a string with debug parameters from the</span>
<span class="cm"> * command line</span>
<span class="cm"> *</span>
<span class="cm"> * @d_level: level structure (D_LEVEL)</span>
<span class="cm"> * @d_level_size: number of items in the level structure</span>
<span class="cm"> *     (D_LEVEL_SIZE).</span>
<span class="cm"> * @_params: string with the parameters; this is a space (not tab!)</span>
<span class="cm"> *     separated list of NAME:VALUE, where value is the debug level</span>
<span class="cm"> *     and NAME is the name of the submodule.</span>
<span class="cm"> * @tag: string for error messages (example: MODULE.ARGNAME).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">d_parse_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">d_level</span> <span class="o">*</span><span class="n">d_level</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">d_level_size</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_params</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">submodule</span><span class="p">[</span><span class="mi">130</span><span class="p">],</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">params_orig</span><span class="p">,</span> <span class="o">*</span><span class="n">token</span><span class="p">,</span> <span class="o">*</span><span class="n">colon</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">level</span><span class="p">,</span> <span class="n">tokens</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_params</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">params_orig</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">_params</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">params</span> <span class="o">=</span> <span class="n">params_orig</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">token</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">token</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>	<span class="cm">/* eat joint spaces */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* kernel&#39;s sscanf %s eats until whitespace, so we</span>
<span class="cm">		 * replace : by \n so it doesn&#39;t get eaten later by</span>
<span class="cm">		 * strsep */</span>
		<span class="n">colon</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">colon</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">colon</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
		<span class="n">tokens</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">%u&quot;</span><span class="p">,</span> <span class="n">submodule</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">colon</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">colon</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>	<span class="cm">/* set back, for error messages */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tokens</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">d_submodule_set</span><span class="p">(</span><span class="n">d_level</span><span class="p">,</span> <span class="n">d_level_size</span><span class="p">,</span>
					<span class="n">submodule</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: can&#39;t parse &#39;%s&#39; as a &quot;</span>
			       <span class="s">&quot;SUBMODULE:LEVEL (%d tokens)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">tag</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">tokens</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">params_orig</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* #ifndef __debug__h__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
