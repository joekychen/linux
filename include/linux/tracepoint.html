<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › tracepoint.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tracepoint.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_TRACEPOINT_H</span>
<span class="cp">#define _LINUX_TRACEPOINT_H</span>

<span class="cm">/*</span>
<span class="cm"> * Kernel Tracepoint API.</span>
<span class="cm"> *</span>
<span class="cm"> * See Documentation/trace/tracepoints.txt.</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2008 Mathieu Desnoyers &lt;mathieu.desnoyers@polymtl.ca&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Heavily inspired from the Linux Kernel Markers.</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2.</span>
<span class="cm"> * See the file COPYING for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/static_key.h&gt;</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">tracepoint</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tracepoint_func</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tracepoint</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>		<span class="cm">/* Tracepoint name */</span>
	<span class="k">struct</span> <span class="n">static_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">regfunc</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">unregfunc</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tracepoint_func</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">funcs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Connect a probe to a tracepoint.</span>
<span class="cm"> * Internal API, should not be used directly.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tracepoint_probe_register</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">probe</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Disconnect a probe from a tracepoint.</span>
<span class="cm"> * Internal API, should not be used directly.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">tracepoint_probe_unregister</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">probe</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">tracepoint_probe_register_noupdate</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">probe</span><span class="p">,</span>
					      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">tracepoint_probe_unregister_noupdate</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">probe</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tracepoint_probe_update_all</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MODULES</span>
<span class="k">struct</span> <span class="n">tp_module</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_tracepoints</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tracepoint</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">tracepoints_ptrs</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULES */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">tracepoint_iter</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_MODULES</span>
	<span class="k">struct</span> <span class="n">tp_module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MODULES */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">tracepoint</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">tracepoint</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">tracepoint_iter_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracepoint_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tracepoint_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracepoint_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tracepoint_iter_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracepoint_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">tracepoint_iter_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tracepoint_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * tracepoint_synchronize_unregister must be called between the last tracepoint</span>
<span class="cm"> * probe unregistration and the end of module exit to make sure there is no</span>
<span class="cm"> * caller executing a probe when it is freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tracepoint_synchronize_unregister</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">synchronize_sched</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#define PARAMS(args...) args</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_TRACEPOINT_H */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Note: we keep the TRACE_EVENT and DECLARE_TRACE outside the include</span>
<span class="cm"> *  file ifdef protection.</span>
<span class="cm"> *  This is due to the way trace events work. If a file includes two</span>
<span class="cm"> *  trace event headers under one &quot;CREATE_TRACE_POINTS&quot; the first include</span>
<span class="cm"> *  will override the TRACE_EVENT and break the second include.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef DECLARE_TRACE</span>

<span class="cp">#define TP_PROTO(args...)	args</span>
<span class="cp">#define TP_ARGS(args...)	args</span>
<span class="cp">#define TP_CONDITION(args...)	args</span>

<span class="cp">#ifdef CONFIG_TRACEPOINTS</span>

<span class="cm">/*</span>
<span class="cm"> * it_func[0] is never NULL because there is at least one element in the array</span>
<span class="cm"> * when the array itself is non NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the proto and args passed in includes &quot;__data&quot; as the first parameter.</span>
<span class="cm"> * The reason for this is to handle the &quot;void&quot; prototype. If a tracepoint</span>
<span class="cm"> * has a &quot;void&quot; prototype, then it is invalid to declare a function</span>
<span class="cm"> * as &quot;(void *, void)&quot;. The DECLARE_TRACE_NOARGS() will pass in just</span>
<span class="cm"> * &quot;void *data&quot;, where as the DECLARE_TRACE() will pass in &quot;void *data, proto&quot;.</span>
<span class="cm"> */</span>
<span class="cp">#define __DO_TRACE(tp, proto, args, cond, prercu, postrcu)		\</span>
<span class="cp">	do {								\</span>
<span class="cp">		struct tracepoint_func *it_func_ptr;			\</span>
<span class="cp">		void *it_func;						\</span>
<span class="cp">		void *__data;						\</span>
<span class="cp">									\</span>
<span class="cp">		if (!(cond))						\</span>
<span class="cp">			return;						\</span>
<span class="cp">		prercu;							\</span>
<span class="cp">		rcu_read_lock_sched_notrace();				\</span>
<span class="cp">		it_func_ptr = rcu_dereference_sched((tp)-&gt;funcs);	\</span>
<span class="cp">		if (it_func_ptr) {					\</span>
<span class="cp">			do {						\</span>
<span class="cp">				it_func = (it_func_ptr)-&gt;func;		\</span>
<span class="cp">				__data = (it_func_ptr)-&gt;data;		\</span>
<span class="cp">				((void(*)(proto))(it_func))(args);	\</span>
<span class="cp">			} while ((++it_func_ptr)-&gt;func);		\</span>
<span class="cp">		}							\</span>
<span class="cp">		rcu_read_unlock_sched_notrace();			\</span>
<span class="cp">		postrcu;						\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * Make sure the alignment of the structure in the __tracepoints section will</span>
<span class="cm"> * not add unwanted padding between the beginning of the section and the</span>
<span class="cm"> * structure. Force alignment to the same alignment as the section start.</span>
<span class="cm"> */</span>
<span class="cp">#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \</span>
<span class="cp">	extern struct tracepoint __tracepoint_##name;			\</span>
<span class="cp">	static inline void trace_##name(proto)				\</span>
<span class="cp">	{								\</span>
<span class="cp">		if (static_key_false(&amp;__tracepoint_##name.key))		\</span>
<span class="cp">			__DO_TRACE(&amp;__tracepoint_##name,		\</span>
<span class="cp">				TP_PROTO(data_proto),			\</span>
<span class="cp">				TP_ARGS(data_args),			\</span>
<span class="cp">				TP_CONDITION(cond),,);			\</span>
<span class="cp">	}								\</span>
<span class="cp">	static inline void trace_##name##_rcuidle(proto)		\</span>
<span class="cp">	{								\</span>
<span class="cp">		if (static_branch(&amp;__tracepoint_##name.key))		\</span>
<span class="cp">			__DO_TRACE(&amp;__tracepoint_##name,		\</span>
<span class="cp">				TP_PROTO(data_proto),			\</span>
<span class="cp">				TP_ARGS(data_args),			\</span>
<span class="cp">				TP_CONDITION(cond),			\</span>
<span class="cp">				rcu_idle_exit(),			\</span>
<span class="cp">				rcu_idle_enter());			\</span>
<span class="cp">	}								\</span>
<span class="cp">	static inline int						\</span>
<span class="cp">	register_trace_##name(void (*probe)(data_proto), void *data)	\</span>
<span class="cp">	{								\</span>
<span class="cp">		return tracepoint_probe_register(#name, (void *)probe,	\</span>
<span class="cp">						 data);			\</span>
<span class="cp">	}								\</span>
<span class="cp">	static inline int						\</span>
<span class="cp">	unregister_trace_##name(void (*probe)(data_proto), void *data)	\</span>
<span class="cp">	{								\</span>
<span class="cp">		return tracepoint_probe_unregister(#name, (void *)probe, \</span>
<span class="cp">						   data);		\</span>
<span class="cp">	}								\</span>
<span class="cp">	static inline void						\</span>
<span class="cp">	check_trace_callback_type_##name(void (*cb)(data_proto))	\</span>
<span class="cp">	{								\</span>
<span class="cp">	}</span>

<span class="cm">/*</span>
<span class="cm"> * We have no guarantee that gcc and the linker won&#39;t up-align the tracepoint</span>
<span class="cm"> * structures, so we create an array of pointers that will be used for iteration</span>
<span class="cm"> * on the tracepoints.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFINE_TRACE_FN(name, reg, unreg)				 \</span>
<span class="cp">	static const char __tpstrtab_##name[]				 \</span>
<span class="cp">	__attribute__((section(&quot;__tracepoints_strings&quot;))) = #name;	 \</span>
<span class="cp">	struct tracepoint __tracepoint_##name				 \</span>
<span class="cp">	__attribute__((section(&quot;__tracepoints&quot;))) =			 \</span>
<span class="cp">		{ __tpstrtab_##name, STATIC_KEY_INIT_FALSE, reg, unreg, NULL };\</span>
<span class="cp">	static struct tracepoint * const __tracepoint_ptr_##name __used	 \</span>
<span class="cp">	__attribute__((section(&quot;__tracepoints_ptrs&quot;))) =		 \</span>
<span class="cp">		&amp;__tracepoint_##name;</span>

<span class="cp">#define DEFINE_TRACE(name)						\</span>
<span class="cp">	DEFINE_TRACE_FN(name, NULL, NULL);</span>

<span class="cp">#define EXPORT_TRACEPOINT_SYMBOL_GPL(name)				\</span>
<span class="cp">	EXPORT_SYMBOL_GPL(__tracepoint_##name)</span>
<span class="cp">#define EXPORT_TRACEPOINT_SYMBOL(name)					\</span>
<span class="cp">	EXPORT_SYMBOL(__tracepoint_##name)</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_TRACEPOINTS */</span><span class="cp"></span>
<span class="cp">#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \</span>
<span class="cp">	static inline void trace_##name(proto)				\</span>
<span class="cp">	{ }								\</span>
<span class="cp">	static inline void trace_##name##_rcuidle(proto)		\</span>
<span class="cp">	{ }								\</span>
<span class="cp">	static inline int						\</span>
<span class="cp">	register_trace_##name(void (*probe)(data_proto),		\</span>
<span class="cp">			      void *data)				\</span>
<span class="cp">	{								\</span>
<span class="cp">		return -ENOSYS;						\</span>
<span class="cp">	}								\</span>
<span class="cp">	static inline int						\</span>
<span class="cp">	unregister_trace_##name(void (*probe)(data_proto),		\</span>
<span class="cp">				void *data)				\</span>
<span class="cp">	{								\</span>
<span class="cp">		return -ENOSYS;						\</span>
<span class="cp">	}								\</span>
<span class="cp">	static inline void check_trace_callback_type_##name(void (*cb)(data_proto)) \</span>
<span class="cp">	{								\</span>
<span class="cp">	}</span>

<span class="cp">#define DEFINE_TRACE_FN(name, reg, unreg)</span>
<span class="cp">#define DEFINE_TRACE(name)</span>
<span class="cp">#define EXPORT_TRACEPOINT_SYMBOL_GPL(name)</span>
<span class="cp">#define EXPORT_TRACEPOINT_SYMBOL(name)</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_TRACEPOINTS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The need for the DECLARE_TRACE_NOARGS() is to handle the prototype</span>
<span class="cm"> * (void). &quot;void&quot; is a special value in a function prototype and can</span>
<span class="cm"> * not be combined with other arguments. Since the DECLARE_TRACE()</span>
<span class="cm"> * macro adds a data element at the beginning of the prototype,</span>
<span class="cm"> * we need a way to differentiate &quot;(void *data, proto)&quot; from</span>
<span class="cm"> * &quot;(void *data, void)&quot;. The second prototype is invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * DECLARE_TRACE_NOARGS() passes &quot;void&quot; as the tracepoint prototype</span>
<span class="cm"> * and &quot;void *__data&quot; as the callback prototype.</span>
<span class="cm"> *</span>
<span class="cm"> * DECLARE_TRACE() passes &quot;proto&quot; as the tracepoint protoype and</span>
<span class="cm"> * &quot;void *__data, proto&quot; as the callback prototype.</span>
<span class="cm"> */</span>
<span class="cp">#define DECLARE_TRACE_NOARGS(name)					\</span>
<span class="cp">		__DECLARE_TRACE(name, void, , 1, void *__data, __data)</span>

<span class="cp">#define DECLARE_TRACE(name, proto, args)				\</span>
<span class="cp">		__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args), 1,	\</span>
<span class="cp">				PARAMS(void *__data, proto),		\</span>
<span class="cp">				PARAMS(__data, args))</span>

<span class="cp">#define DECLARE_TRACE_CONDITION(name, proto, args, cond)		\</span>
<span class="cp">	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args), PARAMS(cond), \</span>
<span class="cp">			PARAMS(void *__data, proto),			\</span>
<span class="cp">			PARAMS(__data, args))</span>

<span class="cp">#define TRACE_EVENT_FLAGS(event, flag)</span>

<span class="cp">#endif </span><span class="cm">/* DECLARE_TRACE */</span><span class="cp"></span>

<span class="cp">#ifndef TRACE_EVENT</span>
<span class="cm">/*</span>
<span class="cm"> * For use with the TRACE_EVENT macro:</span>
<span class="cm"> *</span>
<span class="cm"> * We define a tracepoint, its arguments, its printk format</span>
<span class="cm"> * and its &#39;fast binay record&#39; layout.</span>
<span class="cm"> *</span>
<span class="cm"> * Firstly, name your tracepoint via TRACE_EVENT(name : the</span>
<span class="cm"> * &#39;subsystem_event&#39; notation is fine.</span>
<span class="cm"> *</span>
<span class="cm"> * Think about this whole construct as the</span>
<span class="cm"> * &#39;trace_sched_switch() function&#39; from now on.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  TRACE_EVENT(sched_switch,</span>
<span class="cm"> *</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* A function has a regular function arguments</span>
<span class="cm"> *	* prototype, declare it via TP_PROTO():</span>
<span class="cm"> *	*</span>
<span class="cm"> *</span>
<span class="cm"> *	TP_PROTO(struct rq *rq, struct task_struct *prev,</span>
<span class="cm"> *		 struct task_struct *next),</span>
<span class="cm"> *</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* Define the call signature of the &#39;function&#39;.</span>
<span class="cm"> *	* (Design sidenote: we use this instead of a</span>
<span class="cm"> *	*  TP_PROTO1/TP_PROTO2/TP_PROTO3 ugliness.)</span>
<span class="cm"> *	*</span>
<span class="cm"> *</span>
<span class="cm"> *	TP_ARGS(rq, prev, next),</span>
<span class="cm"> *</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* Fast binary tracing: define the trace record via</span>
<span class="cm"> *	* TP_STRUCT__entry(). You can think about it like a</span>
<span class="cm"> *	* regular C structure local variable definition.</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* This is how the trace record is structured and will</span>
<span class="cm"> *	* be saved into the ring buffer. These are the fields</span>
<span class="cm"> *	* that will be exposed to user-space in</span>
<span class="cm"> *	* /sys/kernel/debug/tracing/events/&lt;*&gt;/format.</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* The declared &#39;local variable&#39; is called &#39;__entry&#39;</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* __field(pid_t, prev_prid) is equivalent to a standard declariton:</span>
<span class="cm"> *	*</span>
<span class="cm"> *	*	pid_t	prev_pid;</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* __array(char, prev_comm, TASK_COMM_LEN) is equivalent to:</span>
<span class="cm"> *	*</span>
<span class="cm"> *	*	char	prev_comm[TASK_COMM_LEN];</span>
<span class="cm"> *	*</span>
<span class="cm"> *</span>
<span class="cm"> *	TP_STRUCT__entry(</span>
<span class="cm"> *		__array(	char,	prev_comm,	TASK_COMM_LEN	)</span>
<span class="cm"> *		__field(	pid_t,	prev_pid			)</span>
<span class="cm"> *		__field(	int,	prev_prio			)</span>
<span class="cm"> *		__array(	char,	next_comm,	TASK_COMM_LEN	)</span>
<span class="cm"> *		__field(	pid_t,	next_pid			)</span>
<span class="cm"> *		__field(	int,	next_prio			)</span>
<span class="cm"> *	),</span>
<span class="cm"> *</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* Assign the entry into the trace record, by embedding</span>
<span class="cm"> *	* a full C statement block into TP_fast_assign(). You</span>
<span class="cm"> *	* can refer to the trace record as &#39;__entry&#39; -</span>
<span class="cm"> *	* otherwise you can put arbitrary C code in here.</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* Note: this C code will execute every time a trace event</span>
<span class="cm"> *	* happens, on an active tracepoint.</span>
<span class="cm"> *	*</span>
<span class="cm"> *</span>
<span class="cm"> *	TP_fast_assign(</span>
<span class="cm"> *		memcpy(__entry-&gt;next_comm, next-&gt;comm, TASK_COMM_LEN);</span>
<span class="cm"> *		__entry-&gt;prev_pid	= prev-&gt;pid;</span>
<span class="cm"> *		__entry-&gt;prev_prio	= prev-&gt;prio;</span>
<span class="cm"> *		memcpy(__entry-&gt;prev_comm, prev-&gt;comm, TASK_COMM_LEN);</span>
<span class="cm"> *		__entry-&gt;next_pid	= next-&gt;pid;</span>
<span class="cm"> *		__entry-&gt;next_prio	= next-&gt;prio;</span>
<span class="cm"> *	),</span>
<span class="cm"> *</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* Formatted output of a trace record via TP_printk().</span>
<span class="cm"> *	* This is how the tracepoint will appear under ftrace</span>
<span class="cm"> *	* plugins that make use of this tracepoint.</span>
<span class="cm"> *	*</span>
<span class="cm"> *	* (raw-binary tracing wont actually perform this step.)</span>
<span class="cm"> *	*</span>
<span class="cm"> *</span>
<span class="cm"> *	TP_printk(&quot;task %s:%d [%d] ==&gt; %s:%d [%d]&quot;,</span>
<span class="cm"> *		__entry-&gt;prev_comm, __entry-&gt;prev_pid, __entry-&gt;prev_prio,</span>
<span class="cm"> *		__entry-&gt;next_comm, __entry-&gt;next_pid, __entry-&gt;next_prio),</span>
<span class="cm"> *</span>
<span class="cm"> * );</span>
<span class="cm"> *</span>
<span class="cm"> * This macro construct is thus used for the regular printk format</span>
<span class="cm"> * tracing setup, it is used to construct a function pointer based</span>
<span class="cm"> * tracepoint callback (this is used by programmatic plugins and</span>
<span class="cm"> * can also by used by generic instrumentation like SystemTap), and</span>
<span class="cm"> * it is also used to expose a structured trace record in</span>
<span class="cm"> * /sys/kernel/debug/tracing/events/.</span>
<span class="cm"> *</span>
<span class="cm"> * A set of (un)registration functions can be passed to the variant</span>
<span class="cm"> * TRACE_EVENT_FN to perform any (un)registration work.</span>
<span class="cm"> */</span>

<span class="cp">#define DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)</span>
<span class="cp">#define DEFINE_EVENT(template, name, proto, args)		\</span>
<span class="cp">	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))</span>
<span class="cp">#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\</span>
<span class="cp">	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))</span>
<span class="cp">#define DEFINE_EVENT_CONDITION(template, name, proto,		\</span>
<span class="cp">			       args, cond)			\</span>
<span class="cp">	DECLARE_TRACE_CONDITION(name, PARAMS(proto),		\</span>
<span class="cp">				PARAMS(args), PARAMS(cond))</span>

<span class="cp">#define TRACE_EVENT(name, proto, args, struct, assign, print)	\</span>
<span class="cp">	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))</span>
<span class="cp">#define TRACE_EVENT_FN(name, proto, args, struct,		\</span>
<span class="cp">		assign, print, reg, unreg)			\</span>
<span class="cp">	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))</span>
<span class="cp">#define TRACE_EVENT_CONDITION(name, proto, args, cond,		\</span>
<span class="cp">			      struct, assign, print)		\</span>
<span class="cp">	DECLARE_TRACE_CONDITION(name, PARAMS(proto),		\</span>
<span class="cp">				PARAMS(args), PARAMS(cond))</span>

<span class="cp">#define TRACE_EVENT_FLAGS(event, flag)</span>

<span class="cp">#endif </span><span class="cm">/* ifdef TRACE_EVENT (see note above) */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
