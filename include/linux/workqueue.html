<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › workqueue.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>workqueue.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * workqueue.h --- work queue handling for Linux.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_WORKQUEUE_H</span>
<span class="cp">#define _LINUX_WORKQUEUE_H</span>

<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/lockdep.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="k">struct</span> <span class="n">workqueue_struct</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">work_struct</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">work_func_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The first word is the work queue pointer and the flags rolled into</span>
<span class="cm"> * one</span>
<span class="cm"> */</span>
<span class="cp">#define work_data_bits(work) ((unsigned long *)(&amp;(work)-&gt;data))</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">WORK_STRUCT_PENDING_BIT</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* work item is pending execution */</span>
	<span class="n">WORK_STRUCT_DELAYED_BIT</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* work item is delayed */</span>
	<span class="n">WORK_STRUCT_CWQ_BIT</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* data points to cwq */</span>
	<span class="n">WORK_STRUCT_LINKED_BIT</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* next work is linked to this one */</span>
<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_WORK</span>
	<span class="n">WORK_STRUCT_STATIC_BIT</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* static initializer (debugobjects) */</span>
	<span class="n">WORK_STRUCT_COLOR_SHIFT</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* color for workqueue flushing */</span>
<span class="cp">#else</span>
	<span class="n">WORK_STRUCT_COLOR_SHIFT</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* color for workqueue flushing */</span>
<span class="cp">#endif</span>

	<span class="n">WORK_STRUCT_COLOR_BITS</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

	<span class="n">WORK_STRUCT_PENDING</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_PENDING_BIT</span><span class="p">,</span>
	<span class="n">WORK_STRUCT_DELAYED</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_DELAYED_BIT</span><span class="p">,</span>
	<span class="n">WORK_STRUCT_CWQ</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_CWQ_BIT</span><span class="p">,</span>
	<span class="n">WORK_STRUCT_LINKED</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_LINKED_BIT</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_WORK</span>
	<span class="n">WORK_STRUCT_STATIC</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_STATIC_BIT</span><span class="p">,</span>
<span class="cp">#else</span>
	<span class="n">WORK_STRUCT_STATIC</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * The last color is no color used for works which don&#39;t</span>
<span class="cm">	 * participate in workqueue flushing.</span>
<span class="cm">	 */</span>
	<span class="n">WORK_NR_COLORS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_COLOR_BITS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">WORK_NO_COLOR</span>		<span class="o">=</span> <span class="n">WORK_NR_COLORS</span><span class="p">,</span>

	<span class="cm">/* special cpu IDs */</span>
	<span class="n">WORK_CPU_UNBOUND</span>	<span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">,</span>
	<span class="n">WORK_CPU_NONE</span>		<span class="o">=</span> <span class="n">NR_CPUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">WORK_CPU_LAST</span>		<span class="o">=</span> <span class="n">WORK_CPU_NONE</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reserve 7 bits off of cwq pointer w/ debugobjects turned</span>
<span class="cm">	 * off.  This makes cwqs aligned to 256 bytes and allows 15</span>
<span class="cm">	 * workqueue flush colors.</span>
<span class="cm">	 */</span>
	<span class="n">WORK_STRUCT_FLAG_BITS</span>	<span class="o">=</span> <span class="n">WORK_STRUCT_COLOR_SHIFT</span> <span class="o">+</span>
				  <span class="n">WORK_STRUCT_COLOR_BITS</span><span class="p">,</span>

	<span class="n">WORK_STRUCT_FLAG_MASK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_FLAG_BITS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">WORK_STRUCT_WQ_DATA_MASK</span> <span class="o">=</span> <span class="o">~</span><span class="n">WORK_STRUCT_FLAG_MASK</span><span class="p">,</span>
	<span class="n">WORK_STRUCT_NO_CPU</span>	<span class="o">=</span> <span class="n">WORK_CPU_NONE</span> <span class="o">&lt;&lt;</span> <span class="n">WORK_STRUCT_FLAG_BITS</span><span class="p">,</span>

	<span class="cm">/* bit mask for work_busy() return values */</span>
	<span class="n">WORK_BUSY_PENDING</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">WORK_BUSY_RUNNING</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">work_struct</span> <span class="p">{</span>
	<span class="n">atomic_long_t</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">work_func_t</span> <span class="n">func</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">lockdep_map</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define WORK_DATA_INIT()	ATOMIC_LONG_INIT(WORK_STRUCT_NO_CPU)</span>
<span class="cp">#define WORK_DATA_STATIC_INIT()	\</span>
<span class="cp">	ATOMIC_LONG_INIT(WORK_STRUCT_NO_CPU | WORK_STRUCT_STATIC)</span>

<span class="k">struct</span> <span class="n">delayed_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="nf">to_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">delayed_work</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">execute_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="cm">/*</span>
<span class="cm"> * NB: because we have to copy the lockdep_map, setting _key</span>
<span class="cm"> * here is required, otherwise it could get initialised to the</span>
<span class="cm"> * copy of the lockdep_map!</span>
<span class="cm"> */</span>
<span class="cp">#define __WORK_INIT_LOCKDEP_MAP(n, k) \</span>
<span class="cp">	.lockdep_map = STATIC_LOCKDEP_MAP_INIT(n, k),</span>
<span class="cp">#else</span>
<span class="cp">#define __WORK_INIT_LOCKDEP_MAP(n, k)</span>
<span class="cp">#endif</span>

<span class="cp">#define __WORK_INITIALIZER(n, f) {				\</span>
<span class="cp">	.data = WORK_DATA_STATIC_INIT(),			\</span>
<span class="cp">	.entry	= { &amp;(n).entry, &amp;(n).entry },			\</span>
<span class="cp">	.func = (f),						\</span>
<span class="cp">	__WORK_INIT_LOCKDEP_MAP(#n, &amp;(n))			\</span>
<span class="cp">	}</span>

<span class="cp">#define __DELAYED_WORK_INITIALIZER(n, f) {			\</span>
<span class="cp">	.work = __WORK_INITIALIZER((n).work, (f)),		\</span>
<span class="cp">	.timer = TIMER_INITIALIZER(NULL, 0, 0),			\</span>
<span class="cp">	}</span>

<span class="cp">#define __DEFERRED_WORK_INITIALIZER(n, f) {			\</span>
<span class="cp">	.work = __WORK_INITIALIZER((n).work, (f)),		\</span>
<span class="cp">	.timer = TIMER_DEFERRED_INITIALIZER(NULL, 0, 0),	\</span>
<span class="cp">	}</span>

<span class="cp">#define DECLARE_WORK(n, f)					\</span>
<span class="cp">	struct work_struct n = __WORK_INITIALIZER(n, f)</span>

<span class="cp">#define DECLARE_DELAYED_WORK(n, f)				\</span>
<span class="cp">	struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f)</span>

<span class="cp">#define DECLARE_DEFERRED_WORK(n, f)				\</span>
<span class="cp">	struct delayed_work n = __DEFERRED_WORK_INITIALIZER(n, f)</span>

<span class="cm">/*</span>
<span class="cm"> * initialize a work item&#39;s function pointer</span>
<span class="cm"> */</span>
<span class="cp">#define PREPARE_WORK(_work, _func)				\</span>
<span class="cp">	do {							\</span>
<span class="cp">		(_work)-&gt;func = (_func);			\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define PREPARE_DELAYED_WORK(_work, _func)			\</span>
<span class="cp">	PREPARE_WORK(&amp;(_work)-&gt;work, (_func))</span>

<span class="cp">#ifdef CONFIG_DEBUG_OBJECTS_WORK</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__init_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onstack</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">destroy_work_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">work_static</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WORK_STRUCT_STATIC</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__init_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onstack</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">destroy_work_on_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">work_static</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * initialize all of a work item in one go</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! No point in using &quot;atomic_long_set()&quot;: using a direct</span>
<span class="cm"> * assignment of the work data initializer allows the compiler</span>
<span class="cm"> * to generate better code.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="cp">#define __INIT_WORK(_work, _func, _onstack)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		static struct lock_class_key __key;			\</span>
<span class="cp">									\</span>
<span class="cp">		__init_work((_work), _onstack);				\</span>
<span class="cp">		(_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT();	\</span>
<span class="cp">		lockdep_init_map(&amp;(_work)-&gt;lockdep_map, #_work, &amp;__key, 0);\</span>
<span class="cp">		INIT_LIST_HEAD(&amp;(_work)-&gt;entry);			\</span>
<span class="cp">		PREPARE_WORK((_work), (_func));				\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define __INIT_WORK(_work, _func, _onstack)				\</span>
<span class="cp">	do {								\</span>
<span class="cp">		__init_work((_work), _onstack);				\</span>
<span class="cp">		(_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT();	\</span>
<span class="cp">		INIT_LIST_HEAD(&amp;(_work)-&gt;entry);			\</span>
<span class="cp">		PREPARE_WORK((_work), (_func));				\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#endif</span>

<span class="cp">#define INIT_WORK(_work, _func)					\</span>
<span class="cp">	do {							\</span>
<span class="cp">		__INIT_WORK((_work), (_func), 0);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define INIT_WORK_ONSTACK(_work, _func)				\</span>
<span class="cp">	do {							\</span>
<span class="cp">		__INIT_WORK((_work), (_func), 1);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define INIT_DELAYED_WORK(_work, _func)				\</span>
<span class="cp">	do {							\</span>
<span class="cp">		INIT_WORK(&amp;(_work)-&gt;work, (_func));		\</span>
<span class="cp">		init_timer(&amp;(_work)-&gt;timer);			\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define INIT_DELAYED_WORK_ONSTACK(_work, _func)			\</span>
<span class="cp">	do {							\</span>
<span class="cp">		INIT_WORK_ONSTACK(&amp;(_work)-&gt;work, (_func));	\</span>
<span class="cp">		init_timer_on_stack(&amp;(_work)-&gt;timer);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define INIT_DELAYED_WORK_DEFERRABLE(_work, _func)		\</span>
<span class="cp">	do {							\</span>
<span class="cp">		INIT_WORK(&amp;(_work)-&gt;work, (_func));		\</span>
<span class="cp">		init_timer_deferrable(&amp;(_work)-&gt;timer);		\</span>
<span class="cp">	} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * work_pending - Find out whether a work item is currently pending</span>
<span class="cm"> * @work: The work item in question</span>
<span class="cm"> */</span>
<span class="cp">#define work_pending(work) \</span>
<span class="cp">	test_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))</span>

<span class="cm">/**</span>
<span class="cm"> * delayed_work_pending - Find out whether a delayable work item is currently</span>
<span class="cm"> * pending</span>
<span class="cm"> * @work: The work item in question</span>
<span class="cm"> */</span>
<span class="cp">#define delayed_work_pending(w) \</span>
<span class="cp">	work_pending(&amp;(w)-&gt;work)</span>

<span class="cm">/**</span>
<span class="cm"> * work_clear_pending - for internal use only, mark a work item as not pending</span>
<span class="cm"> * @work: The work item in question</span>
<span class="cm"> */</span>
<span class="cp">#define work_clear_pending(work) \</span>
<span class="cp">	clear_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))</span>

<span class="cm">/*</span>
<span class="cm"> * Workqueue flags and constants.  For details, please refer to</span>
<span class="cm"> * Documentation/workqueue.txt.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">WQ_NON_REENTRANT</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* guarantee non-reentrance */</span>
	<span class="n">WQ_UNBOUND</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="cm">/* not bound to any cpu */</span>
	<span class="n">WQ_FREEZABLE</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="cm">/* freeze during suspend */</span>
	<span class="n">WQ_MEM_RECLAIM</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* may be used for memory reclaim */</span>
	<span class="n">WQ_HIGHPRI</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/* high priority */</span>
	<span class="n">WQ_CPU_INTENSIVE</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="cm">/* cpu instensive workqueue */</span>

	<span class="n">WQ_DRAINING</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/* internal: workqueue is draining */</span>
	<span class="n">WQ_RESCUER</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/* internal: workqueue has rescuer */</span>

	<span class="n">WQ_MAX_ACTIVE</span>		<span class="o">=</span> <span class="mi">512</span><span class="p">,</span>	  <span class="cm">/* I like 512, better ideas? */</span>
	<span class="n">WQ_MAX_UNBOUND_PER_CPU</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	  <span class="cm">/* 4 * #cpus for unbound wq */</span>
	<span class="n">WQ_DFL_ACTIVE</span>		<span class="o">=</span> <span class="n">WQ_MAX_ACTIVE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* unbound wq&#39;s aren&#39;t per-cpu, scale max_active according to #cpus */</span>
<span class="cp">#define WQ_UNBOUND_MAX_ACTIVE	\</span>
<span class="cp">	max_t(int, WQ_MAX_ACTIVE, num_possible_cpus() * WQ_MAX_UNBOUND_PER_CPU)</span>

<span class="cm">/*</span>
<span class="cm"> * System-wide workqueues which are always present.</span>
<span class="cm"> *</span>
<span class="cm"> * system_wq is the one used by schedule[_delayed]_work[_on]().</span>
<span class="cm"> * Multi-CPU multi-threaded.  There are users which expect relatively</span>
<span class="cm"> * short queue flush time.  Don&#39;t queue works which can run for too</span>
<span class="cm"> * long.</span>
<span class="cm"> *</span>
<span class="cm"> * system_long_wq is similar to system_wq but may host long running</span>
<span class="cm"> * works.  Queue flushing might take relatively long.</span>
<span class="cm"> *</span>
<span class="cm"> * system_nrt_wq is non-reentrant and guarantees that any given work</span>
<span class="cm"> * item is never executed in parallel by multiple CPUs.  Queue</span>
<span class="cm"> * flushing might take relatively long.</span>
<span class="cm"> *</span>
<span class="cm"> * system_unbound_wq is unbound workqueue.  Workers are not bound to</span>
<span class="cm"> * any specific CPU, not concurrency managed, and all queued works are</span>
<span class="cm"> * executed immediately as long as max_active limit is not reached and</span>
<span class="cm"> * resources are available.</span>
<span class="cm"> *</span>
<span class="cm"> * system_freezable_wq is equivalent to system_wq except that it&#39;s</span>
<span class="cm"> * freezable.</span>
<span class="cm"> *</span>
<span class="cm"> * system_nrt_freezable_wq is equivalent to system_nrt_wq except that</span>
<span class="cm"> * it&#39;s freezable.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_wq</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_long_wq</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_nrt_wq</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_unbound_wq</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_freezable_wq</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">system_nrt_freezable_wq</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span>
<span class="n">__alloc_workqueue_key</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_active</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">lock_class_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lock_name</span><span class="p">,</span> <span class="p">...)</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_workqueue - allocate a workqueue</span>
<span class="cm"> * @fmt: printf format for the name of the workqueue</span>
<span class="cm"> * @flags: WQ_* flags</span>
<span class="cm"> * @max_active: max in-flight work items, 0 for default</span>
<span class="cm"> * @args: args for @fmt</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a workqueue with the specified parameters.  For detailed</span>
<span class="cm"> * information on WQ_* flags, please refer to Documentation/workqueue.txt.</span>
<span class="cm"> *</span>
<span class="cm"> * The __lock_name macro dance is to guarantee that single lock_class_key</span>
<span class="cm"> * doesn&#39;t end up with different namesm, which isn&#39;t allowed by lockdep.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the allocated workqueue on success, %NULL on failure.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="cp">#define alloc_workqueue(fmt, flags, max_active, args...)	\</span>
<span class="cp">({								\</span>
<span class="cp">	static struct lock_class_key __key;			\</span>
<span class="cp">	const char *__lock_name;				\</span>
<span class="cp">								\</span>
<span class="cp">	if (__builtin_constant_p(fmt))				\</span>
<span class="cp">		__lock_name = (fmt);				\</span>
<span class="cp">	else							\</span>
<span class="cp">		__lock_name = #fmt;				\</span>
<span class="cp">								\</span>
<span class="cp">	__alloc_workqueue_key((fmt), (flags), (max_active),	\</span>
<span class="cp">			      &amp;__key, __lock_name, ##args);	\</span>
<span class="cp">})</span>
<span class="cp">#else</span>
<span class="cp">#define alloc_workqueue(fmt, flags, max_active, args...)	\</span>
<span class="cp">	__alloc_workqueue_key((fmt), (flags), (max_active),	\</span>
<span class="cp">			      NULL, NULL, ##args)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_ordered_workqueue - allocate an ordered workqueue</span>
<span class="cm"> * @fmt: printf format for the name of the workqueue</span>
<span class="cm"> * @flags: WQ_* flags (only WQ_FREEZABLE and WQ_MEM_RECLAIM are meaningful)</span>
<span class="cm"> * @args: args for @fmt</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate an ordered workqueue.  An ordered workqueue executes at</span>
<span class="cm"> * most one work item at any given time in the queued order.  They are</span>
<span class="cm"> * implemented as unbound workqueues with @max_active of one.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the allocated workqueue on success, %NULL on failure.</span>
<span class="cm"> */</span>
<span class="cp">#define alloc_ordered_workqueue(fmt, flags, args...)		\</span>
<span class="cp">	alloc_workqueue(fmt, WQ_UNBOUND | (flags), 1, ##args)</span>

<span class="cp">#define create_workqueue(name)					\</span>
<span class="cp">	alloc_workqueue((name), WQ_MEM_RECLAIM, 1)</span>
<span class="cp">#define create_freezable_workqueue(name)			\</span>
<span class="cp">	alloc_workqueue((name), WQ_FREEZABLE | WQ_UNBOUND | WQ_MEM_RECLAIM, 1)</span>
<span class="cp">#define create_singlethread_workqueue(name)			\</span>
<span class="cp">	alloc_workqueue((name), WQ_UNBOUND | WQ_MEM_RECLAIM, 1)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">destroy_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">queue_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">queue_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">queue_delayed_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">drain_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">flush_scheduled_work</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">schedule_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">schedule_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">schedule_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">schedule_delayed_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">schedule_on_each_cpu</span><span class="p">(</span><span class="n">work_func_t</span> <span class="n">func</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">keventd_up</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">execute_in_process_context</span><span class="p">(</span><span class="n">work_func_t</span> <span class="n">fn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">execute_work</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">flush_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">flush_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">cancel_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">flush_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">flush_delayed_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">workqueue_set_max_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">max_active</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">workqueue_congested</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">work_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">work_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Kill off a pending schedule_delayed_work().  Note that the work callback</span>
<span class="cm"> * function may still be running on return from cancel_delayed_work(), unless</span>
<span class="cm"> * it returns 1 and the work doesn&#39;t re-arm itself. Run flush_workqueue() or</span>
<span class="cm"> * cancel_work_sync() to wait on it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cancel_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">work_clear_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Like above, but uses del_timer() instead of del_timer_sync(). This means,</span>
<span class="cm"> * if it returns 0 the timer function may be running and the queueing is in</span>
<span class="cm"> * progress.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__cancel_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">work_clear_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_SMP</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">work_on_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">long</span> <span class="n">work_on_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_FREEZER</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">freeze_workqueues_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">bool</span> <span class="n">freeze_workqueues_busy</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">thaw_workqueues</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_FREEZER */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
