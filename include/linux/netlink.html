<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › netlink.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>netlink.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_NETLINK_H</span>
<span class="cp">#define __LINUX_NETLINK_H</span>

<span class="cp">#include &lt;linux/socket.h&gt; </span><span class="cm">/* for __kernel_sa_family_t */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#define NETLINK_ROUTE		0	</span><span class="cm">/* Routing/device hook				*/</span><span class="cp"></span>
<span class="cp">#define NETLINK_UNUSED		1	</span><span class="cm">/* Unused number				*/</span><span class="cp"></span>
<span class="cp">#define NETLINK_USERSOCK	2	</span><span class="cm">/* Reserved for user mode socket protocols 	*/</span><span class="cp"></span>
<span class="cp">#define NETLINK_FIREWALL	3	</span><span class="cm">/* Unused number, formerly ip_queue		*/</span><span class="cp"></span>
<span class="cp">#define NETLINK_SOCK_DIAG	4	</span><span class="cm">/* socket monitoring				*/</span><span class="cp"></span>
<span class="cp">#define NETLINK_NFLOG		5	</span><span class="cm">/* netfilter/iptables ULOG */</span><span class="cp"></span>
<span class="cp">#define NETLINK_XFRM		6	</span><span class="cm">/* ipsec */</span><span class="cp"></span>
<span class="cp">#define NETLINK_SELINUX		7	</span><span class="cm">/* SELinux event notifications */</span><span class="cp"></span>
<span class="cp">#define NETLINK_ISCSI		8	</span><span class="cm">/* Open-iSCSI */</span><span class="cp"></span>
<span class="cp">#define NETLINK_AUDIT		9	</span><span class="cm">/* auditing */</span><span class="cp"></span>
<span class="cp">#define NETLINK_FIB_LOOKUP	10	</span>
<span class="cp">#define NETLINK_CONNECTOR	11</span>
<span class="cp">#define NETLINK_NETFILTER	12	</span><span class="cm">/* netfilter subsystem */</span><span class="cp"></span>
<span class="cp">#define NETLINK_IP6_FW		13</span>
<span class="cp">#define NETLINK_DNRTMSG		14	</span><span class="cm">/* DECnet routing messages */</span><span class="cp"></span>
<span class="cp">#define NETLINK_KOBJECT_UEVENT	15	</span><span class="cm">/* Kernel messages to userspace */</span><span class="cp"></span>
<span class="cp">#define NETLINK_GENERIC		16</span>
<span class="cm">/* leave room for NETLINK_DM (DM Events) */</span>
<span class="cp">#define NETLINK_SCSITRANSPORT	18	</span><span class="cm">/* SCSI Transports */</span><span class="cp"></span>
<span class="cp">#define NETLINK_ECRYPTFS	19</span>
<span class="cp">#define NETLINK_RDMA		20</span>
<span class="cp">#define NETLINK_CRYPTO		21	</span><span class="cm">/* Crypto layer */</span><span class="cp"></span>

<span class="cp">#define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG</span>

<span class="cp">#define MAX_LINKS 32		</span>

<span class="k">struct</span> <span class="n">sockaddr_nl</span> <span class="p">{</span>
	<span class="n">__kernel_sa_family_t</span>	<span class="n">nl_family</span><span class="p">;</span>	<span class="cm">/* AF_NETLINK	*/</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">nl_pad</span><span class="p">;</span>		<span class="cm">/* zero		*/</span>
	<span class="n">__u32</span>		<span class="n">nl_pid</span><span class="p">;</span>		<span class="cm">/* port ID	*/</span>
       	<span class="n">__u32</span>		<span class="n">nl_groups</span><span class="p">;</span>	<span class="cm">/* multicast groups mask */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">nlmsg_len</span><span class="p">;</span>	<span class="cm">/* Length of message including header */</span>
	<span class="n">__u16</span>		<span class="n">nlmsg_type</span><span class="p">;</span>	<span class="cm">/* Message content */</span>
	<span class="n">__u16</span>		<span class="n">nlmsg_flags</span><span class="p">;</span>	<span class="cm">/* Additional flags */</span>
	<span class="n">__u32</span>		<span class="n">nlmsg_seq</span><span class="p">;</span>	<span class="cm">/* Sequence number */</span>
	<span class="n">__u32</span>		<span class="n">nlmsg_pid</span><span class="p">;</span>	<span class="cm">/* Sending process port ID */</span>
<span class="p">};</span>

<span class="cm">/* Flags values */</span>

<span class="cp">#define NLM_F_REQUEST		1	</span><span class="cm">/* It is request message. 	*/</span><span class="cp"></span>
<span class="cp">#define NLM_F_MULTI		2	</span><span class="cm">/* Multipart message, terminated by NLMSG_DONE */</span><span class="cp"></span>
<span class="cp">#define NLM_F_ACK		4	</span><span class="cm">/* Reply with ack, with zero or error code */</span><span class="cp"></span>
<span class="cp">#define NLM_F_ECHO		8	</span><span class="cm">/* Echo this request 		*/</span><span class="cp"></span>
<span class="cp">#define NLM_F_DUMP_INTR		16	</span><span class="cm">/* Dump was inconsistent due to sequence change */</span><span class="cp"></span>

<span class="cm">/* Modifiers to GET request */</span>
<span class="cp">#define NLM_F_ROOT	0x100	</span><span class="cm">/* specify tree	root	*/</span><span class="cp"></span>
<span class="cp">#define NLM_F_MATCH	0x200	</span><span class="cm">/* return all matching	*/</span><span class="cp"></span>
<span class="cp">#define NLM_F_ATOMIC	0x400	</span><span class="cm">/* atomic GET		*/</span><span class="cp"></span>
<span class="cp">#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)</span>

<span class="cm">/* Modifiers to NEW request */</span>
<span class="cp">#define NLM_F_REPLACE	0x100	</span><span class="cm">/* Override existing		*/</span><span class="cp"></span>
<span class="cp">#define NLM_F_EXCL	0x200	</span><span class="cm">/* Do not touch, if it exists	*/</span><span class="cp"></span>
<span class="cp">#define NLM_F_CREATE	0x400	</span><span class="cm">/* Create, if it does not exist	*/</span><span class="cp"></span>
<span class="cp">#define NLM_F_APPEND	0x800	</span><span class="cm">/* Add to end of list		*/</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL</span>
<span class="cm">   4.4BSD CHANGE	NLM_F_REPLACE</span>

<span class="cm">   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE</span>
<span class="cm">   Append		NLM_F_CREATE</span>
<span class="cm">   Check		NLM_F_EXCL</span>
<span class="cm"> */</span>

<span class="cp">#define NLMSG_ALIGNTO	4U</span>
<span class="cp">#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) &amp; ~(NLMSG_ALIGNTO-1) )</span>
<span class="cp">#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))</span>
<span class="cp">#define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))</span>
<span class="cp">#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))</span>
<span class="cp">#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))</span>
<span class="cp">#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)-&gt;nlmsg_len), \</span>
<span class="cp">				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)-&gt;nlmsg_len)))</span>
<span class="cp">#define NLMSG_OK(nlh,len) ((len) &gt;= (int)sizeof(struct nlmsghdr) &amp;&amp; \</span>
<span class="cp">			   (nlh)-&gt;nlmsg_len &gt;= sizeof(struct nlmsghdr) &amp;&amp; \</span>
<span class="cp">			   (nlh)-&gt;nlmsg_len &lt;= (len))</span>
<span class="cp">#define NLMSG_PAYLOAD(nlh,len) ((nlh)-&gt;nlmsg_len - NLMSG_SPACE((len)))</span>

<span class="cp">#define NLMSG_NOOP		0x1	</span><span class="cm">/* Nothing.		*/</span><span class="cp"></span>
<span class="cp">#define NLMSG_ERROR		0x2	</span><span class="cm">/* Error		*/</span><span class="cp"></span>
<span class="cp">#define NLMSG_DONE		0x3	</span><span class="cm">/* End of a dump	*/</span><span class="cp"></span>
<span class="cp">#define NLMSG_OVERRUN		0x4	</span><span class="cm">/* Data lost		*/</span><span class="cp"></span>

<span class="cp">#define NLMSG_MIN_TYPE		0x10	</span><span class="cm">/* &lt; 0x10: reserved control messages */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">nlmsgerr</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NETLINK_ADD_MEMBERSHIP	1</span>
<span class="cp">#define NETLINK_DROP_MEMBERSHIP	2</span>
<span class="cp">#define NETLINK_PKTINFO		3</span>
<span class="cp">#define NETLINK_BROADCAST_ERROR	4</span>
<span class="cp">#define NETLINK_NO_ENOBUFS	5</span>

<span class="k">struct</span> <span class="n">nl_pktinfo</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">group</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NET_MAJOR 36		</span><span class="cm">/* Major 36 is reserved for networking 						*/</span><span class="cp"></span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NETLINK_UNCONNECTED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">NETLINK_CONNECTED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  &lt;------- NLA_HDRLEN ------&gt; &lt;-- NLA_ALIGN(payload)--&gt;</span>
<span class="cm"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span>
<span class="cm"> * |        Header       | Pad |     Payload       | Pad |</span>
<span class="cm"> * |   (struct nlattr)   | ing |                   | ing |</span>
<span class="cm"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span>
<span class="cm"> *  &lt;-------------- nlattr-&gt;nla_len --------------&gt;</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">nlattr</span> <span class="p">{</span>
	<span class="n">__u16</span>           <span class="n">nla_len</span><span class="p">;</span>
	<span class="n">__u16</span>           <span class="n">nla_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * nla_type (16 bits)</span>
<span class="cm"> * +---+---+-------------------------------+</span>
<span class="cm"> * | N | O | Attribute Type                |</span>
<span class="cm"> * +---+---+-------------------------------+</span>
<span class="cm"> * N := Carries nested attributes</span>
<span class="cm"> * O := Payload stored in network byte order</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The N and O flag are mutually exclusive.</span>
<span class="cm"> */</span>
<span class="cp">#define NLA_F_NESTED		(1 &lt;&lt; 15)</span>
<span class="cp">#define NLA_F_NET_BYTEORDER	(1 &lt;&lt; 14)</span>
<span class="cp">#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)</span>

<span class="cp">#define NLA_ALIGNTO		4</span>
<span class="cp">#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) &amp; ~(NLA_ALIGNTO - 1))</span>
<span class="cp">#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>

<span class="k">struct</span> <span class="n">net</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="nf">nlmsg_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">netlink_skb_parms</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ucred</span>		<span class="n">creds</span><span class="p">;</span>		<span class="cm">/* Skb credentials	*/</span>
	<span class="n">__u32</span>			<span class="n">pid</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">dst_group</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&amp;((skb)-&gt;cb))</span>
<span class="cp">#define NETLINK_CREDS(skb)	(&amp;NETLINK_CB((skb)).creds)</span>


<span class="k">extern</span> <span class="kt">void</span> <span class="n">netlink_table_grab</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netlink_table_ungrab</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">netlink_kernel_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">unit</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">groups</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">input</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">),</span>
					  <span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">cb_mutex</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netlink_kernel_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__netlink_change_ngroups</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">groups</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_change_ngroups</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">groups</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__netlink_clear_multicast_users</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netlink_clear_multicast_users</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netlink_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">in_skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_has_listeners</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_unicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">ssk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_broadcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">ssk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">pid</span><span class="p">,</span>
			     <span class="n">__u32</span> <span class="n">group</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">allocation</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_broadcast_filtered</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">ssk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="n">__u32</span> <span class="n">pid</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">group</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">allocation</span><span class="p">,</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">filter</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">dsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">filter_data</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_set_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">ssk</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">pid</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_register_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_unregister_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="cm">/* finegrained unicast helpers: */</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">netlink_getsockbyfilp</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlink_attachskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		      <span class="kt">long</span> <span class="o">*</span><span class="n">timeo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">ssk</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">netlink_detachskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">netlink_sendskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	skb should fit one page. This choice is good for headerless malloc.</span>
<span class="cm"> *	But we should limit to 8K so that userspace does not have to</span>
<span class="cm"> *	use enormous buffer sizes on recvmsg() calls just to avoid</span>
<span class="cm"> *	MSG_TRUNC when PAGE_SIZE is very large.</span>
<span class="cm"> */</span>
<span class="cp">#if PAGE_SIZE &lt; 8192UL</span>
<span class="cp">#define NLMSG_GOODSIZE	SKB_WITH_OVERHEAD(PAGE_SIZE)</span>
<span class="cp">#else</span>
<span class="cp">#define NLMSG_GOODSIZE	SKB_WITH_OVERHEAD(8192UL)</span>
<span class="cp">#endif</span>

<span class="cp">#define NLMSG_DEFAULT_SIZE (NLMSG_GOODSIZE - NLMSG_HDRLEN)</span>


<span class="k">struct</span> <span class="n">netlink_callback</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span>	<span class="o">*</span><span class="n">nlh</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">dump</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">skb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">family</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">min_dump_alloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">prev_seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">long</span>			<span class="n">args</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">netlink_notify</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">protocol</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span>
<span class="n">__nlmsg_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pid</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#define NLMSG_NEW(skb, pid, seq, type, len, flags) \</span>
<span class="cp">({	if (unlikely(skb_tailroom(skb) &lt; (int)NLMSG_SPACE(len))) \</span>
<span class="cp">		goto nlmsg_failure; \</span>
<span class="cp">	__nlmsg_put(skb, pid, seq, type, len, flags); })</span>

<span class="cp">#define NLMSG_PUT(skb, pid, seq, type, len) \</span>
<span class="cp">	NLMSG_NEW(skb, pid, seq, type, len, 0)</span>

<span class="k">struct</span> <span class="n">netlink_dump_control</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dump</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">netlink_callback</span><span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">min_dump_alloc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">netlink_dump_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">ssk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">nlmsghdr</span> <span class="o">*</span><span class="n">nlh</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">netlink_dump_control</span> <span class="o">*</span><span class="n">control</span><span class="p">);</span>


<span class="cp">#define NL_NONROOT_RECV 0x1</span>
<span class="cp">#define NL_NONROOT_SEND 0x2</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">netlink_set_nonroot</span><span class="p">(</span><span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flag</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* __LINUX_NETLINK_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
