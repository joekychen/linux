<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › jbd.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>jbd.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/include/linux/jbd.h</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Definitions for transaction data structures for the buffer cache</span>
<span class="cm"> * filesystem journaling support.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_JBD_H</span>
<span class="cp">#define _LINUX_JBD_H</span>

<span class="cm">/* Allow this file to be included directly into e2fsprogs */</span>
<span class="cp">#ifndef __KERNEL__</span>
<span class="cp">#include &quot;jfs_compat.h&quot;</span>
<span class="cp">#define JFS_DEBUG</span>
<span class="cp">#define jfs_debug jbd_debug</span>
<span class="cp">#else</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/journal-head.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/lockdep.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#define journal_oom_retry 1</span>

<span class="cm">/*</span>
<span class="cm"> * Define JBD_PARANOID_IOFAIL to cause a kernel BUG() if ext3 finds</span>
<span class="cm"> * certain classes of error which can occur due to failed IOs.  Under</span>
<span class="cm"> * normal use we want ext3 to continue after such errors, because</span>
<span class="cm"> * hardware _can_ fail, but for debugging purposes when running tests on</span>
<span class="cm"> * known-good hardware we may want to trap these errors.</span>
<span class="cm"> */</span>
<span class="cp">#undef JBD_PARANOID_IOFAIL</span>

<span class="cm">/*</span>
<span class="cm"> * The default maximum commit age, in seconds.</span>
<span class="cm"> */</span>
<span class="cp">#define JBD_DEFAULT_MAX_COMMIT_AGE 5</span>

<span class="cp">#ifdef CONFIG_JBD_DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * Define JBD_EXPENSIVE_CHECKING to enable more expensive internal</span>
<span class="cm"> * consistency checks.  By default we don&#39;t do this unless</span>
<span class="cm"> * CONFIG_JBD_DEBUG is on.</span>
<span class="cm"> */</span>
<span class="cp">#define JBD_EXPENSIVE_CHECKING</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">journal_enable_debug</span><span class="p">;</span>

<span class="cp">#define jbd_debug(n, f, a...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		if ((n) &lt;= journal_enable_debug) {			\</span>
<span class="cp">			printk (KERN_DEBUG &quot;(%s, %d): %s: &quot;,		\</span>
<span class="cp">				__FILE__, __LINE__, __func__);	\</span>
<span class="cp">			printk (f, ## a);				\</span>
<span class="cp">		}							\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define jbd_debug(f, a...)	</span><span class="cm">/**/</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">jbd_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">jbd_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="p">};</span>

<span class="cp">#define JFS_MIN_JOURNAL_BLOCKS 1024</span>


<span class="cm">/**</span>
<span class="cm"> * typedef handle_t - The handle_t type represents a single atomic update being performed by some process.</span>
<span class="cm"> *</span>
<span class="cm"> * All filesystem modifications made by the process go</span>
<span class="cm"> * through this handle.  Recursive operations (such as quota operations)</span>
<span class="cm"> * are gathered into a single update.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer credits field is used to account for journaled buffers</span>
<span class="cm"> * being modified by the running process.  To ensure that there is</span>
<span class="cm"> * enough log space for all outstanding operations, we need to limit the</span>
<span class="cm"> * number of outstanding buffers possible at any time.  When the</span>
<span class="cm"> * operation completes, any buffer credits not used are credited back to</span>
<span class="cm"> * the transaction, so that at all times we know how many buffers the</span>
<span class="cm"> * outstanding updates on a transaction might possibly touch.</span>
<span class="cm"> *</span>
<span class="cm"> * This is an opaque datatype.</span>
<span class="cm"> **/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">handle_s</span>		<span class="n">handle_t</span><span class="p">;</span>	<span class="cm">/* Atomic operation type */</span>


<span class="cm">/**</span>
<span class="cm"> * typedef journal_t - The journal_t maintains all of the journaling state information for a single filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> * journal_t is linked to from the fs superblock structure.</span>
<span class="cm"> *</span>
<span class="cm"> * We use the journal_t to keep track of all outstanding transaction</span>
<span class="cm"> * activity on the filesystem, and to manage the state of the log</span>
<span class="cm"> * writing process.</span>
<span class="cm"> *</span>
<span class="cm"> * This is an opaque datatype.</span>
<span class="cm"> **/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_s</span>	<span class="n">journal_t</span><span class="p">;</span>	<span class="cm">/* Journal control structure */</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Internal structures used by the logging mechanism:</span>
<span class="cm"> */</span>

<span class="cp">#define JFS_MAGIC_NUMBER 0xc03b3998U </span><span class="cm">/* The first 4 bytes of /dev/random! */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * On-disk structures</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Descriptor block types:</span>
<span class="cm"> */</span>

<span class="cp">#define JFS_DESCRIPTOR_BLOCK	1</span>
<span class="cp">#define JFS_COMMIT_BLOCK	2</span>
<span class="cp">#define JFS_SUPERBLOCK_V1	3</span>
<span class="cp">#define JFS_SUPERBLOCK_V2	4</span>
<span class="cp">#define JFS_REVOKE_BLOCK	5</span>

<span class="cm">/*</span>
<span class="cm"> * Standard header for all descriptor blocks:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_header_s</span>
<span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">h_magic</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">h_blocktype</span><span class="p">;</span>
	<span class="n">__be32</span>		<span class="n">h_sequence</span><span class="p">;</span>
<span class="p">}</span> <span class="n">journal_header_t</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * The block tag: used to describe a single buffer in the journal</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_block_tag_s</span>
<span class="p">{</span>
	<span class="n">__be32</span>		<span class="n">t_blocknr</span><span class="p">;</span>	<span class="cm">/* The on-disk block number */</span>
	<span class="n">__be32</span>		<span class="n">t_flags</span><span class="p">;</span>	<span class="cm">/* See below */</span>
<span class="p">}</span> <span class="n">journal_block_tag_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The revoke descriptor: used on disk to describe a series of blocks to</span>
<span class="cm"> * be revoked from the log</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_revoke_header_s</span>
<span class="p">{</span>
	<span class="n">journal_header_t</span> <span class="n">r_header</span><span class="p">;</span>
	<span class="n">__be32</span>		 <span class="n">r_count</span><span class="p">;</span>	<span class="cm">/* Count of bytes used in the block */</span>
<span class="p">}</span> <span class="n">journal_revoke_header_t</span><span class="p">;</span>


<span class="cm">/* Definitions for the journal tag flags word: */</span>
<span class="cp">#define JFS_FLAG_ESCAPE		1	</span><span class="cm">/* on-disk block is escaped */</span><span class="cp"></span>
<span class="cp">#define JFS_FLAG_SAME_UUID	2	</span><span class="cm">/* block has same uuid as previous */</span><span class="cp"></span>
<span class="cp">#define JFS_FLAG_DELETED	4	</span><span class="cm">/* block deleted by this transaction */</span><span class="cp"></span>
<span class="cp">#define JFS_FLAG_LAST_TAG	8	</span><span class="cm">/* last tag in this descriptor block */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * The journal superblock.  All fields are in big-endian byte order.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">journal_superblock_s</span>
<span class="p">{</span>
<span class="cm">/* 0x0000 */</span>
	<span class="n">journal_header_t</span> <span class="n">s_header</span><span class="p">;</span>

<span class="cm">/* 0x000C */</span>
	<span class="cm">/* Static information describing the journal */</span>
	<span class="n">__be32</span>	<span class="n">s_blocksize</span><span class="p">;</span>		<span class="cm">/* journal device blocksize */</span>
	<span class="n">__be32</span>	<span class="n">s_maxlen</span><span class="p">;</span>		<span class="cm">/* total blocks in journal file */</span>
	<span class="n">__be32</span>	<span class="n">s_first</span><span class="p">;</span>		<span class="cm">/* first block of log information */</span>

<span class="cm">/* 0x0018 */</span>
	<span class="cm">/* Dynamic information describing the current state of the log */</span>
	<span class="n">__be32</span>	<span class="n">s_sequence</span><span class="p">;</span>		<span class="cm">/* first commit ID expected in log */</span>
	<span class="n">__be32</span>	<span class="n">s_start</span><span class="p">;</span>		<span class="cm">/* blocknr of start of log */</span>

<span class="cm">/* 0x0020 */</span>
	<span class="cm">/* Error value, as set by journal_abort(). */</span>
	<span class="n">__be32</span>	<span class="n">s_errno</span><span class="p">;</span>

<span class="cm">/* 0x0024 */</span>
	<span class="cm">/* Remaining fields are only valid in a version-2 superblock */</span>
	<span class="n">__be32</span>	<span class="n">s_feature_compat</span><span class="p">;</span>	<span class="cm">/* compatible feature set */</span>
	<span class="n">__be32</span>	<span class="n">s_feature_incompat</span><span class="p">;</span>	<span class="cm">/* incompatible feature set */</span>
	<span class="n">__be32</span>	<span class="n">s_feature_ro_compat</span><span class="p">;</span>	<span class="cm">/* readonly-compatible feature set */</span>
<span class="cm">/* 0x0030 */</span>
	<span class="n">__u8</span>	<span class="n">s_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 128-bit uuid for journal */</span>

<span class="cm">/* 0x0040 */</span>
	<span class="n">__be32</span>	<span class="n">s_nr_users</span><span class="p">;</span>		<span class="cm">/* Nr of filesystems sharing log */</span>

	<span class="n">__be32</span>	<span class="n">s_dynsuper</span><span class="p">;</span>		<span class="cm">/* Blocknr of dynamic superblock copy*/</span>

<span class="cm">/* 0x0048 */</span>
	<span class="n">__be32</span>	<span class="n">s_max_transaction</span><span class="p">;</span>	<span class="cm">/* Limit of journal blocks per trans.*/</span>
	<span class="n">__be32</span>	<span class="n">s_max_trans_data</span><span class="p">;</span>	<span class="cm">/* Limit of data blocks per trans. */</span>

<span class="cm">/* 0x0050 */</span>
	<span class="n">__u32</span>	<span class="n">s_padding</span><span class="p">[</span><span class="mi">44</span><span class="p">];</span>

<span class="cm">/* 0x0100 */</span>
	<span class="n">__u8</span>	<span class="n">s_users</span><span class="p">[</span><span class="mi">16</span><span class="o">*</span><span class="mi">48</span><span class="p">];</span>		<span class="cm">/* ids of all fs&#39;es sharing the log */</span>
<span class="cm">/* 0x0400 */</span>
<span class="p">}</span> <span class="n">journal_superblock_t</span><span class="p">;</span>

<span class="cp">#define JFS_HAS_COMPAT_FEATURE(j,mask)					\</span>
<span class="cp">	((j)-&gt;j_format_version &gt;= 2 &amp;&amp;					\</span>
<span class="cp">	 ((j)-&gt;j_superblock-&gt;s_feature_compat &amp; cpu_to_be32((mask))))</span>
<span class="cp">#define JFS_HAS_RO_COMPAT_FEATURE(j,mask)				\</span>
<span class="cp">	((j)-&gt;j_format_version &gt;= 2 &amp;&amp;					\</span>
<span class="cp">	 ((j)-&gt;j_superblock-&gt;s_feature_ro_compat &amp; cpu_to_be32((mask))))</span>
<span class="cp">#define JFS_HAS_INCOMPAT_FEATURE(j,mask)				\</span>
<span class="cp">	((j)-&gt;j_format_version &gt;= 2 &amp;&amp;					\</span>
<span class="cp">	 ((j)-&gt;j_superblock-&gt;s_feature_incompat &amp; cpu_to_be32((mask))))</span>

<span class="cp">#define JFS_FEATURE_INCOMPAT_REVOKE	0x00000001</span>

<span class="cm">/* Features known to this kernel version: */</span>
<span class="cp">#define JFS_KNOWN_COMPAT_FEATURES	0</span>
<span class="cp">#define JFS_KNOWN_ROCOMPAT_FEATURES	0</span>
<span class="cp">#define JFS_KNOWN_INCOMPAT_FEATURES	JFS_FEATURE_INCOMPAT_REVOKE</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/jbd_common.h&gt;</span>

<span class="cp">#define J_ASSERT(assert)	BUG_ON(!(assert))</span>

<span class="cp">#define J_ASSERT_BH(bh, expr)	J_ASSERT(expr)</span>
<span class="cp">#define J_ASSERT_JH(jh, expr)	J_ASSERT(expr)</span>

<span class="cp">#if defined(JBD_PARANOID_IOFAIL)</span>
<span class="cp">#define J_EXPECT(expr, why...)		J_ASSERT(expr)</span>
<span class="cp">#define J_EXPECT_BH(bh, expr, why...)	J_ASSERT_BH(bh, expr)</span>
<span class="cp">#define J_EXPECT_JH(jh, expr, why...)	J_ASSERT_JH(jh, expr)</span>
<span class="cp">#else</span>
<span class="cp">#define __journal_expect(expr, why...)					     \</span>
<span class="cp">	({								     \</span>
<span class="cp">		int val = (expr);					     \</span>
<span class="cp">		if (!val) {						     \</span>
<span class="cp">			printk(KERN_ERR					     \</span>
<span class="cp">				&quot;EXT3-fs unexpected failure: %s;\n&quot;,# expr); \</span>
<span class="cp">			printk(KERN_ERR why &quot;\n&quot;);			     \</span>
<span class="cp">		}							     \</span>
<span class="cp">		val;							     \</span>
<span class="cp">	})</span>
<span class="cp">#define J_EXPECT(expr, why...)		__journal_expect(expr, ## why)</span>
<span class="cp">#define J_EXPECT_BH(bh, expr, why...)	__journal_expect(expr, ## why)</span>
<span class="cp">#define J_EXPECT_JH(jh, expr, why...)	__journal_expect(expr, ## why)</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">jbd_revoke_table_s</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct handle_s - this is the concrete type associated with handle_t.</span>
<span class="cm"> * @h_transaction: Which compound transaction is this update a part of?</span>
<span class="cm"> * @h_buffer_credits: Number of remaining buffers we are allowed to dirty.</span>
<span class="cm"> * @h_ref: Reference count on this handle</span>
<span class="cm"> * @h_err: Field for caller&#39;s use to track errors through large fs operations</span>
<span class="cm"> * @h_sync: flag for sync-on-close</span>
<span class="cm"> * @h_jdata: flag to force data journaling</span>
<span class="cm"> * @h_aborted: flag indicating fatal error on handle</span>
<span class="cm"> * @h_lockdep_map: lockdep info for debugging lock problems</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">handle_s</span>
<span class="p">{</span>
	<span class="cm">/* Which compound transaction is this update a part of? */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">h_transaction</span><span class="p">;</span>

	<span class="cm">/* Number of remaining buffers we are allowed to dirty: */</span>
	<span class="kt">int</span>			<span class="n">h_buffer_credits</span><span class="p">;</span>

	<span class="cm">/* Reference count on this handle */</span>
	<span class="kt">int</span>			<span class="n">h_ref</span><span class="p">;</span>

	<span class="cm">/* Field for caller&#39;s use to track errors through large fs */</span>
	<span class="cm">/* operations */</span>
	<span class="kt">int</span>			<span class="n">h_err</span><span class="p">;</span>

	<span class="cm">/* Flags [no locking] */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_sync</span><span class="o">:</span>		<span class="mi">1</span><span class="p">;</span>	<span class="cm">/* sync-on-close */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_jdata</span><span class="o">:</span>	<span class="mi">1</span><span class="p">;</span>	<span class="cm">/* force data journaling */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">h_aborted</span><span class="o">:</span>	<span class="mi">1</span><span class="p">;</span>	<span class="cm">/* fatal error on handle */</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span>	<span class="n">h_lockdep_map</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="cm">/* The transaction_t type is the guts of the journaling mechanism.  It</span>
<span class="cm"> * tracks a compound transaction through its various states:</span>
<span class="cm"> *</span>
<span class="cm"> * RUNNING:	accepting new updates</span>
<span class="cm"> * LOCKED:	Updates still running but we don&#39;t accept new ones</span>
<span class="cm"> * RUNDOWN:	Updates are tidying up but have finished requesting</span>
<span class="cm"> *		new buffers to modify (state not used for now)</span>
<span class="cm"> * FLUSH:       All updates complete, but we are still writing to disk</span>
<span class="cm"> * COMMIT:      All data on disk, writing commit record</span>
<span class="cm"> * FINISHED:	We still have to keep the transaction for checkpointing.</span>
<span class="cm"> *</span>
<span class="cm"> * The transaction keeps track of all of the buffers modified by a</span>
<span class="cm"> * running transaction, and all of the buffers committed but not yet</span>
<span class="cm"> * flushed to home for finished transactions.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Lock ranking:</span>
<span class="cm"> *</span>
<span class="cm"> *    j_list_lock</span>
<span class="cm"> *      -&gt;jbd_lock_bh_journal_head()	(This is &quot;innermost&quot;)</span>
<span class="cm"> *</span>
<span class="cm"> *    j_state_lock</span>
<span class="cm"> *    -&gt;jbd_lock_bh_state()</span>
<span class="cm"> *</span>
<span class="cm"> *    jbd_lock_bh_state()</span>
<span class="cm"> *    -&gt;j_list_lock</span>
<span class="cm"> *</span>
<span class="cm"> *    j_state_lock</span>
<span class="cm"> *    -&gt;t_handle_lock</span>
<span class="cm"> *</span>
<span class="cm"> *    j_state_lock</span>
<span class="cm"> *    -&gt;j_list_lock			(journal_unmap_buffer)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">transaction_s</span>
<span class="p">{</span>
	<span class="cm">/* Pointer to the journal for this transaction. [no locking] */</span>
	<span class="n">journal_t</span>		<span class="o">*</span><span class="n">t_journal</span><span class="p">;</span>

	<span class="cm">/* Sequence number for this transaction [no locking] */</span>
	<span class="n">tid_t</span>			<span class="n">t_tid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transaction&#39;s current state</span>
<span class="cm">	 * [no locking - only kjournald alters this]</span>
<span class="cm">	 * [j_list_lock] guards transition of a transaction into T_FINISHED</span>
<span class="cm">	 * state and subsequent call of __journal_drop_transaction()</span>
<span class="cm">	 * FIXME: needs barriers</span>
<span class="cm">	 * KLUDGE: [use j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="p">{</span>
		<span class="n">T_RUNNING</span><span class="p">,</span>
		<span class="n">T_LOCKED</span><span class="p">,</span>
		<span class="n">T_FLUSH</span><span class="p">,</span>
		<span class="n">T_COMMIT</span><span class="p">,</span>
		<span class="n">T_COMMIT_RECORD</span><span class="p">,</span>
		<span class="n">T_FINISHED</span>
	<span class="p">}</span>			<span class="n">t_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Where in the log does this transaction&#39;s commit start? [no locking]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">t_log_start</span><span class="p">;</span>

	<span class="cm">/* Number of buffers on the t_buffers list [j_list_lock] */</span>
	<span class="kt">int</span>			<span class="n">t_nr_buffers</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all buffers reserved but not yet</span>
<span class="cm">	 * modified by this transaction [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_reserved_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all buffers under writeout during</span>
<span class="cm">	 * commit [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_locked_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all metadata buffers owned by this</span>
<span class="cm">	 * transaction [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_buffers</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all data buffers still to be</span>
<span class="cm">	 * flushed before this transaction can be committed [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_sync_datalist</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all forget buffers (superseded</span>
<span class="cm">	 * buffers which we can un-checkpoint once this transaction commits)</span>
<span class="cm">	 * [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_forget</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all buffers still to be flushed before</span>
<span class="cm">	 * this transaction can be checkpointed. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_checkpoint_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of all buffers submitted for IO while</span>
<span class="cm">	 * checkpointing. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_checkpoint_io_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of temporary buffers currently undergoing</span>
<span class="cm">	 * IO in the log [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_iobuf_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of metadata buffers being shadowed by log</span>
<span class="cm">	 * IO.  The IO buffers on the iobuf list and the shadow buffers on this</span>
<span class="cm">	 * list match each other one for one at all times. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_shadow_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doubly-linked circular list of control buffers being written to the</span>
<span class="cm">	 * log. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">journal_head</span>	<span class="o">*</span><span class="n">t_log_list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protects info related to handles</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">t_handle_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of outstanding updates running on this transaction</span>
<span class="cm">	 * [t_handle_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">t_updates</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of buffers reserved for use by all handles in this transaction</span>
<span class="cm">	 * handle but not yet modified. [t_handle_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">t_outstanding_credits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Forward and backward links for the circular list of all transactions</span>
<span class="cm">	 * awaiting checkpoint. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">t_cpnext</span><span class="p">,</span> <span class="o">*</span><span class="n">t_cpprev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When will the transaction expire (become due for commit), in jiffies?</span>
<span class="cm">	 * [no locking]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">t_expires</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When this transaction started, in nanoseconds [no locking]</span>
<span class="cm">	 */</span>
	<span class="n">ktime_t</span>			<span class="n">t_start_time</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * How many handles used this transaction? [t_handle_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">t_handle_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct journal_s - this is the concrete type associated with journal_t.</span>
<span class="cm"> * @j_flags:  General journaling state flags</span>
<span class="cm"> * @j_errno:  Is there an outstanding uncleared error on the journal (from a</span>
<span class="cm"> *     prior abort)?</span>
<span class="cm"> * @j_sb_buffer: First part of superblock buffer</span>
<span class="cm"> * @j_superblock: Second part of superblock buffer</span>
<span class="cm"> * @j_format_version: Version of the superblock format</span>
<span class="cm"> * @j_state_lock: Protect the various scalars in the journal</span>
<span class="cm"> * @j_barrier_count:  Number of processes waiting to create a barrier lock</span>
<span class="cm"> * @j_running_transaction: The current running transaction..</span>
<span class="cm"> * @j_committing_transaction: the transaction we are pushing to disk</span>
<span class="cm"> * @j_checkpoint_transactions: a linked circular list of all transactions</span>
<span class="cm"> *  waiting for checkpointing</span>
<span class="cm"> * @j_wait_transaction_locked: Wait queue for waiting for a locked transaction</span>
<span class="cm"> *  to start committing, or for a barrier lock to be released</span>
<span class="cm"> * @j_wait_logspace: Wait queue for waiting for checkpointing to complete</span>
<span class="cm"> * @j_wait_done_commit: Wait queue for waiting for commit to complete</span>
<span class="cm"> * @j_wait_checkpoint:  Wait queue to trigger checkpointing</span>
<span class="cm"> * @j_wait_commit: Wait queue to trigger commit</span>
<span class="cm"> * @j_wait_updates: Wait queue to wait for updates to complete</span>
<span class="cm"> * @j_checkpoint_mutex: Mutex for locking against concurrent checkpoints</span>
<span class="cm"> * @j_head: Journal head - identifies the first unused block in the journal</span>
<span class="cm"> * @j_tail: Journal tail - identifies the oldest still-used block in the</span>
<span class="cm"> *  journal.</span>
<span class="cm"> * @j_free: Journal free - how many free blocks are there in the journal?</span>
<span class="cm"> * @j_first: The block number of the first usable block</span>
<span class="cm"> * @j_last: The block number one beyond the last usable block</span>
<span class="cm"> * @j_dev: Device where we store the journal</span>
<span class="cm"> * @j_blocksize: blocksize for the location where we store the journal.</span>
<span class="cm"> * @j_blk_offset: starting block offset for into the device where we store the</span>
<span class="cm"> *     journal</span>
<span class="cm"> * @j_fs_dev: Device which holds the client fs.  For internal journal this will</span>
<span class="cm"> *     be equal to j_dev</span>
<span class="cm"> * @j_maxlen: Total maximum capacity of the journal region on disk.</span>
<span class="cm"> * @j_list_lock: Protects the buffer lists and internal buffer state.</span>
<span class="cm"> * @j_inode: Optional inode where we store the journal.  If present, all journal</span>
<span class="cm"> *     block numbers are mapped into this inode via bmap().</span>
<span class="cm"> * @j_tail_sequence:  Sequence number of the oldest transaction in the log</span>
<span class="cm"> * @j_transaction_sequence: Sequence number of the next transaction to grant</span>
<span class="cm"> * @j_commit_sequence: Sequence number of the most recently committed</span>
<span class="cm"> *  transaction</span>
<span class="cm"> * @j_commit_request: Sequence number of the most recent transaction wanting</span>
<span class="cm"> *     commit</span>
<span class="cm"> * @j_commit_waited: Sequence number of the most recent transaction someone</span>
<span class="cm"> *     is waiting for to commit.</span>
<span class="cm"> * @j_uuid: Uuid of client object.</span>
<span class="cm"> * @j_task: Pointer to the current commit thread for this journal</span>
<span class="cm"> * @j_max_transaction_buffers:  Maximum number of metadata buffers to allow in a</span>
<span class="cm"> *     single compound commit transaction</span>
<span class="cm"> * @j_commit_interval: What is the maximum transaction lifetime before we begin</span>
<span class="cm"> *  a commit?</span>
<span class="cm"> * @j_commit_timer:  The timer used to wakeup the commit thread</span>
<span class="cm"> * @j_revoke_lock: Protect the revoke table</span>
<span class="cm"> * @j_revoke: The revoke table - maintains the list of revoked blocks in the</span>
<span class="cm"> *     current transaction.</span>
<span class="cm"> * @j_revoke_table: alternate revoke tables for j_revoke</span>
<span class="cm"> * @j_wbuf: array of buffer_heads for journal_commit_transaction</span>
<span class="cm"> * @j_wbufsize: maximum number of buffer_heads allowed in j_wbuf, the</span>
<span class="cm"> *	number that will fit in j_blocksize</span>
<span class="cm"> * @j_last_sync_writer: most recent pid which did a synchronous write</span>
<span class="cm"> * @j_average_commit_time: the average amount of time in nanoseconds it</span>
<span class="cm"> *	takes to commit a transaction to the disk.</span>
<span class="cm"> * @j_private: An opaque pointer to fs-private information.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">journal_s</span>
<span class="p">{</span>
	<span class="cm">/* General journaling state flags [j_state_lock] */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is there an outstanding uncleared error on the journal (from a prior</span>
<span class="cm">	 * abort)? [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">j_errno</span><span class="p">;</span>

	<span class="cm">/* The superblock buffer */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">*</span><span class="n">j_sb_buffer</span><span class="p">;</span>
	<span class="n">journal_superblock_t</span>	<span class="o">*</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="cm">/* Version of the superblock format */</span>
	<span class="kt">int</span>			<span class="n">j_format_version</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protect the various scalars in the journal</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">j_state_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Number of processes waiting to create a barrier lock [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">j_barrier_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transactions: The current running transaction...</span>
<span class="cm">	 * [j_state_lock] [caller holding open handle]</span>
<span class="cm">	 */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">j_running_transaction</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the transaction we are pushing to disk</span>
<span class="cm">	 * [j_state_lock] [caller holding open handle]</span>
<span class="cm">	 */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">j_committing_transaction</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ... and a linked circular list of all transactions waiting for</span>
<span class="cm">	 * checkpointing. [j_list_lock]</span>
<span class="cm">	 */</span>
	<span class="n">transaction_t</span>		<span class="o">*</span><span class="n">j_checkpoint_transactions</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait queue for waiting for a locked transaction to start committing,</span>
<span class="cm">	 * or for a barrier lock to be released</span>
<span class="cm">	 */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_transaction_locked</span><span class="p">;</span>

	<span class="cm">/* Wait queue for waiting for checkpointing to complete */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_logspace</span><span class="p">;</span>

	<span class="cm">/* Wait queue for waiting for commit to complete */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_done_commit</span><span class="p">;</span>

	<span class="cm">/* Wait queue to trigger checkpointing */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_checkpoint</span><span class="p">;</span>

	<span class="cm">/* Wait queue to trigger commit */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_commit</span><span class="p">;</span>

	<span class="cm">/* Wait queue to wait for updates to complete */</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">j_wait_updates</span><span class="p">;</span>

	<span class="cm">/* Semaphore for locking against concurrent checkpoints */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">j_checkpoint_mutex</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal head: identifies the first unused block in the journal.</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_head</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal tail: identifies the oldest still-used block in the journal.</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_tail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal free: how many free blocks are there in the journal?</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_free</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal start and end: the block numbers of the first usable block</span>
<span class="cm">	 * and one beyond the last usable block in the journal. [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_last</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device, blocksize and starting block offset for the location where we</span>
<span class="cm">	 * store the journal.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">j_dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">j_blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_blk_offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device which holds the client fs.  For internal journal this will be</span>
<span class="cm">	 * equal to j_dev.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">block_device</span>	<span class="o">*</span><span class="n">j_fs_dev</span><span class="p">;</span>

	<span class="cm">/* Total maximum capacity of the journal region on disk. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">j_maxlen</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protects the buffer lists and internal buffer state.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">j_list_lock</span><span class="p">;</span>

	<span class="cm">/* Optional inode where we store the journal.  If present, all */</span>
	<span class="cm">/* journal block numbers are mapped into this inode via */</span>
	<span class="cm">/* bmap(). */</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">j_inode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the oldest transaction in the log [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>			<span class="n">j_tail_sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the next transaction to grant [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>			<span class="n">j_transaction_sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the most recently committed transaction</span>
<span class="cm">	 * [j_state_lock].</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>			<span class="n">j_commit_sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the most recent transaction wanting commit</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>			<span class="n">j_commit_request</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sequence number of the most recent transaction someone is waiting</span>
<span class="cm">	 * for to commit.</span>
<span class="cm">	 * [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span>                   <span class="n">j_commit_waited</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Journal uuid: identifies the object (filesystem, LVM volume etc)</span>
<span class="cm">	 * backed by this journal.  This will eventually be replaced by an array</span>
<span class="cm">	 * of uuids, allowing us to index multiple devices within a single</span>
<span class="cm">	 * journal and to perform atomic updates across them.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span>			<span class="n">j_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="cm">/* Pointer to the current commit thread for this journal */</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">j_task</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum number of metadata buffers to allow in a single compound</span>
<span class="cm">	 * commit transaction</span>
<span class="cm">	 */</span>
	<span class="kt">int</span>			<span class="n">j_max_transaction_buffers</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * What is the maximum transaction lifetime before we begin a commit?</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">j_commit_interval</span><span class="p">;</span>

	<span class="cm">/* The timer used to wakeup the commit thread: */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">j_commit_timer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The revoke table: maintains the list of revoked blocks in the</span>
<span class="cm">	 * current transaction.  [j_revoke_lock]</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span>		<span class="n">j_revoke_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd_revoke_table_s</span> <span class="o">*</span><span class="n">j_revoke</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd_revoke_table_s</span> <span class="o">*</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * array of bhs for journal_commit_transaction</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>	<span class="o">**</span><span class="n">j_wbuf</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">j_wbufsize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * this is the pid of the last person to run a synchronous operation</span>
<span class="cm">	 * through the journal.</span>
<span class="cm">	 */</span>
	<span class="n">pid_t</span>			<span class="n">j_last_sync_writer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the average amount of time in nanoseconds it takes to commit a</span>
<span class="cm">	 * transaction to the disk.  [j_state_lock]</span>
<span class="cm">	 */</span>
	<span class="n">u64</span>			<span class="n">j_average_commit_time</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * An opaque pointer to fs-private information.  ext3 puts its</span>
<span class="cm">	 * superblock pointer here</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">j_private</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Journal flag definitions</span>
<span class="cm"> */</span>
<span class="cp">#define JFS_UNMOUNT	0x001	</span><span class="cm">/* Journal thread is being destroyed */</span><span class="cp"></span>
<span class="cp">#define JFS_ABORT	0x002	</span><span class="cm">/* Journaling has been aborted for errors. */</span><span class="cp"></span>
<span class="cp">#define JFS_ACK_ERR	0x004	</span><span class="cm">/* The errno in the sb has been acked */</span><span class="cp"></span>
<span class="cp">#define JFS_FLUSHED	0x008	</span><span class="cm">/* The journal superblock has been flushed */</span><span class="cp"></span>
<span class="cp">#define JFS_LOADED	0x010	</span><span class="cm">/* The journal superblock has been loaded */</span><span class="cp"></span>
<span class="cp">#define JFS_BARRIER	0x020	</span><span class="cm">/* Use IDE barriers */</span><span class="cp"></span>
<span class="cp">#define JFS_ABORT_ON_SYNCDATA_ERR	0x040  </span><span class="cm">/* Abort the journal on file</span>
<span class="cm">						* data write error in ordered</span>
<span class="cm">						* mode */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Function declarations for the journaling transaction and buffer</span>
<span class="cm"> * management</span>
<span class="cm"> */</span>

<span class="cm">/* Filing buffers */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">journal_unfile_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__journal_unfile_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__journal_refile_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">journal_refile_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__journal_file_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__journal_free_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">journal_file_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__journal_clean_data_list</span><span class="p">(</span><span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">);</span>

<span class="cm">/* Log buffer allocation */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span> <span class="n">journal_get_descriptor_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_next_log_block</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Commit management */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">journal_commit_transaction</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Checkpoint list management */</span>
<span class="kt">int</span> <span class="n">__journal_clean_checkpoint_list</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__journal_remove_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__journal_insert_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Buffer IO */</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">journal_write_metadata_buffer</span><span class="p">(</span><span class="n">transaction_t</span>	  <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">journal_head</span>  <span class="o">*</span><span class="n">jh_in</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="n">jh_out</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocknr</span><span class="p">);</span>

<span class="cm">/* Transaction locking */</span>
<span class="k">extern</span> <span class="kt">void</span>		<span class="n">__wait_on_journal</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Journal locking.</span>
<span class="cm"> *</span>
<span class="cm"> * We need to lock the journal during transaction state changes so that nobody</span>
<span class="cm"> * ever tries to take a handle on the running transaction while we are in the</span>
<span class="cm"> * middle of moving it to the commit phase.  j_state_lock does this.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the locking is completely interrupt unsafe.  We never touch</span>
<span class="cm"> * journal structures from interrupts.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">journal_current_handle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The journaling code user interface:</span>
<span class="cm"> *</span>
<span class="cm"> * Create and destroy handles</span>
<span class="cm"> * Register buffer modifications against the current transaction.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">journal_start</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_restart</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_extend</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_get_write_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_get_create_access</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_get_undo_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_dirty_data</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_dirty_metadata</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">journal_release_buffer</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_forget</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">journal_sync_buffer</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">journal_invalidatepage</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_try_to_free_buffers</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_stop</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	 <span class="n">journal_flush</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">journal_lock_updates</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	 <span class="n">journal_unlock_updates</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">journal_t</span> <span class="o">*</span> <span class="n">journal_init_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">fs_dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bsize</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">journal_t</span> <span class="o">*</span> <span class="n">journal_init_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_update_format</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_check_used_features</span>
		   <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_check_available_features</span>
		   <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_set_features</span>
		   <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_create</span>     <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_load</span>       <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_destroy</span>    <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_recover</span>    <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_wipe</span>       <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_skip_recovery</span>	<span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">journal_update_sb_log_tail</span>	<span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">tid_t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
						 <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">journal_abort</span>      <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_errno</span>      <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">journal_ack_err</span>    <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_clear_err</span>  <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_bmap</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_force_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * journal_head management</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">journal_add_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">journal_grab_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">journal_put_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * handle management</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">jbd_handle_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">jbd_alloc_handle</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">jbd_handle_cache</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">jbd_free_handle</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd_handle_cache</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Primary revoke support */</span>
<span class="cp">#define JOURNAL_REVOKE_DEFAULT_HASH 256</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_init_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">journal_destroy_revoke_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_init_revoke_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">journal_destroy_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_revoke</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	   <span class="n">journal_cancel_revoke</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	   <span class="n">journal_write_revoke_records</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span>
						<span class="n">transaction_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* Recovery revoke support */</span>
<span class="k">extern</span> <span class="kt">int</span>	<span class="n">journal_set_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tid_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	<span class="n">journal_test_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tid_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	<span class="n">journal_clear_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	<span class="n">journal_switch_revoke_table</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	<span class="n">journal_clear_buffer_revoked_flags</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The log thread user interface:</span>
<span class="cm"> *</span>
<span class="cm"> * Request space in the current transaction, and force transaction commit</span>
<span class="cm"> * transitions on demand.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__log_space_left</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span> <span class="cm">/* Called with journal locked */</span>
<span class="kt">int</span> <span class="n">log_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__log_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="o">*</span><span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_force_commit_nested</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">log_wait_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">log_do_checkpoint</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">journal_trans_will_send_data_barrier</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__log_wait_for_space</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span>	<span class="n">__journal_drop_transaction</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>	<span class="n">cleanup_journal_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Debugging code only: */</span>

<span class="cp">#define jbd_ENOSYS() \</span>
<span class="cp">do {								           \</span>
<span class="cp">	printk (KERN_ERR &quot;JBD unimplemented function %s\n&quot;, __func__); \</span>
<span class="cp">	current-&gt;state = TASK_UNINTERRUPTIBLE;			           \</span>
<span class="cp">	schedule();						           \</span>
<span class="cp">} while (1)</span>

<span class="cm">/*</span>
<span class="cm"> * is_journal_abort</span>
<span class="cm"> *</span>
<span class="cm"> * Simple test wrapper function to test the JFS_ABORT state flag.  This</span>
<span class="cm"> * bit, when set, indicates that we have had a fatal error somewhere,</span>
<span class="cm"> * either inside the journaling layer or indicated to us by the client</span>
<span class="cm"> * (eg. ext3), and that we and should not commit any further</span>
<span class="cm"> * transactions.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_journal_aborted</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JFS_ABORT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_handle_aborted</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_aborted</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">journal_abort_handle</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_aborted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__   */</span><span class="cp"></span>

<span class="cm">/* Comparison functions for transaction IDs: perform comparisons using</span>
<span class="cm"> * modulo arithmetic so that they work over sequence number wraps. */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tid_gt</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">difference</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">difference</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tid_geq</span><span class="p">(</span><span class="n">tid_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">difference</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">difference</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">journal_blocks_per_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return the minimum number of blocks which must be free in the journal</span>
<span class="cm"> * before a new transaction may be started.  Must be called under j_state_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">jbd_space_needed</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nblocks</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span>
		<span class="n">nblocks</span> <span class="o">+=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="o">-&gt;</span>
					<span class="n">t_outstanding_credits</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nblocks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions which augment the buffer_head layer</span>
<span class="cm"> */</span>

<span class="cm">/* journaling buffer types */</span>
<span class="cp">#define BJ_None		0	</span><span class="cm">/* Not journaled */</span><span class="cp"></span>
<span class="cp">#define BJ_SyncData	1	</span><span class="cm">/* Normal data: flush before commit */</span><span class="cp"></span>
<span class="cp">#define BJ_Metadata	2	</span><span class="cm">/* Normal journaled metadata */</span><span class="cp"></span>
<span class="cp">#define BJ_Forget	3	</span><span class="cm">/* Buffer superseded by this transaction */</span><span class="cp"></span>
<span class="cp">#define BJ_IO		4	</span><span class="cm">/* Buffer is for temporary IO use */</span><span class="cp"></span>
<span class="cp">#define BJ_Shadow	5	</span><span class="cm">/* Buffer contents being shadowed to the log */</span><span class="cp"></span>
<span class="cp">#define BJ_LogCtl	6	</span><span class="cm">/* Buffer contains log descriptors */</span><span class="cp"></span>
<span class="cp">#define BJ_Reserved	7	</span><span class="cm">/* Buffer is reserved for access by journal */</span><span class="cp"></span>
<span class="cp">#define BJ_Locked	8	</span><span class="cm">/* Locked for I/O during commit */</span><span class="cp"></span>
<span class="cp">#define BJ_Types	9</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">jbd_blocks_per_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#define buffer_trace_init(bh)	do {} while (0)</span>
<span class="cp">#define print_buffer_fields(bh)	do {} while (0)</span>
<span class="cp">#define print_buffer_trace(bh)	do {} while (0)</span>
<span class="cp">#define BUFFER_TRACE(bh, info)	do {} while (0)</span>
<span class="cp">#define BUFFER_TRACE2(bh, bh2, info)	do {} while (0)</span>
<span class="cp">#define JBUFFER_TRACE(jh, info)	do {} while (0)</span>

<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif	</span><span class="cm">/* _LINUX_JBD_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
