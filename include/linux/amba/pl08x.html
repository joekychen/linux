<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › amba › pl08x.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pl08x.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/amba/pl08x.h - ARM PrimeCell DMA Controller driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 ARM Ltd</span>
<span class="cm"> * Copyright (C) 2010 ST-Ericsson SA</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * pl08x information required by platform code</span>
<span class="cm"> *</span>
<span class="cm"> * Please credit ARM.com</span>
<span class="cm"> * Documentation: ARM DDI 0196D</span>
<span class="cm"> */</span>

<span class="cp">#ifndef AMBA_PL08X_H</span>
<span class="cp">#define AMBA_PL08X_H</span>

<span class="cm">/* We need sizes of structs from this header */</span>
<span class="cp">#include &lt;linux/dmaengine.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="k">struct</span> <span class="n">pl08x_lli</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">pl08x_driver_data</span><span class="p">;</span>

<span class="cm">/* Bitmasks for selecting AHB ports for DMA transfers */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">PL08X_AHB1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">PL08X_AHB2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pl08x_channel_data - data structure to pass info between</span>
<span class="cm"> * platform and PL08x driver regarding channel configuration</span>
<span class="cm"> * @bus_id: name of this device channel, not just a device name since</span>
<span class="cm"> * devices may have more than one channel e.g. &quot;foo_tx&quot;</span>
<span class="cm"> * @min_signal: the minimum DMA signal number to be muxed in for this</span>
<span class="cm"> * channel (for platforms supporting muxed signals). If you have</span>
<span class="cm"> * static assignments, make sure this is set to the assigned signal</span>
<span class="cm"> * number, PL08x have 16 possible signals in number 0 thru 15 so</span>
<span class="cm"> * when these are not enough they often get muxed (in hardware)</span>
<span class="cm"> * disabling simultaneous use of the same channel for two devices.</span>
<span class="cm"> * @max_signal: the maximum DMA signal number to be muxed in for</span>
<span class="cm"> * the channel. Set to the same as min_signal for</span>
<span class="cm"> * devices with static assignments</span>
<span class="cm"> * @muxval: a number usually used to poke into some mux regiser to</span>
<span class="cm"> * mux in the signal to this channel</span>
<span class="cm"> * @cctl_opt: default options for the channel control register</span>
<span class="cm"> * @addr: source/target address in physical memory for this DMA channel,</span>
<span class="cm"> * can be the address of a FIFO register for burst requests for example.</span>
<span class="cm"> * This can be left undefined if the PrimeCell API is used for configuring</span>
<span class="cm"> * this.</span>
<span class="cm"> * @circular_buffer: whether the buffer passed in is circular and</span>
<span class="cm"> * shall simply be looped round round (like a record baby round</span>
<span class="cm"> * round round round)</span>
<span class="cm"> * @single: the device connected to this channel will request single DMA</span>
<span class="cm"> * transfers, not bursts. (Bursts are default.)</span>
<span class="cm"> * @periph_buses: the device connected to this channel is accessible via</span>
<span class="cm"> * these buses (use PL08X_AHB1 | PL08X_AHB2).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pl08x_channel_data</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bus_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_signal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_signal</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">muxval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cctl</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">circular_buffer</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">single</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">periph_buses</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Struct pl08x_bus_data - information of source or destination</span>
<span class="cm"> * busses for a transfer</span>
<span class="cm"> * @addr: current address</span>
<span class="cm"> * @maxwidth: the maximum width of a transfer on this bus</span>
<span class="cm"> * @buswidth: the width of this bus in bytes: 1, 2 or 4</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pl08x_bus_data</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">maxwidth</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">buswidth</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pl08x_phy_chan - holder for the physical channels</span>
<span class="cm"> * @id: physical index to this channel</span>
<span class="cm"> * @lock: a lock to use when altering an instance of this struct</span>
<span class="cm"> * @signal: the physical signal (aka channel) serving this physical channel</span>
<span class="cm"> * right now</span>
<span class="cm"> * @serving: the virtual channel currently being served by this physical</span>
<span class="cm"> * channel</span>
<span class="cm"> * @locked: channel unavailable for the system, e.g. dedicated to secure</span>
<span class="cm"> * world</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pl08x_phy_chan</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">signal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pl08x_dma_chan</span> <span class="o">*</span><span class="n">serving</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">locked</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pl08x_sg - structure containing data per sg</span>
<span class="cm"> * @src_addr: src address of sg</span>
<span class="cm"> * @dst_addr: dst address of sg</span>
<span class="cm"> * @len: transfer len in bytes</span>
<span class="cm"> * @node: node for txd&#39;s dsg_list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pl08x_sg</span> <span class="p">{</span>
	<span class="n">dma_addr_t</span> <span class="n">src_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dst_addr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pl08x_txd - wrapper for struct dma_async_tx_descriptor</span>
<span class="cm"> * @tx: async tx descriptor</span>
<span class="cm"> * @node: node for txd list for channels</span>
<span class="cm"> * @dsg_list: list of children sg&#39;s</span>
<span class="cm"> * @direction: direction of transfer</span>
<span class="cm"> * @llis_bus: DMA memory address (physical) start for the LLIs</span>
<span class="cm"> * @llis_va: virtual memory address start for the LLIs</span>
<span class="cm"> * @cctl: control reg values for current txd</span>
<span class="cm"> * @ccfg: config reg values for current txd</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pl08x_txd</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dsg_list</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">direction</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">llis_bus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pl08x_lli</span> <span class="o">*</span><span class="n">llis_va</span><span class="p">;</span>
	<span class="cm">/* Default cctl value for LLIs */</span>
	<span class="n">u32</span> <span class="n">cctl</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Settings to be put into the physical channel when we</span>
<span class="cm">	 * trigger this txd.  Other registers are in llis_va[0].</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ccfg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pl08x_dma_chan_state - holds the PL08x specific virtual channel</span>
<span class="cm"> * states</span>
<span class="cm"> * @PL08X_CHAN_IDLE: the channel is idle</span>
<span class="cm"> * @PL08X_CHAN_RUNNING: the channel has allocated a physical transport</span>
<span class="cm"> * channel and is running a transfer on it</span>
<span class="cm"> * @PL08X_CHAN_PAUSED: the channel has allocated a physical transport</span>
<span class="cm"> * channel, but the transfer is currently paused</span>
<span class="cm"> * @PL08X_CHAN_WAITING: the channel is waiting for a physical transport</span>
<span class="cm"> * channel to become available (only pertains to memcpy channels)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">pl08x_dma_chan_state</span> <span class="p">{</span>
	<span class="n">PL08X_CHAN_IDLE</span><span class="p">,</span>
	<span class="n">PL08X_CHAN_RUNNING</span><span class="p">,</span>
	<span class="n">PL08X_CHAN_PAUSED</span><span class="p">,</span>
	<span class="n">PL08X_CHAN_WAITING</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pl08x_dma_chan - this structure wraps a DMA ENGINE channel</span>
<span class="cm"> * @chan: wrappped abstract channel</span>
<span class="cm"> * @phychan: the physical channel utilized by this channel, if there is one</span>
<span class="cm"> * @phychan_hold: if non-zero, hold on to the physical channel even if we</span>
<span class="cm"> * have no pending entries</span>
<span class="cm"> * @tasklet: tasklet scheduled by the IRQ to handle actual work etc</span>
<span class="cm"> * @name: name of channel</span>
<span class="cm"> * @cd: channel platform data</span>
<span class="cm"> * @runtime_addr: address for RX/TX according to the runtime config</span>
<span class="cm"> * @runtime_direction: current direction of this channel according to</span>
<span class="cm"> * runtime config</span>
<span class="cm"> * @pend_list: queued transactions pending on this channel</span>
<span class="cm"> * @at: active transaction on this channel</span>
<span class="cm"> * @lock: a lock for this channel data</span>
<span class="cm"> * @host: a pointer to the host (internal use)</span>
<span class="cm"> * @state: whether the channel is idle, paused, running etc</span>
<span class="cm"> * @slave: whether this channel is a device (slave) or for memcpy</span>
<span class="cm"> * @device_fc: Flow Controller Settings for ccfg register. Only valid for slave</span>
<span class="cm"> * channels. Fill with &#39;true&#39; if peripheral should be flow controller. Direction</span>
<span class="cm"> * will be selected at Runtime.</span>
<span class="cm"> * @waiting: a TX descriptor on this channel which is waiting for a physical</span>
<span class="cm"> * channel to become available</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pl08x_dma_chan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="n">chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pl08x_phy_chan</span> <span class="o">*</span><span class="n">phychan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phychan_hold</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tasklet</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pl08x_channel_data</span> <span class="o">*</span><span class="n">cd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">src_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dst_addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src_cctl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dst_cctl</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_transfer_direction</span> <span class="n">runtime_direction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pend_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pl08x_txd</span> <span class="o">*</span><span class="n">at</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pl08x_driver_data</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">pl08x_dma_chan_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">slave</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">device_fc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pl08x_txd</span> <span class="o">*</span><span class="n">waiting</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct pl08x_platform_data - the platform configuration for the PL08x</span>
<span class="cm"> * PrimeCells.</span>
<span class="cm"> * @slave_channels: the channels defined for the different devices on the</span>
<span class="cm"> * platform, all inclusive, including multiplexed channels. The available</span>
<span class="cm"> * physical channels will be multiplexed around these signals as they are</span>
<span class="cm"> * requested, just enumerate all possible channels.</span>
<span class="cm"> * @get_signal: request a physical signal to be used for a DMA transfer</span>
<span class="cm"> * immediately: if there is some multiplexing or similar blocking the use</span>
<span class="cm"> * of the channel the transfer can be denied by returning less than zero,</span>
<span class="cm"> * else it returns the allocated signal number</span>
<span class="cm"> * @put_signal: indicate to the platform that this physical signal is not</span>
<span class="cm"> * running any DMA transfer and multiplexing can be recycled</span>
<span class="cm"> * @lli_buses: buses which LLIs can be fetched from: PL08X_AHB1 | PL08X_AHB2</span>
<span class="cm"> * @mem_buses: buses which memory can be accessed from: PL08X_AHB1 | PL08X_AHB2</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pl08x_platform_data</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pl08x_channel_data</span> <span class="o">*</span><span class="n">slave_channels</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_slave_channels</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pl08x_channel_data</span> <span class="n">memcpy_channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_signal</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pl08x_dma_chan</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_signal</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pl08x_dma_chan</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">lli_buses</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mem_buses</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_AMBA_PL08X</span>
<span class="n">bool</span> <span class="n">pl08x_filter_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">chan_id</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">pl08x_filter_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">chan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif	</span><span class="cm">/* AMBA_PL08X_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
