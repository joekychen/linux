<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › netfilter_bridge › ebtables.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ebtables.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  ebtables</span>
<span class="cm"> *</span>
<span class="cm"> *	Authors:</span>
<span class="cm"> *	Bart De Schuymer		&lt;bdschuym@pandora.be&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  ebtables.c,v 2.0, April, 2002</span>
<span class="cm"> *</span>
<span class="cm"> *  This code is stongly inspired on the iptables code which is</span>
<span class="cm"> *  Copyright (C) 1999 Paul `Rusty&#39; Russell &amp; Michael J. Neuling</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_BRIDGE_EFF_H</span>
<span class="cp">#define __LINUX_BRIDGE_EFF_H</span>
<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter_bridge.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>

<span class="cp">#define EBT_TABLE_MAXNAMELEN 32</span>
<span class="cp">#define EBT_CHAIN_MAXNAMELEN EBT_TABLE_MAXNAMELEN</span>
<span class="cp">#define EBT_FUNCTION_MAXNAMELEN EBT_TABLE_MAXNAMELEN</span>

<span class="cm">/* verdicts &gt;0 are &quot;branches&quot; */</span>
<span class="cp">#define EBT_ACCEPT   -1</span>
<span class="cp">#define EBT_DROP     -2</span>
<span class="cp">#define EBT_CONTINUE -3</span>
<span class="cp">#define EBT_RETURN   -4</span>
<span class="cp">#define NUM_STANDARD_TARGETS   4</span>
<span class="cm">/* ebtables target modules store the verdict inside an int. We can</span>
<span class="cm"> * reclaim a part of this int for backwards compatible extensions.</span>
<span class="cm"> * The 4 lsb are more than enough to store the verdict. */</span>
<span class="cp">#define EBT_VERDICT_BITS 0x0000000F</span>

<span class="k">struct</span> <span class="n">xt_match</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xt_target</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">pcnt</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">bcnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_replace</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_TABLE_MAXNAMELEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>
	<span class="cm">/* nr of rules in the table */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nentries</span><span class="p">;</span>
	<span class="cm">/* total size of the entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entries_size</span><span class="p">;</span>
	<span class="cm">/* start of the chains */</span>
	<span class="k">struct</span> <span class="n">ebt_entries</span> <span class="n">__user</span> <span class="o">*</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_BR_NUMHOOKS</span><span class="p">];</span>
	<span class="cm">/* nr of counters userspace expects back */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="p">;</span>
	<span class="cm">/* where the kernel will put the old counters */</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="n">__user</span> <span class="o">*</span><span class="n">counters</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_replace_kernel</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_TABLE_MAXNAMELEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>
	<span class="cm">/* nr of rules in the table */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nentries</span><span class="p">;</span>
	<span class="cm">/* total size of the entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entries_size</span><span class="p">;</span>
	<span class="cm">/* start of the chains */</span>
	<span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_BR_NUMHOOKS</span><span class="p">];</span>
	<span class="cm">/* nr of counters userspace expects back */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_counters</span><span class="p">;</span>
	<span class="cm">/* where the kernel will put the old counters */</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="o">*</span><span class="n">counters</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_entries</span> <span class="p">{</span>
	<span class="cm">/* this field is always set to zero</span>
<span class="cm">	 * See EBT_ENTRY_OR_ENTRIES.</span>
<span class="cm">	 * Must be same size as ebt_entry.bitmask */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">distinguisher</span><span class="p">;</span>
	<span class="cm">/* the chain name */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_CHAIN_MAXNAMELEN</span><span class="p">];</span>
	<span class="cm">/* counter offset for this chain */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">counter_offset</span><span class="p">;</span>
	<span class="cm">/* one standard (accept, drop, return) per hook */</span>
	<span class="kt">int</span> <span class="n">policy</span><span class="p">;</span>
	<span class="cm">/* nr. of entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nentries</span><span class="p">;</span>
	<span class="cm">/* entry list */</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/* used for the bitmask of struct ebt_entry */</span>

<span class="cm">/* This is a hack to make a difference between an ebt_entry struct and an</span>
<span class="cm"> * ebt_entries struct when traversing the entries from start to end.</span>
<span class="cm"> * Using this simplifies the code a lot, while still being able to use</span>
<span class="cm"> * ebt_entries.</span>
<span class="cm"> * Contrary, iptables doesn&#39;t use something like ebt_entries and therefore uses</span>
<span class="cm"> * different techniques for naming the policy and such. So, iptables doesn&#39;t</span>
<span class="cm"> * need a hack like this.</span>
<span class="cm"> */</span>
<span class="cp">#define EBT_ENTRY_OR_ENTRIES 0x01</span>
<span class="cm">/* these are the normal masks */</span>
<span class="cp">#define EBT_NOPROTO 0x02</span>
<span class="cp">#define EBT_802_3 0x04</span>
<span class="cp">#define EBT_SOURCEMAC 0x08</span>
<span class="cp">#define EBT_DESTMAC 0x10</span>
<span class="cp">#define EBT_F_MASK (EBT_NOPROTO | EBT_802_3 | EBT_SOURCEMAC | EBT_DESTMAC \</span>
<span class="cp">   | EBT_ENTRY_OR_ENTRIES)</span>

<span class="cp">#define EBT_IPROTO 0x01</span>
<span class="cp">#define EBT_IIN 0x02</span>
<span class="cp">#define EBT_IOUT 0x04</span>
<span class="cp">#define EBT_ISOURCE 0x8</span>
<span class="cp">#define EBT_IDEST 0x10</span>
<span class="cp">#define EBT_ILOGICALIN 0x20</span>
<span class="cp">#define EBT_ILOGICALOUT 0x40</span>
<span class="cp">#define EBT_INV_MASK (EBT_IPROTO | EBT_IIN | EBT_IOUT | EBT_ILOGICALIN \</span>
<span class="cp">   | EBT_ILOGICALOUT | EBT_ISOURCE | EBT_IDEST)</span>

<span class="k">struct</span> <span class="n">ebt_entry_match</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">xt_match</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="cm">/* size of data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">match_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span><span class="p">))));</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_entry_watcher</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">watcher</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="cm">/* size of data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">watcher_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span><span class="p">))));</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="cm">/* size of data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cp">#define EBT_STANDARD_TARGET &quot;standard&quot;</span>
<span class="k">struct</span> <span class="n">ebt_standard_target</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_entry_target</span> <span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">verdict</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* one entry */</span>
<span class="k">struct</span> <span class="n">ebt_entry</span> <span class="p">{</span>
	<span class="cm">/* this needs to be the first field */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitmask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">invflags</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">ethproto</span><span class="p">;</span>
	<span class="cm">/* the physical in-dev */</span>
	<span class="kt">char</span> <span class="n">in</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="cm">/* the logical in-dev */</span>
	<span class="kt">char</span> <span class="n">logical_in</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="cm">/* the physical out-dev */</span>
	<span class="kt">char</span> <span class="n">out</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="cm">/* the logical out-dev */</span>
	<span class="kt">char</span> <span class="n">logical_out</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sourcemac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sourcemsk</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">destmac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">destmsk</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="cm">/* sizeof ebt_entry + matches */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">watchers_offset</span><span class="p">;</span>
	<span class="cm">/* sizeof ebt_entry + matches + watchers */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">target_offset</span><span class="p">;</span>
	<span class="cm">/* sizeof ebt_entry + matches + watchers + target */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="n">__alignof__</span><span class="p">(</span><span class="k">struct</span> <span class="n">ebt_replace</span><span class="p">))));</span>
<span class="p">};</span>

<span class="cm">/* {g,s}etsockopt numbers */</span>
<span class="cp">#define EBT_BASE_CTL            128</span>

<span class="cp">#define EBT_SO_SET_ENTRIES      (EBT_BASE_CTL)</span>
<span class="cp">#define EBT_SO_SET_COUNTERS     (EBT_SO_SET_ENTRIES+1)</span>
<span class="cp">#define EBT_SO_SET_MAX          (EBT_SO_SET_COUNTERS+1)</span>

<span class="cp">#define EBT_SO_GET_INFO         (EBT_BASE_CTL)</span>
<span class="cp">#define EBT_SO_GET_ENTRIES      (EBT_SO_GET_INFO+1)</span>
<span class="cp">#define EBT_SO_GET_INIT_INFO    (EBT_SO_GET_ENTRIES+1)</span>
<span class="cp">#define EBT_SO_GET_INIT_ENTRIES (EBT_SO_GET_INIT_INFO+1)</span>
<span class="cp">#define EBT_SO_GET_MAX          (EBT_SO_GET_INIT_ENTRIES+1)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/* return values for match() functions */</span>
<span class="cp">#define EBT_MATCH 0</span>
<span class="cp">#define EBT_NOMATCH 1</span>

<span class="k">struct</span> <span class="n">ebt_match</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_match</span> <span class="o">*</span><span class="n">match</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">matchinfo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protoff</span><span class="p">,</span>
		<span class="n">bool</span> <span class="o">*</span><span class="n">hotdrop</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">checkentry</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">xt_match</span> <span class="o">*</span><span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">matchinfo</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_mask</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xt_match</span> <span class="o">*</span><span class="n">match</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">matchinfo</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">matchsize</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">revision</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_watcher</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">target</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_num</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">targinfo</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">checkentry</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">targinfo</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_mask</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">targinfo</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">targetsize</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">revision</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_target</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_FUNCTION_MAXNAMELEN</span><span class="p">];</span>
	<span class="cm">/* returns one of the standard EBT_* verdicts */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">target</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_num</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">targinfo</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">checkentry</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">targinfo</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook_mask</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xt_target</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">targinfo</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">targetsize</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">revision</span><span class="p">;</span>
	<span class="n">u_int8_t</span> <span class="n">family</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* used for jumping from and into user defined chains (udc) */</span>
<span class="k">struct</span> <span class="n">ebt_chainstack</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="n">chaininfo</span><span class="p">;</span> <span class="cm">/* pointer to chain data */</span>
	<span class="k">struct</span> <span class="n">ebt_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span> <span class="cm">/* pointer to entry data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="cm">/* n&#39;th entry */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="p">{</span>
	<span class="cm">/* total size of the entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entries_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nentries</span><span class="p">;</span>
	<span class="cm">/* pointers to the start of the chains */</span>
	<span class="k">struct</span> <span class="n">ebt_entries</span> <span class="o">*</span><span class="n">hook_entry</span><span class="p">[</span><span class="n">NF_BR_NUMHOOKS</span><span class="p">];</span>
	<span class="cm">/* room to maintain the stack used for jumping from and into udc */</span>
	<span class="k">struct</span> <span class="n">ebt_chainstack</span> <span class="o">**</span><span class="n">chainstack</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ebt_counter</span> <span class="n">counters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ebt_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">EBT_TABLE_MAXNAMELEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ebt_replace_kernel</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">;</span>
	<span class="n">rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="cm">/* e.g. could be the table explicitly only allows certain</span>
<span class="cm">	 * matches, targets, ... 0 == let it in */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
	   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">valid_hooks</span><span class="p">);</span>
	<span class="cm">/* the data used by the kernel */</span>
	<span class="k">struct</span> <span class="n">ebt_table_info</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">me</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define EBT_ALIGN(s) (((s) + (__alignof__(struct _xt_align)-1)) &amp; \</span>
<span class="cp">		     ~(__alignof__(struct _xt_align)-1))</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">ebt_register_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ebt_unregister_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ebt_do_table</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
   <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
   <span class="k">struct</span> <span class="n">ebt_table</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>

<span class="cm">/* Used in the kernel match() functions */</span>
<span class="cp">#define FWINV(bool,invflg) ((bool) ^ !!(info-&gt;invflags &amp; invflg))</span>
<span class="cm">/* True if the hook mask denotes that the rule is in a base chain,</span>
<span class="cm"> * used in the check() functions */</span>
<span class="cp">#define BASE_CHAIN (par-&gt;hook_mask &amp; (1 &lt;&lt; NF_BR_NUMHOOKS))</span>
<span class="cm">/* Clear the bit in the hook mask that tells if the rule is on a base chain */</span>
<span class="cp">#define CLEAR_BASE_CHAIN_BIT (par-&gt;hook_mask &amp;= ~(1 &lt;&lt; NF_BR_NUMHOOKS))</span>
<span class="cm">/* True if the target is not a standard target */</span>
<span class="cp">#define INVALID_TARGET (info-&gt;target &lt; -NUM_STANDARD_TARGETS || info-&gt;target &gt;= 0)</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/* blatently stolen from ip_tables.h</span>
<span class="cm"> * fn returns 0 to continue iteration */</span>
<span class="cp">#define EBT_MATCH_ITERATE(e, fn, args...)                   \</span>
<span class="cp">({                                                          \</span>
<span class="cp">	unsigned int __i;                                   \</span>
<span class="cp">	int __ret = 0;                                      \</span>
<span class="cp">	struct ebt_entry_match *__match;                    \</span>
<span class="cp">	                                                    \</span>
<span class="cp">	for (__i = sizeof(struct ebt_entry);                \</span>
<span class="cp">	     __i &lt; (e)-&gt;watchers_offset;                    \</span>
<span class="cp">	     __i += __match-&gt;match_size +                   \</span>
<span class="cp">	     sizeof(struct ebt_entry_match)) {              \</span>
<span class="cp">		__match = (void *)(e) + __i;                \</span>
<span class="cp">		                                            \</span>
<span class="cp">		__ret = fn(__match , ## args);              \</span>
<span class="cp">		if (__ret != 0)                             \</span>
<span class="cp">			break;                              \</span>
<span class="cp">	}                                                   \</span>
<span class="cp">	if (__ret == 0) {                                   \</span>
<span class="cp">		if (__i != (e)-&gt;watchers_offset)            \</span>
<span class="cp">			__ret = -EINVAL;                    \</span>
<span class="cp">	}                                                   \</span>
<span class="cp">	__ret;                                              \</span>
<span class="cp">})</span>

<span class="cp">#define EBT_WATCHER_ITERATE(e, fn, args...)                 \</span>
<span class="cp">({                                                          \</span>
<span class="cp">	unsigned int __i;                                   \</span>
<span class="cp">	int __ret = 0;                                      \</span>
<span class="cp">	struct ebt_entry_watcher *__watcher;                \</span>
<span class="cp">	                                                    \</span>
<span class="cp">	for (__i = e-&gt;watchers_offset;                      \</span>
<span class="cp">	     __i &lt; (e)-&gt;target_offset;                      \</span>
<span class="cp">	     __i += __watcher-&gt;watcher_size +               \</span>
<span class="cp">	     sizeof(struct ebt_entry_watcher)) {            \</span>
<span class="cp">		__watcher = (void *)(e) + __i;              \</span>
<span class="cp">		                                            \</span>
<span class="cp">		__ret = fn(__watcher , ## args);            \</span>
<span class="cp">		if (__ret != 0)                             \</span>
<span class="cp">			break;                              \</span>
<span class="cp">	}                                                   \</span>
<span class="cp">	if (__ret == 0) {                                   \</span>
<span class="cp">		if (__i != (e)-&gt;target_offset)              \</span>
<span class="cp">			__ret = -EINVAL;                    \</span>
<span class="cp">	}                                                   \</span>
<span class="cp">	__ret;                                              \</span>
<span class="cp">})</span>

<span class="cp">#define EBT_ENTRY_ITERATE(entries, size, fn, args...)       \</span>
<span class="cp">({                                                          \</span>
<span class="cp">	unsigned int __i;                                   \</span>
<span class="cp">	int __ret = 0;                                      \</span>
<span class="cp">	struct ebt_entry *__entry;                          \</span>
<span class="cp">	                                                    \</span>
<span class="cp">	for (__i = 0; __i &lt; (size);) {                      \</span>
<span class="cp">		__entry = (void *)(entries) + __i;          \</span>
<span class="cp">		__ret = fn(__entry , ## args);              \</span>
<span class="cp">		if (__ret != 0)                             \</span>
<span class="cp">			break;                              \</span>
<span class="cp">		if (__entry-&gt;bitmask != 0)                  \</span>
<span class="cp">			__i += __entry-&gt;next_offset;        \</span>
<span class="cp">		else                                        \</span>
<span class="cp">			__i += sizeof(struct ebt_entries);  \</span>
<span class="cp">	}                                                   \</span>
<span class="cp">	if (__ret == 0) {                                   \</span>
<span class="cp">		if (__i != (size))                          \</span>
<span class="cp">			__ret = -EINVAL;                    \</span>
<span class="cp">	}                                                   \</span>
<span class="cp">	__ret;                                              \</span>
<span class="cp">})</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
