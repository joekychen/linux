<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › regmap.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>regmap.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __LINUX_REGMAP_H</span>
<span class="cp">#define __LINUX_REGMAP_H</span>

<span class="cm">/*</span>
<span class="cm"> * Register map access API</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2011 Wolfson Microelectronics plc</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Mark Brown &lt;broonie@opensource.wolfsonmicro.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="k">struct</span> <span class="n">module</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">i2c_client</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">spi_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">regmap</span><span class="p">;</span>

<span class="cm">/* An enum of all the supported cache types */</span>
<span class="k">enum</span> <span class="n">regcache_type</span> <span class="p">{</span>
	<span class="n">REGCACHE_NONE</span><span class="p">,</span>
	<span class="n">REGCACHE_RBTREE</span><span class="p">,</span>
	<span class="n">REGCACHE_COMPRESSED</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Default value for a register.  We use an array of structs rather</span>
<span class="cm"> * than a simple array as many modern devices have very sparse</span>
<span class="cm"> * register maps.</span>
<span class="cm"> *</span>
<span class="cm"> * @reg: Register address.</span>
<span class="cm"> * @def: Register default value.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">reg_default</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">def</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_REGMAP</span>

<span class="cm">/**</span>
<span class="cm"> * Configuration for the register map of a device.</span>
<span class="cm"> *</span>
<span class="cm"> * @name: Optional name of the regmap. Useful when a device has multiple</span>
<span class="cm"> *        register regions.</span>
<span class="cm"> *</span>
<span class="cm"> * @reg_bits: Number of bits in a register address, mandatory.</span>
<span class="cm"> * @reg_stride: The register address stride. Valid register addresses are a</span>
<span class="cm"> *              multiple of this value. If set to 0, a value of 1 will be</span>
<span class="cm"> *              used.</span>
<span class="cm"> * @pad_bits: Number of bits of padding between register and value.</span>
<span class="cm"> * @val_bits: Number of bits in a register value, mandatory.</span>
<span class="cm"> *</span>
<span class="cm"> * @writeable_reg: Optional callback returning true if the register</span>
<span class="cm"> *                 can be written to.</span>
<span class="cm"> * @readable_reg: Optional callback returning true if the register</span>
<span class="cm"> *                can be read from.</span>
<span class="cm"> * @volatile_reg: Optional callback returning true if the register</span>
<span class="cm"> *                value can&#39;t be cached.</span>
<span class="cm"> * @precious_reg: Optional callback returning true if the rgister</span>
<span class="cm"> *                should not be read outside of a call from the driver</span>
<span class="cm"> *                (eg, a clear on read interrupt status register).</span>
<span class="cm"> *</span>
<span class="cm"> * @max_register: Optional, specifies the maximum valid register index.</span>
<span class="cm"> * @reg_defaults: Power on reset values for registers (for use with</span>
<span class="cm"> *                register cache support).</span>
<span class="cm"> * @num_reg_defaults: Number of elements in reg_defaults.</span>
<span class="cm"> *</span>
<span class="cm"> * @read_flag_mask: Mask to be set in the top byte of the register when doing</span>
<span class="cm"> *                  a read.</span>
<span class="cm"> * @write_flag_mask: Mask to be set in the top byte of the register when doing</span>
<span class="cm"> *                   a write. If both read_flag_mask and write_flag_mask are</span>
<span class="cm"> *                   empty the regmap_bus default masks are used.</span>
<span class="cm"> * @use_single_rw: If set, converts the bulk read and write operations into</span>
<span class="cm"> *		    a series of single read and write operations. This is useful</span>
<span class="cm"> *		    for device that does not support bulk read and write.</span>
<span class="cm"> *</span>
<span class="cm"> * @cache_type: The actual cache type.</span>
<span class="cm"> * @reg_defaults_raw: Power on reset values for registers (for use with</span>
<span class="cm"> *                    register cache support).</span>
<span class="cm"> * @num_reg_defaults_raw: Number of elements in reg_defaults_raw.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">regmap_config</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">reg_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg_stride</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pad_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val_bits</span><span class="p">;</span>

	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">writeable_reg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">readable_reg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">volatile_reg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">precious_reg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_register</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">reg_default</span> <span class="o">*</span><span class="n">reg_defaults</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_reg_defaults</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">regcache_type</span> <span class="n">cache_type</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reg_defaults_raw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_reg_defaults_raw</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">read_flag_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">write_flag_mask</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">use_single_rw</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">regmap_hw_write</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">regmap_hw_gather_write</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">reg_len</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val_len</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">regmap_hw_read</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reg_buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">reg_size</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">val_buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val_size</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">regmap_hw_free_context</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Description of a hardware bus for the register map infrastructure.</span>
<span class="cm"> *</span>
<span class="cm"> * @fast_io: Register IO is fast. Use a spinlock instead of a mutex</span>
<span class="cm"> *           to perform locking.</span>
<span class="cm"> * @write: Write operation.</span>
<span class="cm"> * @gather_write: Write operation with split register/value, return -ENOTSUPP</span>
<span class="cm"> *                if not implemented  on a given device.</span>
<span class="cm"> * @read: Read operation.  Data is returned in the buffer used to transmit</span>
<span class="cm"> *         data.</span>
<span class="cm"> * @read_flag_mask: Mask to be set in the top byte of the register when doing</span>
<span class="cm"> *                  a read.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">regmap_bus</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">fast_io</span><span class="p">;</span>
	<span class="n">regmap_hw_write</span> <span class="n">write</span><span class="p">;</span>
	<span class="n">regmap_hw_gather_write</span> <span class="n">gather_write</span><span class="p">;</span>
	<span class="n">regmap_hw_read</span> <span class="n">read</span><span class="p">;</span>
	<span class="n">regmap_hw_free_context</span> <span class="n">free_context</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">read_flag_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">regmap_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">bus_context</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">regmap_init_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">i2c</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">regmap_init_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">regmap_init_mmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">devm_regmap_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">bus_context</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">devm_regmap_init_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">i2c</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">devm_regmap_init_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">devm_regmap_init_mmio</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">regmap_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_reinit_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">dev_get_regmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_raw_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val_len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_bulk_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">val_count</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_raw_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		    <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val_len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_bulk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">val_count</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_update_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_update_bits_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="o">*</span><span class="n">change</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_get_val_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">regcache_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regcache_sync_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">regcache_cache_only</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">regcache_cache_bypass</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">regcache_mark_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">regmap_register_patch</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">reg_default</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">num_regs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Description of an IRQ for the generic regmap irq_chip.</span>
<span class="cm"> *</span>
<span class="cm"> * @reg_offset: Offset of the status/mask register within the bank</span>
<span class="cm"> * @mask:       Mask used to flag/control the register.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">regmap_irq</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Description of a generic regmap irq_chip.  This is not intended to</span>
<span class="cm"> * handle every possible interrupt controller, but it should handle a</span>
<span class="cm"> * substantial proportion of those that are found in the wild.</span>
<span class="cm"> *</span>
<span class="cm"> * @name:        Descriptive name for IRQ controller.</span>
<span class="cm"> *</span>
<span class="cm"> * @status_base: Base status register address.</span>
<span class="cm"> * @mask_base:   Base mask register address.</span>
<span class="cm"> * @ack_base:    Base ack address.  If zero then the chip is clear on read.</span>
<span class="cm"> * @irq_reg_stride:  Stride to use for chips where registers are not contiguous.</span>
<span class="cm"> *</span>
<span class="cm"> * @num_regs:    Number of registers in each control bank.</span>
<span class="cm"> * @irqs:        Descriptors for individual IRQs.  Interrupt numbers are</span>
<span class="cm"> *               assigned based on the index in the array of the interrupt.</span>
<span class="cm"> * @num_irqs:    Number of descriptors.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">regmap_irq_chip</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ack_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_reg_stride</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">num_regs</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">regmap_irq</span> <span class="o">*</span><span class="n">irqs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_irqs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">regmap_irq_chip_data</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">regmap_add_irq_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq_flags</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">irq_base</span><span class="p">,</span> <span class="k">struct</span> <span class="n">regmap_irq_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">regmap_irq_chip_data</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">regmap_del_irq_chip</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">regmap_irq_chip_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_irq_chip_get_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap_irq_chip_data</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regmap_irq_get_virq</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap_irq_chip_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>

<span class="cp">#else</span>

<span class="cm">/*</span>
<span class="cm"> * These stubs should only ever be called by generic code which has</span>
<span class="cm"> * regmap based facilities, if they ever get called at runtime</span>
<span class="cm"> * something is going wrong and something probably needs to select</span>
<span class="cm"> * REGMAP.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_raw_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_bulk_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
				    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_raw_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_bulk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_update_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_update_bits_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span>
					   <span class="n">bool</span> <span class="o">*</span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_get_val_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regcache_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regcache_sync_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">regcache_cache_only</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">regcache_cache_bypass</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">bool</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">regcache_mark_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">regmap_register_patch</span><span class="p">(</span><span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">reg_default</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">num_regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="nf">dev_get_regmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;regmap API is disabled&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
