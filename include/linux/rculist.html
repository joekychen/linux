<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › rculist.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rculist.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _LINUX_RCULIST_H</span>
<span class="cp">#define _LINUX_RCULIST_H</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * RCU-protected list version</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Why is there no list_empty_rcu()?  Because list_empty() serves this</span>
<span class="cm"> * purpose.  The list_empty() function fetches the RCU-protected pointer</span>
<span class="cm"> * and compares it to the address of the list head, but neither dereferences</span>
<span class="cm"> * this pointer itself nor provides this pointer to the caller.  Therefore,</span>
<span class="cm"> * it is not necessary to use rcu_dereference(), so that list_empty() can</span>
<span class="cm"> * be used anywhere you would want to use a list_empty_rcu().</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * return the -&gt;next pointer of a list_head in an rcu safe</span>
<span class="cm"> * way, we must not access it directly</span>
<span class="cm"> */</span>
<span class="cp">#define list_next_rcu(list)	(*((struct list_head __rcu **)(&amp;(list)-&gt;next)))</span>

<span class="cm">/*</span>
<span class="cm"> * Insert a new entry between two known consecutive entries.</span>
<span class="cm"> *</span>
<span class="cm"> * This is only for internal list manipulation where we know</span>
<span class="cm"> * the prev/next entries already!</span>
<span class="cm"> */</span>
<span class="cp">#ifndef CONFIG_DEBUG_LIST</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__list_add_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">list_next_rcu</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__list_add_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * list_add_rcu - add a new entry to rcu-protected list</span>
<span class="cm"> * @new: new entry to be added</span>
<span class="cm"> * @head: list head to add it after</span>
<span class="cm"> *</span>
<span class="cm"> * Insert a new entry after the specified head.</span>
<span class="cm"> * This is good for implementing stacks.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take whatever precautions are necessary</span>
<span class="cm"> * (such as holding appropriate locks) to avoid racing</span>
<span class="cm"> * with another list-mutation primitive, such as list_add_rcu()</span>
<span class="cm"> * or list_del_rcu(), running on this same list.</span>
<span class="cm"> * However, it is perfectly legal to run concurrently with</span>
<span class="cm"> * the _rcu list-traversal primitives, such as</span>
<span class="cm"> * list_for_each_entry_rcu().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_add_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__list_add_rcu</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * list_add_tail_rcu - add a new entry to rcu-protected list</span>
<span class="cm"> * @new: new entry to be added</span>
<span class="cm"> * @head: list head to add it before</span>
<span class="cm"> *</span>
<span class="cm"> * Insert a new entry before the specified head.</span>
<span class="cm"> * This is useful for implementing queues.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take whatever precautions are necessary</span>
<span class="cm"> * (such as holding appropriate locks) to avoid racing</span>
<span class="cm"> * with another list-mutation primitive, such as list_add_tail_rcu()</span>
<span class="cm"> * or list_del_rcu(), running on this same list.</span>
<span class="cm"> * However, it is perfectly legal to run concurrently with</span>
<span class="cm"> * the _rcu list-traversal primitives, such as</span>
<span class="cm"> * list_for_each_entry_rcu().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_add_tail_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__list_add_rcu</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * list_del_rcu - deletes entry from list without re-initialization</span>
<span class="cm"> * @entry: the element to delete from the list.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: list_empty() on entry does not return true after this,</span>
<span class="cm"> * the entry is in an undefined state. It is useful for RCU based</span>
<span class="cm"> * lockfree traversal.</span>
<span class="cm"> *</span>
<span class="cm"> * In particular, it means that we can not poison the forward</span>
<span class="cm"> * pointers that may still be used for walking the list.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take whatever precautions are necessary</span>
<span class="cm"> * (such as holding appropriate locks) to avoid racing</span>
<span class="cm"> * with another list-mutation primitive, such as list_del_rcu()</span>
<span class="cm"> * or list_add_rcu(), running on this same list.</span>
<span class="cm"> * However, it is perfectly legal to run concurrently with</span>
<span class="cm"> * the _rcu list-traversal primitives, such as</span>
<span class="cm"> * list_for_each_entry_rcu().</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the caller is not permitted to immediately free</span>
<span class="cm"> * the newly deleted entry.  Instead, either synchronize_rcu()</span>
<span class="cm"> * or call_rcu() must be used to defer freeing until an RCU</span>
<span class="cm"> * grace period has elapsed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_del_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__list_del_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">LIST_POISON2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_del_init_rcu - deletes entry from hash list with re-initialization</span>
<span class="cm"> * @n: the element to delete from the hash list.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: list_unhashed() on the node return true after this. It is</span>
<span class="cm"> * useful for RCU based read lockfree traversal if the writer side</span>
<span class="cm"> * must know if the list entry is still hashed or already unhashed.</span>
<span class="cm"> *</span>
<span class="cm"> * In particular, it means that we can not poison the forward pointers</span>
<span class="cm"> * that may still be used for walking the hash list and we can only</span>
<span class="cm"> * zero the pprev pointer so list_unhashed() will return true after</span>
<span class="cm"> * this.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take whatever precautions are necessary (such as</span>
<span class="cm"> * holding appropriate locks) to avoid racing with another</span>
<span class="cm"> * list-mutation primitive, such as hlist_add_head_rcu() or</span>
<span class="cm"> * hlist_del_rcu(), running on this same list.  However, it is</span>
<span class="cm"> * perfectly legal to run concurrently with the _rcu list-traversal</span>
<span class="cm"> * primitives, such as hlist_for_each_entry_rcu().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hlist_del_init_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__hlist_del</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * list_replace_rcu - replace old entry by new one</span>
<span class="cm"> * @old : the element to be replaced</span>
<span class="cm"> * @new : the new element to insert</span>
<span class="cm"> *</span>
<span class="cm"> * The @old entry will be replaced with the @new entry atomically.</span>
<span class="cm"> * Note: @old should not be empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_replace_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">list_next_rcu</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">),</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">old</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">LIST_POISON2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * list_splice_init_rcu - splice an RCU-protected list into an existing list.</span>
<span class="cm"> * @list:	the RCU-protected list to splice</span>
<span class="cm"> * @head:	the place in the list to splice the first list into</span>
<span class="cm"> * @sync:	function to sync: synchronize_rcu(), synchronize_sched(), ...</span>
<span class="cm"> *</span>
<span class="cm"> * @head can be RCU-read traversed concurrently with this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * Important note: the caller must take whatever action is necessary to</span>
<span class="cm"> *	prevent any other updates to @head.  In principle, it is possible</span>
<span class="cm"> *	to modify the list as soon as sync() begins execution.</span>
<span class="cm"> *	If this sort of thing becomes necessary, an alternative version</span>
<span class="cm"> *	based on call_rcu() could be created.  But only if -really-</span>
<span class="cm"> *	needed -- there is no shortage of RCU API members.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_splice_init_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
					<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sync</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">at</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* &quot;first&quot; and &quot;last&quot; tracking list, so initialize it. */</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, the list body still points to the source list.</span>
<span class="cm">	 * Wait for any readers to finish using the list before splicing</span>
<span class="cm">	 * the list body into the new list.  Any new readers will see</span>
<span class="cm">	 * an empty list.</span>
<span class="cm">	 */</span>

	<span class="n">sync</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Readers are finished with the source list, so perform splice.</span>
<span class="cm">	 * The order is important if the new list is global and accessible</span>
<span class="cm">	 * to concurrent RCU readers.  Note that RCU readers are not</span>
<span class="cm">	 * permitted to traverse the prev pointers without excluding</span>
<span class="cm">	 * this function.</span>
<span class="cm">	 */</span>

	<span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">at</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">list_next_rcu</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="n">first</span><span class="p">);</span>
	<span class="n">first</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">at</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * list_entry_rcu - get the struct for this entry</span>
<span class="cm"> * @ptr:        the &amp;struct list_head pointer.</span>
<span class="cm"> * @type:       the type of the struct this is embedded in.</span>
<span class="cm"> * @member:     the name of the list_struct within the struct.</span>
<span class="cm"> *</span>
<span class="cm"> * This primitive may safely run concurrently with the _rcu list-mutation</span>
<span class="cm"> * primitives such as list_add_rcu() as long as it&#39;s guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="cp">#define list_entry_rcu(ptr, type, member) \</span>
<span class="cp">	({typeof (*ptr) __rcu *__ptr = (typeof (*ptr) __rcu __force *)ptr; \</span>
<span class="cp">	 container_of((typeof(ptr))rcu_dereference_raw(__ptr), type, member); \</span>
<span class="cp">	})</span>

<span class="cm">/**</span>
<span class="cm"> * Where are list_empty_rcu() and list_first_entry_rcu()?</span>
<span class="cm"> *</span>
<span class="cm"> * Implementing those functions following their counterparts list_empty() and</span>
<span class="cm"> * list_first_entry() is not advisable because they lead to subtle race</span>
<span class="cm"> * conditions as the following snippet shows:</span>
<span class="cm"> *</span>
<span class="cm"> * if (!list_empty_rcu(mylist)) {</span>
<span class="cm"> *	struct foo *bar = list_first_entry_rcu(mylist, struct foo, list_member);</span>
<span class="cm"> *	do_something(bar);</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * The list may not be empty when list_empty_rcu checks it, but it may be when</span>
<span class="cm"> * list_first_entry_rcu rereads the -&gt;next pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Rereading the -&gt;next pointer is not a problem for list_empty() and</span>
<span class="cm"> * list_first_entry() because they would be protected by a lock that blocks</span>
<span class="cm"> * writers.</span>
<span class="cm"> *</span>
<span class="cm"> * See list_first_or_null_rcu for an alternative.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * list_first_or_null_rcu - get the first element from a list</span>
<span class="cm"> * @ptr:        the list head to take the element from.</span>
<span class="cm"> * @type:       the type of the struct this is embedded in.</span>
<span class="cm"> * @member:     the name of the list_struct within the struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if the list is empty, it returns NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * This primitive may safely run concurrently with the _rcu list-mutation</span>
<span class="cm"> * primitives such as list_add_rcu() as long as it&#39;s guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="cp">#define list_first_or_null_rcu(ptr, type, member) \</span>
<span class="cp">	({struct list_head *__ptr = (ptr); \</span>
<span class="cp">	  struct list_head __rcu *__next = list_next_rcu(__ptr); \</span>
<span class="cp">	  likely(__ptr != __next) ? container_of(__next, type, member) : NULL; \</span>
<span class="cp">	})</span>

<span class="cm">/**</span>
<span class="cm"> * list_for_each_entry_rcu	-	iterate over rcu list of given type</span>
<span class="cm"> * @pos:	the type * to use as a loop cursor.</span>
<span class="cm"> * @head:	the head for your list.</span>
<span class="cm"> * @member:	the name of the list_struct within the struct.</span>
<span class="cm"> *</span>
<span class="cm"> * This list-traversal primitive may safely run concurrently with</span>
<span class="cm"> * the _rcu list-mutation primitives such as list_add_rcu()</span>
<span class="cm"> * as long as the traversal is guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="cp">#define list_for_each_entry_rcu(pos, head, member) \</span>
<span class="cp">	for (pos = list_entry_rcu((head)-&gt;next, typeof(*pos), member); \</span>
<span class="cp">		&amp;pos-&gt;member != (head); \</span>
<span class="cp">		pos = list_entry_rcu(pos-&gt;member.next, typeof(*pos), member))</span>


<span class="cm">/**</span>
<span class="cm"> * list_for_each_continue_rcu</span>
<span class="cm"> * @pos:	the &amp;struct list_head to use as a loop cursor.</span>
<span class="cm"> * @head:	the head for your list.</span>
<span class="cm"> *</span>
<span class="cm"> * Iterate over an rcu-protected list, continuing after current point.</span>
<span class="cm"> *</span>
<span class="cm"> * This list-traversal primitive may safely run concurrently with</span>
<span class="cm"> * the _rcu list-mutation primitives such as list_add_rcu()</span>
<span class="cm"> * as long as the traversal is guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="cp">#define list_for_each_continue_rcu(pos, head) \</span>
<span class="cp">	for ((pos) = rcu_dereference_raw(list_next_rcu(pos)); \</span>
<span class="cp">		(pos) != (head); \</span>
<span class="cp">		(pos) = rcu_dereference_raw(list_next_rcu(pos)))</span>

<span class="cm">/**</span>
<span class="cm"> * list_for_each_entry_continue_rcu - continue iteration over list of given type</span>
<span class="cm"> * @pos:	the type * to use as a loop cursor.</span>
<span class="cm"> * @head:	the head for your list.</span>
<span class="cm"> * @member:	the name of the list_struct within the struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Continue to iterate over list of given type, continuing after</span>
<span class="cm"> * the current position.</span>
<span class="cm"> */</span>
<span class="cp">#define list_for_each_entry_continue_rcu(pos, head, member) 		\</span>
<span class="cp">	for (pos = list_entry_rcu(pos-&gt;member.next, typeof(*pos), member); \</span>
<span class="cp">	     &amp;pos-&gt;member != (head);	\</span>
<span class="cp">	     pos = list_entry_rcu(pos-&gt;member.next, typeof(*pos), member))</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_del_rcu - deletes entry from hash list without re-initialization</span>
<span class="cm"> * @n: the element to delete from the hash list.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: list_unhashed() on entry does not return true after this,</span>
<span class="cm"> * the entry is in an undefined state. It is useful for RCU based</span>
<span class="cm"> * lockfree traversal.</span>
<span class="cm"> *</span>
<span class="cm"> * In particular, it means that we can not poison the forward</span>
<span class="cm"> * pointers that may still be used for walking the hash list.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take whatever precautions are necessary</span>
<span class="cm"> * (such as holding appropriate locks) to avoid racing</span>
<span class="cm"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>
<span class="cm"> * or hlist_del_rcu(), running on this same list.</span>
<span class="cm"> * However, it is perfectly legal to run concurrently with</span>
<span class="cm"> * the _rcu list-traversal primitives, such as</span>
<span class="cm"> * hlist_for_each_entry().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hlist_del_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__hlist_del</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">LIST_POISON2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_replace_rcu - replace old entry by new one</span>
<span class="cm"> * @old : the element to be replaced</span>
<span class="cm"> * @new : the new element to insert</span>
<span class="cm"> *</span>
<span class="cm"> * The @old entry will be replaced with the @new entry atomically.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hlist_replace_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">__rcu</span> <span class="o">**</span><span class="p">)</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">old</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">LIST_POISON2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return the first or the next element in an RCU protected hlist</span>
<span class="cm"> */</span>
<span class="cp">#define hlist_first_rcu(head)	(*((struct hlist_node __rcu **)(&amp;(head)-&gt;first)))</span>
<span class="cp">#define hlist_next_rcu(node)	(*((struct hlist_node __rcu **)(&amp;(node)-&gt;next)))</span>
<span class="cp">#define hlist_pprev_rcu(node)	(*((struct hlist_node __rcu **)((node)-&gt;pprev)))</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_add_head_rcu</span>
<span class="cm"> * @n: the element to add to the hash list.</span>
<span class="cm"> * @h: the list to add to.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Adds the specified element to the specified hlist,</span>
<span class="cm"> * while permitting racing traversals.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take whatever precautions are necessary</span>
<span class="cm"> * (such as holding appropriate locks) to avoid racing</span>
<span class="cm"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>
<span class="cm"> * or hlist_del_rcu(), running on this same list.</span>
<span class="cm"> * However, it is perfectly legal to run concurrently with</span>
<span class="cm"> * the _rcu list-traversal primitives, such as</span>
<span class="cm"> * hlist_for_each_entry_rcu(), used to prevent memory-consistency</span>
<span class="cm"> * problems on Alpha CPUs.  Regardless of the type of CPU, the</span>
<span class="cm"> * list-traversal primitive must be guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hlist_add_head_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>

	<span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">hlist_first_rcu</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
		<span class="n">first</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_add_before_rcu</span>
<span class="cm"> * @n: the new element to add to the hash list.</span>
<span class="cm"> * @next: the existing element to add the new element before.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Adds the specified element to the specified hlist</span>
<span class="cm"> * before the specified node while permitting racing traversals.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take whatever precautions are necessary</span>
<span class="cm"> * (such as holding appropriate locks) to avoid racing</span>
<span class="cm"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>
<span class="cm"> * or hlist_del_rcu(), running on this same list.</span>
<span class="cm"> * However, it is perfectly legal to run concurrently with</span>
<span class="cm"> * the _rcu list-traversal primitives, such as</span>
<span class="cm"> * hlist_for_each_entry_rcu(), used to prevent memory-consistency</span>
<span class="cm"> * problems on Alpha CPUs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hlist_add_before_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">pprev</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">hlist_pprev_rcu</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">next</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_add_after_rcu</span>
<span class="cm"> * @prev: the existing element to add the new element after.</span>
<span class="cm"> * @n: the new element to add to the hash list.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Adds the specified element to the specified hlist</span>
<span class="cm"> * after the specified node while permitting racing traversals.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must take whatever precautions are necessary</span>
<span class="cm"> * (such as holding appropriate locks) to avoid racing</span>
<span class="cm"> * with another list-mutation primitive, such as hlist_add_head_rcu()</span>
<span class="cm"> * or hlist_del_rcu(), running on this same list.</span>
<span class="cm"> * However, it is perfectly legal to run concurrently with</span>
<span class="cm"> * the _rcu list-traversal primitives, such as</span>
<span class="cm"> * hlist_for_each_entry_rcu(), used to prevent memory-consistency</span>
<span class="cm"> * problems on Alpha CPUs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hlist_add_after_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">hlist_next_rcu</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pprev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define __hlist_for_each_rcu(pos, head)				\</span>
<span class="cp">	for (pos = rcu_dereference(hlist_first_rcu(head));	\</span>
<span class="cp">	     pos;						\</span>
<span class="cp">	     pos = rcu_dereference(hlist_next_rcu(pos)))</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_for_each_entry_rcu - iterate over rcu list of given type</span>
<span class="cm"> * @tpos:	the type * to use as a loop cursor.</span>
<span class="cm"> * @pos:	the &amp;struct hlist_node to use as a loop cursor.</span>
<span class="cm"> * @head:	the head for your list.</span>
<span class="cm"> * @member:	the name of the hlist_node within the struct.</span>
<span class="cm"> *</span>
<span class="cm"> * This list-traversal primitive may safely run concurrently with</span>
<span class="cm"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span>
<span class="cm"> * as long as the traversal is guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="cp">#define hlist_for_each_entry_rcu(tpos, pos, head, member)		\</span>
<span class="cp">	for (pos = rcu_dereference_raw(hlist_first_rcu(head));		\</span>
<span class="cp">		pos &amp;&amp;							 \</span>
<span class="cp">		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1; }); \</span>
<span class="cp">		pos = rcu_dereference_raw(hlist_next_rcu(pos)))</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_for_each_entry_rcu_bh - iterate over rcu list of given type</span>
<span class="cm"> * @tpos:	the type * to use as a loop cursor.</span>
<span class="cm"> * @pos:	the &amp;struct hlist_node to use as a loop cursor.</span>
<span class="cm"> * @head:	the head for your list.</span>
<span class="cm"> * @member:	the name of the hlist_node within the struct.</span>
<span class="cm"> *</span>
<span class="cm"> * This list-traversal primitive may safely run concurrently with</span>
<span class="cm"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span>
<span class="cm"> * as long as the traversal is guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="cp">#define hlist_for_each_entry_rcu_bh(tpos, pos, head, member)		 \</span>
<span class="cp">	for (pos = rcu_dereference_bh((head)-&gt;first);			 \</span>
<span class="cp">		pos &amp;&amp;							 \</span>
<span class="cp">		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1; }); \</span>
<span class="cp">		pos = rcu_dereference_bh(pos-&gt;next))</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_for_each_entry_continue_rcu - iterate over a hlist continuing after current point</span>
<span class="cm"> * @tpos:	the type * to use as a loop cursor.</span>
<span class="cm"> * @pos:	the &amp;struct hlist_node to use as a loop cursor.</span>
<span class="cm"> * @member:	the name of the hlist_node within the struct.</span>
<span class="cm"> */</span>
<span class="cp">#define hlist_for_each_entry_continue_rcu(tpos, pos, member)		\</span>
<span class="cp">	for (pos = rcu_dereference((pos)-&gt;next);			\</span>
<span class="cp">	     pos &amp;&amp;							\</span>
<span class="cp">	     ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1; });  \</span>
<span class="cp">	     pos = rcu_dereference(pos-&gt;next))</span>

<span class="cm">/**</span>
<span class="cm"> * hlist_for_each_entry_continue_rcu_bh - iterate over a hlist continuing after current point</span>
<span class="cm"> * @tpos:	the type * to use as a loop cursor.</span>
<span class="cm"> * @pos:	the &amp;struct hlist_node to use as a loop cursor.</span>
<span class="cm"> * @member:	the name of the hlist_node within the struct.</span>
<span class="cm"> */</span>
<span class="cp">#define hlist_for_each_entry_continue_rcu_bh(tpos, pos, member)		\</span>
<span class="cp">	for (pos = rcu_dereference_bh((pos)-&gt;next);			\</span>
<span class="cp">	     pos &amp;&amp;							\</span>
<span class="cp">	     ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1; });  \</span>
<span class="cp">	     pos = rcu_dereference_bh(pos-&gt;next))</span>


<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
