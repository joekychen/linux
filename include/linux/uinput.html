<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › uinput.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>uinput.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __UINPUT_H_</span>
<span class="cp">#define __UINPUT_H_</span>
<span class="cm">/*</span>
<span class="cm"> *  User level driver support for input subsystem</span>
<span class="cm"> *</span>
<span class="cm"> * Heavily based on evdev.c by Vojtech Pavlik</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Aristeu Sergio Rozanski Filho &lt;aris@cathedrallabs.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Changes/Revisions:</span>
<span class="cm"> *	0.3	24/05/2006 (Anssi Hannula &lt;anssi.hannulagmail.com&gt;)</span>
<span class="cm"> *		- update ff support for the changes in kernel interface</span>
<span class="cm"> *		- add UINPUT_VERSION</span>
<span class="cm"> *	0.2	16/10/2004 (Micah Dowty &lt;micah@navi.cx&gt;)</span>
<span class="cm"> *		- added force feedback support</span>
<span class="cm"> *             - added UI_SET_PHYS</span>
<span class="cm"> *	0.1	20/06/2002</span>
<span class="cm"> *		- first public version</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/input.h&gt;</span>

<span class="cp">#define UINPUT_VERSION		3</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#define UINPUT_NAME		&quot;uinput&quot;</span>
<span class="cp">#define UINPUT_BUFFER_SIZE	16</span>
<span class="cp">#define UINPUT_NUM_REQUESTS	16</span>

<span class="k">enum</span> <span class="n">uinput_state</span> <span class="p">{</span> <span class="n">UIST_NEW_DEVICE</span><span class="p">,</span> <span class="n">UIST_SETUP_COMPLETE</span><span class="p">,</span> <span class="n">UIST_CREATED</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">uinput_request</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">code</span><span class="p">;</span>	<span class="cm">/* UI_FF_UPLOAD, UI_FF_ERASE */</span>

	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">done</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">effect_id</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ff_effect</span> <span class="o">*</span><span class="n">effect</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ff_effect</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">upload</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">uinput_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">input_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">mutex</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">uinput_state</span>	<span class="n">state</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">waitq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">ready</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">tail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">input_event</span>	<span class="n">buff</span><span class="p">[</span><span class="n">UINPUT_BUFFER_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ff_effects_max</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uinput_request</span>	<span class="o">*</span><span class="n">requests</span><span class="p">[</span><span class="n">UINPUT_NUM_REQUESTS</span><span class="p">];</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">requests_waitq</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">requests_lock</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">uinput_ff_upload</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">request_id</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ff_effect</span>	<span class="n">effect</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ff_effect</span>	<span class="n">old</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">uinput_ff_erase</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">request_id</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">effect_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* ioctl */</span>
<span class="cp">#define UINPUT_IOCTL_BASE	&#39;U&#39;</span>
<span class="cp">#define UI_DEV_CREATE		_IO(UINPUT_IOCTL_BASE, 1)</span>
<span class="cp">#define UI_DEV_DESTROY		_IO(UINPUT_IOCTL_BASE, 2)</span>

<span class="cp">#define UI_SET_EVBIT		_IOW(UINPUT_IOCTL_BASE, 100, int)</span>
<span class="cp">#define UI_SET_KEYBIT		_IOW(UINPUT_IOCTL_BASE, 101, int)</span>
<span class="cp">#define UI_SET_RELBIT		_IOW(UINPUT_IOCTL_BASE, 102, int)</span>
<span class="cp">#define UI_SET_ABSBIT		_IOW(UINPUT_IOCTL_BASE, 103, int)</span>
<span class="cp">#define UI_SET_MSCBIT		_IOW(UINPUT_IOCTL_BASE, 104, int)</span>
<span class="cp">#define UI_SET_LEDBIT		_IOW(UINPUT_IOCTL_BASE, 105, int)</span>
<span class="cp">#define UI_SET_SNDBIT		_IOW(UINPUT_IOCTL_BASE, 106, int)</span>
<span class="cp">#define UI_SET_FFBIT		_IOW(UINPUT_IOCTL_BASE, 107, int)</span>
<span class="cp">#define UI_SET_PHYS		_IOW(UINPUT_IOCTL_BASE, 108, char*)</span>
<span class="cp">#define UI_SET_SWBIT		_IOW(UINPUT_IOCTL_BASE, 109, int)</span>
<span class="cp">#define UI_SET_PROPBIT		_IOW(UINPUT_IOCTL_BASE, 110, int)</span>

<span class="cp">#define UI_BEGIN_FF_UPLOAD	_IOWR(UINPUT_IOCTL_BASE, 200, struct uinput_ff_upload)</span>
<span class="cp">#define UI_END_FF_UPLOAD	_IOW(UINPUT_IOCTL_BASE, 201, struct uinput_ff_upload)</span>
<span class="cp">#define UI_BEGIN_FF_ERASE	_IOWR(UINPUT_IOCTL_BASE, 202, struct uinput_ff_erase)</span>
<span class="cp">#define UI_END_FF_ERASE		_IOW(UINPUT_IOCTL_BASE, 203, struct uinput_ff_erase)</span>

<span class="cm">/*</span>
<span class="cm"> * To write a force-feedback-capable driver, the upload_effect</span>
<span class="cm"> * and erase_effect callbacks in input_dev must be implemented.</span>
<span class="cm"> * The uinput driver will generate a fake input event when one of</span>
<span class="cm"> * these callbacks are invoked. The userspace code then uses</span>
<span class="cm"> * ioctls to retrieve additional parameters and send the return code.</span>
<span class="cm"> * The callback blocks until this return code is sent.</span>
<span class="cm"> *</span>
<span class="cm"> * The described callback mechanism is only used if ff_effects_max</span>
<span class="cm"> * is set.</span>
<span class="cm"> *</span>
<span class="cm"> * To implement upload_effect():</span>
<span class="cm"> *   1. Wait for an event with type == EV_UINPUT and code == UI_FF_UPLOAD.</span>
<span class="cm"> *      A request ID will be given in &#39;value&#39;.</span>
<span class="cm"> *   2. Allocate a uinput_ff_upload struct, fill in request_id with</span>
<span class="cm"> *      the &#39;value&#39; from the EV_UINPUT event.</span>
<span class="cm"> *   3. Issue a UI_BEGIN_FF_UPLOAD ioctl, giving it the</span>
<span class="cm"> *      uinput_ff_upload struct. It will be filled in with the</span>
<span class="cm"> *      ff_effects passed to upload_effect().</span>
<span class="cm"> *   4. Perform the effect upload, and place a return code back into</span>
<span class="cm">        the uinput_ff_upload struct.</span>
<span class="cm"> *   5. Issue a UI_END_FF_UPLOAD ioctl, also giving it the</span>
<span class="cm"> *      uinput_ff_upload_effect struct. This will complete execution</span>
<span class="cm"> *      of our upload_effect() handler.</span>
<span class="cm"> *</span>
<span class="cm"> * To implement erase_effect():</span>
<span class="cm"> *   1. Wait for an event with type == EV_UINPUT and code == UI_FF_ERASE.</span>
<span class="cm"> *      A request ID will be given in &#39;value&#39;.</span>
<span class="cm"> *   2. Allocate a uinput_ff_erase struct, fill in request_id with</span>
<span class="cm"> *      the &#39;value&#39; from the EV_UINPUT event.</span>
<span class="cm"> *   3. Issue a UI_BEGIN_FF_ERASE ioctl, giving it the</span>
<span class="cm"> *      uinput_ff_erase struct. It will be filled in with the</span>
<span class="cm"> *      effect ID passed to erase_effect().</span>
<span class="cm"> *   4. Perform the effect erasure, and place a return code back</span>
<span class="cm"> *      into the uinput_ff_erase struct.</span>
<span class="cm"> *   5. Issue a UI_END_FF_ERASE ioctl, also giving it the</span>
<span class="cm"> *      uinput_ff_erase_effect struct. This will complete execution</span>
<span class="cm"> *      of our erase_effect() handler.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This is the new event type, used only by uinput.</span>
<span class="cm"> * &#39;code&#39; is UI_FF_UPLOAD or UI_FF_ERASE, and &#39;value&#39;</span>
<span class="cm"> * is the unique request ID. This number was picked</span>
<span class="cm"> * arbitrarily, above EV_MAX (since the input system</span>
<span class="cm"> * never sees it) but in the range of a 16-bit int.</span>
<span class="cm"> */</span>
<span class="cp">#define EV_UINPUT		0x0101</span>
<span class="cp">#define UI_FF_UPLOAD		1</span>
<span class="cp">#define UI_FF_ERASE		2</span>

<span class="cp">#define UINPUT_MAX_NAME_SIZE	80</span>
<span class="k">struct</span> <span class="n">uinput_user_dev</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">UINPUT_MAX_NAME_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">input_id</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ff_effects_max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">absmax</span><span class="p">[</span><span class="n">ABS_CNT</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">absmin</span><span class="p">[</span><span class="n">ABS_CNT</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">absfuzz</span><span class="p">[</span><span class="n">ABS_CNT</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">absflat</span><span class="p">[</span><span class="n">ABS_CNT</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#endif	</span><span class="cm">/* __UINPUT_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
