<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › zlib.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>zlib.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* zlib.h -- interface of the &#39;zlib&#39; general purpose compression library</span>

<span class="cm">  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler</span>

<span class="cm">  This software is provided &#39;as-is&#39;, without any express or implied</span>
<span class="cm">  warranty.  In no event will the authors be held liable for any damages</span>
<span class="cm">  arising from the use of this software.</span>

<span class="cm">  Permission is granted to anyone to use this software for any purpose,</span>
<span class="cm">  including commercial applications, and to alter it and redistribute it</span>
<span class="cm">  freely, subject to the following restrictions:</span>

<span class="cm">  1. The origin of this software must not be misrepresented; you must not</span>
<span class="cm">     claim that you wrote the original software. If you use this software</span>
<span class="cm">     in a product, an acknowledgment in the product documentation would be</span>
<span class="cm">     appreciated but is not required.</span>
<span class="cm">  2. Altered source versions must be plainly marked as such, and must not be</span>
<span class="cm">     misrepresented as being the original software.</span>
<span class="cm">  3. This notice may not be removed or altered from any source distribution.</span>

<span class="cm">  Jean-loup Gailly        Mark Adler</span>
<span class="cm">  jloup@gzip.org          madler@alumni.caltech.edu</span>


<span class="cm">  The data format used by the zlib library is described by RFCs (Request for</span>
<span class="cm">  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt</span>
<span class="cm">  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).</span>
<span class="cm">*/</span>

<span class="cp">#ifndef _ZLIB_H</span>
<span class="cp">#define _ZLIB_H</span>

<span class="cp">#include &lt;linux/zconf.h&gt;</span>

<span class="cm">/* zlib deflate based on ZLIB_VERSION &quot;1.1.3&quot; */</span>
<span class="cm">/* zlib inflate based on ZLIB_VERSION &quot;1.2.3&quot; */</span>

<span class="cm">/*</span>
<span class="cm">  This is a modified version of zlib for use inside the Linux kernel.</span>
<span class="cm">  The main changes are to perform all memory allocation in advance.</span>

<span class="cm">  Inflation Changes:</span>
<span class="cm">    * Z_PACKET_FLUSH is added and used by ppp_deflate. Before returning</span>
<span class="cm">      this checks there is no more input data available and the next data</span>
<span class="cm">      is a STORED block. It also resets the mode to be read for the next</span>
<span class="cm">      data, all as per PPP requirements.</span>
<span class="cm">    * Addition of zlib_inflateIncomp which copies incompressible data into</span>
<span class="cm">      the history window and adjusts the accoutning without calling</span>
<span class="cm">      zlib_inflate itself to inflate the data.</span>
<span class="cm">*/</span>

<span class="cm">/* </span>
<span class="cm">     The &#39;zlib&#39; compression library provides in-memory compression and</span>
<span class="cm">  decompression functions, including integrity checks of the uncompressed</span>
<span class="cm">  data.  This version of the library supports only one compression method</span>
<span class="cm">  (deflation) but other algorithms will be added later and will have the same</span>
<span class="cm">  stream interface.</span>

<span class="cm">     Compression can be done in a single step if the buffers are large</span>
<span class="cm">  enough (for example if an input file is mmap&#39;ed), or can be done by</span>
<span class="cm">  repeated calls of the compression function.  In the latter case, the</span>
<span class="cm">  application must provide more input and/or consume the output</span>
<span class="cm">  (providing more output space) before each call.</span>

<span class="cm">     The compressed data format used by default by the in-memory functions is</span>
<span class="cm">  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped</span>
<span class="cm">  around a deflate stream, which is itself documented in RFC 1951.</span>

<span class="cm">     The library also supports reading and writing files in gzip (.gz) format</span>
<span class="cm">  with an interface similar to that of stdio.</span>

<span class="cm">     The zlib format was designed to be compact and fast for use in memory</span>
<span class="cm">  and on communications channels.  The gzip format was designed for single-</span>
<span class="cm">  file compression on file systems, has a larger header than zlib to maintain</span>
<span class="cm">  directory information, and uses a different, slower check method than zlib.</span>

<span class="cm">     The library does not install any signal handler. The decoder checks</span>
<span class="cm">  the consistency of the compressed data, so the library should never</span>
<span class="cm">  crash even in case of corrupted input.</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">internal_state</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">z_stream_s</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Byte</span> <span class="o">*</span><span class="n">next_in</span><span class="p">;</span>   <span class="cm">/* next input byte */</span>
    <span class="n">uInt</span>     <span class="n">avail_in</span><span class="p">;</span>  <span class="cm">/* number of bytes available at next_in */</span>
    <span class="n">uLong</span>    <span class="n">total_in</span><span class="p">;</span>  <span class="cm">/* total nb of input bytes read so far */</span>

    <span class="n">Byte</span>    <span class="o">*</span><span class="n">next_out</span><span class="p">;</span>  <span class="cm">/* next output byte should be put there */</span>
    <span class="n">uInt</span>     <span class="n">avail_out</span><span class="p">;</span> <span class="cm">/* remaining free space at next_out */</span>
    <span class="n">uLong</span>    <span class="n">total_out</span><span class="p">;</span> <span class="cm">/* total nb of bytes output so far */</span>

    <span class="kt">char</span>     <span class="o">*</span><span class="n">msg</span><span class="p">;</span>      <span class="cm">/* last error message, NULL if no error */</span>
    <span class="k">struct</span> <span class="n">internal_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span> <span class="cm">/* not visible by applications */</span>

    <span class="kt">void</span>     <span class="o">*</span><span class="n">workspace</span><span class="p">;</span> <span class="cm">/* memory allocated for this stream */</span>

    <span class="kt">int</span>     <span class="n">data_type</span><span class="p">;</span>  <span class="cm">/* best guess about the data type: ascii or binary */</span>
    <span class="n">uLong</span>   <span class="n">adler</span><span class="p">;</span>      <span class="cm">/* adler32 value of the uncompressed data */</span>
    <span class="n">uLong</span>   <span class="n">reserved</span><span class="p">;</span>   <span class="cm">/* reserved for future use */</span>
<span class="p">}</span> <span class="n">z_stream</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">z_stream</span> <span class="o">*</span><span class="n">z_streamp</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">   The application must update next_in and avail_in when avail_in has</span>
<span class="cm">   dropped to zero. It must update next_out and avail_out when avail_out</span>
<span class="cm">   has dropped to zero. The application must initialize zalloc, zfree and</span>
<span class="cm">   opaque before calling the init function. All other fields are set by the</span>
<span class="cm">   compression library and must not be updated by the application.</span>

<span class="cm">   The opaque value provided by the application will be passed as the first</span>
<span class="cm">   parameter for calls of zalloc and zfree. This can be useful for custom</span>
<span class="cm">   memory management. The compression library attaches no meaning to the</span>
<span class="cm">   opaque value.</span>

<span class="cm">   zalloc must return NULL if there is not enough memory for the object.</span>
<span class="cm">   If zlib is used in a multi-threaded application, zalloc and zfree must be</span>
<span class="cm">   thread safe.</span>

<span class="cm">   On 16-bit systems, the functions zalloc and zfree must be able to allocate</span>
<span class="cm">   exactly 65536 bytes, but will not be required to allocate more than this</span>
<span class="cm">   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,</span>
<span class="cm">   pointers returned by zalloc for objects of exactly 65536 bytes *must*</span>
<span class="cm">   have their offset normalized to zero. The default allocation function</span>
<span class="cm">   provided by this library ensures this (see zutil.c). To reduce memory</span>
<span class="cm">   requirements and avoid any allocation of 64K objects, at the expense of</span>
<span class="cm">   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).</span>

<span class="cm">   The fields total_in and total_out can be used for statistics or</span>
<span class="cm">   progress reports. After compression, total_in holds the total size of</span>
<span class="cm">   the uncompressed data and may be saved for use in the decompressor</span>
<span class="cm">   (particularly if the decompressor wants to decompress everything in</span>
<span class="cm">   a single step).</span>
<span class="cm">*/</span>

                        <span class="cm">/* constants */</span>

<span class="cp">#define Z_NO_FLUSH      0</span>
<span class="cp">#define Z_PARTIAL_FLUSH 1 </span><span class="cm">/* will be removed, use Z_SYNC_FLUSH instead */</span><span class="cp"></span>
<span class="cp">#define Z_PACKET_FLUSH  2</span>
<span class="cp">#define Z_SYNC_FLUSH    3</span>
<span class="cp">#define Z_FULL_FLUSH    4</span>
<span class="cp">#define Z_FINISH        5</span>
<span class="cp">#define Z_BLOCK         6 </span><span class="cm">/* Only for inflate at present */</span><span class="cp"></span>
<span class="cm">/* Allowed flush values; see deflate() and inflate() below for details */</span>

<span class="cp">#define Z_OK            0</span>
<span class="cp">#define Z_STREAM_END    1</span>
<span class="cp">#define Z_NEED_DICT     2</span>
<span class="cp">#define Z_ERRNO        (-1)</span>
<span class="cp">#define Z_STREAM_ERROR (-2)</span>
<span class="cp">#define Z_DATA_ERROR   (-3)</span>
<span class="cp">#define Z_MEM_ERROR    (-4)</span>
<span class="cp">#define Z_BUF_ERROR    (-5)</span>
<span class="cp">#define Z_VERSION_ERROR (-6)</span>
<span class="cm">/* Return codes for the compression/decompression functions. Negative</span>
<span class="cm"> * values are errors, positive values are used for special but normal events.</span>
<span class="cm"> */</span>

<span class="cp">#define Z_NO_COMPRESSION         0</span>
<span class="cp">#define Z_BEST_SPEED             1</span>
<span class="cp">#define Z_BEST_COMPRESSION       9</span>
<span class="cp">#define Z_DEFAULT_COMPRESSION  (-1)</span>
<span class="cm">/* compression levels */</span>

<span class="cp">#define Z_FILTERED            1</span>
<span class="cp">#define Z_HUFFMAN_ONLY        2</span>
<span class="cp">#define Z_DEFAULT_STRATEGY    0</span>
<span class="cm">/* compression strategy; see deflateInit2() below for details */</span>

<span class="cp">#define Z_BINARY   0</span>
<span class="cp">#define Z_ASCII    1</span>
<span class="cp">#define Z_UNKNOWN  2</span>
<span class="cm">/* Possible values of the data_type field */</span>

<span class="cp">#define Z_DEFLATED   8</span>
<span class="cm">/* The deflate compression method (the only one supported in this version) */</span>

                        <span class="cm">/* basic functions */</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_deflate_workspacesize</span> <span class="p">(</span><span class="kt">int</span> <span class="n">windowBits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">memLevel</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">   Returns the number of bytes that needs to be allocated for a per-</span>
<span class="cm">   stream workspace with the specified parameters.  A pointer to this</span>
<span class="cm">   number of bytes should be returned in stream-&gt;workspace before</span>
<span class="cm">   you call zlib_deflateInit() or zlib_deflateInit2().  If you call</span>
<span class="cm">   zlib_deflateInit(), specify windowBits = MAX_WBITS and memLevel =</span>
<span class="cm">   MAX_MEM_LEVEL here.  If you call zlib_deflateInit2(), the windowBits</span>
<span class="cm">   and memLevel parameters passed to zlib_deflateInit2() must not</span>
<span class="cm">   exceed those passed here.</span>
<span class="cm">*/</span>

<span class="cm">/* </span>
<span class="cm">extern int deflateInit (z_streamp strm, int level);</span>

<span class="cm">     Initializes the internal stream state for compression. The fields</span>
<span class="cm">   zalloc, zfree and opaque must be initialized before by the caller.</span>
<span class="cm">   If zalloc and zfree are set to NULL, deflateInit updates them to</span>
<span class="cm">   use default allocation functions.</span>

<span class="cm">     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:</span>
<span class="cm">   1 gives best speed, 9 gives best compression, 0 gives no compression at</span>
<span class="cm">   all (the input data is simply copied a block at a time).</span>
<span class="cm">   Z_DEFAULT_COMPRESSION requests a default compromise between speed and</span>
<span class="cm">   compression (currently equivalent to level 6).</span>

<span class="cm">     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not</span>
<span class="cm">   enough memory, Z_STREAM_ERROR if level is not a valid compression level,</span>
<span class="cm">   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible</span>
<span class="cm">   with the version assumed by the caller (ZLIB_VERSION).</span>
<span class="cm">   msg is set to null if there is no error message.  deflateInit does not</span>
<span class="cm">   perform any compression: this will be done by deflate().</span>
<span class="cm">*/</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_deflate</span> <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">    deflate compresses as much data as possible, and stops when the input</span>
<span class="cm">  buffer becomes empty or the output buffer becomes full. It may introduce some</span>
<span class="cm">  output latency (reading input without producing any output) except when</span>
<span class="cm">  forced to flush.</span>

<span class="cm">    The detailed semantics are as follows. deflate performs one or both of the</span>
<span class="cm">  following actions:</span>

<span class="cm">  - Compress more input starting at next_in and update next_in and avail_in</span>
<span class="cm">    accordingly. If not all input can be processed (because there is not</span>
<span class="cm">    enough room in the output buffer), next_in and avail_in are updated and</span>
<span class="cm">    processing will resume at this point for the next call of deflate().</span>

<span class="cm">  - Provide more output starting at next_out and update next_out and avail_out</span>
<span class="cm">    accordingly. This action is forced if the parameter flush is non zero.</span>
<span class="cm">    Forcing flush frequently degrades the compression ratio, so this parameter</span>
<span class="cm">    should be set only when necessary (in interactive applications).</span>
<span class="cm">    Some output may be provided even if flush is not set.</span>

<span class="cm">  Before the call of deflate(), the application should ensure that at least</span>
<span class="cm">  one of the actions is possible, by providing more input and/or consuming</span>
<span class="cm">  more output, and updating avail_in or avail_out accordingly; avail_out</span>
<span class="cm">  should never be zero before the call. The application can consume the</span>
<span class="cm">  compressed output when it wants, for example when the output buffer is full</span>
<span class="cm">  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK</span>
<span class="cm">  and with zero avail_out, it must be called again after making room in the</span>
<span class="cm">  output buffer because there might be more output pending.</span>

<span class="cm">    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is</span>
<span class="cm">  flushed to the output buffer and the output is aligned on a byte boundary, so</span>
<span class="cm">  that the decompressor can get all input data available so far. (In particular</span>
<span class="cm">  avail_in is zero after the call if enough output space has been provided</span>
<span class="cm">  before the call.)  Flushing may degrade compression for some compression</span>
<span class="cm">  algorithms and so it should be used only when necessary.</span>

<span class="cm">    If flush is set to Z_FULL_FLUSH, all output is flushed as with</span>
<span class="cm">  Z_SYNC_FLUSH, and the compression state is reset so that decompression can</span>
<span class="cm">  restart from this point if previous compressed data has been damaged or if</span>
<span class="cm">  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade</span>
<span class="cm">  the compression.</span>

<span class="cm">    If deflate returns with avail_out == 0, this function must be called again</span>
<span class="cm">  with the same value of the flush parameter and more output space (updated</span>
<span class="cm">  avail_out), until the flush is complete (deflate returns with non-zero</span>
<span class="cm">  avail_out).</span>

<span class="cm">    If the parameter flush is set to Z_FINISH, pending input is processed,</span>
<span class="cm">  pending output is flushed and deflate returns with Z_STREAM_END if there</span>
<span class="cm">  was enough output space; if deflate returns with Z_OK, this function must be</span>
<span class="cm">  called again with Z_FINISH and more output space (updated avail_out) but no</span>
<span class="cm">  more input data, until it returns with Z_STREAM_END or an error. After</span>
<span class="cm">  deflate has returned Z_STREAM_END, the only possible operations on the</span>
<span class="cm">  stream are deflateReset or deflateEnd.</span>
<span class="cm">  </span>
<span class="cm">    Z_FINISH can be used immediately after deflateInit if all the compression</span>
<span class="cm">  is to be done in a single step. In this case, avail_out must be at least</span>
<span class="cm">  0.1% larger than avail_in plus 12 bytes.  If deflate does not return</span>
<span class="cm">  Z_STREAM_END, then it must be called again as described above.</span>

<span class="cm">    deflate() sets strm-&gt;adler to the adler32 checksum of all input read</span>
<span class="cm">  so far (that is, total_in bytes).</span>

<span class="cm">    deflate() may update data_type if it can make a good guess about</span>
<span class="cm">  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered</span>
<span class="cm">  binary. This field is only for information purposes and does not affect</span>
<span class="cm">  the compression algorithm in any manner.</span>

<span class="cm">    deflate() returns Z_OK if some progress has been made (more input</span>
<span class="cm">  processed or more output produced), Z_STREAM_END if all input has been</span>
<span class="cm">  consumed and all output has been produced (only when flush is set to</span>
<span class="cm">  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example</span>
<span class="cm">  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible</span>
<span class="cm">  (for example avail_in or avail_out was zero).</span>
<span class="cm">*/</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_deflateEnd</span> <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">     All dynamically allocated data structures for this stream are freed.</span>
<span class="cm">   This function discards any unprocessed input and does not flush any</span>
<span class="cm">   pending output.</span>

<span class="cm">     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the</span>
<span class="cm">   stream state was inconsistent, Z_DATA_ERROR if the stream was freed</span>
<span class="cm">   prematurely (some input or output was discarded). In the error case,</span>
<span class="cm">   msg may be set but then points to a static string (which must not be</span>
<span class="cm">   deallocated).</span>
<span class="cm">*/</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_inflate_workspacesize</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">   Returns the number of bytes that needs to be allocated for a per-</span>
<span class="cm">   stream workspace.  A pointer to this number of bytes should be</span>
<span class="cm">   returned in stream-&gt;workspace before calling zlib_inflateInit().</span>
<span class="cm">*/</span>

<span class="cm">/* </span>
<span class="cm">extern int zlib_inflateInit (z_streamp strm);</span>

<span class="cm">     Initializes the internal stream state for decompression. The fields</span>
<span class="cm">   next_in, avail_in, and workspace must be initialized before by</span>
<span class="cm">   the caller. If next_in is not NULL and avail_in is large enough (the exact</span>
<span class="cm">   value depends on the compression method), inflateInit determines the</span>
<span class="cm">   compression method from the zlib header and allocates all data structures</span>
<span class="cm">   accordingly; otherwise the allocation will be deferred to the first call of</span>
<span class="cm">   inflate.  If zalloc and zfree are set to NULL, inflateInit updates them to</span>
<span class="cm">   use default allocation functions.</span>

<span class="cm">     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<span class="cm">   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the</span>
<span class="cm">   version assumed by the caller.  msg is set to null if there is no error</span>
<span class="cm">   message. inflateInit does not perform any decompression apart from reading</span>
<span class="cm">   the zlib header if present: this will be done by inflate().  (So next_in and</span>
<span class="cm">   avail_in may be modified, but next_out and avail_out are unchanged.)</span>
<span class="cm">*/</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_inflate</span> <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">    inflate decompresses as much data as possible, and stops when the input</span>
<span class="cm">  buffer becomes empty or the output buffer becomes full. It may introduce</span>
<span class="cm">  some output latency (reading input without producing any output) except when</span>
<span class="cm">  forced to flush.</span>

<span class="cm">  The detailed semantics are as follows. inflate performs one or both of the</span>
<span class="cm">  following actions:</span>

<span class="cm">  - Decompress more input starting at next_in and update next_in and avail_in</span>
<span class="cm">    accordingly. If not all input can be processed (because there is not</span>
<span class="cm">    enough room in the output buffer), next_in is updated and processing</span>
<span class="cm">    will resume at this point for the next call of inflate().</span>

<span class="cm">  - Provide more output starting at next_out and update next_out and avail_out</span>
<span class="cm">    accordingly.  inflate() provides as much output as possible, until there</span>
<span class="cm">    is no more input data or no more space in the output buffer (see below</span>
<span class="cm">    about the flush parameter).</span>

<span class="cm">  Before the call of inflate(), the application should ensure that at least</span>
<span class="cm">  one of the actions is possible, by providing more input and/or consuming</span>
<span class="cm">  more output, and updating the next_* and avail_* values accordingly.</span>
<span class="cm">  The application can consume the uncompressed output when it wants, for</span>
<span class="cm">  example when the output buffer is full (avail_out == 0), or after each</span>
<span class="cm">  call of inflate(). If inflate returns Z_OK and with zero avail_out, it</span>
<span class="cm">  must be called again after making room in the output buffer because there</span>
<span class="cm">  might be more output pending.</span>

<span class="cm">    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,</span>
<span class="cm">  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much</span>
<span class="cm">  output as possible to the output buffer. Z_BLOCK requests that inflate() stop</span>
<span class="cm">  if and when it gets to the next deflate block boundary. When decoding the</span>
<span class="cm">  zlib or gzip format, this will cause inflate() to return immediately after</span>
<span class="cm">  the header and before the first block. When doing a raw inflate, inflate()</span>
<span class="cm">  will go ahead and process the first block, and will return when it gets to</span>
<span class="cm">  the end of that block, or when it runs out of data.</span>

<span class="cm">    The Z_BLOCK option assists in appending to or combining deflate streams.</span>
<span class="cm">  Also to assist in this, on return inflate() will set strm-&gt;data_type to the</span>
<span class="cm">  number of unused bits in the last byte taken from strm-&gt;next_in, plus 64</span>
<span class="cm">  if inflate() is currently decoding the last block in the deflate stream,</span>
<span class="cm">  plus 128 if inflate() returned immediately after decoding an end-of-block</span>
<span class="cm">  code or decoding the complete header up to just before the first byte of the</span>
<span class="cm">  deflate stream. The end-of-block will not be indicated until all of the</span>
<span class="cm">  uncompressed data from that block has been written to strm-&gt;next_out.  The</span>
<span class="cm">  number of unused bits may in general be greater than seven, except when</span>
<span class="cm">  bit 7 of data_type is set, in which case the number of unused bits will be</span>
<span class="cm">  less than eight.</span>

<span class="cm">    inflate() should normally be called until it returns Z_STREAM_END or an</span>
<span class="cm">  error. However if all decompression is to be performed in a single step</span>
<span class="cm">  (a single call of inflate), the parameter flush should be set to</span>
<span class="cm">  Z_FINISH. In this case all pending input is processed and all pending</span>
<span class="cm">  output is flushed; avail_out must be large enough to hold all the</span>
<span class="cm">  uncompressed data. (The size of the uncompressed data may have been saved</span>
<span class="cm">  by the compressor for this purpose.) The next operation on this stream must</span>
<span class="cm">  be inflateEnd to deallocate the decompression state. The use of Z_FINISH</span>
<span class="cm">  is never required, but can be used to inform inflate that a faster approach</span>
<span class="cm">  may be used for the single inflate() call.</span>

<span class="cm">     In this implementation, inflate() always flushes as much output as</span>
<span class="cm">  possible to the output buffer, and always uses the faster approach on the</span>
<span class="cm">  first call. So the only effect of the flush parameter in this implementation</span>
<span class="cm">  is on the return value of inflate(), as noted below, or when it returns early</span>
<span class="cm">  because Z_BLOCK is used.</span>

<span class="cm">     If a preset dictionary is needed after this call (see inflateSetDictionary</span>
<span class="cm">  below), inflate sets strm-&gt;adler to the adler32 checksum of the dictionary</span>
<span class="cm">  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets</span>
<span class="cm">  strm-&gt;adler to the adler32 checksum of all output produced so far (that is,</span>
<span class="cm">  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described</span>
<span class="cm">  below. At the end of the stream, inflate() checks that its computed adler32</span>
<span class="cm">  checksum is equal to that saved by the compressor and returns Z_STREAM_END</span>
<span class="cm">  only if the checksum is correct.</span>

<span class="cm">    inflate() will decompress and check either zlib-wrapped or gzip-wrapped</span>
<span class="cm">  deflate data.  The header type is detected automatically.  Any information</span>
<span class="cm">  contained in the gzip header is not retained, so applications that need that</span>
<span class="cm">  information should instead use raw inflate, see inflateInit2() below, or</span>
<span class="cm">  inflateBack() and perform their own processing of the gzip header and</span>
<span class="cm">  trailer.</span>

<span class="cm">    inflate() returns Z_OK if some progress has been made (more input processed</span>
<span class="cm">  or more output produced), Z_STREAM_END if the end of the compressed data has</span>
<span class="cm">  been reached and all uncompressed output has been produced, Z_NEED_DICT if a</span>
<span class="cm">  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was</span>
<span class="cm">  corrupted (input stream not conforming to the zlib format or incorrect check</span>
<span class="cm">  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example</span>
<span class="cm">  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,</span>
<span class="cm">  Z_BUF_ERROR if no progress is possible or if there was not enough room in the</span>
<span class="cm">  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and</span>
<span class="cm">  inflate() can be called again with more input and more output space to</span>
<span class="cm">  continue decompressing. If Z_DATA_ERROR is returned, the application may then</span>
<span class="cm">  call inflateSync() to look for a good compression block if a partial recovery</span>
<span class="cm">  of the data is desired.</span>
<span class="cm">*/</span>


<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_inflateEnd</span> <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">     All dynamically allocated data structures for this stream are freed.</span>
<span class="cm">   This function discards any unprocessed input and does not flush any</span>
<span class="cm">   pending output.</span>

<span class="cm">     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state</span>
<span class="cm">   was inconsistent. In the error case, msg may be set but then points to a</span>
<span class="cm">   static string (which must not be deallocated).</span>
<span class="cm">*/</span>

                        <span class="cm">/* Advanced functions */</span>

<span class="cm">/*</span>
<span class="cm">    The following functions are needed only in some special applications.</span>
<span class="cm">*/</span>

<span class="cm">/*   </span>
<span class="cm">extern int deflateInit2 (z_streamp strm,</span>
<span class="cm">                                     int  level,</span>
<span class="cm">                                     int  method,</span>
<span class="cm">                                     int  windowBits,</span>
<span class="cm">                                     int  memLevel,</span>
<span class="cm">                                     int  strategy);</span>

<span class="cm">     This is another version of deflateInit with more compression options. The</span>
<span class="cm">   fields next_in, zalloc, zfree and opaque must be initialized before by</span>
<span class="cm">   the caller.</span>

<span class="cm">     The method parameter is the compression method. It must be Z_DEFLATED in</span>
<span class="cm">   this version of the library.</span>

<span class="cm">     The windowBits parameter is the base two logarithm of the window size</span>
<span class="cm">   (the size of the history buffer).  It should be in the range 8..15 for this</span>
<span class="cm">   version of the library. Larger values of this parameter result in better</span>
<span class="cm">   compression at the expense of memory usage. The default value is 15 if</span>
<span class="cm">   deflateInit is used instead.</span>

<span class="cm">     The memLevel parameter specifies how much memory should be allocated</span>
<span class="cm">   for the internal compression state. memLevel=1 uses minimum memory but</span>
<span class="cm">   is slow and reduces compression ratio; memLevel=9 uses maximum memory</span>
<span class="cm">   for optimal speed. The default value is 8. See zconf.h for total memory</span>
<span class="cm">   usage as a function of windowBits and memLevel.</span>

<span class="cm">     The strategy parameter is used to tune the compression algorithm. Use the</span>
<span class="cm">   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a</span>
<span class="cm">   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no</span>
<span class="cm">   string match).  Filtered data consists mostly of small values with a</span>
<span class="cm">   somewhat random distribution. In this case, the compression algorithm is</span>
<span class="cm">   tuned to compress them better. The effect of Z_FILTERED is to force more</span>
<span class="cm">   Huffman coding and less string matching; it is somewhat intermediate</span>
<span class="cm">   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects</span>
<span class="cm">   the compression ratio but not the correctness of the compressed output even</span>
<span class="cm">   if it is not set appropriately.</span>

<span class="cm">      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<span class="cm">   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid</span>
<span class="cm">   method). msg is set to null if there is no error message.  deflateInit2 does</span>
<span class="cm">   not perform any compression: this will be done by deflate().</span>
<span class="cm">*/</span>
                            
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">extern int zlib_deflateSetDictionary (z_streamp strm,</span>
<span class="c">						     const Byte *dictionary,</span>
<span class="c">						     uInt  dictLength);</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm">     Initializes the compression dictionary from the given byte sequence</span>
<span class="cm">   without producing any compressed output. This function must be called</span>
<span class="cm">   immediately after deflateInit, deflateInit2 or deflateReset, before any</span>
<span class="cm">   call of deflate. The compressor and decompressor must use exactly the same</span>
<span class="cm">   dictionary (see inflateSetDictionary).</span>

<span class="cm">     The dictionary should consist of strings (byte sequences) that are likely</span>
<span class="cm">   to be encountered later in the data to be compressed, with the most commonly</span>
<span class="cm">   used strings preferably put towards the end of the dictionary. Using a</span>
<span class="cm">   dictionary is most useful when the data to be compressed is short and can be</span>
<span class="cm">   predicted with good accuracy; the data can then be compressed better than</span>
<span class="cm">   with the default empty dictionary.</span>

<span class="cm">     Depending on the size of the compression data structures selected by</span>
<span class="cm">   deflateInit or deflateInit2, a part of the dictionary may in effect be</span>
<span class="cm">   discarded, for example if the dictionary is larger than the window size in</span>
<span class="cm">   deflate or deflate2. Thus the strings most likely to be useful should be</span>
<span class="cm">   put at the end of the dictionary, not at the front.</span>

<span class="cm">     Upon return of this function, strm-&gt;adler is set to the Adler32 value</span>
<span class="cm">   of the dictionary; the decompressor may later use this value to determine</span>
<span class="cm">   which dictionary has been used by the compressor. (The Adler32 value</span>
<span class="cm">   applies to the whole dictionary even if only a subset of the dictionary is</span>
<span class="cm">   actually used by the compressor.)</span>

<span class="cm">     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a</span>
<span class="cm">   parameter is invalid (such as NULL dictionary) or the stream state is</span>
<span class="cm">   inconsistent (for example if deflate has already been called for this stream</span>
<span class="cm">   or if the compression method is bsort). deflateSetDictionary does not</span>
<span class="cm">   perform any compression: this will be done by deflate().</span>
<span class="cm">*/</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">extern int zlib_deflateCopy (z_streamp dest, z_streamp source);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">     Sets the destination stream as a complete copy of the source stream.</span>

<span class="cm">     This function can be useful when several compression strategies will be</span>
<span class="cm">   tried, for example when there are several ways of pre-processing the input</span>
<span class="cm">   data with a filter. The streams that will be discarded should then be freed</span>
<span class="cm">   by calling deflateEnd.  Note that deflateCopy duplicates the internal</span>
<span class="cm">   compression state which can be quite large, so this strategy is slow and</span>
<span class="cm">   can consume lots of memory.</span>

<span class="cm">     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not</span>
<span class="cm">   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent</span>
<span class="cm">   (such as zalloc being NULL). msg is left unchanged in both source and</span>
<span class="cm">   destination.</span>
<span class="cm">*/</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_deflateReset</span> <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">     This function is equivalent to deflateEnd followed by deflateInit,</span>
<span class="cm">   but does not free and reallocate all the internal compression state.</span>
<span class="cm">   The stream will keep the same compression level and any other attributes</span>
<span class="cm">   that may have been set by deflateInit2.</span>

<span class="cm">      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<span class="cm">   stream state was inconsistent (such as zalloc or state being NULL).</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">deflateBound</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">63</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="mi">11</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">extern int zlib_deflateParams (z_streamp strm, int level, int strategy);</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm">     Dynamically update the compression level and compression strategy.  The</span>
<span class="cm">   interpretation of level and strategy is as in deflateInit2.  This can be</span>
<span class="cm">   used to switch between compression and straight copy of the input data, or</span>
<span class="cm">   to switch to a different kind of input data requiring a different</span>
<span class="cm">   strategy. If the compression level is changed, the input available so far</span>
<span class="cm">   is compressed with the old level (and may be flushed); the new level will</span>
<span class="cm">   take effect only at the next call of deflate().</span>

<span class="cm">     Before the call of deflateParams, the stream state must be set as for</span>
<span class="cm">   a call of deflate(), since the currently available input may have to</span>
<span class="cm">   be compressed and flushed. In particular, strm-&gt;avail_out must be non-zero.</span>

<span class="cm">     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source</span>
<span class="cm">   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR</span>
<span class="cm">   if strm-&gt;avail_out was zero.</span>
<span class="cm">*/</span>

<span class="cm">/*   </span>
<span class="cm">extern int inflateInit2 (z_streamp strm, int  windowBits);</span>

<span class="cm">     This is another version of inflateInit with an extra parameter. The</span>
<span class="cm">   fields next_in, avail_in, zalloc, zfree and opaque must be initialized</span>
<span class="cm">   before by the caller.</span>

<span class="cm">     The windowBits parameter is the base two logarithm of the maximum window</span>
<span class="cm">   size (the size of the history buffer).  It should be in the range 8..15 for</span>
<span class="cm">   this version of the library. The default value is 15 if inflateInit is used</span>
<span class="cm">   instead. windowBits must be greater than or equal to the windowBits value</span>
<span class="cm">   provided to deflateInit2() while compressing, or it must be equal to 15 if</span>
<span class="cm">   deflateInit2() was not used. If a compressed stream with a larger window</span>
<span class="cm">   size is given as input, inflate() will return with the error code</span>
<span class="cm">   Z_DATA_ERROR instead of trying to allocate a larger window.</span>

<span class="cm">     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits</span>
<span class="cm">   determines the window size. inflate() will then process raw deflate data,</span>
<span class="cm">   not looking for a zlib or gzip header, not generating a check value, and not</span>
<span class="cm">   looking for any check values for comparison at the end of the stream. This</span>
<span class="cm">   is for use with other formats that use the deflate compressed data format</span>
<span class="cm">   such as zip.  Those formats provide their own check values. If a custom</span>
<span class="cm">   format is developed using the raw deflate format for compressed data, it is</span>
<span class="cm">   recommended that a check value such as an adler32 or a crc32 be applied to</span>
<span class="cm">   the uncompressed data as is done in the zlib, gzip, and zip formats.  For</span>
<span class="cm">   most applications, the zlib format should be used as is. Note that comments</span>
<span class="cm">   above on the use in deflateInit2() applies to the magnitude of windowBits.</span>

<span class="cm">     windowBits can also be greater than 15 for optional gzip decoding. Add</span>
<span class="cm">   32 to windowBits to enable zlib and gzip decoding with automatic header</span>
<span class="cm">   detection, or add 16 to decode only the gzip format (the zlib format will</span>
<span class="cm">   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm-&gt;adler is</span>
<span class="cm">   a crc32 instead of an adler32.</span>

<span class="cm">     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
<span class="cm">   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg</span>
<span class="cm">   is set to null if there is no error message.  inflateInit2 does not perform</span>
<span class="cm">   any decompression apart from reading the zlib header if present: this will</span>
<span class="cm">   be done by inflate(). (So next_in and avail_in may be modified, but next_out</span>
<span class="cm">   and avail_out are unchanged.)</span>
<span class="cm">*/</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_inflateSetDictionary</span> <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span>
						     <span class="k">const</span> <span class="n">Byte</span> <span class="o">*</span><span class="n">dictionary</span><span class="p">,</span>
						     <span class="n">uInt</span>  <span class="n">dictLength</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">     Initializes the decompression dictionary from the given uncompressed byte</span>
<span class="cm">   sequence. This function must be called immediately after a call of inflate,</span>
<span class="cm">   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor</span>
<span class="cm">   can be determined from the adler32 value returned by that call of inflate.</span>
<span class="cm">   The compressor and decompressor must use exactly the same dictionary (see</span>
<span class="cm">   deflateSetDictionary).  For raw inflate, this function can be called</span>
<span class="cm">   immediately after inflateInit2() or inflateReset() and before any call of</span>
<span class="cm">   inflate() to set the dictionary.  The application must insure that the</span>
<span class="cm">   dictionary that was used for compression is provided.</span>

<span class="cm">     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a</span>
<span class="cm">   parameter is invalid (such as NULL dictionary) or the stream state is</span>
<span class="cm">   inconsistent, Z_DATA_ERROR if the given dictionary doesn&#39;t match the</span>
<span class="cm">   expected one (incorrect adler32 value). inflateSetDictionary does not</span>
<span class="cm">   perform any decompression: this will be done by subsequent calls of</span>
<span class="cm">   inflate().</span>
<span class="cm">*/</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">extern int zlib_inflateSync (z_streamp strm);</span>
<span class="cp">#endif</span>
<span class="cm">/* </span>
<span class="cm">    Skips invalid compressed data until a full flush point (see above the</span>
<span class="cm">  description of deflate with Z_FULL_FLUSH) can be found, or until all</span>
<span class="cm">  available input is skipped. No output is provided.</span>

<span class="cm">    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR</span>
<span class="cm">  if no more input was provided, Z_DATA_ERROR if no flush point has been found,</span>
<span class="cm">  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success</span>
<span class="cm">  case, the application may save the current current value of total_in which</span>
<span class="cm">  indicates where valid compressed data was found. In the error case, the</span>
<span class="cm">  application may repeatedly call inflateSync, providing more input each time,</span>
<span class="cm">  until success or end of the input data.</span>
<span class="cm">*/</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_inflateReset</span> <span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">     This function is equivalent to inflateEnd followed by inflateInit,</span>
<span class="cm">   but does not free and reallocate all the internal decompression state.</span>
<span class="cm">   The stream will keep attributes that may have been set by inflateInit2.</span>

<span class="cm">      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
<span class="cm">   stream state was inconsistent (such as zalloc or state being NULL).</span>
<span class="cm">*/</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_inflateIncomp</span> <span class="p">(</span><span class="n">z_stream</span> <span class="o">*</span><span class="n">strm</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">     This function adds the data at next_in (avail_in bytes) to the output</span>
<span class="cm">   history without performing any output.  There must be no pending output,</span>
<span class="cm">   and the decompressor must be expecting to see the start of a block.</span>
<span class="cm">   Calling this function is equivalent to decompressing a stored block</span>
<span class="cm">   containing the data at next_in (except that the data is not output).</span>
<span class="cm">*/</span>

<span class="cp">#define zlib_deflateInit(strm, level) \</span>
<span class="cp">	zlib_deflateInit2((strm), (level), Z_DEFLATED, MAX_WBITS, \</span>
<span class="cp">			      DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)</span>
<span class="cp">#define zlib_inflateInit(strm) \</span>
<span class="cp">	zlib_inflateInit2((strm), DEF_WBITS)</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_deflateInit2</span><span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span> <span class="kt">int</span>  <span class="n">level</span><span class="p">,</span> <span class="kt">int</span>  <span class="n">method</span><span class="p">,</span>
                                      <span class="kt">int</span> <span class="n">windowBits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">memLevel</span><span class="p">,</span>
                                      <span class="kt">int</span> <span class="n">strategy</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_inflateInit2</span><span class="p">(</span><span class="n">z_streamp</span> <span class="n">strm</span><span class="p">,</span> <span class="kt">int</span>  <span class="n">windowBits</span><span class="p">);</span>

<span class="cp">#if !defined(_Z_UTIL_H) &amp;&amp; !defined(NO_DUMMY_DECL)</span>
    <span class="k">struct</span> <span class="n">internal_state</span> <span class="p">{</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">;};</span> <span class="cm">/* hack for buggy compilers */</span>
<span class="cp">#endif</span>

<span class="cm">/* Utility function: initialize zlib, unpack binary blob, clean up zlib,</span>
<span class="cm"> * return len or negative error code. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">zlib_inflate_blob</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">dst_sz</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">src_sz</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _ZLIB_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
