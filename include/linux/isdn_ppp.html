<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › isdn_ppp.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>isdn_ppp.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Linux ISDN subsystem, sync PPP, interface to ipppd</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1994-1999  by Fritz Elfert (fritz@isdn4linux.de)</span>
<span class="cm"> * Copyright 1995,96    Thinking Objects Software GmbH Wuerzburg</span>
<span class="cm"> * Copyright 1995,96    by Michael Hipp (Michael.Hipp@student.uni-tuebingen.de)</span>
<span class="cm"> * Copyright 2000-2002  by Kai Germaschewski (kai@germaschewski.name)</span>
<span class="cm"> *</span>
<span class="cm"> * This software may be used and distributed according to the terms</span>
<span class="cm"> * of the GNU General Public License, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_ISDN_PPP_H</span>
<span class="cp">#define _LINUX_ISDN_PPP_H</span>

<span class="cp">#define CALLTYPE_INCOMING 0x1</span>
<span class="cp">#define CALLTYPE_OUTGOING 0x2</span>
<span class="cp">#define CALLTYPE_CALLBACK 0x4</span>

<span class="cp">#define IPPP_VERSION    &quot;2.2.0&quot;</span>

<span class="k">struct</span> <span class="n">pppcallinfo</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">calltype</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">local_num</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">remote_num</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">charge_units</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define PPPIOCGCALLINFO _IOWR(&#39;t&#39;,128,struct pppcallinfo)</span>
<span class="cp">#define PPPIOCBUNDLE   _IOW(&#39;t&#39;,129,int)</span>
<span class="cp">#define PPPIOCGMPFLAGS _IOR(&#39;t&#39;,130,int)</span>
<span class="cp">#define PPPIOCSMPFLAGS _IOW(&#39;t&#39;,131,int)</span>
<span class="cp">#define PPPIOCSMPMTU   _IOW(&#39;t&#39;,132,int)</span>
<span class="cp">#define PPPIOCSMPMRU   _IOW(&#39;t&#39;,133,int)</span>
<span class="cp">#define PPPIOCGCOMPRESSORS _IOR(&#39;t&#39;,134,unsigned long [8])</span>
<span class="cp">#define PPPIOCSCOMPRESSOR _IOW(&#39;t&#39;,135,int)</span>
<span class="cp">#define PPPIOCGIFNAME      _IOR(&#39;t&#39;,136, char [IFNAMSIZ] )</span>


<span class="cp">#define SC_MP_PROT       0x00000200</span>
<span class="cp">#define SC_REJ_MP_PROT   0x00000400</span>
<span class="cp">#define SC_OUT_SHORT_SEQ 0x00000800</span>
<span class="cp">#define SC_IN_SHORT_SEQ  0x00004000</span>

<span class="cp">#define SC_DECOMP_ON		0x01</span>
<span class="cp">#define SC_COMP_ON		0x02</span>
<span class="cp">#define SC_DECOMP_DISCARD	0x04</span>
<span class="cp">#define SC_COMP_DISCARD		0x08</span>
<span class="cp">#define SC_LINK_DECOMP_ON	0x10</span>
<span class="cp">#define SC_LINK_COMP_ON		0x20</span>
<span class="cp">#define SC_LINK_DECOMP_DISCARD	0x40</span>
<span class="cp">#define SC_LINK_COMP_DISCARD	0x80</span>

<span class="cp">#define ISDN_PPP_COMP_MAX_OPTIONS 16</span>

<span class="cp">#define IPPP_COMP_FLAG_XMIT 0x1</span>
<span class="cp">#define IPPP_COMP_FLAG_LINK 0x2</span>

<span class="k">struct</span> <span class="n">isdn_ppp_comp_data</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">options</span><span class="p">[</span><span class="n">ISDN_PPP_COMP_MAX_OPTIONS</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">optlen</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>



<span class="cp">#ifdef CONFIG_IPPP_FILTER</span>
<span class="cp">#include &lt;linux/filter.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#define DECOMP_ERR_NOMEM	(-10)</span>

<span class="cp">#define MP_END_FRAG    0x40</span>
<span class="cp">#define MP_BEGIN_FRAG  0x80</span>

<span class="cp">#define MP_MAX_QUEUE_LEN	16</span>

<span class="cm">/*</span>
<span class="cm"> * We need a way for the decompressor to influence the generation of CCP</span>
<span class="cm"> * Reset-Requests in a variety of ways. The decompressor is already returning</span>
<span class="cm"> * a lot of information (generated skb length, error conditions) so we use</span>
<span class="cm"> * another parameter. This parameter is a pointer to a structure which is</span>
<span class="cm"> * to be marked valid by the decompressor and only in this case is ever used.</span>
<span class="cm"> * Furthermore, the only case where this data is used is when the decom-</span>
<span class="cm"> * pressor returns DECOMP_ERROR.</span>
<span class="cm"> *</span>
<span class="cm"> * We use this same struct for the reset entry of the compressor to commu-</span>
<span class="cm"> * nicate to its caller how to deal with sending of a Reset Ack. In this</span>
<span class="cm"> * case, expra is not used, but other options still apply (suppressing</span>
<span class="cm"> * sending with rsend, appending arbitrary data, etc).</span>
<span class="cm"> */</span>

<span class="cp">#define IPPP_RESET_MAXDATABYTES	32</span>

<span class="k">struct</span> <span class="n">isdn_ppp_resetparams</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* rw Is this structure filled at all ? */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rsend</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* rw Should we send one at all ? */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">idval</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* rw Is the id field valid ? */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dtval</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* rw Is the data field valid ? */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">expra</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* rw Is an Ack expected for this Req ? */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">;</span>		<span class="cm">/* wo Send CCP ResetReq with this id */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">maxdlen</span><span class="p">;</span>	<span class="cm">/* ro Max bytes to be stored in data field */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dlen</span><span class="p">;</span>		<span class="cm">/* rw Bytes stored in data field */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>		<span class="cm">/* wo Data for ResetReq info field */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * this is an &#39;old friend&#39; from ppp-comp.h under a new name </span>
<span class="cm"> * check the original include for more information</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">isdn_ppp_compressor</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">isdn_ppp_compressor</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span> <span class="cm">/* CCP compression protocol number */</span>
  
  <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">isdn_ppp_comp_data</span> <span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
  <span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">isdn_ppp_comp_data</span> <span class="o">*</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">unit</span><span class="p">,</span><span class="kt">int</span> <span class="n">debug</span><span class="p">);</span>
  
  <span class="cm">/* The reset entry needs to get more exact information about the</span>
<span class="cm">     ResetReq or ResetAck it was called with. The parameters are</span>
<span class="cm">     obvious. If reset is called without a Req or Ack frame which</span>
<span class="cm">     could be handed into it, code MUST be set to 0. Using rsparm,</span>
<span class="cm">     the reset entry can control if and how a ResetAck is returned. */</span>
  
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">isdn_ppp_resetparams</span> <span class="o">*</span><span class="n">rsparm</span><span class="p">);</span>
  
  <span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">compress</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">proto</span><span class="p">);</span>
  
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">decompress</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_out</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">isdn_ppp_resetparams</span> <span class="o">*</span><span class="n">rsparm</span><span class="p">);</span>
  
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">incomp</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span><span class="kt">int</span> <span class="n">proto</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stat</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compstat</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">isdn_ppp_register_compressor</span><span class="p">(</span><span class="k">struct</span> <span class="n">isdn_ppp_compressor</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">isdn_ppp_unregister_compressor</span><span class="p">(</span><span class="k">struct</span> <span class="n">isdn_ppp_compressor</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">isdn_ppp_dial_slave</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">isdn_ppp_hangup_slave</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seqerrs</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">frame_drops</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overflows</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_queue_len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">isdn_mppp_stats</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">mp_mrru</span><span class="p">;</span>                        <span class="cm">/* unused                             */</span>
  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span> <span class="n">frags</span><span class="p">;</span>	<span class="cm">/* fragments sl list -- use skb-&gt;next */</span>
  <span class="kt">long</span> <span class="n">frames</span><span class="p">;</span>			<span class="cm">/* number of frames in the frame list */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>		<span class="cm">/* last processed packet seq #: any packets</span>
<span class="cm">  				 * with smaller seq # will be dropped</span>
<span class="cm">				 * unconditionally */</span>
  <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ref_ct</span><span class="p">;</span>				 
  <span class="cm">/* statistics */</span>
  <span class="n">isdn_mppp_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ippp_bundle</span><span class="p">;</span>

<span class="cp">#define NUM_RCV_BUFFS     64</span>

<span class="k">struct</span> <span class="n">ippp_buf_queue</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">ippp_buf_queue</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ippp_buf_queue</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>                 <span class="cm">/* NULL here indicates end of queue */</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The data structure for one CCP reset transaction */</span>
<span class="k">enum</span> <span class="n">ippp_ccp_reset_states</span> <span class="p">{</span>
  <span class="n">CCPResetIdle</span><span class="p">,</span>
  <span class="n">CCPResetSentReq</span><span class="p">,</span>
  <span class="n">CCPResetRcvdReq</span><span class="p">,</span>
  <span class="n">CCPResetSentAck</span><span class="p">,</span>
  <span class="n">CCPResetRcvdAck</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ippp_ccp_reset_state</span> <span class="p">{</span>
  <span class="k">enum</span> <span class="n">ippp_ccp_reset_states</span> <span class="n">state</span><span class="p">;</span>	<span class="cm">/* State of this transaction */</span>
  <span class="k">struct</span> <span class="n">ippp_struct</span> <span class="o">*</span><span class="n">is</span><span class="p">;</span>		<span class="cm">/* Backlink to device stuff */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">id</span><span class="p">;</span>			<span class="cm">/* Backlink id index */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ta</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* The timer is active (flag) */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">expra</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* We expect a ResetAck at all */</span>
  <span class="kt">int</span> <span class="n">dlen</span><span class="p">;</span>				<span class="cm">/* Databytes stored in data */</span>
  <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>		<span class="cm">/* For timeouts/retries */</span>
  <span class="cm">/* This is a hack but seems sufficient for the moment. We do not want</span>
<span class="cm">     to have this be yet another allocation for some bytes, it is more</span>
<span class="cm">     memory management overhead than the whole mess is worth. */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">IPPP_RESET_MAXDATABYTES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* The data structure keeping track of the currently outstanding CCP Reset</span>
<span class="cm">   transactions. */</span>
<span class="k">struct</span> <span class="n">ippp_ccp_reset</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">ippp_ccp_reset_state</span> <span class="o">*</span><span class="n">rs</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>	<span class="cm">/* One per possible id */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lastid</span><span class="p">;</span>			<span class="cm">/* Last id allocated by the engine */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ippp_struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">ippp_struct</span> <span class="o">*</span><span class="n">next_link</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
  <span class="n">spinlock_t</span> <span class="n">buflock</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ippp_buf_queue</span> <span class="n">rq</span><span class="p">[</span><span class="n">NUM_RCV_BUFFS</span><span class="p">];</span> <span class="cm">/* packet queue for isdn_ppp_read() */</span>
  <span class="k">struct</span> <span class="n">ippp_buf_queue</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>  <span class="cm">/* pointer to (current) first packet */</span>
  <span class="k">struct</span> <span class="n">ippp_buf_queue</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>   <span class="cm">/* pointer to (current) last used packet in queue */</span>
  <span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tk</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mpppcfg</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pppcfg</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mru</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mpmru</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mpmtu</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxcid</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">isdn_net_local_s</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">unit</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minor</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">last_link_seqno</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">mp_seqno</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ISDN_PPP_VJ</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cbuf</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">slcomp</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_IPPP_FILTER</span>
  <span class="k">struct</span> <span class="n">sock_filter</span> <span class="o">*</span><span class="n">pass_filter</span><span class="p">;</span>	<span class="cm">/* filter for packets to pass */</span>
  <span class="k">struct</span> <span class="n">sock_filter</span> <span class="o">*</span><span class="n">active_filter</span><span class="p">;</span>	<span class="cm">/* filter for pkts to reset idle */</span>
  <span class="kt">unsigned</span> <span class="n">pass_len</span><span class="p">,</span> <span class="n">active_len</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">debug</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">isdn_ppp_compressor</span> <span class="o">*</span><span class="n">compressor</span><span class="p">,</span><span class="o">*</span><span class="n">decompressor</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">isdn_ppp_compressor</span> <span class="o">*</span><span class="n">link_compressor</span><span class="p">,</span><span class="o">*</span><span class="n">link_decompressor</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">decomp_stat</span><span class="p">,</span><span class="o">*</span><span class="n">comp_stat</span><span class="p">,</span><span class="o">*</span><span class="n">link_decomp_stat</span><span class="p">,</span><span class="o">*</span><span class="n">link_comp_stat</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ippp_ccp_reset</span> <span class="o">*</span><span class="n">reset</span><span class="p">;</span>	<span class="cm">/* Allocated on demand, may never be needed */</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">compflags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* _LINUX_ISDN_PPP_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
