<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › regulator › driver.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>driver.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * driver.h -- SoC Regulator driver support.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007, 2008 Wolfson Microelectronics PLC.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Liam Girdwood &lt;lrg@slimlogic.co.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Regulator Driver Interface.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_REGULATOR_DRIVER_H_</span>
<span class="cp">#define __LINUX_REGULATOR_DRIVER_H_</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/regulator/consumer.h&gt;</span>

<span class="k">struct</span> <span class="n">regmap</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">regulator_dev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">regulator_init_data</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">regulator_status</span> <span class="p">{</span>
	<span class="n">REGULATOR_STATUS_OFF</span><span class="p">,</span>
	<span class="n">REGULATOR_STATUS_ON</span><span class="p">,</span>
	<span class="n">REGULATOR_STATUS_ERROR</span><span class="p">,</span>
	<span class="cm">/* fast/normal/idle/standby are flavors of &quot;on&quot; */</span>
	<span class="n">REGULATOR_STATUS_FAST</span><span class="p">,</span>
	<span class="n">REGULATOR_STATUS_NORMAL</span><span class="p">,</span>
	<span class="n">REGULATOR_STATUS_IDLE</span><span class="p">,</span>
	<span class="n">REGULATOR_STATUS_STANDBY</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct regulator_ops - regulator operations.</span>
<span class="cm"> *</span>
<span class="cm"> * @enable: Configure the regulator as enabled.</span>
<span class="cm"> * @disable: Configure the regulator as disabled.</span>
<span class="cm"> * @is_enabled: Return 1 if the regulator is enabled, 0 if not.</span>
<span class="cm"> *		May also return negative errno.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_voltage: Set the voltage for the regulator within the range specified.</span>
<span class="cm"> *               The driver should select the voltage closest to min_uV.</span>
<span class="cm"> * @set_voltage_sel: Set the voltage for the regulator using the specified</span>
<span class="cm"> *                   selector.</span>
<span class="cm"> * @map_voltage: Convert a voltage into a selector</span>
<span class="cm"> * @get_voltage: Return the currently configured voltage for the regulator.</span>
<span class="cm"> * @get_voltage_sel: Return the currently configured voltage selector for the</span>
<span class="cm"> *                   regulator.</span>
<span class="cm"> * @list_voltage: Return one of the supported voltages, in microvolts; zero</span>
<span class="cm"> *	if the selector indicates a voltage that is unusable on this system;</span>
<span class="cm"> *	or negative errno.  Selectors range from zero to one less than</span>
<span class="cm"> *	regulator_desc.n_voltages.  Voltages may be reported in any order.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_current_limit: Configure a limit for a current-limited regulator.</span>
<span class="cm"> * @get_current_limit: Get the configured limit for a current-limited regulator.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_mode: Set the configured operating mode for the regulator.</span>
<span class="cm"> * @get_mode: Get the configured operating mode for the regulator.</span>
<span class="cm"> * @get_status: Return actual (not as-configured) status of regulator, as a</span>
<span class="cm"> *	REGULATOR_STATUS value (or negative errno)</span>
<span class="cm"> * @get_optimum_mode: Get the most efficient operating mode for the regulator</span>
<span class="cm"> *                    when running with the specified parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * @enable_time: Time taken for the regulator voltage output voltage to</span>
<span class="cm"> *               stabilise after being enabled, in microseconds.</span>
<span class="cm"> * @set_voltage_time_sel: Time taken for the regulator voltage output voltage</span>
<span class="cm"> *               to stabilise after being set to a new value, in microseconds.</span>
<span class="cm"> *               The function provides the from and to voltage selector, the</span>
<span class="cm"> *               function should return the worst case.</span>
<span class="cm"> *</span>
<span class="cm"> * @set_suspend_voltage: Set the voltage for the regulator when the system</span>
<span class="cm"> *                       is suspended.</span>
<span class="cm"> * @set_suspend_enable: Mark the regulator as enabled when the system is</span>
<span class="cm"> *                      suspended.</span>
<span class="cm"> * @set_suspend_disable: Mark the regulator as disabled when the system is</span>
<span class="cm"> *                       suspended.</span>
<span class="cm"> * @set_suspend_mode: Set the operating mode for the regulator when the</span>
<span class="cm"> *                    system is suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * This struct describes regulator operations which can be implemented by</span>
<span class="cm"> * regulator chip drivers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">regulator_ops</span> <span class="p">{</span>

	<span class="cm">/* enumerate supported voltages */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">list_voltage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">selector</span><span class="p">);</span>

	<span class="cm">/* get/set regulator voltage */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_voltage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_uV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_uV</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="o">*</span><span class="n">selector</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">map_voltage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_uV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_uV</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_voltage_sel</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">selector</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_voltage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_voltage_sel</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* get/set regulator current  */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_current_limit</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">min_uA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_uA</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_current_limit</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* enable/disable regulator */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">disable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">is_enabled</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* get/set regulator operating mode (defined in consumer.h) */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_mode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_mode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Time taken to enable or set voltage on the regulator */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_time</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_voltage_time_sel</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_selector</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_selector</span><span class="p">);</span>

	<span class="cm">/* report regulator status ... most other accessors report</span>
<span class="cm">	 * control inputs, this reports results of combining inputs</span>
<span class="cm">	 * from Linux (and other sources) with the actual load.</span>
<span class="cm">	 * returns REGULATOR_STATUS_* or negative errno.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* get most efficient regulator operating mode for load */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_optimum_mode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">input_uV</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">output_uV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_uA</span><span class="p">);</span>

	<span class="cm">/* the operations below are for configuration of regulator state when</span>
<span class="cm">	 * its parent PMIC enters a global STANDBY/HIBERNATE state */</span>

	<span class="cm">/* set regulator suspend voltage */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_suspend_voltage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uV</span><span class="p">);</span>

	<span class="cm">/* enable/disable regulator in suspend state */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_suspend_enable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_suspend_disable</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* set regulator suspend operating mode (defined in consumer.h) */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_suspend_mode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Regulators can either control voltage or current.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">regulator_type</span> <span class="p">{</span>
	<span class="n">REGULATOR_VOLTAGE</span><span class="p">,</span>
	<span class="n">REGULATOR_CURRENT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct regulator_desc - Static regulator descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Each regulator registered with the core is described with a</span>
<span class="cm"> * structure of this type and a struct regulator_config.  This</span>
<span class="cm"> * structure contains the non-varying parts of the regulator</span>
<span class="cm"> * description.</span>
<span class="cm"> *</span>
<span class="cm"> * @name: Identifying name for the regulator.</span>
<span class="cm"> * @supply_name: Identifying the regulator supply</span>
<span class="cm"> * @id: Numerical identifier for the regulator.</span>
<span class="cm"> * @ops: Regulator operations table.</span>
<span class="cm"> * @irq: Interrupt number for the regulator.</span>
<span class="cm"> * @type: Indicates if the regulator is a voltage or current regulator.</span>
<span class="cm"> * @owner: Module providing the regulator, used for refcounting.</span>
<span class="cm"> *</span>
<span class="cm"> * @n_voltages: Number of selectors available for ops.list_voltage().</span>
<span class="cm"> *</span>
<span class="cm"> * @min_uV: Voltage given by the lowest selector (if linear mapping)</span>
<span class="cm"> * @uV_step: Voltage increase with each selector (if linear mapping)</span>
<span class="cm"> *</span>
<span class="cm"> * @vsel_reg: Register for selector when using regulator_regmap_X_voltage_</span>
<span class="cm"> * @vsel_mask: Mask for register bitfield used for selector</span>
<span class="cm"> * @enable_reg: Register for control when using regmap enable/disable ops</span>
<span class="cm"> * @enable_mask: Mask for control when using regmap enable/disable ops</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">regulator_desc</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">supply_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_voltages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulator_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">regulator_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_uV</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uV_step</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vsel_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vsel_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enable_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enable_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct regulator_config - Dynamic regulator descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Each regulator registered with the core is described with a</span>
<span class="cm"> * structure of this type and a struct regulator_desc.  This structure</span>
<span class="cm"> * contains the runtime variable parts of the regulator description.</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: struct device for the regulator</span>
<span class="cm"> * @init_data: platform provided init data, passed through by driver</span>
<span class="cm"> * @driver_data: private regulator data</span>
<span class="cm"> * @of_node: OpenFirmware node to parse for device tree bindings (may be</span>
<span class="cm"> *           NULL).</span>
<span class="cm"> * @regmap: regmap to use for core regmap helpers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">regulator_config</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">regulator_init_data</span> <span class="o">*</span><span class="n">init_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">regmap</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct regulator_dev</span>
<span class="cm"> *</span>
<span class="cm"> * Voltage / Current regulator class device. One for each</span>
<span class="cm"> * regulator.</span>
<span class="cm"> *</span>
<span class="cm"> * This should *not* be used directly by anything except the regulator</span>
<span class="cm"> * core and notification injection (which should take the mutex and do</span>
<span class="cm"> * no other direct access).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">regulator_dev</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">regulator_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exclusive</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">use_count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">open_count</span><span class="p">;</span>

	<span class="cm">/* lists we belong to */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span> <span class="cm">/* list of all regulators */</span>

	<span class="cm">/* lists we own */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">consumer_list</span><span class="p">;</span> <span class="cm">/* consumers we supply */</span>

	<span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="n">notifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span> <span class="cm">/* consumer lock */</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulation_constraints</span> <span class="o">*</span><span class="n">constraints</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulator</span> <span class="o">*</span><span class="n">supply</span><span class="p">;</span>	<span class="cm">/* for tree */</span>
	<span class="k">struct</span> <span class="n">regmap</span> <span class="o">*</span><span class="n">regmap</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">disable_work</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">deferred_disables</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">reg_data</span><span class="p">;</span>		<span class="cm">/* regulator_dev data */</span>

	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span>
<span class="n">regulator_register</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">regulator_desc</span> <span class="o">*</span><span class="n">regulator_desc</span><span class="p">,</span>
		   <span class="k">const</span> <span class="k">struct</span> <span class="n">regulator_config</span> <span class="o">*</span><span class="n">config</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">regulator_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">regulator_notifier_call_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">rdev_get_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">rdev_get_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rdev_get_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">regulator_mode_to_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">regulator_list_voltage_linear</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">selector</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regulator_map_voltage_linear</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">min_uV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_uV</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regulator_map_voltage_iterate</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">min_uV</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_uV</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regulator_get_voltage_sel_regmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regulator_set_voltage_sel_regmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">sel</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regulator_is_enabled_regmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regulator_enable_regmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">regulator_disable_regmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_dev</span> <span class="o">*</span><span class="n">rdev</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">regulator_get_init_drvdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">regulator_init_data</span> <span class="o">*</span><span class="n">reg_init_data</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
