<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › rfkill.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rfkill.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef __RFKILL_H</span>
<span class="cp">#define __RFKILL_H</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2006 - 2007 Ivo van Doorn</span>
<span class="cm"> * Copyright (C) 2007 Dmitry Torokhov</span>
<span class="cm"> * Copyright 2009 Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Permission to use, copy, modify, and/or distribute this software for any</span>
<span class="cm"> * purpose with or without fee is hereby granted, provided that the above</span>
<span class="cm"> * copyright notice and this permission notice appear in all copies.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span>
<span class="cm"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span>
<span class="cm"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span>
<span class="cm"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span>
<span class="cm"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cm">/* define userspace visible states */</span>
<span class="cp">#define RFKILL_STATE_SOFT_BLOCKED	0</span>
<span class="cp">#define RFKILL_STATE_UNBLOCKED		1</span>
<span class="cp">#define RFKILL_STATE_HARD_BLOCKED	2</span>

<span class="cm">/**</span>
<span class="cm"> * enum rfkill_type - type of rfkill switch.</span>
<span class="cm"> *</span>
<span class="cm"> * @RFKILL_TYPE_ALL: toggles all switches (requests only - not a switch type)</span>
<span class="cm"> * @RFKILL_TYPE_WLAN: switch is on a 802.11 wireless network device.</span>
<span class="cm"> * @RFKILL_TYPE_BLUETOOTH: switch is on a bluetooth device.</span>
<span class="cm"> * @RFKILL_TYPE_UWB: switch is on a ultra wideband device.</span>
<span class="cm"> * @RFKILL_TYPE_WIMAX: switch is on a WiMAX device.</span>
<span class="cm"> * @RFKILL_TYPE_WWAN: switch is on a wireless WAN device.</span>
<span class="cm"> * @RFKILL_TYPE_GPS: switch is on a GPS device.</span>
<span class="cm"> * @RFKILL_TYPE_FM: switch is on a FM radio device.</span>
<span class="cm"> * @NUM_RFKILL_TYPES: number of defined rfkill types</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rfkill_type</span> <span class="p">{</span>
	<span class="n">RFKILL_TYPE_ALL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RFKILL_TYPE_WLAN</span><span class="p">,</span>
	<span class="n">RFKILL_TYPE_BLUETOOTH</span><span class="p">,</span>
	<span class="n">RFKILL_TYPE_UWB</span><span class="p">,</span>
	<span class="n">RFKILL_TYPE_WIMAX</span><span class="p">,</span>
	<span class="n">RFKILL_TYPE_WWAN</span><span class="p">,</span>
	<span class="n">RFKILL_TYPE_GPS</span><span class="p">,</span>
	<span class="n">RFKILL_TYPE_FM</span><span class="p">,</span>
	<span class="n">NUM_RFKILL_TYPES</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum rfkill_operation - operation types</span>
<span class="cm"> * @RFKILL_OP_ADD: a device was added</span>
<span class="cm"> * @RFKILL_OP_DEL: a device was removed</span>
<span class="cm"> * @RFKILL_OP_CHANGE: a device&#39;s state changed -- userspace changes one device</span>
<span class="cm"> * @RFKILL_OP_CHANGE_ALL: userspace changes all devices (of a type, or all)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rfkill_operation</span> <span class="p">{</span>
	<span class="n">RFKILL_OP_ADD</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RFKILL_OP_DEL</span><span class="p">,</span>
	<span class="n">RFKILL_OP_CHANGE</span><span class="p">,</span>
	<span class="n">RFKILL_OP_CHANGE_ALL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rfkill_event - events for userspace on /dev/rfkill</span>
<span class="cm"> * @idx: index of dev rfkill</span>
<span class="cm"> * @type: type of the rfkill struct</span>
<span class="cm"> * @op: operation code</span>
<span class="cm"> * @hard: hard state (0/1)</span>
<span class="cm"> * @soft: soft state (0/1)</span>
<span class="cm"> *</span>
<span class="cm"> * Structure used for userspace communication on /dev/rfkill,</span>
<span class="cm"> * used for events from the kernel and control to the kernel.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rfkill_event</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">type</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">op</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">soft</span><span class="p">,</span> <span class="n">hard</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * We are planning to be backward and forward compatible with changes</span>
<span class="cm"> * to the event struct, by adding new, optional, members at the end.</span>
<span class="cm"> * When reading an event (whether the kernel from userspace or vice</span>
<span class="cm"> * versa) we need to accept anything that&#39;s at least as large as the</span>
<span class="cm"> * version 1 event size, but might be able to accept other sizes in</span>
<span class="cm"> * the future.</span>
<span class="cm"> *</span>
<span class="cm"> * One exception is the kernel -- we already have two event sizes in</span>
<span class="cm"> * that we&#39;ve made the &#39;hard&#39; member optional since our only option</span>
<span class="cm"> * is to ignore it anyway.</span>
<span class="cm"> */</span>
<span class="cp">#define RFKILL_EVENT_SIZE_V1	8</span>

<span class="cm">/* ioctl for turning off rfkill-input (if present) */</span>
<span class="cp">#define RFKILL_IOC_MAGIC	&#39;R&#39;</span>
<span class="cp">#define RFKILL_IOC_NOINPUT	1</span>
<span class="cp">#define RFKILL_IOCTL_NOINPUT	_IO(RFKILL_IOC_MAGIC, RFKILL_IOC_NOINPUT)</span>

<span class="cm">/* and that&#39;s all userspace gets */</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cm">/* don&#39;t allow anyone to use these in the kernel */</span>
<span class="k">enum</span> <span class="n">rfkill_user_states</span> <span class="p">{</span>
	<span class="n">RFKILL_USER_STATE_SOFT_BLOCKED</span>	<span class="o">=</span> <span class="n">RFKILL_STATE_SOFT_BLOCKED</span><span class="p">,</span>
	<span class="n">RFKILL_USER_STATE_UNBLOCKED</span>	<span class="o">=</span> <span class="n">RFKILL_STATE_UNBLOCKED</span><span class="p">,</span>
	<span class="n">RFKILL_USER_STATE_HARD_BLOCKED</span>	<span class="o">=</span> <span class="n">RFKILL_STATE_HARD_BLOCKED</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#undef RFKILL_STATE_SOFT_BLOCKED</span>
<span class="cp">#undef RFKILL_STATE_UNBLOCKED</span>
<span class="cp">#undef RFKILL_STATE_HARD_BLOCKED</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/leds.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>

<span class="k">struct</span> <span class="n">device</span><span class="p">;</span>
<span class="cm">/* this is opaque */</span>
<span class="k">struct</span> <span class="n">rfkill</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct rfkill_ops - rfkill driver methods</span>
<span class="cm"> *</span>
<span class="cm"> * @poll: poll the rfkill block state(s) -- only assign this method</span>
<span class="cm"> *	when you need polling. When called, simply call one of the</span>
<span class="cm"> *	rfkill_set{,_hw,_sw}_state family of functions. If the hw</span>
<span class="cm"> *	is getting unblocked you need to take into account the return</span>
<span class="cm"> *	value of those functions to make sure the software block is</span>
<span class="cm"> *	properly used.</span>
<span class="cm"> * @query: query the rfkill block state(s) and call exactly one of the</span>
<span class="cm"> *	rfkill_set{,_hw,_sw}_state family of functions. Assign this</span>
<span class="cm"> *	method if input events can cause hardware state changes to make</span>
<span class="cm"> *	the rfkill core query your driver before setting a requested</span>
<span class="cm"> *	block.</span>
<span class="cm"> * @set_block: turn the transmitter on (blocked == false) or off</span>
<span class="cm"> *	(blocked == true) -- ignore and return 0 when hard blocked.</span>
<span class="cm"> *	This callback must be assigned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rfkill_ops</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">query</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_block</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)</span>
<span class="cm">/**</span>
<span class="cm"> * rfkill_alloc - allocate rfkill structure</span>
<span class="cm"> * @name: name of the struct -- the string is not copied internally</span>
<span class="cm"> * @parent: device that has rf switch on it</span>
<span class="cm"> * @type: type of the switch (RFKILL_TYPE_*)</span>
<span class="cm"> * @ops: rfkill methods</span>
<span class="cm"> * @ops_data: data passed to each method</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called by the transmitter driver to allocate an</span>
<span class="cm"> * rfkill structure. Returns %NULL on failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span> <span class="n">__must_check</span> <span class="n">rfkill_alloc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">type</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">rfkill_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">ops_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_register - Register a rfkill structure.</span>
<span class="cm"> * @rfkill: rfkill structure to be registered</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called by the transmitter driver to register</span>
<span class="cm"> * the rfkill structure. Before calling this function the driver needs</span>
<span class="cm"> * to be ready to service method calls from rfkill.</span>
<span class="cm"> *</span>
<span class="cm"> * If rfkill_init_sw_state() is not called before registration,</span>
<span class="cm"> * set_block() will be called to initialize the software blocked state</span>
<span class="cm"> * to a default value.</span>
<span class="cm"> *</span>
<span class="cm"> * If the hardware blocked state is not set before registration,</span>
<span class="cm"> * it is assumed to be unblocked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__must_check</span> <span class="n">rfkill_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_pause_polling(struct rfkill *rfkill)</span>
<span class="cm"> *</span>
<span class="cm"> * Pause polling -- say transmitter is off for other reasons.</span>
<span class="cm"> * NOTE: not necessary for suspend/resume -- in that case the</span>
<span class="cm"> * core stops polling anyway</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rfkill_pause_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_resume_polling(struct rfkill *rfkill)</span>
<span class="cm"> *</span>
<span class="cm"> * Pause polling -- say transmitter is off for other reasons.</span>
<span class="cm"> * NOTE: not necessary for suspend/resume -- in that case the</span>
<span class="cm"> * core stops polling anyway</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rfkill_resume_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * rfkill_unregister - Unregister a rfkill structure.</span>
<span class="cm"> * @rfkill: rfkill structure to be unregistered</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called by the network driver during device</span>
<span class="cm"> * teardown to destroy rfkill structure. Until it returns, the driver</span>
<span class="cm"> * needs to be able to service method calls.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rfkill_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_destroy - free rfkill structure</span>
<span class="cm"> * @rfkill: rfkill structure to be destroyed</span>
<span class="cm"> *</span>
<span class="cm"> * Destroys the rfkill structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rfkill_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_set_hw_state - Set the internal rfkill hardware block state</span>
<span class="cm"> * @rfkill: pointer to the rfkill class to modify.</span>
<span class="cm"> * @state: the current hardware block state to set</span>
<span class="cm"> *</span>
<span class="cm"> * rfkill drivers that get events when the hard-blocked state changes</span>
<span class="cm"> * use this function to notify the rfkill core (and through that also</span>
<span class="cm"> * userspace) of the current state.  They should also use this after</span>
<span class="cm"> * resume if the state could have changed.</span>
<span class="cm"> *</span>
<span class="cm"> * You need not (but may) call this function if poll_state is assigned.</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be called in any context, even from within rfkill</span>
<span class="cm"> * callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns the combined block state (true if transmitter</span>
<span class="cm"> * should be blocked) so that drivers need not keep track of the soft</span>
<span class="cm"> * block state -- which they might not be able to.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">rfkill_set_hw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_set_sw_state - Set the internal rfkill software block state</span>
<span class="cm"> * @rfkill: pointer to the rfkill class to modify.</span>
<span class="cm"> * @state: the current software block state to set</span>
<span class="cm"> *</span>
<span class="cm"> * rfkill drivers that get events when the soft-blocked state changes</span>
<span class="cm"> * (yes, some platforms directly act on input but allow changing again)</span>
<span class="cm"> * use this function to notify the rfkill core (and through that also</span>
<span class="cm"> * userspace) of the current state.</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers should also call this function after resume if the state has</span>
<span class="cm"> * been changed by the user.  This only makes sense for &quot;persistent&quot;</span>
<span class="cm"> * devices (see rfkill_init_sw_state()).</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be called in any context, even from within rfkill</span>
<span class="cm"> * callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns the combined block state (true if transmitter</span>
<span class="cm"> * should be blocked).</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">rfkill_set_sw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_init_sw_state - Initialize persistent software block state</span>
<span class="cm"> * @rfkill: pointer to the rfkill class to modify.</span>
<span class="cm"> * @state: the current software block state to set</span>
<span class="cm"> *</span>
<span class="cm"> * rfkill drivers that preserve their software block state over power off</span>
<span class="cm"> * use this function to notify the rfkill core (and through that also</span>
<span class="cm"> * userspace) of their initial state.  It should only be used before</span>
<span class="cm"> * registration.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition, it marks the device as &quot;persistent&quot;, an attribute which</span>
<span class="cm"> * can be read by userspace.  Persistent devices are expected to preserve</span>
<span class="cm"> * their own state when suspended.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rfkill_init_sw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_set_states - Set the internal rfkill block states</span>
<span class="cm"> * @rfkill: pointer to the rfkill class to modify.</span>
<span class="cm"> * @sw: the current software block state to set</span>
<span class="cm"> * @hw: the current hardware block state to set</span>
<span class="cm"> *</span>
<span class="cm"> * This function can be called in any context, even from within rfkill</span>
<span class="cm"> * callbacks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">rfkill_set_states</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_blocked - query rfkill block</span>
<span class="cm"> *</span>
<span class="cm"> * @rfkill: rfkill struct to query</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">rfkill_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* !RFKILL */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span> <span class="n">__must_check</span>
<span class="nf">rfkill_alloc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
	     <span class="k">const</span> <span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">type</span><span class="p">,</span>
	     <span class="k">const</span> <span class="k">struct</span> <span class="n">rfkill_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
	     <span class="kt">void</span> <span class="o">*</span><span class="n">ops_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">rfkill_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span> <span class="o">==</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rfkill_pause_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rfkill_resume_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rfkill_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rfkill_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rfkill_set_hw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocked</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rfkill_set_sw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocked</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rfkill_init_sw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rfkill_set_states</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">rfkill_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* RFKILL || RFKILL_MODULE */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* RFKILL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
