<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › soundcard.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>soundcard.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef SOUNDCARD_H</span>
<span class="cp">#define SOUNDCARD_H</span>
<span class="cm">/*</span>
<span class="cm"> * Copyright by Hannu Savolainen 1993-1997</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are</span>
<span class="cm"> * met: 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> * notice, this list of conditions and the following disclaimer. 2.</span>
<span class="cm"> * Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="cm"> * this list of conditions and the following disclaimer in the documentation</span>
<span class="cm"> * and/or other materials provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND ANY</span>
<span class="cm"> * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR</span>
<span class="cm"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="cm"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="cm"> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="cm"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
<span class="cm"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
<span class="cm"> * SUCH DAMAGE.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * OSS interface version. With versions earlier than 3.6 this value is</span>
<span class="cm"> * an integer with value less than 361. In versions 3.6 and later</span>
<span class="cm"> * it&#39;s a six digit hexadecimal value. For example value</span>
<span class="cm"> * of 0x030600 represents OSS version 3.6.0.</span>
<span class="cm"> * Use ioctl(fd, OSS_GETVERSION, &amp;int) to get the version number of</span>
<span class="cm"> * the currently active driver.</span>
<span class="cm"> */</span>
<span class="cp">#define SOUND_VERSION	0x030802</span>
<span class="cp">#define OPEN_SOUND_SYSTEM</span>

<span class="cm">/* In Linux we need to be prepared for cross compiling */</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>

<span class="cm">/* Endian macros. */</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#  include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#else</span>
<span class="cp">#  include &lt;endian.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	Supported card ID numbers (Should be somewhere else?)</span>
<span class="cm"> */</span>

<span class="cp">#define SNDCARD_ADLIB		1</span>
<span class="cp">#define SNDCARD_SB		2</span>
<span class="cp">#define SNDCARD_PAS		3</span>
<span class="cp">#define SNDCARD_GUS		4</span>
<span class="cp">#define SNDCARD_MPU401		5</span>
<span class="cp">#define SNDCARD_SB16		6</span>
<span class="cp">#define SNDCARD_SB16MIDI	7</span>
<span class="cp">#define SNDCARD_UART6850	8</span>
<span class="cp">#define SNDCARD_GUS16		9</span>
<span class="cp">#define SNDCARD_MSS		10</span>
<span class="cp">#define SNDCARD_PSS     	11</span>
<span class="cp">#define SNDCARD_SSCAPE		12</span>
<span class="cp">#define SNDCARD_PSS_MPU     	13</span>
<span class="cp">#define SNDCARD_PSS_MSS     	14</span>
<span class="cp">#define SNDCARD_SSCAPE_MSS	15</span>
<span class="cp">#define SNDCARD_TRXPRO		16</span>
<span class="cp">#define SNDCARD_TRXPRO_SB	17</span>
<span class="cp">#define SNDCARD_TRXPRO_MPU	18</span>
<span class="cp">#define SNDCARD_MAD16		19</span>
<span class="cp">#define SNDCARD_MAD16_MPU	20</span>
<span class="cp">#define SNDCARD_CS4232		21</span>
<span class="cp">#define SNDCARD_CS4232_MPU	22</span>
<span class="cp">#define SNDCARD_MAUI		23</span>
<span class="cp">#define SNDCARD_PSEUDO_MSS	24</span>
<span class="cp">#define SNDCARD_GUSPNP		25</span>
<span class="cp">#define SNDCARD_UART401		26</span>
<span class="cm">/* Sound card numbers 27 to N are reserved. Don&#39;t add more numbers here. */</span>

<span class="cm">/***********************************</span>
<span class="cm"> * IOCTL Commands for /dev/sequencer</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _SIOWR</span>
<span class="cp">#if defined(_IOWR) &amp;&amp; (defined(_AIX) || (!defined(sun) &amp;&amp; !defined(sparc) &amp;&amp; !defined(__sparc__) &amp;&amp; !defined(__INCioctlh) &amp;&amp; !defined(__Lynx__)))</span>
<span class="cm">/* Use already defined ioctl defines if they exist (except with Sun or Sparc) */</span>
<span class="cp">#define	SIOCPARM_MASK	IOCPARM_MASK</span>
<span class="cp">#define	SIOC_VOID	IOC_VOID</span>
<span class="cp">#define	SIOC_OUT	IOC_OUT</span>
<span class="cp">#define	SIOC_IN		IOC_IN</span>
<span class="cp">#define	SIOC_INOUT	IOC_INOUT</span>
<span class="cp">#define _SIOC_SIZE	_IOC_SIZE</span>
<span class="cp">#define _SIOC_DIR	_IOC_DIR</span>
<span class="cp">#define _SIOC_NONE	_IOC_NONE</span>
<span class="cp">#define _SIOC_READ	_IOC_READ</span>
<span class="cp">#define _SIOC_WRITE	_IOC_WRITE</span>
<span class="cp">#define	_SIO		_IO</span>
<span class="cp">#define	_SIOR		_IOR</span>
<span class="cp">#define	_SIOW		_IOW</span>
<span class="cp">#define	_SIOWR		_IOWR</span>
<span class="cp">#else</span>

<span class="cm">/* Ioctl&#39;s have the command encoded in the lower word,</span>
<span class="cm"> * and the size of any in or out parameters in the upper</span>
<span class="cm"> * word.  The high 2 bits of the upper word are used</span>
<span class="cm"> * to encode the in/out status of the parameter; for now</span>
<span class="cm"> * we restrict parameters to at most 8191 bytes.</span>
<span class="cm"> */</span>
<span class="cm">/* #define	SIOCTYPE		(0xff&lt;&lt;8) */</span>
<span class="cp">#define	SIOCPARM_MASK	0x1fff		</span><span class="cm">/* parameters must be &lt; 8192 bytes */</span><span class="cp"></span>
<span class="cp">#define	SIOC_VOID	0x00000000	</span><span class="cm">/* no parameters */</span><span class="cp"></span>
<span class="cp">#define	SIOC_OUT	0x20000000	</span><span class="cm">/* copy out parameters */</span><span class="cp"></span>
<span class="cp">#define	SIOC_IN		0x40000000	</span><span class="cm">/* copy in parameters */</span><span class="cp"></span>
<span class="cp">#define	SIOC_INOUT	(SIOC_IN|SIOC_OUT)</span>
<span class="cm">/* the 0x20000000 is so we can distinguish new ioctl&#39;s from old */</span>
<span class="cp">#define	_SIO(x,y)	((int)(SIOC_VOID|(x&lt;&lt;8)|y))</span>
<span class="cp">#define	_SIOR(x,y,t)	((int)(SIOC_OUT|((sizeof(t)&amp;SIOCPARM_MASK)&lt;&lt;16)|(x&lt;&lt;8)|y))</span>
<span class="cp">#define	_SIOW(x,y,t)	((int)(SIOC_IN|((sizeof(t)&amp;SIOCPARM_MASK)&lt;&lt;16)|(x&lt;&lt;8)|y))</span>
<span class="cm">/* this should be _SIORW, but stdio got there first */</span>
<span class="cp">#define	_SIOWR(x,y,t)	((int)(SIOC_INOUT|((sizeof(t)&amp;SIOCPARM_MASK)&lt;&lt;16)|(x&lt;&lt;8)|y))</span>
<span class="cp">#define _SIOC_SIZE(x)	((x&gt;&gt;16)&amp;SIOCPARM_MASK)	</span>
<span class="cp">#define _SIOC_DIR(x)	(x &amp; 0xf0000000)</span>
<span class="cp">#define _SIOC_NONE	SIOC_VOID</span>
<span class="cp">#define _SIOC_READ	SIOC_OUT</span>
<span class="cp">#define _SIOC_WRITE	SIOC_IN</span>
<span class="cp">#  endif </span><span class="cm">/* _IOWR */</span><span class="cp"></span>
<span class="cp">#endif  </span><span class="cm">/* !_SIOWR */</span><span class="cp"></span>

<span class="cp">#define SNDCTL_SEQ_RESET		_SIO  (&#39;Q&#39;, 0)</span>
<span class="cp">#define SNDCTL_SEQ_SYNC			_SIO  (&#39;Q&#39;, 1)</span>
<span class="cp">#define SNDCTL_SYNTH_INFO		_SIOWR(&#39;Q&#39;, 2, struct synth_info)</span>
<span class="cp">#define SNDCTL_SEQ_CTRLRATE		_SIOWR(&#39;Q&#39;, 3, int)	</span><span class="cm">/* Set/get timer resolution (HZ) */</span><span class="cp"></span>
<span class="cp">#define SNDCTL_SEQ_GETOUTCOUNT		_SIOR (&#39;Q&#39;, 4, int)</span>
<span class="cp">#define SNDCTL_SEQ_GETINCOUNT		_SIOR (&#39;Q&#39;, 5, int)</span>
<span class="cp">#define SNDCTL_SEQ_PERCMODE		_SIOW (&#39;Q&#39;, 6, int)</span>
<span class="cp">#define SNDCTL_FM_LOAD_INSTR		_SIOW (&#39;Q&#39;, 7, struct sbi_instrument)	</span><span class="cm">/* Obsolete. Don&#39;t use!!!!!! */</span><span class="cp"></span>
<span class="cp">#define SNDCTL_SEQ_TESTMIDI		_SIOW (&#39;Q&#39;, 8, int)</span>
<span class="cp">#define SNDCTL_SEQ_RESETSAMPLES		_SIOW (&#39;Q&#39;, 9, int)</span>
<span class="cp">#define SNDCTL_SEQ_NRSYNTHS		_SIOR (&#39;Q&#39;,10, int)</span>
<span class="cp">#define SNDCTL_SEQ_NRMIDIS		_SIOR (&#39;Q&#39;,11, int)</span>
<span class="cp">#define SNDCTL_MIDI_INFO		_SIOWR(&#39;Q&#39;,12, struct midi_info)</span>
<span class="cp">#define SNDCTL_SEQ_THRESHOLD		_SIOW (&#39;Q&#39;,13, int)</span>
<span class="cp">#define SNDCTL_SYNTH_MEMAVL		_SIOWR(&#39;Q&#39;,14, int)	</span><span class="cm">/* in=dev#, out=memsize */</span><span class="cp"></span>
<span class="cp">#define SNDCTL_FM_4OP_ENABLE		_SIOW (&#39;Q&#39;,15, int)	</span><span class="cm">/* in=dev# */</span><span class="cp"></span>
<span class="cp">#define SNDCTL_SEQ_PANIC		_SIO  (&#39;Q&#39;,17)</span>
<span class="cp">#define SNDCTL_SEQ_OUTOFBAND		_SIOW (&#39;Q&#39;,18, struct seq_event_rec)</span>
<span class="cp">#define SNDCTL_SEQ_GETTIME		_SIOR (&#39;Q&#39;,19, int)</span>
<span class="cp">#define SNDCTL_SYNTH_ID			_SIOWR(&#39;Q&#39;,20, struct synth_info)</span>
<span class="cp">#define SNDCTL_SYNTH_CONTROL		_SIOWR(&#39;Q&#39;,21, struct synth_control)</span>
<span class="cp">#define SNDCTL_SYNTH_REMOVESAMPLE	_SIOWR(&#39;Q&#39;,22, struct remove_sample)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">synth_control</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">devno</span><span class="p">;</span>	<span class="cm">/* Synthesizer # */</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">4000</span><span class="p">];</span> <span class="cm">/* Device spesific command/data record */</span>
<span class="p">}</span><span class="n">synth_control</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">remove_sample</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">devno</span><span class="p">;</span>	<span class="cm">/* Synthesizer # */</span>
	<span class="kt">int</span> <span class="n">bankno</span><span class="p">;</span>	<span class="cm">/* MIDI bank # (0=General MIDI) */</span>
	<span class="kt">int</span> <span class="n">instrno</span><span class="p">;</span>	<span class="cm">/* MIDI instrument number */</span>
<span class="p">}</span> <span class="n">remove_sample</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">seq_event_rec</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">arr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">seq_event_rec</span><span class="p">;</span>

<span class="cp">#define SNDCTL_TMR_TIMEBASE		_SIOWR(&#39;T&#39;, 1, int)</span>
<span class="cp">#define SNDCTL_TMR_START		_SIO  (&#39;T&#39;, 2)</span>
<span class="cp">#define SNDCTL_TMR_STOP			_SIO  (&#39;T&#39;, 3)</span>
<span class="cp">#define SNDCTL_TMR_CONTINUE		_SIO  (&#39;T&#39;, 4)</span>
<span class="cp">#define SNDCTL_TMR_TEMPO		_SIOWR(&#39;T&#39;, 5, int)</span>
<span class="cp">#define SNDCTL_TMR_SOURCE		_SIOWR(&#39;T&#39;, 6, int)</span>
<span class="cp">#	define TMR_INTERNAL		0x00000001</span>
<span class="cp">#	define TMR_EXTERNAL		0x00000002</span>
<span class="cp">#		define TMR_MODE_MIDI	0x00000010</span>
<span class="cp">#		define TMR_MODE_FSK	0x00000020</span>
<span class="cp">#		define TMR_MODE_CLS	0x00000040</span>
<span class="cp">#		define TMR_MODE_SMPTE	0x00000080</span>
<span class="cp">#define SNDCTL_TMR_METRONOME		_SIOW (&#39;T&#39;, 7, int)</span>
<span class="cp">#define SNDCTL_TMR_SELECT		_SIOW (&#39;T&#39;, 8, int)</span>

<span class="cm">/*</span>
<span class="cm"> * Some big endian/little endian handling macros</span>
<span class="cm"> */</span>

<span class="cp">#define _LINUX_PATCHKEY_H_INDIRECT</span>
<span class="cp">#include &lt;linux/patchkey.h&gt;</span>
<span class="cp">#undef _LINUX_PATCHKEY_H_INDIRECT</span>

<span class="cp">#if defined(__KERNEL__)</span>
<span class="cp">#  if defined(__BIG_ENDIAN)</span>
<span class="cp">#    define AFMT_S16_NE AFMT_S16_BE</span>
<span class="cp">#  elif defined(__LITTLE_ENDIAN)</span>
<span class="cp">#    define AFMT_S16_NE AFMT_S16_LE</span>
<span class="cp">#  else</span>
<span class="cp">#    error &quot;could not determine byte order&quot;</span>
<span class="cp">#  endif</span>
<span class="cp">#else</span>
<span class="cp"># if defined(__BYTE_ORDER)</span>
<span class="cp">#  if __BYTE_ORDER == __BIG_ENDIAN</span>
<span class="cp">#    define AFMT_S16_NE AFMT_S16_BE</span>
<span class="cp">#  elif __BYTE_ORDER == __LITTLE_ENDIAN</span>
<span class="cp">#    define AFMT_S16_NE AFMT_S16_LE</span>
<span class="cp">#  else</span>
<span class="cp">#    error &quot;could not determine byte order&quot;</span>
<span class="cp">#  endif</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *	Sample loading mechanism for internal synthesizers (/dev/sequencer)</span>
<span class="cm"> *	The following patch_info structure has been designed to support</span>
<span class="cm"> *	Gravis UltraSound. It tries to be universal format for uploading</span>
<span class="cm"> *	sample based patches but is probably too limited.</span>
<span class="cm"> *</span>
<span class="cm"> *      (PBD) As Hannu guessed, the GUS structure is too limited for </span>
<span class="cm"> *      the WaveFront, but this is the right place for a constant definition.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">patch_info</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">key</span><span class="p">;</span>		<span class="cm">/* Use WAVE_PATCH here */</span>
<span class="cp">#define WAVE_PATCH	   _PATCHKEY(0x04)</span>
<span class="cp">#define GUS_PATCH	   WAVE_PATCH</span>
<span class="cp">#define WAVEFRONT_PATCH    _PATCHKEY(0x06)</span>

		<span class="kt">short</span> <span class="n">device_no</span><span class="p">;</span>	<span class="cm">/* Synthesizer number */</span>
		<span class="kt">short</span> <span class="n">instr_no</span><span class="p">;</span>		<span class="cm">/* Midi pgm# */</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * The least significant byte has the same format than the GUS .PAT</span>
<span class="cm"> * files</span>
<span class="cm"> */</span>
<span class="cp">#define WAVE_16_BITS	0x01	</span><span class="cm">/* bit 0 = 8 or 16 bit wave data. */</span><span class="cp"></span>
<span class="cp">#define WAVE_UNSIGNED	0x02	</span><span class="cm">/* bit 1 = Signed - Unsigned data. */</span><span class="cp"></span>
<span class="cp">#define WAVE_LOOPING	0x04	</span><span class="cm">/* bit 2 = looping enabled-1. */</span><span class="cp"></span>
<span class="cp">#define WAVE_BIDIR_LOOP	0x08	</span><span class="cm">/* bit 3 = Set is bidirectional looping. */</span><span class="cp"></span>
<span class="cp">#define WAVE_LOOP_BACK	0x10	</span><span class="cm">/* bit 4 = Set is looping backward. */</span><span class="cp"></span>
<span class="cp">#define WAVE_SUSTAIN_ON	0x20	</span><span class="cm">/* bit 5 = Turn sustaining on. (Env. pts. 3)*/</span><span class="cp"></span>
<span class="cp">#define WAVE_ENVELOPES	0x40	</span><span class="cm">/* bit 6 = Enable envelopes - 1 */</span><span class="cp"></span>
<span class="cp">#define WAVE_FAST_RELEASE 0x80	</span><span class="cm">/* bit 7 = Shut off immediately after note off */</span><span class="cp"></span>
				<span class="cm">/* 	(use the env_rate/env_offs fields). */</span>
<span class="cm">/* Linux specific bits */</span>
<span class="cp">#define WAVE_VIBRATO	0x00010000	</span><span class="cm">/* The vibrato info is valid */</span><span class="cp"></span>
<span class="cp">#define WAVE_TREMOLO	0x00020000	</span><span class="cm">/* The tremolo info is valid */</span><span class="cp"></span>
<span class="cp">#define WAVE_SCALE	0x00040000	</span><span class="cm">/* The scaling info is valid */</span><span class="cp"></span>
<span class="cp">#define WAVE_FRACTIONS	0x00080000	</span><span class="cm">/* Fraction information is valid */</span><span class="cp"></span>
<span class="cm">/* Reserved bits */</span>
<span class="cp">#define WAVE_ROM	0x40000000	</span><span class="cm">/* For future use */</span><span class="cp"></span>
<span class="cp">#define WAVE_MULAW	0x20000000	</span><span class="cm">/* For future use */</span><span class="cp"></span>
<span class="cm">/* Other bits must be zeroed */</span>

		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>	<span class="cm">/* Size of the wave data in bytes */</span>
		<span class="kt">int</span> <span class="n">loop_start</span><span class="p">,</span> <span class="n">loop_end</span><span class="p">;</span> <span class="cm">/* Byte offsets from the beginning */</span>

<span class="cm">/* </span>
<span class="cm"> * The base_freq and base_note fields are used when computing the</span>
<span class="cm"> * playback speed for a note. The base_note defines the tone frequency</span>
<span class="cm"> * which is heard if the sample is played using the base_freq as the</span>
<span class="cm"> * playback speed.</span>
<span class="cm"> *</span>
<span class="cm"> * The low_note and high_note fields define the minimum and maximum note</span>
<span class="cm"> * frequencies for which this sample is valid. It is possible to define</span>
<span class="cm"> * more than one samples for an instrument number at the same time. The</span>
<span class="cm"> * low_note and high_note fields are used to select the most suitable one.</span>
<span class="cm"> *</span>
<span class="cm"> * The fields base_note, high_note and low_note should contain</span>
<span class="cm"> * the note frequency multiplied by 1000. For example value for the</span>
<span class="cm"> * middle A is 440*1000.</span>
<span class="cm"> */</span>

		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base_freq</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base_note</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">high_note</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">low_note</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">panning</span><span class="p">;</span>	<span class="cm">/* -128=left, 127=right */</span>
		<span class="kt">int</span> <span class="n">detuning</span><span class="p">;</span>

<span class="cm">/*	New fields introduced in version 1.99.5	*/</span>

       <span class="cm">/* Envelope. Enabled by mode bit WAVE_ENVELOPES	*/</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">env_rate</span><span class="p">[</span> <span class="mi">6</span> <span class="p">];</span>	 <span class="cm">/* GUS HW ramping rate */</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">env_offset</span><span class="p">[</span> <span class="mi">6</span> <span class="p">];</span> <span class="cm">/* 255 == 100% */</span>

	<span class="cm">/* </span>
<span class="cm">	 * The tremolo, vibrato and scale info are not supported yet.</span>
<span class="cm">	 * Enable by setting the mode bits WAVE_TREMOLO, WAVE_VIBRATO or</span>
<span class="cm">	 * WAVE_SCALE</span>
<span class="cm">	 */</span>

		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tremolo_sweep</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tremolo_rate</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">tremolo_depth</span><span class="p">;</span>
	
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">vibrato_sweep</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">vibrato_rate</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">vibrato_depth</span><span class="p">;</span>

		<span class="kt">int</span>		<span class="n">scale_frequency</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">scale_factor</span><span class="p">;</span>		<span class="cm">/* from 0 to 2048 or 0 to 2 */</span>
	
	        <span class="kt">int</span>		<span class="n">volume</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">fractions</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">reserved1</span><span class="p">;</span>
	        <span class="kt">int</span>		<span class="n">spare</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* The waveform data starts here */</span>
	<span class="p">};</span>

<span class="k">struct</span> <span class="n">sysex_info</span> <span class="p">{</span>
		<span class="kt">short</span> <span class="n">key</span><span class="p">;</span>		<span class="cm">/* Use SYSEX_PATCH or MAUI_PATCH here */</span>
<span class="cp">#define SYSEX_PATCH	_PATCHKEY(0x05)</span>
<span class="cp">#define MAUI_PATCH	_PATCHKEY(0x06)</span>
		<span class="kt">short</span> <span class="n">device_no</span><span class="p">;</span>	<span class="cm">/* Synthesizer number */</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>	<span class="cm">/* Size of the sysex data in bytes */</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* Sysex data starts here */</span>
	<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * /dev/sequencer input events.</span>
<span class="cm"> *</span>
<span class="cm"> * The data written to the /dev/sequencer is a stream of events. Events</span>
<span class="cm"> * are records of 4 or 8 bytes. The first byte defines the size. </span>
<span class="cm"> * Any number of events can be written with a write call. There</span>
<span class="cm"> * is a set of macros for sending these events. Use these macros if you</span>
<span class="cm"> * want to maximize portability of your program.</span>
<span class="cm"> *</span>
<span class="cm"> * Events SEQ_WAIT, SEQ_MIDIPUTC and SEQ_ECHO. Are also input events.</span>
<span class="cm"> * (All input events are currently 4 bytes long. Be prepared to support</span>
<span class="cm"> * 8 byte events also. If you receive any event having first byte &gt;= 128,</span>
<span class="cm"> * it&#39;s a 8 byte event.</span>
<span class="cm"> *</span>
<span class="cm"> * The events are documented at the end of this file.</span>
<span class="cm"> *</span>
<span class="cm"> * Normal events (4 bytes)</span>
<span class="cm"> * There is also a 8 byte version of most of the 4 byte events. The</span>
<span class="cm"> * 8 byte one is recommended.</span>
<span class="cm"> */</span>
<span class="cp">#define SEQ_NOTEOFF		0</span>
<span class="cp">#define SEQ_FMNOTEOFF		SEQ_NOTEOFF	</span><span class="cm">/* Just old name */</span><span class="cp"></span>
<span class="cp">#define SEQ_NOTEON		1</span>
<span class="cp">#define	SEQ_FMNOTEON		SEQ_NOTEON</span>
<span class="cp">#define SEQ_WAIT		TMR_WAIT_ABS</span>
<span class="cp">#define SEQ_PGMCHANGE		3</span>
<span class="cp">#define SEQ_FMPGMCHANGE		SEQ_PGMCHANGE</span>
<span class="cp">#define SEQ_SYNCTIMER		TMR_START</span>
<span class="cp">#define SEQ_MIDIPUTC		5</span>
<span class="cp">#define SEQ_DRUMON		6	</span><span class="cm">/*** OBSOLETE ***/</span><span class="cp"></span>
<span class="cp">#define SEQ_DRUMOFF		7	</span><span class="cm">/*** OBSOLETE ***/</span><span class="cp"></span>
<span class="cp">#define SEQ_ECHO		TMR_ECHO	</span><span class="cm">/* For synching programs with output */</span><span class="cp"></span>
<span class="cp">#define SEQ_AFTERTOUCH		9</span>
<span class="cp">#define SEQ_CONTROLLER		10</span>

<span class="cm">/*******************************************</span>
<span class="cm"> *	Midi controller numbers</span>
<span class="cm"> *******************************************</span>
<span class="cm"> * Controllers 0 to 31 (0x00 to 0x1f) and</span>
<span class="cm"> * 32 to 63 (0x20 to 0x3f) are continuous</span>
<span class="cm"> * controllers.</span>
<span class="cm"> * In the MIDI 1.0 these controllers are sent using</span>
<span class="cm"> * two messages. Controller numbers 0 to 31 are used</span>
<span class="cm"> * to send the MSB and the controller numbers 32 to 63</span>
<span class="cm"> * are for the LSB. Note that just 7 bits are used in MIDI bytes.</span>
<span class="cm"> */</span>

<span class="cp">#define	   CTL_BANK_SELECT		0x00</span>
<span class="cp">#define	   CTL_MODWHEEL			0x01</span>
<span class="cp">#define    CTL_BREATH			0x02</span>
<span class="cm">/*		undefined		0x03 */</span>
<span class="cp">#define    CTL_FOOT			0x04</span>
<span class="cp">#define    CTL_PORTAMENTO_TIME		0x05</span>
<span class="cp">#define    CTL_DATA_ENTRY		0x06</span>
<span class="cp">#define    CTL_MAIN_VOLUME		0x07</span>
<span class="cp">#define    CTL_BALANCE			0x08</span>
<span class="cm">/*		undefined		0x09 */</span>
<span class="cp">#define    CTL_PAN			0x0a</span>
<span class="cp">#define    CTL_EXPRESSION		0x0b</span>
<span class="cm">/*		undefined		0x0c */</span>
<span class="cm">/*		undefined		0x0d */</span>
<span class="cm">/*		undefined		0x0e */</span>
<span class="cm">/*		undefined		0x0f */</span>
<span class="cp">#define    CTL_GENERAL_PURPOSE1	0x10</span>
<span class="cp">#define    CTL_GENERAL_PURPOSE2	0x11</span>
<span class="cp">#define    CTL_GENERAL_PURPOSE3	0x12</span>
<span class="cp">#define    CTL_GENERAL_PURPOSE4	0x13</span>
<span class="cm">/*		undefined		0x14 - 0x1f */</span>

<span class="cm">/*		undefined		0x20 */</span>
<span class="cm">/* The controller numbers 0x21 to 0x3f are reserved for the */</span>
<span class="cm">/* least significant bytes of the controllers 0x00 to 0x1f. */</span>
<span class="cm">/* These controllers are not recognised by the driver. */</span>

<span class="cm">/* Controllers 64 to 69 (0x40 to 0x45) are on/off switches. */</span>
<span class="cm">/* 0=OFF and 127=ON (intermediate values are possible) */</span>
<span class="cp">#define    CTL_DAMPER_PEDAL		0x40</span>
<span class="cp">#define    CTL_SUSTAIN			0x40	</span><span class="cm">/* Alias */</span><span class="cp"></span>
<span class="cp">#define    CTL_HOLD			0x40	</span><span class="cm">/* Alias */</span><span class="cp"></span>
<span class="cp">#define    CTL_PORTAMENTO		0x41</span>
<span class="cp">#define    CTL_SOSTENUTO		0x42</span>
<span class="cp">#define    CTL_SOFT_PEDAL		0x43</span>
<span class="cm">/*		undefined		0x44 */</span>
<span class="cp">#define    CTL_HOLD2			0x45</span>
<span class="cm">/*		undefined		0x46 - 0x4f */</span>

<span class="cp">#define    CTL_GENERAL_PURPOSE5	0x50</span>
<span class="cp">#define    CTL_GENERAL_PURPOSE6	0x51</span>
<span class="cp">#define    CTL_GENERAL_PURPOSE7	0x52</span>
<span class="cp">#define    CTL_GENERAL_PURPOSE8	0x53</span>
<span class="cm">/*		undefined		0x54 - 0x5a */</span>
<span class="cp">#define    CTL_EXT_EFF_DEPTH		0x5b</span>
<span class="cp">#define    CTL_TREMOLO_DEPTH		0x5c</span>
<span class="cp">#define    CTL_CHORUS_DEPTH		0x5d</span>
<span class="cp">#define    CTL_DETUNE_DEPTH		0x5e</span>
<span class="cp">#define    CTL_CELESTE_DEPTH		0x5e	</span><span class="cm">/* Alias for the above one */</span><span class="cp"></span>
<span class="cp">#define    CTL_PHASER_DEPTH		0x5f</span>
<span class="cp">#define    CTL_DATA_INCREMENT		0x60</span>
<span class="cp">#define    CTL_DATA_DECREMENT		0x61</span>
<span class="cp">#define    CTL_NONREG_PARM_NUM_LSB	0x62</span>
<span class="cp">#define    CTL_NONREG_PARM_NUM_MSB	0x63</span>
<span class="cp">#define    CTL_REGIST_PARM_NUM_LSB	0x64</span>
<span class="cp">#define    CTL_REGIST_PARM_NUM_MSB	0x65</span>
<span class="cm">/*		undefined		0x66 - 0x78 */</span>
<span class="cm">/*		reserved		0x79 - 0x7f */</span>

<span class="cm">/* Pseudo controllers (not midi compatible) */</span>
<span class="cp">#define    CTRL_PITCH_BENDER		255</span>
<span class="cp">#define    CTRL_PITCH_BENDER_RANGE	254</span>
<span class="cp">#define    CTRL_EXPRESSION		253	</span><span class="cm">/* Obsolete */</span><span class="cp"></span>
<span class="cp">#define    CTRL_MAIN_VOLUME		252	</span><span class="cm">/* Obsolete */</span><span class="cp"></span>
<span class="cp">#define SEQ_BALANCE		11</span>
<span class="cp">#define SEQ_VOLMODE             12</span>

<span class="cm">/*</span>
<span class="cm"> * Volume mode decides how volumes are used</span>
<span class="cm"> */</span>

<span class="cp">#define VOL_METHOD_ADAGIO	1</span>
<span class="cp">#define VOL_METHOD_LINEAR	2</span>

<span class="cm">/*</span>
<span class="cm"> * Note! SEQ_WAIT, SEQ_MIDIPUTC and SEQ_ECHO are used also as</span>
<span class="cm"> *	 input events.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Event codes 0xf0 to 0xfc are reserved for future extensions.</span>
<span class="cm"> */</span>

<span class="cp">#define SEQ_FULLSIZE		0xfd	</span><span class="cm">/* Long events */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> *	SEQ_FULLSIZE events are used for loading patches/samples to the</span>
<span class="cm"> *	synthesizer devices. These events are passed directly to the driver</span>
<span class="cm"> *	of the associated synthesizer device. There is no limit to the size</span>
<span class="cm"> *	of the extended events. These events are not queued but executed</span>
<span class="cm"> *	immediately when the write() is called (execution can take several</span>
<span class="cm"> *	seconds of time). </span>
<span class="cm"> *</span>
<span class="cm"> *	When a SEQ_FULLSIZE message is written to the device, it must</span>
<span class="cm"> *	be written using exactly one write() call. Other events cannot</span>
<span class="cm"> *	be mixed to the same write.</span>
<span class="cm"> *	</span>
<span class="cm"> *	For FM synths (YM3812/OPL3) use struct sbi_instrument and write it to the </span>
<span class="cm"> *	/dev/sequencer. Don&#39;t write other data together with the instrument structure</span>
<span class="cm"> *	Set the key field of the structure to FM_PATCH. The device field is used to</span>
<span class="cm"> *	route the patch to the corresponding device.</span>
<span class="cm"> *</span>
<span class="cm"> *	For wave table use struct patch_info. Initialize the key field</span>
<span class="cm"> *      to WAVE_PATCH.</span>
<span class="cm"> */</span>
<span class="cp">#define SEQ_PRIVATE		0xfe	</span><span class="cm">/* Low level HW dependent events (8 bytes) */</span><span class="cp"></span>
<span class="cp">#define SEQ_EXTENDED		0xff	</span><span class="cm">/* Extended events (8 bytes) OBSOLETE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Record for FM patches</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sbi_instr_data</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">sbi_instrument</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">key</span><span class="p">;</span>	<span class="cm">/* FM_PATCH or OPL3_PATCH */</span>
<span class="cp">#define FM_PATCH	_PATCHKEY(0x01)</span>
<span class="cp">#define OPL3_PATCH	_PATCHKEY(0x03)</span>
		<span class="kt">short</span>		<span class="n">device</span><span class="p">;</span>		<span class="cm">/*	Synth# (0-4)	*/</span>
		<span class="kt">int</span> 		<span class="n">channel</span><span class="p">;</span>	<span class="cm">/*	Program# to be initialized 	*/</span>
		<span class="n">sbi_instr_data</span>	<span class="n">operators</span><span class="p">;</span>	<span class="cm">/*	Register settings for operator cells (.SBI format)	*/</span>
	<span class="p">};</span>

<span class="k">struct</span> <span class="n">synth_info</span> <span class="p">{</span>	<span class="cm">/* Read only */</span>
		<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
		<span class="kt">int</span>	<span class="n">device</span><span class="p">;</span>		<span class="cm">/* 0-N. INITIALIZE BEFORE CALLING */</span>
		<span class="kt">int</span>	<span class="n">synth_type</span><span class="p">;</span>
<span class="cp">#define SYNTH_TYPE_FM			0</span>
<span class="cp">#define SYNTH_TYPE_SAMPLE		1</span>
<span class="cp">#define SYNTH_TYPE_MIDI			2	</span><span class="cm">/* Midi interface */</span><span class="cp"></span>

		<span class="kt">int</span>	<span class="n">synth_subtype</span><span class="p">;</span>
<span class="cp">#define FM_TYPE_ADLIB			0x00</span>
<span class="cp">#define FM_TYPE_OPL3			0x01</span>
<span class="cp">#define MIDI_TYPE_MPU401		0x401</span>

<span class="cp">#define SAMPLE_TYPE_BASIC		0x10</span>
<span class="cp">#define SAMPLE_TYPE_GUS			SAMPLE_TYPE_BASIC</span>
<span class="cp">#define SAMPLE_TYPE_WAVEFRONT           0x11</span>

		<span class="kt">int</span>	<span class="n">perc_mode</span><span class="p">;</span>	<span class="cm">/* No longer supported */</span>
		<span class="kt">int</span>	<span class="n">nr_voices</span><span class="p">;</span>
		<span class="kt">int</span>	<span class="n">nr_drums</span><span class="p">;</span>	<span class="cm">/* Obsolete field */</span>
		<span class="kt">int</span>	<span class="n">instr_bank_size</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">capabilities</span><span class="p">;</span>	
<span class="cp">#define SYNTH_CAP_PERCMODE		0x00000001 </span><span class="cm">/* No longer used */</span><span class="cp"></span>
<span class="cp">#define SYNTH_CAP_OPL3			0x00000002 </span><span class="cm">/* Set if OPL3 supported */</span><span class="cp"></span>
<span class="cp">#define SYNTH_CAP_INPUT			0x00000004 </span><span class="cm">/* Input (MIDI) device */</span><span class="cp"></span>
		<span class="kt">int</span>	<span class="n">dummies</span><span class="p">[</span><span class="mi">19</span><span class="p">];</span>	<span class="cm">/* Reserve space */</span>
	<span class="p">};</span>

<span class="k">struct</span> <span class="n">sound_timer_info</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">caps</span><span class="p">;</span>
	<span class="p">};</span>

<span class="cp">#define MIDI_CAP_MPU401		1		</span><span class="cm">/* MPU-401 intelligent mode */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">midi_info</span> <span class="p">{</span>
		<span class="kt">char</span>		<span class="n">name</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
		<span class="kt">int</span>		<span class="n">device</span><span class="p">;</span>		<span class="cm">/* 0-N. INITIALIZE BEFORE CALLING */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">capabilities</span><span class="p">;</span>	<span class="cm">/* To be defined later */</span>
		<span class="kt">int</span>		<span class="n">dev_type</span><span class="p">;</span>
		<span class="kt">int</span>		<span class="n">dummies</span><span class="p">[</span><span class="mi">18</span><span class="p">];</span>	<span class="cm">/* Reserve space */</span>
	<span class="p">};</span>

<span class="cm">/********************************************</span>
<span class="cm"> * ioctl commands for the /dev/midi##</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">nr_args</span><span class="p">,</span> <span class="n">nr_returns</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">mpu_command_rec</span><span class="p">;</span>

<span class="cp">#define SNDCTL_MIDI_PRETIME		_SIOWR(&#39;m&#39;, 0, int)</span>
<span class="cp">#define SNDCTL_MIDI_MPUMODE		_SIOWR(&#39;m&#39;, 1, int)</span>
<span class="cp">#define SNDCTL_MIDI_MPUCMD		_SIOWR(&#39;m&#39;, 2, mpu_command_rec)</span>

<span class="cm">/********************************************</span>
<span class="cm"> * IOCTL commands for /dev/dsp and /dev/audio</span>
<span class="cm"> */</span>

<span class="cp">#define SNDCTL_DSP_RESET		_SIO  (&#39;P&#39;, 0)</span>
<span class="cp">#define SNDCTL_DSP_SYNC			_SIO  (&#39;P&#39;, 1)</span>
<span class="cp">#define SNDCTL_DSP_SPEED		_SIOWR(&#39;P&#39;, 2, int)</span>
<span class="cp">#define SNDCTL_DSP_STEREO		_SIOWR(&#39;P&#39;, 3, int)</span>
<span class="cp">#define SNDCTL_DSP_GETBLKSIZE		_SIOWR(&#39;P&#39;, 4, int)</span>
<span class="cp">#define SNDCTL_DSP_SAMPLESIZE		SNDCTL_DSP_SETFMT</span>
<span class="cp">#define SNDCTL_DSP_CHANNELS		_SIOWR(&#39;P&#39;, 6, int)</span>
<span class="cp">#define SOUND_PCM_WRITE_CHANNELS	SNDCTL_DSP_CHANNELS</span>
<span class="cp">#define SOUND_PCM_WRITE_FILTER		_SIOWR(&#39;P&#39;, 7, int)</span>
<span class="cp">#define SNDCTL_DSP_POST			_SIO  (&#39;P&#39;, 8)</span>
<span class="cp">#define SNDCTL_DSP_SUBDIVIDE		_SIOWR(&#39;P&#39;, 9, int)</span>
<span class="cp">#define SNDCTL_DSP_SETFRAGMENT		_SIOWR(&#39;P&#39;,10, int)</span>

<span class="cm">/*	Audio data formats (Note! U8=8 and S16_LE=16 for compatibility) */</span>
<span class="cp">#define SNDCTL_DSP_GETFMTS		_SIOR (&#39;P&#39;,11, int) </span><span class="cm">/* Returns a mask */</span><span class="cp"></span>
<span class="cp">#define SNDCTL_DSP_SETFMT		_SIOWR(&#39;P&#39;,5, int) </span><span class="cm">/* Selects ONE fmt*/</span><span class="cp"></span>
<span class="cp">#	define AFMT_QUERY		0x00000000	</span><span class="cm">/* Return current fmt */</span><span class="cp"></span>
<span class="cp">#	define AFMT_MU_LAW		0x00000001</span>
<span class="cp">#	define AFMT_A_LAW		0x00000002</span>
<span class="cp">#	define AFMT_IMA_ADPCM		0x00000004</span>
<span class="cp">#	define AFMT_U8			0x00000008</span>
<span class="cp">#	define AFMT_S16_LE		0x00000010	</span><span class="cm">/* Little endian signed 16*/</span><span class="cp"></span>
<span class="cp">#	define AFMT_S16_BE		0x00000020	</span><span class="cm">/* Big endian signed 16 */</span><span class="cp"></span>
<span class="cp">#	define AFMT_S8			0x00000040</span>
<span class="cp">#	define AFMT_U16_LE		0x00000080	</span><span class="cm">/* Little endian U16 */</span><span class="cp"></span>
<span class="cp">#	define AFMT_U16_BE		0x00000100	</span><span class="cm">/* Big endian U16 */</span><span class="cp"></span>
<span class="cp">#	define AFMT_MPEG		0x00000200	</span><span class="cm">/* MPEG (2) audio */</span><span class="cp"></span>
<span class="cp">#	define AFMT_AC3		0x00000400	</span><span class="cm">/* Dolby Digital AC3 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Buffer status queries.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">audio_buf_info</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">fragments</span><span class="p">;</span>	<span class="cm">/* # of available fragments (partially usend ones not counted) */</span>
			<span class="kt">int</span> <span class="n">fragstotal</span><span class="p">;</span>	<span class="cm">/* Total # of fragments allocated */</span>
			<span class="kt">int</span> <span class="n">fragsize</span><span class="p">;</span>	<span class="cm">/* Size of a fragment in bytes */</span>

			<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>	<span class="cm">/* Available space in bytes (includes partially used fragments) */</span>
			<span class="cm">/* Note! &#39;bytes&#39; could be more than fragments*fragsize */</span>
		<span class="p">}</span> <span class="n">audio_buf_info</span><span class="p">;</span>

<span class="cp">#define SNDCTL_DSP_GETOSPACE		_SIOR (&#39;P&#39;,12, audio_buf_info)</span>
<span class="cp">#define SNDCTL_DSP_GETISPACE		_SIOR (&#39;P&#39;,13, audio_buf_info)</span>
<span class="cp">#define SNDCTL_DSP_NONBLOCK		_SIO  (&#39;P&#39;,14)</span>
<span class="cp">#define SNDCTL_DSP_GETCAPS		_SIOR (&#39;P&#39;,15, int)</span>
<span class="cp">#	define DSP_CAP_REVISION		0x000000ff	</span><span class="cm">/* Bits for revision level (0 to 255) */</span><span class="cp"></span>
<span class="cp">#	define DSP_CAP_DUPLEX		0x00000100	</span><span class="cm">/* Full duplex record/playback */</span><span class="cp"></span>
<span class="cp">#	define DSP_CAP_REALTIME		0x00000200	</span><span class="cm">/* Real time capability */</span><span class="cp"></span>
<span class="cp">#	define DSP_CAP_BATCH		0x00000400	</span><span class="cm">/* Device has some kind of */</span><span class="cp"></span>
							<span class="cm">/* internal buffers which may */</span>
							<span class="cm">/* cause some delays and */</span>
							<span class="cm">/* decrease precision of timing */</span>
<span class="cp">#	define DSP_CAP_COPROC		0x00000800	</span><span class="cm">/* Has a coprocessor */</span><span class="cp"></span>
							<span class="cm">/* Sometimes it&#39;s a DSP */</span>
							<span class="cm">/* but usually not */</span>
<span class="cp">#	define DSP_CAP_TRIGGER		0x00001000	</span><span class="cm">/* Supports SETTRIGGER */</span><span class="cp"></span>
<span class="cp">#	define DSP_CAP_MMAP		0x00002000	</span><span class="cm">/* Supports mmap() */</span><span class="cp"></span>
<span class="cp">#	define DSP_CAP_MULTI		0x00004000	</span><span class="cm">/* support multiple open */</span><span class="cp"></span>
<span class="cp">#	define DSP_CAP_BIND		0x00008000	</span><span class="cm">/* channel binding to front/rear/cneter/lfe */</span><span class="cp"></span>


<span class="cp">#define SNDCTL_DSP_GETTRIGGER		_SIOR (&#39;P&#39;,16, int)</span>
<span class="cp">#define SNDCTL_DSP_SETTRIGGER		_SIOW (&#39;P&#39;,16, int)</span>
<span class="cp">#	define PCM_ENABLE_INPUT		0x00000001</span>
<span class="cp">#	define PCM_ENABLE_OUTPUT		0x00000002</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">count_info</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>	<span class="cm">/* Total # of bytes processed */</span>
		<span class="kt">int</span> <span class="n">blocks</span><span class="p">;</span>	<span class="cm">/* # of fragment transitions since last time */</span>
		<span class="kt">int</span> <span class="n">ptr</span><span class="p">;</span>	<span class="cm">/* Current DMA pointer value */</span>
	<span class="p">}</span> <span class="n">count_info</span><span class="p">;</span>

<span class="cp">#define SNDCTL_DSP_GETIPTR		_SIOR (&#39;P&#39;,17, count_info)</span>
<span class="cp">#define SNDCTL_DSP_GETOPTR		_SIOR (&#39;P&#39;,18, count_info)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">buffmem_desc</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">buffmem_desc</span><span class="p">;</span>
<span class="cp">#define SNDCTL_DSP_MAPINBUF		_SIOR (&#39;P&#39;, 19, buffmem_desc)</span>
<span class="cp">#define SNDCTL_DSP_MAPOUTBUF		_SIOR (&#39;P&#39;, 20, buffmem_desc)</span>
<span class="cp">#define SNDCTL_DSP_SETSYNCRO		_SIO  (&#39;P&#39;, 21)</span>
<span class="cp">#define SNDCTL_DSP_SETDUPLEX		_SIO  (&#39;P&#39;, 22)</span>
<span class="cp">#define SNDCTL_DSP_GETODELAY		_SIOR (&#39;P&#39;, 23, int)</span>

<span class="cp">#define SNDCTL_DSP_GETCHANNELMASK		_SIOWR(&#39;P&#39;, 64, int)</span>
<span class="cp">#define SNDCTL_DSP_BIND_CHANNEL		_SIOWR(&#39;P&#39;, 65, int)</span>
<span class="cp">#	define DSP_BIND_QUERY		0x00000000</span>
<span class="cp">#	define DSP_BIND_FRONT		0x00000001</span>
<span class="cp">#	define DSP_BIND_SURR		0x00000002</span>
<span class="cp">#	define DSP_BIND_CENTER_LFE	0x00000004</span>
<span class="cp">#	define DSP_BIND_HANDSET		0x00000008</span>
<span class="cp">#	define DSP_BIND_MIC		0x00000010</span>
<span class="cp">#	define DSP_BIND_MODEM1		0x00000020</span>
<span class="cp">#	define DSP_BIND_MODEM2		0x00000040</span>
<span class="cp">#	define DSP_BIND_I2S		0x00000080</span>
<span class="cp">#	define DSP_BIND_SPDIF		0x00000100</span>

<span class="cp">#define SNDCTL_DSP_SETSPDIF		_SIOW (&#39;P&#39;, 66, int)</span>
<span class="cp">#define SNDCTL_DSP_GETSPDIF		_SIOR (&#39;P&#39;, 67, int)</span>
<span class="cp">#	define SPDIF_PRO	0x0001</span>
<span class="cp">#	define SPDIF_N_AUD	0x0002</span>
<span class="cp">#	define SPDIF_COPY	0x0004</span>
<span class="cp">#	define SPDIF_PRE	0x0008</span>
<span class="cp">#	define SPDIF_CC		0x07f0</span>
<span class="cp">#	define SPDIF_L		0x0800</span>
<span class="cp">#	define SPDIF_DRS	0x4000</span>
<span class="cp">#	define SPDIF_V		0x8000</span>

<span class="cm">/*</span>
<span class="cm"> * Application&#39;s profile defines the way how playback underrun situations should be handled.</span>
<span class="cm"> * </span>
<span class="cm"> *	APF_NORMAL (the default) and APF_NETWORK make the driver to cleanup the</span>
<span class="cm"> *	playback buffer whenever an underrun occurs. This consumes some time</span>
<span class="cm"> *	prevents looping the existing buffer.</span>
<span class="cm"> *	APF_CPUINTENS is intended to be set by CPU intensive applications which</span>
<span class="cm"> *	are likely to run out of time occasionally. In this mode the buffer cleanup is</span>
<span class="cm"> *	disabled which saves CPU time but also let&#39;s the previous buffer content to</span>
<span class="cm"> *	be played during the &quot;pause&quot; after the underrun.</span>
<span class="cm"> */</span>
<span class="cp">#define SNDCTL_DSP_PROFILE		_SIOW (&#39;P&#39;, 23, int)</span>
<span class="cp">#define	  APF_NORMAL	0	</span><span class="cm">/* Normal applications */</span><span class="cp"></span>
<span class="cp">#define	  APF_NETWORK	1	</span><span class="cm">/* Underruns probably caused by an &quot;external&quot; delay */</span><span class="cp"></span>
<span class="cp">#define   APF_CPUINTENS 2	</span><span class="cm">/* Underruns probably caused by &quot;overheating&quot; the CPU */</span><span class="cp"></span>

<span class="cp">#define SOUND_PCM_READ_RATE		_SIOR (&#39;P&#39;, 2, int)</span>
<span class="cp">#define SOUND_PCM_READ_CHANNELS		_SIOR (&#39;P&#39;, 6, int)</span>
<span class="cp">#define SOUND_PCM_READ_BITS		_SIOR (&#39;P&#39;, 5, int)</span>
<span class="cp">#define SOUND_PCM_READ_FILTER		_SIOR (&#39;P&#39;, 7, int)</span>

<span class="cm">/* Some alias names */</span>
<span class="cp">#define SOUND_PCM_WRITE_BITS		SNDCTL_DSP_SETFMT</span>
<span class="cp">#define SOUND_PCM_WRITE_RATE		SNDCTL_DSP_SPEED</span>
<span class="cp">#define SOUND_PCM_POST			SNDCTL_DSP_POST</span>
<span class="cp">#define SOUND_PCM_RESET			SNDCTL_DSP_RESET</span>
<span class="cp">#define SOUND_PCM_SYNC			SNDCTL_DSP_SYNC</span>
<span class="cp">#define SOUND_PCM_SUBDIVIDE		SNDCTL_DSP_SUBDIVIDE</span>
<span class="cp">#define SOUND_PCM_SETFRAGMENT		SNDCTL_DSP_SETFRAGMENT</span>
<span class="cp">#define SOUND_PCM_GETFMTS		SNDCTL_DSP_GETFMTS</span>
<span class="cp">#define SOUND_PCM_SETFMT		SNDCTL_DSP_SETFMT</span>
<span class="cp">#define SOUND_PCM_GETOSPACE		SNDCTL_DSP_GETOSPACE</span>
<span class="cp">#define SOUND_PCM_GETISPACE		SNDCTL_DSP_GETISPACE</span>
<span class="cp">#define SOUND_PCM_NONBLOCK		SNDCTL_DSP_NONBLOCK</span>
<span class="cp">#define SOUND_PCM_GETCAPS		SNDCTL_DSP_GETCAPS</span>
<span class="cp">#define SOUND_PCM_GETTRIGGER		SNDCTL_DSP_GETTRIGGER</span>
<span class="cp">#define SOUND_PCM_SETTRIGGER		SNDCTL_DSP_SETTRIGGER</span>
<span class="cp">#define SOUND_PCM_SETSYNCRO		SNDCTL_DSP_SETSYNCRO</span>
<span class="cp">#define SOUND_PCM_GETIPTR		SNDCTL_DSP_GETIPTR</span>
<span class="cp">#define SOUND_PCM_GETOPTR		SNDCTL_DSP_GETOPTR</span>
<span class="cp">#define SOUND_PCM_MAPINBUF		SNDCTL_DSP_MAPINBUF</span>
<span class="cp">#define SOUND_PCM_MAPOUTBUF		SNDCTL_DSP_MAPOUTBUF</span>

<span class="cm">/*</span>
<span class="cm"> * ioctl calls to be used in communication with coprocessors and</span>
<span class="cm"> * DSP chips.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">copr_buffer</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">command</span><span class="p">;</span>	<span class="cm">/* Set to 0 if not used */</span>
		<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define CPF_NONE		0x0000</span>
<span class="cp">#define CPF_FIRST		0x0001	</span><span class="cm">/* First block */</span><span class="cp"></span>
<span class="cp">#define CPF_LAST		0x0002	</span><span class="cm">/* Last block */</span><span class="cp"></span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>	<span class="cm">/* If required by the device (0 if not used) */</span>

		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">4000</span><span class="p">];</span> <span class="cm">/* NOTE! 4000 is not 4k */</span>
	<span class="p">}</span> <span class="n">copr_buffer</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">copr_debug_buf</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">command</span><span class="p">;</span>	<span class="cm">/* Used internally. Set to 0 */</span>
		<span class="kt">int</span> <span class="n">parm1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">parm2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>	
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>	<span class="cm">/* Length of data in bytes */</span>
	<span class="p">}</span> <span class="n">copr_debug_buf</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">copr_msg</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">4000</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">copr_msg</span><span class="p">;</span>

<span class="cp">#define SNDCTL_COPR_RESET             _SIO  (&#39;C&#39;,  0)</span>
<span class="cp">#define SNDCTL_COPR_LOAD	      _SIOWR(&#39;C&#39;,  1, copr_buffer)</span>
<span class="cp">#define SNDCTL_COPR_RDATA	      _SIOWR(&#39;C&#39;,  2, copr_debug_buf)</span>
<span class="cp">#define SNDCTL_COPR_RCODE	      _SIOWR(&#39;C&#39;,  3, copr_debug_buf)</span>
<span class="cp">#define SNDCTL_COPR_WDATA	      _SIOW (&#39;C&#39;,  4, copr_debug_buf)</span>
<span class="cp">#define SNDCTL_COPR_WCODE	      _SIOW (&#39;C&#39;,  5, copr_debug_buf)</span>
<span class="cp">#define SNDCTL_COPR_RUN		      _SIOWR(&#39;C&#39;,  6, copr_debug_buf)</span>
<span class="cp">#define SNDCTL_COPR_HALT	      _SIOWR(&#39;C&#39;,  7, copr_debug_buf)</span>
<span class="cp">#define SNDCTL_COPR_SENDMSG	      _SIOWR(&#39;C&#39;,  8, copr_msg)</span>
<span class="cp">#define SNDCTL_COPR_RCVMSG	      _SIOR (&#39;C&#39;,  9, copr_msg)</span>

<span class="cm">/*********************************************</span>
<span class="cm"> * IOCTL commands for /dev/mixer</span>
<span class="cm"> */</span>
	
<span class="cm">/* </span>
<span class="cm"> * Mixer devices</span>
<span class="cm"> *</span>
<span class="cm"> * There can be up to 20 different analog mixer channels. The</span>
<span class="cm"> * SOUND_MIXER_NRDEVICES gives the currently supported maximum. </span>
<span class="cm"> * The SOUND_MIXER_READ_DEVMASK returns a bitmask which tells</span>
<span class="cm"> * the devices supported by the particular mixer.</span>
<span class="cm"> */</span>

<span class="cp">#define SOUND_MIXER_NRDEVICES	25</span>
<span class="cp">#define SOUND_MIXER_VOLUME	0</span>
<span class="cp">#define SOUND_MIXER_BASS	1</span>
<span class="cp">#define SOUND_MIXER_TREBLE	2</span>
<span class="cp">#define SOUND_MIXER_SYNTH	3</span>
<span class="cp">#define SOUND_MIXER_PCM		4</span>
<span class="cp">#define SOUND_MIXER_SPEAKER	5</span>
<span class="cp">#define SOUND_MIXER_LINE	6</span>
<span class="cp">#define SOUND_MIXER_MIC		7</span>
<span class="cp">#define SOUND_MIXER_CD		8</span>
<span class="cp">#define SOUND_MIXER_IMIX	9	</span><span class="cm">/*  Recording monitor  */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_ALTPCM	10</span>
<span class="cp">#define SOUND_MIXER_RECLEV	11	</span><span class="cm">/* Recording level */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_IGAIN	12	</span><span class="cm">/* Input gain */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_OGAIN	13	</span><span class="cm">/* Output gain */</span><span class="cp"></span>
<span class="cm">/* </span>
<span class="cm"> * The AD1848 codec and compatibles have three line level inputs</span>
<span class="cm"> * (line, aux1 and aux2). Since each card manufacturer have assigned</span>
<span class="cm"> * different meanings to these inputs, it&#39;s inpractical to assign</span>
<span class="cm"> * specific meanings (line, cd, synth etc.) to them.</span>
<span class="cm"> */</span>
<span class="cp">#define SOUND_MIXER_LINE1	14	</span><span class="cm">/* Input source 1  (aux1) */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_LINE2	15	</span><span class="cm">/* Input source 2  (aux2) */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_LINE3	16	</span><span class="cm">/* Input source 3  (line) */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_DIGITAL1	17	</span><span class="cm">/* Digital (input) 1 */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_DIGITAL2	18	</span><span class="cm">/* Digital (input) 2 */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_DIGITAL3	19	</span><span class="cm">/* Digital (input) 3 */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_PHONEIN	20	</span><span class="cm">/* Phone input */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_PHONEOUT	21	</span><span class="cm">/* Phone output */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_VIDEO	22	</span><span class="cm">/* Video/TV (audio) in */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_RADIO	23	</span><span class="cm">/* Radio in */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_MONITOR	24	</span><span class="cm">/* Monitor (usually mic) volume */</span><span class="cp"></span>

<span class="cm">/* Some on/off settings (SOUND_SPECIAL_MIN - SOUND_SPECIAL_MAX) */</span>
<span class="cm">/* Not counted to SOUND_MIXER_NRDEVICES, but use the same number space */</span>
<span class="cp">#define SOUND_ONOFF_MIN		28</span>
<span class="cp">#define SOUND_ONOFF_MAX		30</span>

<span class="cm">/* Note!	Number 31 cannot be used since the sign bit is reserved */</span>
<span class="cp">#define SOUND_MIXER_NONE	31</span>

<span class="cm">/*</span>
<span class="cm"> * The following unsupported macros are no longer functional.</span>
<span class="cm"> * Use SOUND_MIXER_PRIVATE# macros in future.</span>
<span class="cm"> */</span>
<span class="cp">#define SOUND_MIXER_ENHANCE	SOUND_MIXER_NONE</span>
<span class="cp">#define SOUND_MIXER_MUTE	SOUND_MIXER_NONE</span>
<span class="cp">#define SOUND_MIXER_LOUD	SOUND_MIXER_NONE</span>


<span class="cp">#define SOUND_DEVICE_LABELS	{&quot;Vol  &quot;, &quot;Bass &quot;, &quot;Trebl&quot;, &quot;Synth&quot;, &quot;Pcm  &quot;, &quot;Spkr &quot;, &quot;Line &quot;, \</span>
<span class="cp">				 &quot;Mic  &quot;, &quot;CD   &quot;, &quot;Mix  &quot;, &quot;Pcm2 &quot;, &quot;Rec  &quot;, &quot;IGain&quot;, &quot;OGain&quot;, \</span>
<span class="cp">				 &quot;Line1&quot;, &quot;Line2&quot;, &quot;Line3&quot;, &quot;Digital1&quot;, &quot;Digital2&quot;, &quot;Digital3&quot;, \</span>
<span class="cp">				 &quot;PhoneIn&quot;, &quot;PhoneOut&quot;, &quot;Video&quot;, &quot;Radio&quot;, &quot;Monitor&quot;}</span>

<span class="cp">#define SOUND_DEVICE_NAMES	{&quot;vol&quot;, &quot;bass&quot;, &quot;treble&quot;, &quot;synth&quot;, &quot;pcm&quot;, &quot;speaker&quot;, &quot;line&quot;, \</span>
<span class="cp">				 &quot;mic&quot;, &quot;cd&quot;, &quot;mix&quot;, &quot;pcm2&quot;, &quot;rec&quot;, &quot;igain&quot;, &quot;ogain&quot;, \</span>
<span class="cp">				 &quot;line1&quot;, &quot;line2&quot;, &quot;line3&quot;, &quot;dig1&quot;, &quot;dig2&quot;, &quot;dig3&quot;, \</span>
<span class="cp">				 &quot;phin&quot;, &quot;phout&quot;, &quot;video&quot;, &quot;radio&quot;, &quot;monitor&quot;}</span>

<span class="cm">/*	Device bitmask identifiers	*/</span>

<span class="cp">#define SOUND_MIXER_RECSRC	0xff	</span><span class="cm">/* Arg contains a bit for each recording source */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_DEVMASK	0xfe	</span><span class="cm">/* Arg contains a bit for each supported device */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_RECMASK	0xfd	</span><span class="cm">/* Arg contains a bit for each supported recording source */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_CAPS	0xfc</span>
<span class="cp">#	define SOUND_CAP_EXCL_INPUT	0x00000001	</span><span class="cm">/* Only one recording source at a time */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_STEREODEVS	0xfb	</span><span class="cm">/* Mixer channels supporting stereo */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_OUTSRC	0xfa	</span><span class="cm">/* Arg contains a bit for each input source to output */</span><span class="cp"></span>
<span class="cp">#define SOUND_MIXER_OUTMASK	0xf9	</span><span class="cm">/* Arg contains a bit for each supported input source to output */</span><span class="cp"></span>

<span class="cm">/*	Device mask bits	*/</span>

<span class="cp">#define SOUND_MASK_VOLUME	(1 &lt;&lt; SOUND_MIXER_VOLUME)</span>
<span class="cp">#define SOUND_MASK_BASS		(1 &lt;&lt; SOUND_MIXER_BASS)</span>
<span class="cp">#define SOUND_MASK_TREBLE	(1 &lt;&lt; SOUND_MIXER_TREBLE)</span>
<span class="cp">#define SOUND_MASK_SYNTH	(1 &lt;&lt; SOUND_MIXER_SYNTH)</span>
<span class="cp">#define SOUND_MASK_PCM		(1 &lt;&lt; SOUND_MIXER_PCM)</span>
<span class="cp">#define SOUND_MASK_SPEAKER	(1 &lt;&lt; SOUND_MIXER_SPEAKER)</span>
<span class="cp">#define SOUND_MASK_LINE		(1 &lt;&lt; SOUND_MIXER_LINE)</span>
<span class="cp">#define SOUND_MASK_MIC		(1 &lt;&lt; SOUND_MIXER_MIC)</span>
<span class="cp">#define SOUND_MASK_CD		(1 &lt;&lt; SOUND_MIXER_CD)</span>
<span class="cp">#define SOUND_MASK_IMIX		(1 &lt;&lt; SOUND_MIXER_IMIX)</span>
<span class="cp">#define SOUND_MASK_ALTPCM	(1 &lt;&lt; SOUND_MIXER_ALTPCM)</span>
<span class="cp">#define SOUND_MASK_RECLEV	(1 &lt;&lt; SOUND_MIXER_RECLEV)</span>
<span class="cp">#define SOUND_MASK_IGAIN	(1 &lt;&lt; SOUND_MIXER_IGAIN)</span>
<span class="cp">#define SOUND_MASK_OGAIN	(1 &lt;&lt; SOUND_MIXER_OGAIN)</span>
<span class="cp">#define SOUND_MASK_LINE1	(1 &lt;&lt; SOUND_MIXER_LINE1)</span>
<span class="cp">#define SOUND_MASK_LINE2	(1 &lt;&lt; SOUND_MIXER_LINE2)</span>
<span class="cp">#define SOUND_MASK_LINE3	(1 &lt;&lt; SOUND_MIXER_LINE3)</span>
<span class="cp">#define SOUND_MASK_DIGITAL1	(1 &lt;&lt; SOUND_MIXER_DIGITAL1)</span>
<span class="cp">#define SOUND_MASK_DIGITAL2	(1 &lt;&lt; SOUND_MIXER_DIGITAL2)</span>
<span class="cp">#define SOUND_MASK_DIGITAL3	(1 &lt;&lt; SOUND_MIXER_DIGITAL3)</span>
<span class="cp">#define SOUND_MASK_PHONEIN	(1 &lt;&lt; SOUND_MIXER_PHONEIN)</span>
<span class="cp">#define SOUND_MASK_PHONEOUT	(1 &lt;&lt; SOUND_MIXER_PHONEOUT)</span>
<span class="cp">#define SOUND_MASK_RADIO	(1 &lt;&lt; SOUND_MIXER_RADIO)</span>
<span class="cp">#define SOUND_MASK_VIDEO	(1 &lt;&lt; SOUND_MIXER_VIDEO)</span>
<span class="cp">#define SOUND_MASK_MONITOR	(1 &lt;&lt; SOUND_MIXER_MONITOR)</span>

<span class="cm">/* Obsolete macros */</span>
<span class="cp">#define SOUND_MASK_MUTE		(1 &lt;&lt; SOUND_MIXER_MUTE)</span>
<span class="cp">#define SOUND_MASK_ENHANCE	(1 &lt;&lt; SOUND_MIXER_ENHANCE)</span>
<span class="cp">#define SOUND_MASK_LOUD		(1 &lt;&lt; SOUND_MIXER_LOUD)</span>

<span class="cp">#define MIXER_READ(dev)		_SIOR(&#39;M&#39;, dev, int)</span>
<span class="cp">#define SOUND_MIXER_READ_VOLUME		MIXER_READ(SOUND_MIXER_VOLUME)</span>
<span class="cp">#define SOUND_MIXER_READ_BASS		MIXER_READ(SOUND_MIXER_BASS)</span>
<span class="cp">#define SOUND_MIXER_READ_TREBLE		MIXER_READ(SOUND_MIXER_TREBLE)</span>
<span class="cp">#define SOUND_MIXER_READ_SYNTH		MIXER_READ(SOUND_MIXER_SYNTH)</span>
<span class="cp">#define SOUND_MIXER_READ_PCM		MIXER_READ(SOUND_MIXER_PCM)</span>
<span class="cp">#define SOUND_MIXER_READ_SPEAKER	MIXER_READ(SOUND_MIXER_SPEAKER)</span>
<span class="cp">#define SOUND_MIXER_READ_LINE		MIXER_READ(SOUND_MIXER_LINE)</span>
<span class="cp">#define SOUND_MIXER_READ_MIC		MIXER_READ(SOUND_MIXER_MIC)</span>
<span class="cp">#define SOUND_MIXER_READ_CD		MIXER_READ(SOUND_MIXER_CD)</span>
<span class="cp">#define SOUND_MIXER_READ_IMIX		MIXER_READ(SOUND_MIXER_IMIX)</span>
<span class="cp">#define SOUND_MIXER_READ_ALTPCM		MIXER_READ(SOUND_MIXER_ALTPCM)</span>
<span class="cp">#define SOUND_MIXER_READ_RECLEV		MIXER_READ(SOUND_MIXER_RECLEV)</span>
<span class="cp">#define SOUND_MIXER_READ_IGAIN		MIXER_READ(SOUND_MIXER_IGAIN)</span>
<span class="cp">#define SOUND_MIXER_READ_OGAIN		MIXER_READ(SOUND_MIXER_OGAIN)</span>
<span class="cp">#define SOUND_MIXER_READ_LINE1		MIXER_READ(SOUND_MIXER_LINE1)</span>
<span class="cp">#define SOUND_MIXER_READ_LINE2		MIXER_READ(SOUND_MIXER_LINE2)</span>
<span class="cp">#define SOUND_MIXER_READ_LINE3		MIXER_READ(SOUND_MIXER_LINE3)</span>

<span class="cm">/* Obsolete macros */</span>
<span class="cp">#define SOUND_MIXER_READ_MUTE		MIXER_READ(SOUND_MIXER_MUTE)</span>
<span class="cp">#define SOUND_MIXER_READ_ENHANCE	MIXER_READ(SOUND_MIXER_ENHANCE)</span>
<span class="cp">#define SOUND_MIXER_READ_LOUD		MIXER_READ(SOUND_MIXER_LOUD)</span>

<span class="cp">#define SOUND_MIXER_READ_RECSRC		MIXER_READ(SOUND_MIXER_RECSRC)</span>
<span class="cp">#define SOUND_MIXER_READ_DEVMASK	MIXER_READ(SOUND_MIXER_DEVMASK)</span>
<span class="cp">#define SOUND_MIXER_READ_RECMASK	MIXER_READ(SOUND_MIXER_RECMASK)</span>
<span class="cp">#define SOUND_MIXER_READ_STEREODEVS	MIXER_READ(SOUND_MIXER_STEREODEVS)</span>
<span class="cp">#define SOUND_MIXER_READ_CAPS		MIXER_READ(SOUND_MIXER_CAPS)</span>

<span class="cp">#define MIXER_WRITE(dev)		_SIOWR(&#39;M&#39;, dev, int)</span>
<span class="cp">#define SOUND_MIXER_WRITE_VOLUME	MIXER_WRITE(SOUND_MIXER_VOLUME)</span>
<span class="cp">#define SOUND_MIXER_WRITE_BASS		MIXER_WRITE(SOUND_MIXER_BASS)</span>
<span class="cp">#define SOUND_MIXER_WRITE_TREBLE	MIXER_WRITE(SOUND_MIXER_TREBLE)</span>
<span class="cp">#define SOUND_MIXER_WRITE_SYNTH		MIXER_WRITE(SOUND_MIXER_SYNTH)</span>
<span class="cp">#define SOUND_MIXER_WRITE_PCM		MIXER_WRITE(SOUND_MIXER_PCM)</span>
<span class="cp">#define SOUND_MIXER_WRITE_SPEAKER	MIXER_WRITE(SOUND_MIXER_SPEAKER)</span>
<span class="cp">#define SOUND_MIXER_WRITE_LINE		MIXER_WRITE(SOUND_MIXER_LINE)</span>
<span class="cp">#define SOUND_MIXER_WRITE_MIC		MIXER_WRITE(SOUND_MIXER_MIC)</span>
<span class="cp">#define SOUND_MIXER_WRITE_CD		MIXER_WRITE(SOUND_MIXER_CD)</span>
<span class="cp">#define SOUND_MIXER_WRITE_IMIX		MIXER_WRITE(SOUND_MIXER_IMIX)</span>
<span class="cp">#define SOUND_MIXER_WRITE_ALTPCM	MIXER_WRITE(SOUND_MIXER_ALTPCM)</span>
<span class="cp">#define SOUND_MIXER_WRITE_RECLEV	MIXER_WRITE(SOUND_MIXER_RECLEV)</span>
<span class="cp">#define SOUND_MIXER_WRITE_IGAIN		MIXER_WRITE(SOUND_MIXER_IGAIN)</span>
<span class="cp">#define SOUND_MIXER_WRITE_OGAIN		MIXER_WRITE(SOUND_MIXER_OGAIN)</span>
<span class="cp">#define SOUND_MIXER_WRITE_LINE1		MIXER_WRITE(SOUND_MIXER_LINE1)</span>
<span class="cp">#define SOUND_MIXER_WRITE_LINE2		MIXER_WRITE(SOUND_MIXER_LINE2)</span>
<span class="cp">#define SOUND_MIXER_WRITE_LINE3		MIXER_WRITE(SOUND_MIXER_LINE3)</span>

<span class="cm">/* Obsolete macros */</span>
<span class="cp">#define SOUND_MIXER_WRITE_MUTE		MIXER_WRITE(SOUND_MIXER_MUTE)</span>
<span class="cp">#define SOUND_MIXER_WRITE_ENHANCE	MIXER_WRITE(SOUND_MIXER_ENHANCE)</span>
<span class="cp">#define SOUND_MIXER_WRITE_LOUD		MIXER_WRITE(SOUND_MIXER_LOUD)</span>

<span class="cp">#define SOUND_MIXER_WRITE_RECSRC	MIXER_WRITE(SOUND_MIXER_RECSRC)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">mixer_info</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="kt">int</span>  <span class="n">modify_counter</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">fillers</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span> <span class="n">mixer_info</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_old_mixer_info</span> <span class="cm">/* Obsolete */</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">_old_mixer_info</span><span class="p">;</span>

<span class="cp">#define SOUND_MIXER_INFO		_SIOR (&#39;M&#39;, 101, mixer_info)</span>
<span class="cp">#define SOUND_OLD_MIXER_INFO		_SIOR (&#39;M&#39;, 101, _old_mixer_info)</span>

<span class="cm">/*</span>
<span class="cm"> * A mechanism for accessing &quot;proprietary&quot; mixer features. This method</span>
<span class="cm"> * permits passing 128 bytes of arbitrary data between a mixer application</span>
<span class="cm"> * and the mixer driver. Interpretation of the record is defined by</span>
<span class="cm"> * the particular mixer driver.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mixer_record</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

<span class="cp">#define SOUND_MIXER_ACCESS		_SIOWR(&#39;M&#39;, 102, mixer_record)</span>

<span class="cm">/*</span>
<span class="cm"> * Two ioctls for special souncard function</span>
<span class="cm"> */</span>
<span class="cp">#define SOUND_MIXER_AGC  _SIOWR(&#39;M&#39;, 103, int)</span>
<span class="cp">#define SOUND_MIXER_3DSE  _SIOWR(&#39;M&#39;, 104, int)</span>

<span class="cm">/*</span>
<span class="cm"> * The SOUND_MIXER_PRIVATE# commands can be redefined by low level drivers.</span>
<span class="cm"> * These features can be used when accessing device specific features.</span>
<span class="cm"> */</span>
<span class="cp">#define SOUND_MIXER_PRIVATE1		_SIOWR(&#39;M&#39;, 111, int)</span>
<span class="cp">#define SOUND_MIXER_PRIVATE2		_SIOWR(&#39;M&#39;, 112, int)</span>
<span class="cp">#define SOUND_MIXER_PRIVATE3		_SIOWR(&#39;M&#39;, 113, int)</span>
<span class="cp">#define SOUND_MIXER_PRIVATE4		_SIOWR(&#39;M&#39;, 114, int)</span>
<span class="cp">#define SOUND_MIXER_PRIVATE5		_SIOWR(&#39;M&#39;, 115, int)</span>

<span class="cm">/*</span>
<span class="cm"> * SOUND_MIXER_GETLEVELS and SOUND_MIXER_SETLEVELS calls can be used</span>
<span class="cm"> * for querying current mixer settings from the driver and for loading</span>
<span class="cm"> * default volume settings _prior_ activating the mixer (loading</span>
<span class="cm"> * doesn&#39;t affect current state of the mixer hardware). These calls</span>
<span class="cm"> * are for internal use only.</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">mixer_vol_table</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>	<span class="cm">/* Index to volume table */</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">levels</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">mixer_vol_table</span><span class="p">;</span>

<span class="cp">#define SOUND_MIXER_GETLEVELS		_SIOWR(&#39;M&#39;, 116, mixer_vol_table)</span>
<span class="cp">#define SOUND_MIXER_SETLEVELS		_SIOWR(&#39;M&#39;, 117, mixer_vol_table)</span>

<span class="cm">/* </span>
<span class="cm"> * An ioctl for identifying the driver version. It will return value</span>
<span class="cm"> * of the SOUND_VERSION macro used when compiling the driver.</span>
<span class="cm"> * This call was introduced in OSS version 3.6 and it will not work</span>
<span class="cm"> * with earlier versions (returns EINVAL).</span>
<span class="cm"> */</span>
<span class="cp">#define OSS_GETVERSION			_SIOR (&#39;M&#39;, 118, int)</span>

<span class="cm">/*</span>
<span class="cm"> * Level 2 event types for /dev/sequencer</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The 4 most significant bits of byte 0 specify the class of</span>
<span class="cm"> * the event: </span>
<span class="cm"> *</span>
<span class="cm"> *	0x8X = system level events,</span>
<span class="cm"> *	0x9X = device/port specific events, event[1] = device/port,</span>
<span class="cm"> *		The last 4 bits give the subtype:</span>
<span class="cm"> *			0x02	= Channel event (event[3] = chn).</span>
<span class="cm"> *			0x01	= note event (event[4] = note).</span>
<span class="cm"> *			(0x01 is not used alone but always with bit 0x02).</span>
<span class="cm"> *	       event[2] = MIDI message code (0x80=note off etc.)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define EV_SEQ_LOCAL		0x80</span>
<span class="cp">#define EV_TIMING		0x81</span>
<span class="cp">#define EV_CHN_COMMON		0x92</span>
<span class="cp">#define EV_CHN_VOICE		0x93</span>
<span class="cp">#define EV_SYSEX		0x94</span>
<span class="cm">/*</span>
<span class="cm"> * Event types 200 to 220 are reserved for application use.</span>
<span class="cm"> * These numbers will not be used by the driver.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Events for event type EV_CHN_VOICE</span>
<span class="cm"> */</span>

<span class="cp">#define MIDI_NOTEOFF		0x80</span>
<span class="cp">#define MIDI_NOTEON		0x90</span>
<span class="cp">#define MIDI_KEY_PRESSURE	0xA0</span>

<span class="cm">/*</span>
<span class="cm"> * Events for event type EV_CHN_COMMON</span>
<span class="cm"> */</span>

<span class="cp">#define MIDI_CTL_CHANGE		0xB0</span>
<span class="cp">#define MIDI_PGM_CHANGE		0xC0</span>
<span class="cp">#define MIDI_CHN_PRESSURE	0xD0</span>
<span class="cp">#define MIDI_PITCH_BEND		0xE0</span>

<span class="cp">#define MIDI_SYSTEM_PREFIX	0xF0</span>

<span class="cm">/*</span>
<span class="cm"> * Timer event types</span>
<span class="cm"> */</span>
<span class="cp">#define TMR_WAIT_REL		1	</span><span class="cm">/* Time relative to the prev time */</span><span class="cp"></span>
<span class="cp">#define TMR_WAIT_ABS		2	</span><span class="cm">/* Absolute time since TMR_START */</span><span class="cp"></span>
<span class="cp">#define TMR_STOP		3</span>
<span class="cp">#define TMR_START		4</span>
<span class="cp">#define TMR_CONTINUE		5</span>
<span class="cp">#define TMR_TEMPO		6</span>
<span class="cp">#define TMR_ECHO		8</span>
<span class="cp">#define TMR_CLOCK		9	</span><span class="cm">/* MIDI clock */</span><span class="cp"></span>
<span class="cp">#define TMR_SPP			10	</span><span class="cm">/* Song position pointer */</span><span class="cp"></span>
<span class="cp">#define TMR_TIMESIG		11	</span><span class="cm">/* Time signature */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	Local event types</span>
<span class="cm"> */</span>
<span class="cp">#define LOCL_STARTAUDIO		1</span>

<span class="cp">#if !defined(__KERNEL__) || defined(USE_SEQ_MACROS)</span>
<span class="cm">/*</span>
<span class="cm"> *	Some convenience macros to simplify programming of the</span>
<span class="cm"> *	/dev/sequencer interface</span>
<span class="cm"> *</span>
<span class="cm"> *	This is a legacy interface for applications written against</span>
<span class="cm"> *	the OSSlib-3.8 style interface. It is no longer possible</span>
<span class="cm"> *	to actually link against OSSlib with this header, but we</span>
<span class="cm"> *	still provide these macros for programs using them.</span>
<span class="cm"> *</span>
<span class="cm"> *	If you want to use OSSlib, it is recommended that you get</span>
<span class="cm"> *	the GPL version of OSS-4.x and build against that version</span>
<span class="cm"> *	of the header.</span>
<span class="cm"> *</span>
<span class="cm"> *	We redefine the extern keyword so that make headers_check</span>
<span class="cm"> *	does not complain about SEQ_USE_EXTBUF.</span>
<span class="cm"> */</span>
<span class="cp">#define SEQ_DECLAREBUF()		SEQ_USE_EXTBUF()</span>

<span class="kt">void</span> <span class="n">seqbuf_dump</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>	<span class="cm">/* This function must be provided by programs */</span>

<span class="cp">#define SEQ_PM_DEFINES int __foo_bar___</span>

<span class="cp">#define SEQ_LOAD_GMINSTR(dev, instr)</span>
<span class="cp">#define SEQ_LOAD_GMDRUM(dev, drum)</span>

<span class="cp">#define _SEQ_EXTERN extern</span>
<span class="cp">#define SEQ_USE_EXTBUF() \</span>
<span class="cp">		_SEQ_EXTERN unsigned char _seqbuf[]; \</span>
<span class="cp">		_SEQ_EXTERN int _seqbuflen; _SEQ_EXTERN int _seqbufptr</span>

<span class="cp">#ifndef USE_SIMPLE_MACROS</span>
<span class="cm">/* Sample seqbuf_dump() implementation:</span>
<span class="cm"> *</span>
<span class="cm"> *	SEQ_DEFINEBUF (2048);	-- Defines a buffer for 2048 bytes</span>
<span class="cm"> *</span>
<span class="cm"> *	int seqfd;		-- The file descriptor for /dev/sequencer.</span>
<span class="cm"> *</span>
<span class="cm"> *	void</span>
<span class="cm"> *	seqbuf_dump ()</span>
<span class="cm"> *	{</span>
<span class="cm"> *	  if (_seqbufptr)</span>
<span class="cm"> *	    if (write (seqfd, _seqbuf, _seqbufptr) == -1)</span>
<span class="cm"> *	      {</span>
<span class="cm"> *		perror (&quot;write /dev/sequencer&quot;);</span>
<span class="cm"> *		exit (-1);</span>
<span class="cm"> *	      }</span>
<span class="cm"> *	  _seqbufptr = 0;</span>
<span class="cm"> *	}</span>
<span class="cm"> */</span>

<span class="cp">#define SEQ_DEFINEBUF(len)		unsigned char _seqbuf[len]; int _seqbuflen = len;int _seqbufptr = 0</span>
<span class="cp">#define _SEQ_NEEDBUF(len)		if ((_seqbufptr+(len)) &gt; _seqbuflen) seqbuf_dump()</span>
<span class="cp">#define _SEQ_ADVBUF(len)		_seqbufptr += len</span>
<span class="cp">#define SEQ_DUMPBUF			seqbuf_dump</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * This variation of the sequencer macros is used just to format one event</span>
<span class="cm"> * using fixed buffer.</span>
<span class="cm"> * </span>
<span class="cm"> * The program using the macro library must define the following macros before</span>
<span class="cm"> * using this library.</span>
<span class="cm"> *</span>
<span class="cm"> * #define _seqbuf 		 name of the buffer (unsigned char[]) </span>
<span class="cm"> * #define _SEQ_ADVBUF(len)	 If the applic needs to know the exact</span>
<span class="cm"> *				 size of the event, this macro can be used.</span>
<span class="cm"> *				 Otherwise this must be defined as empty.</span>
<span class="cm"> * #define _seqbufptr		 Define the name of index variable or 0 if</span>
<span class="cm"> *				 not required. </span>
<span class="cm"> */</span>
<span class="cp">#define _SEQ_NEEDBUF(len)	</span><span class="cm">/* empty */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#define SEQ_VOLUME_MODE(dev, mode)	{_SEQ_NEEDBUF(8);\</span>
<span class="cp">					_seqbuf[_seqbufptr] = SEQ_EXTENDED;\</span>
<span class="cp">					_seqbuf[_seqbufptr+1] = SEQ_VOLMODE;\</span>
<span class="cp">					_seqbuf[_seqbufptr+2] = (dev);\</span>
<span class="cp">					_seqbuf[_seqbufptr+3] = (mode);\</span>
<span class="cp">					_seqbuf[_seqbufptr+4] = 0;\</span>
<span class="cp">					_seqbuf[_seqbufptr+5] = 0;\</span>
<span class="cp">					_seqbuf[_seqbufptr+6] = 0;\</span>
<span class="cp">					_seqbuf[_seqbufptr+7] = 0;\</span>
<span class="cp">					_SEQ_ADVBUF(8);}</span>

<span class="cm">/*</span>
<span class="cm"> * Midi voice messages</span>
<span class="cm"> */</span>

<span class="cp">#define _CHN_VOICE(dev, event, chn, note, parm) \</span>
<span class="cp">					{_SEQ_NEEDBUF(8);\</span>
<span class="cp">					_seqbuf[_seqbufptr] = EV_CHN_VOICE;\</span>
<span class="cp">					_seqbuf[_seqbufptr+1] = (dev);\</span>
<span class="cp">					_seqbuf[_seqbufptr+2] = (event);\</span>
<span class="cp">					_seqbuf[_seqbufptr+3] = (chn);\</span>
<span class="cp">					_seqbuf[_seqbufptr+4] = (note);\</span>
<span class="cp">					_seqbuf[_seqbufptr+5] = (parm);\</span>
<span class="cp">					_seqbuf[_seqbufptr+6] = (0);\</span>
<span class="cp">					_seqbuf[_seqbufptr+7] = 0;\</span>
<span class="cp">					_SEQ_ADVBUF(8);}</span>

<span class="cp">#define SEQ_START_NOTE(dev, chn, note, vol) \</span>
<span class="cp">		_CHN_VOICE(dev, MIDI_NOTEON, chn, note, vol)</span>

<span class="cp">#define SEQ_STOP_NOTE(dev, chn, note, vol) \</span>
<span class="cp">		_CHN_VOICE(dev, MIDI_NOTEOFF, chn, note, vol)</span>

<span class="cp">#define SEQ_KEY_PRESSURE(dev, chn, note, pressure) \</span>
<span class="cp">		_CHN_VOICE(dev, MIDI_KEY_PRESSURE, chn, note, pressure)</span>

<span class="cm">/*</span>
<span class="cm"> * Midi channel messages</span>
<span class="cm"> */</span>

<span class="cp">#define _CHN_COMMON(dev, event, chn, p1, p2, w14) \</span>
<span class="cp">					{_SEQ_NEEDBUF(8);\</span>
<span class="cp">					_seqbuf[_seqbufptr] = EV_CHN_COMMON;\</span>
<span class="cp">					_seqbuf[_seqbufptr+1] = (dev);\</span>
<span class="cp">					_seqbuf[_seqbufptr+2] = (event);\</span>
<span class="cp">					_seqbuf[_seqbufptr+3] = (chn);\</span>
<span class="cp">					_seqbuf[_seqbufptr+4] = (p1);\</span>
<span class="cp">					_seqbuf[_seqbufptr+5] = (p2);\</span>
<span class="cp">					*(short *)&amp;_seqbuf[_seqbufptr+6] = (w14);\</span>
<span class="cp">					_SEQ_ADVBUF(8);}</span>
<span class="cm">/*</span>
<span class="cm"> * SEQ_SYSEX permits sending of sysex messages. (It may look that it permits</span>
<span class="cm"> * sending any MIDI bytes but it&#39;s absolutely not possible. Trying to do</span>
<span class="cm"> * so _will_ cause problems with MPU401 intelligent mode).</span>
<span class="cm"> *</span>
<span class="cm"> * Sysex messages are sent in blocks of 1 to 6 bytes. Longer messages must be </span>
<span class="cm"> * sent by calling SEQ_SYSEX() several times (there must be no other events</span>
<span class="cm"> * between them). First sysex fragment must have 0xf0 in the first byte</span>
<span class="cm"> * and the last byte (buf[len-1] of the last fragment must be 0xf7. No byte</span>
<span class="cm"> * between these sysex start and end markers cannot be larger than 0x7f. Also</span>
<span class="cm"> * lengths of each fragments (except the last one) must be 6.</span>
<span class="cm"> *</span>
<span class="cm"> * Breaking the above rules may work with some MIDI ports but is likely to</span>
<span class="cm"> * cause fatal problems with some other devices (such as MPU401).</span>
<span class="cm"> */</span>
<span class="cp">#define SEQ_SYSEX(dev, buf, len) \</span>
<span class="cp">					{int ii, ll=(len); \</span>
<span class="cp">					 unsigned char *bufp=buf;\</span>
<span class="cp">					 if (ll&gt;6)ll=6;\</span>
<span class="cp">					_SEQ_NEEDBUF(8);\</span>
<span class="cp">					_seqbuf[_seqbufptr] = EV_SYSEX;\</span>
<span class="cp">					_seqbuf[_seqbufptr+1] = (dev);\</span>
<span class="cp">					for(ii=0;ii&lt;ll;ii++)\</span>
<span class="cp">					   _seqbuf[_seqbufptr+ii+2] = bufp[ii];\</span>
<span class="cp">					for(ii=ll;ii&lt;6;ii++)\</span>
<span class="cp">					   _seqbuf[_seqbufptr+ii+2] = 0xff;\</span>
<span class="cp">					_SEQ_ADVBUF(8);}</span>

<span class="cp">#define SEQ_CHN_PRESSURE(dev, chn, pressure) \</span>
<span class="cp">		_CHN_COMMON(dev, MIDI_CHN_PRESSURE, chn, pressure, 0, 0)</span>

<span class="cp">#define SEQ_SET_PATCH SEQ_PGM_CHANGE</span>
<span class="cp">#define SEQ_PGM_CHANGE(dev, chn, patch) \</span>
<span class="cp">		_CHN_COMMON(dev, MIDI_PGM_CHANGE, chn, patch, 0, 0)</span>

<span class="cp">#define SEQ_CONTROL(dev, chn, controller, value) \</span>
<span class="cp">		_CHN_COMMON(dev, MIDI_CTL_CHANGE, chn, controller, 0, value)</span>

<span class="cp">#define SEQ_BENDER(dev, chn, value) \</span>
<span class="cp">		_CHN_COMMON(dev, MIDI_PITCH_BEND, chn, 0, 0, value)</span>


<span class="cp">#define SEQ_V2_X_CONTROL(dev, voice, controller, value)	{_SEQ_NEEDBUF(8);\</span>
<span class="cp">					_seqbuf[_seqbufptr] = SEQ_EXTENDED;\</span>
<span class="cp">					_seqbuf[_seqbufptr+1] = SEQ_CONTROLLER;\</span>
<span class="cp">					_seqbuf[_seqbufptr+2] = (dev);\</span>
<span class="cp">					_seqbuf[_seqbufptr+3] = (voice);\</span>
<span class="cp">					_seqbuf[_seqbufptr+4] = (controller);\</span>
<span class="cp">					_seqbuf[_seqbufptr+5] = ((value)&amp;0xff);\</span>
<span class="cp">					_seqbuf[_seqbufptr+6] = ((value&gt;&gt;8)&amp;0xff);\</span>
<span class="cp">					_seqbuf[_seqbufptr+7] = 0;\</span>
<span class="cp">					_SEQ_ADVBUF(8);}</span>
<span class="cm">/*</span>
<span class="cm"> * The following 5 macros are incorrectly implemented and obsolete.</span>
<span class="cm"> * Use SEQ_BENDER and SEQ_CONTROL (with proper controller) instead.</span>
<span class="cm"> */</span>
<span class="cp">#define SEQ_PITCHBEND(dev, voice, value) SEQ_V2_X_CONTROL(dev, voice, CTRL_PITCH_BENDER, value)</span>
<span class="cp">#define SEQ_BENDER_RANGE(dev, voice, value) SEQ_V2_X_CONTROL(dev, voice, CTRL_PITCH_BENDER_RANGE, value)</span>
<span class="cp">#define SEQ_EXPRESSION(dev, voice, value) SEQ_CONTROL(dev, voice, CTL_EXPRESSION, value*128)</span>
<span class="cp">#define SEQ_MAIN_VOLUME(dev, voice, value) SEQ_CONTROL(dev, voice, CTL_MAIN_VOLUME, (value*16383)/100)</span>
<span class="cp">#define SEQ_PANNING(dev, voice, pos) SEQ_CONTROL(dev, voice, CTL_PAN, (pos+128) / 2)</span>

<span class="cm">/*</span>
<span class="cm"> * Timing and synchronization macros</span>
<span class="cm"> */</span>

<span class="cp">#define _TIMER_EVENT(ev, parm)		{_SEQ_NEEDBUF(8);\</span>
<span class="cp">				 	_seqbuf[_seqbufptr+0] = EV_TIMING; \</span>
<span class="cp">				 	_seqbuf[_seqbufptr+1] = (ev); \</span>
<span class="cp">					_seqbuf[_seqbufptr+2] = 0;\</span>
<span class="cp">					_seqbuf[_seqbufptr+3] = 0;\</span>
<span class="cp">				 	*(unsigned int *)&amp;_seqbuf[_seqbufptr+4] = (parm); \</span>
<span class="cp">					_SEQ_ADVBUF(8);}</span>

<span class="cp">#define SEQ_START_TIMER()		_TIMER_EVENT(TMR_START, 0)</span>
<span class="cp">#define SEQ_STOP_TIMER()		_TIMER_EVENT(TMR_STOP, 0)</span>
<span class="cp">#define SEQ_CONTINUE_TIMER()		_TIMER_EVENT(TMR_CONTINUE, 0)</span>
<span class="cp">#define SEQ_WAIT_TIME(ticks)		_TIMER_EVENT(TMR_WAIT_ABS, ticks)</span>
<span class="cp">#define SEQ_DELTA_TIME(ticks)		_TIMER_EVENT(TMR_WAIT_REL, ticks)</span>
<span class="cp">#define SEQ_ECHO_BACK(key)		_TIMER_EVENT(TMR_ECHO, key)</span>
<span class="cp">#define SEQ_SET_TEMPO(value)		_TIMER_EVENT(TMR_TEMPO, value)</span>
<span class="cp">#define SEQ_SONGPOS(pos)		_TIMER_EVENT(TMR_SPP, pos)</span>
<span class="cp">#define SEQ_TIME_SIGNATURE(sig)		_TIMER_EVENT(TMR_TIMESIG, sig)</span>

<span class="cm">/*</span>
<span class="cm"> * Local control events</span>
<span class="cm"> */</span>

<span class="cp">#define _LOCAL_EVENT(ev, parm)		{_SEQ_NEEDBUF(8);\</span>
<span class="cp">				 	_seqbuf[_seqbufptr+0] = EV_SEQ_LOCAL; \</span>
<span class="cp">				 	_seqbuf[_seqbufptr+1] = (ev); \</span>
<span class="cp">					_seqbuf[_seqbufptr+2] = 0;\</span>
<span class="cp">					_seqbuf[_seqbufptr+3] = 0;\</span>
<span class="cp">				 	*(unsigned int *)&amp;_seqbuf[_seqbufptr+4] = (parm); \</span>
<span class="cp">					_SEQ_ADVBUF(8);}</span>

<span class="cp">#define SEQ_PLAYAUDIO(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO, devmask)</span>
<span class="cm">/*</span>
<span class="cm"> * Events for the level 1 interface only </span>
<span class="cm"> */</span>

<span class="cp">#define SEQ_MIDIOUT(device, byte)	{_SEQ_NEEDBUF(4);\</span>
<span class="cp">					_seqbuf[_seqbufptr] = SEQ_MIDIPUTC;\</span>
<span class="cp">					_seqbuf[_seqbufptr+1] = (byte);\</span>
<span class="cp">					_seqbuf[_seqbufptr+2] = (device);\</span>
<span class="cp">					_seqbuf[_seqbufptr+3] = 0;\</span>
<span class="cp">					_SEQ_ADVBUF(4);}</span>

<span class="cm">/*</span>
<span class="cm"> * Patch loading.</span>
<span class="cm"> */</span>
<span class="cp">#define SEQ_WRPATCH(patchx, len) \</span>
<span class="cp">		{if (_seqbufptr) SEQ_DUMPBUF();\</span>
<span class="cp">		 if (write(seqfd, (char*)(patchx), len)==-1) \</span>
<span class="cp">		    perror(&quot;Write patch: /dev/sequencer&quot;);}</span>
<span class="cp">#define SEQ_WRPATCH2(patchx, len) \</span>
<span class="cp">		(SEQ_DUMPBUF(), write(seqfd, (char*)(patchx), len))</span>

<span class="cp">#endif</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
