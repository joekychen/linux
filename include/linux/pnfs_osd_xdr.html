<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › pnfs_osd_xdr.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pnfs_osd_xdr.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  pNFS-osd on-the-wire data structures</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2007 Panasas Inc. [year of first publication]</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Benny Halevy &lt;bhalevy@panasas.com&gt;</span>
<span class="cm"> *  Boaz Harrosh &lt;bharrosh@panasas.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License version 2</span>
<span class="cm"> *  See the file COPYING included with this distribution for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *     documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *  3. Neither the name of the Panasas company nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
<span class="cm"> *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span>
<span class="cm"> *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="cm"> *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="cm"> *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __PNFS_OSD_XDR_H__</span>
<span class="cp">#define __PNFS_OSD_XDR_H__</span>

<span class="cp">#include &lt;linux/nfs_fs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_page.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * draft-ietf-nfsv4-minorversion-22</span>
<span class="cm"> * draft-ietf-nfsv4-pnfs-obj-12</span>
<span class="cm"> */</span>

<span class="cm">/* Layout Structure */</span>

<span class="k">enum</span> <span class="n">pnfs_osd_raid_algorithm4</span> <span class="p">{</span>
	<span class="n">PNFS_OSD_RAID_0</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PNFS_OSD_RAID_4</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">PNFS_OSD_RAID_5</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">PNFS_OSD_RAID_PQ</span>	<span class="o">=</span> <span class="mi">4</span>     <span class="cm">/* Reed-Solomon P+Q */</span>
<span class="p">};</span>

<span class="cm">/*   struct pnfs_osd_data_map4 {</span>
<span class="cm"> *       uint32_t                    odm_num_comps;</span>
<span class="cm"> *       length4                     odm_stripe_unit;</span>
<span class="cm"> *       uint32_t                    odm_group_width;</span>
<span class="cm"> *       uint32_t                    odm_group_depth;</span>
<span class="cm"> *       uint32_t                    odm_mirror_cnt;</span>
<span class="cm"> *       pnfs_osd_raid_algorithm4    odm_raid_algorithm;</span>
<span class="cm"> *   };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_osd_data_map</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">odm_num_comps</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">odm_stripe_unit</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">odm_group_width</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">odm_group_depth</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">odm_mirror_cnt</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">odm_raid_algorithm</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*   struct pnfs_osd_objid4 {</span>
<span class="cm"> *       deviceid4       oid_device_id;</span>
<span class="cm"> *       uint64_t        oid_partition_id;</span>
<span class="cm"> *       uint64_t        oid_object_id;</span>
<span class="cm"> *   };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_osd_objid</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_deviceid</span>	<span class="n">oid_device_id</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">oid_partition_id</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">oid_object_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* For printout. I use:</span>
<span class="cm"> * kprint(&quot;dev(%llx:%llx)&quot;, _DEVID_LO(pointer), _DEVID_HI(pointer));</span>
<span class="cm"> * BE style</span>
<span class="cm"> */</span>
<span class="cp">#define _DEVID_LO(oid_device_id) \</span>
<span class="cp">	(unsigned long long)be64_to_cpup((__be64 *)(oid_device_id)-&gt;data)</span>

<span class="cp">#define _DEVID_HI(oid_device_id) \</span>
<span class="cp">	(unsigned long long)be64_to_cpup(((__be64 *)(oid_device_id)-&gt;data) + 1)</span>

<span class="k">enum</span> <span class="n">pnfs_osd_version</span> <span class="p">{</span>
	<span class="n">PNFS_OSD_MISSING</span>              <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PNFS_OSD_VERSION_1</span>            <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PNFS_OSD_VERSION_2</span>            <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pnfs_osd_opaque_cred</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">cred_len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">pnfs_osd_cap_key_sec</span> <span class="p">{</span>
	<span class="n">PNFS_OSD_CAP_KEY_SEC_NONE</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">PNFS_OSD_CAP_KEY_SEC_SSV</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*   struct pnfs_osd_object_cred4 {</span>
<span class="cm"> *       pnfs_osd_objid4         oc_object_id;</span>
<span class="cm"> *       pnfs_osd_version4       oc_osd_version;</span>
<span class="cm"> *       pnfs_osd_cap_key_sec4   oc_cap_key_sec;</span>
<span class="cm"> *       opaque                  oc_capability_key&lt;&gt;;</span>
<span class="cm"> *       opaque                  oc_capability&lt;&gt;;</span>
<span class="cm"> *   };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_osd_object_cred</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_objid</span>		<span class="n">oc_object_id</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">oc_osd_version</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">oc_cap_key_sec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_opaque_cred</span>	<span class="n">oc_cap_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_opaque_cred</span>	<span class="n">oc_cap</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*   struct pnfs_osd_layout4 {</span>
<span class="cm"> *       pnfs_osd_data_map4      olo_map;</span>
<span class="cm"> *       uint32_t                olo_comps_index;</span>
<span class="cm"> *       pnfs_osd_object_cred4   olo_components&lt;&gt;;</span>
<span class="cm"> *   };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_osd_layout</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_data_map</span>	<span class="n">olo_map</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">olo_comps_index</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">olo_num_comps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_object_cred</span>	<span class="o">*</span><span class="n">olo_comps</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Device Address */</span>
<span class="k">enum</span> <span class="n">pnfs_osd_targetid_type</span> <span class="p">{</span>
	<span class="n">OBJ_TARGET_ANON</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">OBJ_TARGET_SCSI_NAME</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">OBJ_TARGET_SCSI_DEVICE_ID</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*   union pnfs_osd_targetid4 switch (pnfs_osd_targetid_type4 oti_type) {</span>
<span class="cm"> *       case OBJ_TARGET_SCSI_NAME:</span>
<span class="cm"> *           string              oti_scsi_name&lt;&gt;;</span>
<span class="cm"> *</span>
<span class="cm"> *       case OBJ_TARGET_SCSI_DEVICE_ID:</span>
<span class="cm"> *           opaque              oti_scsi_device_id&lt;&gt;;</span>
<span class="cm"> *</span>
<span class="cm"> *       default:</span>
<span class="cm"> *           void;</span>
<span class="cm"> *   };</span>
<span class="cm"> *</span>
<span class="cm"> *   union pnfs_osd_targetaddr4 switch (bool ota_available) {</span>
<span class="cm"> *       case TRUE:</span>
<span class="cm"> *           netaddr4            ota_netaddr;</span>
<span class="cm"> *       case FALSE:</span>
<span class="cm"> *           void;</span>
<span class="cm"> *   };</span>
<span class="cm"> *</span>
<span class="cm"> *   struct pnfs_osd_deviceaddr4 {</span>
<span class="cm"> *       pnfs_osd_targetid4      oda_targetid;</span>
<span class="cm"> *       pnfs_osd_targetaddr4    oda_targetaddr;</span>
<span class="cm"> *       uint64_t                oda_lun;</span>
<span class="cm"> *       opaque                  oda_systemid&lt;&gt;;</span>
<span class="cm"> *       pnfs_osd_object_cred4   oda_root_obj_cred;</span>
<span class="cm"> *       opaque                  oda_osdname&lt;&gt;;</span>
<span class="cm"> *   };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_osd_targetid</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">oti_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_string</span>		<span class="n">oti_scsi_device_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*   struct netaddr4 {</span>
<span class="cm"> *       // see struct rpcb in RFC1833</span>
<span class="cm"> *       string r_netid&lt;&gt;;    // network id</span>
<span class="cm"> *       string r_addr&lt;&gt;;     // universal address</span>
<span class="cm"> *   };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_osd_net_addr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_string</span>	<span class="n">r_netid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_string</span>	<span class="n">r_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pnfs_osd_targetaddr</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">ota_available</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_net_addr</span>	<span class="n">ota_netaddr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pnfs_osd_deviceaddr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_targetid</span>	<span class="n">oda_targetid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_targetaddr</span>	<span class="n">oda_targetaddr</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">oda_lun</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">nfs4_string</span>		<span class="n">oda_systemid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_object_cred</span>	<span class="n">oda_root_obj_cred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_string</span>		<span class="n">oda_osdname</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* LAYOUTCOMMIT: layoutupdate */</span>

<span class="cm">/*   union pnfs_osd_deltaspaceused4 switch (bool dsu_valid) {</span>
<span class="cm"> *       case TRUE:</span>
<span class="cm"> *           int64_t     dsu_delta;</span>
<span class="cm"> *       case FALSE:</span>
<span class="cm"> *           void;</span>
<span class="cm"> *   };</span>
<span class="cm"> *</span>
<span class="cm"> *   struct pnfs_osd_layoutupdate4 {</span>
<span class="cm"> *       pnfs_osd_deltaspaceused4    olu_delta_space_used;</span>
<span class="cm"> *       bool                        olu_ioerr_flag;</span>
<span class="cm"> *   };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_osd_layoutupdate</span> <span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dsu_valid</span><span class="p">;</span>
	<span class="n">s64</span>	<span class="n">dsu_delta</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">olu_ioerr_flag</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* LAYOUTRETURN: I/O Rrror Report */</span>

<span class="k">enum</span> <span class="n">pnfs_osd_errno</span> <span class="p">{</span>
	<span class="n">PNFS_OSD_ERR_EIO</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">PNFS_OSD_ERR_NOT_FOUND</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">PNFS_OSD_ERR_NO_SPACE</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">PNFS_OSD_ERR_BAD_CRED</span>		<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">PNFS_OSD_ERR_NO_ACCESS</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">PNFS_OSD_ERR_UNREACHABLE</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">PNFS_OSD_ERR_RESOURCE</span>		<span class="o">=</span> <span class="mi">7</span>
<span class="p">};</span>

<span class="cm">/*   struct pnfs_osd_ioerr4 {</span>
<span class="cm"> *       pnfs_osd_objid4     oer_component;</span>
<span class="cm"> *       length4             oer_comp_offset;</span>
<span class="cm"> *       length4             oer_comp_length;</span>
<span class="cm"> *       bool                oer_iswrite;</span>
<span class="cm"> *       pnfs_osd_errno4     oer_errno;</span>
<span class="cm"> *   };</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_osd_ioerr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_objid</span>	<span class="n">oer_component</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">oer_comp_offset</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">oer_comp_length</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">oer_iswrite</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">oer_errno</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* OSD XDR Client API */</span>
<span class="cm">/* Layout helpers */</span>
<span class="cm">/* Layout decoding is done in two parts:</span>
<span class="cm"> * 1. First Call pnfs_osd_xdr_decode_layout_map to read in only the header part</span>
<span class="cm"> *    of the layout. @iter members need not be initialized.</span>
<span class="cm"> *    Returned:</span>
<span class="cm"> *             @layout members are set. (@layout-&gt;olo_comps set to NULL).</span>
<span class="cm"> *</span>
<span class="cm"> *             Zero on success, or negative error if passed xdr is broken.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. 2nd Call pnfs_osd_xdr_decode_layout_comp() in a loop until it returns</span>
<span class="cm"> *    false, to decode the next component.</span>
<span class="cm"> *    Returned:</span>
<span class="cm"> *       true if there is more to decode or false if we are done or error.</span>
<span class="cm"> *</span>
<span class="cm"> * Example:</span>
<span class="cm"> *	struct pnfs_osd_xdr_decode_layout_iter iter;</span>
<span class="cm"> *	struct pnfs_osd_layout layout;</span>
<span class="cm"> *	struct pnfs_osd_object_cred comp;</span>
<span class="cm"> *	int status;</span>
<span class="cm"> *</span>
<span class="cm"> *	status = pnfs_osd_xdr_decode_layout_map(&amp;layout, &amp;iter, xdr);</span>
<span class="cm"> *	if (unlikely(status))</span>
<span class="cm"> *		goto err;</span>
<span class="cm"> *	while(pnfs_osd_xdr_decode_layout_comp(&amp;comp, &amp;iter, xdr, &amp;status)) {</span>
<span class="cm"> *		// All of @comp strings point to inside the xdr_buffer</span>
<span class="cm"> *		// or scrach buffer. Copy them out to user memory eg.</span>
<span class="cm"> *		copy_single_comp(dest_comp++, &amp;comp);</span>
<span class="cm"> *	}</span>
<span class="cm"> *	if (unlikely(status))</span>
<span class="cm"> *		goto err;</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">pnfs_osd_xdr_decode_layout_iter</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">total_comps</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">decoded_comps</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">pnfs_osd_xdr_decode_layout_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_osd_layout</span> <span class="o">*</span><span class="n">layout</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_xdr_decode_layout_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span> <span class="n">pnfs_osd_xdr_decode_layout_comp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_osd_object_cred</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_xdr_decode_layout_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>

<span class="cm">/* Device Info helpers */</span>

<span class="cm">/* Note: All strings inside @deviceaddr point to space inside @p.</span>
<span class="cm"> * @p should stay valid while @deviceaddr is in use.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pnfs_osd_xdr_decode_deviceaddr</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_deviceaddr</span> <span class="o">*</span><span class="n">deviceaddr</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/* layoutupdate (layout_commit) xdr helpers */</span>
<span class="k">extern</span> <span class="kt">int</span>
<span class="n">pnfs_osd_xdr_encode_layoutupdate</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pnfs_osd_layoutupdate</span> <span class="o">*</span><span class="n">lou</span><span class="p">);</span>

<span class="cm">/* osd_ioerror encoding (layout_return) */</span>
<span class="k">extern</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">pnfs_osd_xdr_ioerr_reserve_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">pnfs_osd_xdr_encode_ioerr</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_ioerr</span> <span class="o">*</span><span class="n">ioerr</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __PNFS_OSD_XDR_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
