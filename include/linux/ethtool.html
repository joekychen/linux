<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › ethtool.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ethtool.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * ethtool.h: Defines for Linux ethtool.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1998 David S. Miller (davem@redhat.com)</span>
<span class="cm"> * Copyright 2001 Jeff Garzik &lt;jgarzik@pobox.com&gt;</span>
<span class="cm"> * Portions Copyright 2001 Sun Microsystems (thockin@sun.com)</span>
<span class="cm"> * Portions Copyright 2002 Intel (eli.kupermann@intel.com,</span>
<span class="cm"> *                                christopher.leech@intel.com,</span>
<span class="cm"> *                                scott.feldman@intel.com)</span>
<span class="cm"> * Portions Copyright (C) Sun Microsystems 2008</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_ETHTOOL_H</span>
<span class="cp">#define _LINUX_ETHTOOL_H</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>

<span class="cm">/* This should work for both 32 and 64 bit userland. */</span>
<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">supported</span><span class="p">;</span>	<span class="cm">/* Features this interface supports */</span>
	<span class="n">__u32</span>	<span class="n">advertising</span><span class="p">;</span>	<span class="cm">/* Features this interface advertises */</span>
	<span class="n">__u16</span>	<span class="n">speed</span><span class="p">;</span>	        <span class="cm">/* The forced speed (lower bits) in</span>
<span class="cm">				 * Mbps. Please use</span>
<span class="cm">				 * ethtool_cmd_speed()/_set() to</span>
<span class="cm">				 * access it */</span>
	<span class="n">__u8</span>	<span class="n">duplex</span><span class="p">;</span>		<span class="cm">/* Duplex, half or full */</span>
	<span class="n">__u8</span>	<span class="n">port</span><span class="p">;</span>		<span class="cm">/* Which connector port */</span>
	<span class="n">__u8</span>	<span class="n">phy_address</span><span class="p">;</span>	<span class="cm">/* MDIO PHY address (PRTAD for clause 45).</span>
<span class="cm">				 * May be read-only or read-write</span>
<span class="cm">				 * depending on the driver.</span>
<span class="cm">				 */</span>
	<span class="n">__u8</span>	<span class="n">transceiver</span><span class="p">;</span>	<span class="cm">/* Which transceiver to use */</span>
	<span class="n">__u8</span>	<span class="n">autoneg</span><span class="p">;</span>	<span class="cm">/* Enable or disable autonegotiation */</span>
	<span class="n">__u8</span>	<span class="n">mdio_support</span><span class="p">;</span>	<span class="cm">/* MDIO protocols supported.  Read-only.</span>
<span class="cm">				 * Not set by all drivers.</span>
<span class="cm">				 */</span>
	<span class="n">__u32</span>	<span class="n">maxtxpkt</span><span class="p">;</span>	<span class="cm">/* Tx pkts before generating tx int */</span>
	<span class="n">__u32</span>	<span class="n">maxrxpkt</span><span class="p">;</span>	<span class="cm">/* Rx pkts before generating rx int */</span>
	<span class="n">__u16</span>	<span class="n">speed_hi</span><span class="p">;</span>       <span class="cm">/* The forced speed (upper</span>
<span class="cm">				 * bits) in Mbps. Please use</span>
<span class="cm">				 * ethtool_cmd_speed()/_set() to</span>
<span class="cm">				 * access it */</span>
	<span class="n">__u8</span>	<span class="n">eth_tp_mdix</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">reserved2</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">lp_advertising</span><span class="p">;</span>	<span class="cm">/* Features the link partner advertises */</span>
	<span class="n">__u32</span>	<span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ethtool_cmd_speed_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
					 <span class="n">__u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u16</span><span class="p">)</span><span class="n">speed</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">speed_hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u16</span><span class="p">)(</span><span class="n">speed</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ethtool_cmd_speed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">speed_hi</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Device supports clause 22 register access to PHY or peripherals</span>
<span class="cm"> * using the interface defined in &lt;linux/mii.h&gt;.  This should not be</span>
<span class="cm"> * set if there are known to be no such peripherals present or if</span>
<span class="cm"> * the driver only emulates clause 22 registers for compatibility.</span>
<span class="cm"> */</span>
<span class="cp">#define ETH_MDIO_SUPPORTS_C22	1</span>

<span class="cm">/* Device supports clause 45 register access to PHY or peripherals</span>
<span class="cm"> * using the interface defined in &lt;linux/mii.h&gt; and &lt;linux/mdio.h&gt;.</span>
<span class="cm"> * This should not be set if there are known to be no such peripherals</span>
<span class="cm"> * present.</span>
<span class="cm"> */</span>
<span class="cp">#define ETH_MDIO_SUPPORTS_C45	2</span>

<span class="cp">#define ETHTOOL_FWVERS_LEN	32</span>
<span class="cp">#define ETHTOOL_BUSINFO_LEN	32</span>
<span class="cm">/* these strings are set to whatever the driver author decides... */</span>
<span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">driver</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* driver short name, &quot;tulip&quot;, &quot;eepro100&quot; */</span>
	<span class="kt">char</span>	<span class="n">version</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* driver version string */</span>
	<span class="kt">char</span>	<span class="n">fw_version</span><span class="p">[</span><span class="n">ETHTOOL_FWVERS_LEN</span><span class="p">];</span>	<span class="cm">/* firmware version string */</span>
	<span class="kt">char</span>	<span class="n">bus_info</span><span class="p">[</span><span class="n">ETHTOOL_BUSINFO_LEN</span><span class="p">];</span>	<span class="cm">/* Bus info for this IF. */</span>
				<span class="cm">/* For PCI devices, use pci_name(pci_dev). */</span>
	<span class="kt">char</span>	<span class="n">reserved1</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">char</span>	<span class="n">reserved2</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
				<span class="cm">/*</span>
<span class="cm">				 * Some struct members below are filled in</span>
<span class="cm">				 * using ops-&gt;get_sset_count().  Obtaining</span>
<span class="cm">				 * this info from ethtool_drvinfo is now</span>
<span class="cm">				 * deprecated; Use ETHTOOL_GSSET_INFO</span>
<span class="cm">				 * instead.</span>
<span class="cm">				 */</span>
	<span class="n">__u32</span>	<span class="n">n_priv_flags</span><span class="p">;</span>	<span class="cm">/* number of flags valid in ETHTOOL_GPFLAGS */</span>
	<span class="n">__u32</span>	<span class="n">n_stats</span><span class="p">;</span>	<span class="cm">/* number of u64&#39;s from ETHTOOL_GSTATS */</span>
	<span class="n">__u32</span>	<span class="n">testinfo_len</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">eedump_len</span><span class="p">;</span>	<span class="cm">/* Size of data from ETHTOOL_GEEPROM (bytes) */</span>
	<span class="n">__u32</span>	<span class="n">regdump_len</span><span class="p">;</span>	<span class="cm">/* Size of data from ETHTOOL_GREGS (bytes) */</span>
<span class="p">};</span>

<span class="cp">#define SOPASS_MAX	6</span>
<span class="cm">/* wake-on-lan settings */</span>
<span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">supported</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">wolopts</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">sopass</span><span class="p">[</span><span class="n">SOPASS_MAX</span><span class="p">];</span> <span class="cm">/* SecureOn(tm) password */</span>
<span class="p">};</span>

<span class="cm">/* for passing single values */</span>
<span class="k">struct</span> <span class="n">ethtool_value</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* for passing big chunks of data */</span>
<span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">version</span><span class="p">;</span> <span class="cm">/* driver-specific, indicates different chips/revs */</span>
	<span class="n">__u32</span>	<span class="n">len</span><span class="p">;</span> <span class="cm">/* bytes */</span>
	<span class="n">__u8</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* for passing EEPROM chunks */</span>
<span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">magic</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">offset</span><span class="p">;</span> <span class="cm">/* in bytes */</span>
	<span class="n">__u32</span>	<span class="n">len</span><span class="p">;</span> <span class="cm">/* in bytes */</span>
	<span class="n">__u8</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_modinfo - plugin module eeprom information</span>
<span class="cm"> * @cmd: %ETHTOOL_GMODULEINFO</span>
<span class="cm"> * @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx</span>
<span class="cm"> * @eeprom_len: Length of the eeprom</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to return the information to</span>
<span class="cm"> * properly size memory for a subsequent call to %ETHTOOL_GMODULEEEPROM.</span>
<span class="cm"> * The type code indicates the eeprom data format</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_modinfo</span> <span class="p">{</span>
	<span class="n">__u32</span>   <span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>   <span class="n">type</span><span class="p">;</span>
	<span class="n">__u32</span>   <span class="n">eeprom_len</span><span class="p">;</span>
	<span class="n">__u32</span>   <span class="n">reserved</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_coalesce - coalescing parameters for IRQs and stats updates</span>
<span class="cm"> * @cmd: ETHTOOL_{G,S}COALESCE</span>
<span class="cm"> * @rx_coalesce_usecs: How many usecs to delay an RX interrupt after</span>
<span class="cm"> *	a packet arrives.</span>
<span class="cm"> * @rx_max_coalesced_frames: Maximum number of packets to receive</span>
<span class="cm"> *	before an RX interrupt.</span>
<span class="cm"> * @rx_coalesce_usecs_irq: Same as @rx_coalesce_usecs, except that</span>
<span class="cm"> *	this value applies while an IRQ is being serviced by the host.</span>
<span class="cm"> * @rx_max_coalesced_frames_irq: Same as @rx_max_coalesced_frames,</span>
<span class="cm"> *	except that this value applies while an IRQ is being serviced</span>
<span class="cm"> *	by the host.</span>
<span class="cm"> * @tx_coalesce_usecs: How many usecs to delay a TX interrupt after</span>
<span class="cm"> *	a packet is sent.</span>
<span class="cm"> * @tx_max_coalesced_frames: Maximum number of packets to be sent</span>
<span class="cm"> *	before a TX interrupt.</span>
<span class="cm"> * @tx_coalesce_usecs_irq: Same as @tx_coalesce_usecs, except that</span>
<span class="cm"> *	this value applies while an IRQ is being serviced by the host.</span>
<span class="cm"> * @tx_max_coalesced_frames_irq: Same as @tx_max_coalesced_frames,</span>
<span class="cm"> *	except that this value applies while an IRQ is being serviced</span>
<span class="cm"> *	by the host.</span>
<span class="cm"> * @stats_block_coalesce_usecs: How many usecs to delay in-memory</span>
<span class="cm"> *	statistics block updates.  Some drivers do not have an</span>
<span class="cm"> *	in-memory statistic block, and in such cases this value is</span>
<span class="cm"> *	ignored.  This value must not be zero.</span>
<span class="cm"> * @use_adaptive_rx_coalesce: Enable adaptive RX coalescing.</span>
<span class="cm"> * @use_adaptive_tx_coalesce: Enable adaptive TX coalescing.</span>
<span class="cm"> * @pkt_rate_low: Threshold for low packet rate (packets per second).</span>
<span class="cm"> * @rx_coalesce_usecs_low: How many usecs to delay an RX interrupt after</span>
<span class="cm"> *	a packet arrives, when the packet rate is below @pkt_rate_low.</span>
<span class="cm"> * @rx_max_coalesced_frames_low: Maximum number of packets to be received</span>
<span class="cm"> *	before an RX interrupt, when the packet rate is below @pkt_rate_low.</span>
<span class="cm"> * @tx_coalesce_usecs_low: How many usecs to delay a TX interrupt after</span>
<span class="cm"> *	a packet is sent, when the packet rate is below @pkt_rate_low.</span>
<span class="cm"> * @tx_max_coalesced_frames_low: Maximum nuumber of packets to be sent before</span>
<span class="cm"> *	a TX interrupt, when the packet rate is below @pkt_rate_low.</span>
<span class="cm"> * @pkt_rate_high: Threshold for high packet rate (packets per second).</span>
<span class="cm"> * @rx_coalesce_usecs_high: How many usecs to delay an RX interrupt after</span>
<span class="cm"> *	a packet arrives, when the packet rate is above @pkt_rate_high.</span>
<span class="cm"> * @rx_max_coalesced_frames_high: Maximum number of packets to be received</span>
<span class="cm"> *	before an RX interrupt, when the packet rate is above @pkt_rate_high.</span>
<span class="cm"> * @tx_coalesce_usecs_high: How many usecs to delay a TX interrupt after</span>
<span class="cm"> *	a packet is sent, when the packet rate is above @pkt_rate_high.</span>
<span class="cm"> * @tx_max_coalesced_frames_high: Maximum number of packets to be sent before</span>
<span class="cm"> *	a TX interrupt, when the packet rate is above @pkt_rate_high.</span>
<span class="cm"> * @rate_sample_interval: How often to do adaptive coalescing packet rate</span>
<span class="cm"> *	sampling, measured in seconds.  Must not be zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Each pair of (usecs, max_frames) fields specifies this exit</span>
<span class="cm"> * condition for interrupt coalescing:</span>
<span class="cm"> *	(usecs &gt; 0 &amp;&amp; time_since_first_completion &gt;= usecs) ||</span>
<span class="cm"> *	(max_frames &gt; 0 &amp;&amp; completed_frames &gt;= max_frames)</span>
<span class="cm"> * It is illegal to set both usecs and max_frames to zero as this</span>
<span class="cm"> * would cause interrupts to never be generated.  To disable</span>
<span class="cm"> * coalescing, set usecs = 0 and max_frames = 1.</span>
<span class="cm"> *</span>
<span class="cm"> * Some implementations ignore the value of max_frames and use the</span>
<span class="cm"> * condition:</span>
<span class="cm"> *	time_since_first_completion &gt;= usecs</span>
<span class="cm"> * This is deprecated.  Drivers for hardware that does not support</span>
<span class="cm"> * counting completions should validate that max_frames == !rx_usecs.</span>
<span class="cm"> *</span>
<span class="cm"> * Adaptive RX/TX coalescing is an algorithm implemented by some</span>
<span class="cm"> * drivers to improve latency under low packet rates and improve</span>
<span class="cm"> * throughput under high packet rates.  Some drivers only implement</span>
<span class="cm"> * one of RX or TX adaptive coalescing.  Anything not implemented by</span>
<span class="cm"> * the driver causes these values to be silently ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * When the packet rate is below @pkt_rate_high but above</span>
<span class="cm"> * @pkt_rate_low (both measured in packets per second) the</span>
<span class="cm"> * normal {rx,tx}_* coalescing parameters are used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_coalesce_usecs</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_max_coalesced_frames</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_coalesce_usecs_irq</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_max_coalesced_frames_irq</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_coalesce_usecs</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_max_coalesced_frames</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_coalesce_usecs_irq</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_max_coalesced_frames_irq</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">stats_block_coalesce_usecs</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">use_adaptive_rx_coalesce</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">use_adaptive_tx_coalesce</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">pkt_rate_low</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_coalesce_usecs_low</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_max_coalesced_frames_low</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_coalesce_usecs_low</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_max_coalesced_frames_low</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">pkt_rate_high</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_coalesce_usecs_high</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_max_coalesced_frames_high</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_coalesce_usecs_high</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_max_coalesced_frames_high</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rate_sample_interval</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* for configuring RX/TX ring parameters */</span>
<span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>	<span class="cm">/* ETHTOOL_{G,S}RINGPARAM */</span>

	<span class="cm">/* Read only attributes.  These indicate the maximum number</span>
<span class="cm">	 * of pending RX/TX ring entries the driver will allow the</span>
<span class="cm">	 * user to set.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span>	<span class="n">rx_max_pending</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_mini_max_pending</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_jumbo_max_pending</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_max_pending</span><span class="p">;</span>

	<span class="cm">/* Values changeable by the user.  The valid values are</span>
<span class="cm">	 * in the range 1 to the &quot;*_max_pending&quot; counterpart above.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span>	<span class="n">rx_pending</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_mini_pending</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_jumbo_pending</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_pending</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_channels - configuring number of network channel</span>
<span class="cm"> * @cmd: ETHTOOL_{G,S}CHANNELS</span>
<span class="cm"> * @max_rx: Read only. Maximum number of receive channel the driver support.</span>
<span class="cm"> * @max_tx: Read only. Maximum number of transmit channel the driver support.</span>
<span class="cm"> * @max_other: Read only. Maximum number of other channel the driver support.</span>
<span class="cm"> * @max_combined: Read only. Maximum number of combined channel the driver</span>
<span class="cm"> *	support. Set of queues RX, TX or other.</span>
<span class="cm"> * @rx_count: Valid values are in the range 1 to the max_rx.</span>
<span class="cm"> * @tx_count: Valid values are in the range 1 to the max_tx.</span>
<span class="cm"> * @other_count: Valid values are in the range 1 to the max_other.</span>
<span class="cm"> * @combined_count: Valid values are in the range 1 to the max_combined.</span>
<span class="cm"> *</span>
<span class="cm"> * This can be used to configure RX, TX and other channels.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ethtool_channels</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">max_rx</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">max_tx</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">max_other</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">max_combined</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_count</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_count</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">other_count</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">combined_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* for configuring link flow control parameters */</span>
<span class="k">struct</span> <span class="n">ethtool_pauseparam</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>	<span class="cm">/* ETHTOOL_{G,S}PAUSEPARAM */</span>

	<span class="cm">/* If the link is being auto-negotiated (via ethtool_cmd.autoneg</span>
<span class="cm">	 * being true) the user may set &#39;autoneg&#39; here non-zero to have the</span>
<span class="cm">	 * pause parameters be auto-negotiated too.  In such a case, the</span>
<span class="cm">	 * {rx,tx}_pause values below determine what capabilities are</span>
<span class="cm">	 * advertised.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If &#39;autoneg&#39; is zero or the link is not being auto-negotiated,</span>
<span class="cm">	 * then {rx,tx}_pause force the driver to use/not-use pause</span>
<span class="cm">	 * flow control.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span>	<span class="n">autoneg</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_pause</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_pause</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define ETH_GSTRING_LEN		32</span>
<span class="k">enum</span> <span class="n">ethtool_stringset</span> <span class="p">{</span>
	<span class="n">ETH_SS_TEST</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ETH_SS_STATS</span><span class="p">,</span>
	<span class="n">ETH_SS_PRIV_FLAGS</span><span class="p">,</span>
	<span class="n">ETH_SS_NTUPLE_FILTERS</span><span class="p">,</span>	<span class="cm">/* Do not use, GRXNTUPLE is now deprecated */</span>
	<span class="n">ETH_SS_FEATURES</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* for passing string sets for data tagging */</span>
<span class="k">struct</span> <span class="n">ethtool_gstrings</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* ETHTOOL_GSTRINGS */</span>
	<span class="n">__u32</span>	<span class="n">string_set</span><span class="p">;</span>	<span class="cm">/* string set id e.c. ETH_SS_TEST, etc*/</span>
	<span class="n">__u32</span>	<span class="n">len</span><span class="p">;</span>		<span class="cm">/* number of strings in the string set */</span>
	<span class="n">__u8</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ethtool_sset_info</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* ETHTOOL_GSSET_INFO */</span>
	<span class="n">__u32</span>	<span class="n">reserved</span><span class="p">;</span>
	<span class="n">__u64</span>	<span class="n">sset_mask</span><span class="p">;</span>	<span class="cm">/* input: each bit selects an sset to query */</span>
				<span class="cm">/* output: each bit a returned sset */</span>
	<span class="n">__u32</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* ETH_SS_xxx count, in order, based on bits</span>
<span class="cm">				   in sset_mask.  One bit implies one</span>
<span class="cm">				   __u32, two bits implies two</span>
<span class="cm">				   __u32&#39;s, etc. */</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum ethtool_test_flags - flags definition of ethtool_test</span>
<span class="cm"> * @ETH_TEST_FL_OFFLINE: if set perform online and offline tests, otherwise</span>
<span class="cm"> *	only online tests.</span>
<span class="cm"> * @ETH_TEST_FL_FAILED: Driver set this flag if test fails.</span>
<span class="cm"> * @ETH_TEST_FL_EXTERNAL_LB: Application request to perform external loopback</span>
<span class="cm"> *	test.</span>
<span class="cm"> * @ETH_TEST_FL_EXTERNAL_LB_DONE: Driver performed the external loopback test</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">ethtool_test_flags</span> <span class="p">{</span>
	<span class="n">ETH_TEST_FL_OFFLINE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">ETH_TEST_FL_FAILED</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">ETH_TEST_FL_EXTERNAL_LB</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">ETH_TEST_FL_EXTERNAL_LB_DONE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* for requesting NIC test and getting results*/</span>
<span class="k">struct</span> <span class="n">ethtool_test</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* ETHTOOL_TEST */</span>
	<span class="n">__u32</span>	<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* ETH_TEST_FL_xxx */</span>
	<span class="n">__u32</span>	<span class="n">reserved</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">len</span><span class="p">;</span>		<span class="cm">/* result length, in number of u64 elements */</span>
	<span class="n">__u64</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* for dumping NIC-specific statistics */</span>
<span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* ETHTOOL_GSTATS */</span>
	<span class="n">__u32</span>	<span class="n">n_stats</span><span class="p">;</span>	<span class="cm">/* number of u64&#39;s being returned */</span>
	<span class="n">__u64</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ethtool_perm_addr</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* ETHTOOL_GPERMADDR */</span>
	<span class="n">__u32</span>	<span class="n">size</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* boolean flags controlling per-interface behavior characteristics.</span>
<span class="cm"> * When reading, the flag indicates whether or not a certain behavior</span>
<span class="cm"> * is enabled/present.  When writing, the flag indicates whether</span>
<span class="cm"> * or not the driver should turn on (set) or off (clear) a behavior.</span>
<span class="cm"> *</span>
<span class="cm"> * Some behaviors may read-only (unconditionally absent or present).</span>
<span class="cm"> * If such is the case, return EINVAL in the set-flags operation if the</span>
<span class="cm"> * flag differs from the read-only value.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ethtool_flags</span> <span class="p">{</span>
	<span class="n">ETH_FLAG_TXVLAN</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>	<span class="cm">/* TX VLAN offload enabled */</span>
	<span class="n">ETH_FLAG_RXVLAN</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* RX VLAN offload enabled */</span>
	<span class="n">ETH_FLAG_LRO</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>	<span class="cm">/* LRO is enabled */</span>
	<span class="n">ETH_FLAG_NTUPLE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">),</span>	<span class="cm">/* N-tuple filters enabled */</span>
	<span class="n">ETH_FLAG_RXHASH</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* The following structures are for supporting RX network flow</span>
<span class="cm"> * classification and RX n-tuple configuration. Note, all multibyte</span>
<span class="cm"> * fields, e.g., ip4src, ip4dst, psrc, pdst, spi, etc. are expected to</span>
<span class="cm"> * be in network byte order.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_tcpip4_spec - flow specification for TCP/IPv4 etc.</span>
<span class="cm"> * @ip4src: Source host</span>
<span class="cm"> * @ip4dst: Destination host</span>
<span class="cm"> * @psrc: Source port</span>
<span class="cm"> * @pdst: Destination port</span>
<span class="cm"> * @tos: Type-of-service</span>
<span class="cm"> *</span>
<span class="cm"> * This can be used to specify a TCP/IPv4, UDP/IPv4 or SCTP/IPv4 flow.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_tcpip4_spec</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">ip4src</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">ip4dst</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">psrc</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">pdst</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">tos</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_ah_espip4_spec - flow specification for IPsec/IPv4</span>
<span class="cm"> * @ip4src: Source host</span>
<span class="cm"> * @ip4dst: Destination host</span>
<span class="cm"> * @spi: Security parameters index</span>
<span class="cm"> * @tos: Type-of-service</span>
<span class="cm"> *</span>
<span class="cm"> * This can be used to specify an IPsec transport or tunnel over IPv4.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_ah_espip4_spec</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">ip4src</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">ip4dst</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">spi</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">tos</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define	ETH_RX_NFC_IP4	1</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_usrip4_spec - general flow specification for IPv4</span>
<span class="cm"> * @ip4src: Source host</span>
<span class="cm"> * @ip4dst: Destination host</span>
<span class="cm"> * @l4_4_bytes: First 4 bytes of transport (layer 4) header</span>
<span class="cm"> * @tos: Type-of-service</span>
<span class="cm"> * @ip_ver: Value must be %ETH_RX_NFC_IP4; mask must be 0</span>
<span class="cm"> * @proto: Transport protocol number; mask must be 0</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_usrip4_spec</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">ip4src</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">ip4dst</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">l4_4_bytes</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">tos</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">ip_ver</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">proto</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">ethtool_flow_union</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethtool_tcpip4_spec</span>		<span class="n">tcp_ip4_spec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_tcpip4_spec</span>		<span class="n">udp_ip4_spec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_tcpip4_spec</span>		<span class="n">sctp_ip4_spec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_ah_espip4_spec</span>		<span class="n">ah_ip4_spec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_ah_espip4_spec</span>		<span class="n">esp_ip4_spec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_usrip4_spec</span>		<span class="n">usr_ip4_spec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span>				<span class="n">ether_spec</span><span class="p">;</span>
	<span class="n">__u8</span>					<span class="n">hdata</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ethtool_flow_ext</span> <span class="p">{</span>
	<span class="n">__be16</span>	<span class="n">vlan_etype</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">vlan_tci</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_rx_flow_spec - classification rule for RX flows</span>
<span class="cm"> * @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW</span>
<span class="cm"> * @h_u: Flow fields to match (dependent on @flow_type)</span>
<span class="cm"> * @h_ext: Additional fields to match</span>
<span class="cm"> * @m_u: Masks for flow field bits to be matched</span>
<span class="cm"> * @m_ext: Masks for additional field bits to be matched</span>
<span class="cm"> *	Note, all additional fields must be ignored unless @flow_type</span>
<span class="cm"> *	includes the %FLOW_EXT flag.</span>
<span class="cm"> * @ring_cookie: RX ring/queue index to deliver to, or %RX_CLS_FLOW_DISC</span>
<span class="cm"> *	if packets should be discarded</span>
<span class="cm"> * @location: Location of rule in the table.  Locations must be</span>
<span class="cm"> *	numbered such that a flow matching multiple rules will be</span>
<span class="cm"> *	classified according to the first (lowest numbered) rule.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_rx_flow_spec</span> <span class="p">{</span>
	<span class="n">__u32</span>		<span class="n">flow_type</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ethtool_flow_union</span> <span class="n">h_u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_flow_ext</span> <span class="n">h_ext</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ethtool_flow_union</span> <span class="n">m_u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_flow_ext</span> <span class="n">m_ext</span><span class="p">;</span>
	<span class="n">__u64</span>		<span class="n">ring_cookie</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">location</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_rxnfc - command to get or set RX flow classification rules</span>
<span class="cm"> * @cmd: Specific command number - %ETHTOOL_GRXFH, %ETHTOOL_SRXFH,</span>
<span class="cm"> *	%ETHTOOL_GRXRINGS, %ETHTOOL_GRXCLSRLCNT, %ETHTOOL_GRXCLSRULE,</span>
<span class="cm"> *	%ETHTOOL_GRXCLSRLALL, %ETHTOOL_SRXCLSRLDEL or %ETHTOOL_SRXCLSRLINS</span>
<span class="cm"> * @flow_type: Type of flow to be affected, e.g. %TCP_V4_FLOW</span>
<span class="cm"> * @data: Command-dependent value</span>
<span class="cm"> * @fs: Flow classification rule</span>
<span class="cm"> * @rule_cnt: Number of rules to be affected</span>
<span class="cm"> * @rule_locs: Array of used rule locations</span>
<span class="cm"> *</span>
<span class="cm"> * For %ETHTOOL_GRXFH and %ETHTOOL_SRXFH, @data is a bitmask indicating</span>
<span class="cm"> * the fields included in the flow hash, e.g. %RXH_IP_SRC.  The following</span>
<span class="cm"> * structure fields must not be used.</span>
<span class="cm"> *</span>
<span class="cm"> * For %ETHTOOL_GRXRINGS, @data is set to the number of RX rings/queues</span>
<span class="cm"> * on return.</span>
<span class="cm"> *</span>
<span class="cm"> * For %ETHTOOL_GRXCLSRLCNT, @rule_cnt is set to the number of defined</span>
<span class="cm"> * rules on return.  If @data is non-zero on return then it is the</span>
<span class="cm"> * size of the rule table, plus the flag %RX_CLS_LOC_SPECIAL if the</span>
<span class="cm"> * driver supports any special location values.  If that flag is not</span>
<span class="cm"> * set in @data then special location values should not be used.</span>
<span class="cm"> *</span>
<span class="cm"> * For %ETHTOOL_GRXCLSRULE, @fs.@location specifies the location of an</span>
<span class="cm"> * existing rule on entry and @fs contains the rule on return.</span>
<span class="cm"> *</span>
<span class="cm"> * For %ETHTOOL_GRXCLSRLALL, @rule_cnt specifies the array size of the</span>
<span class="cm"> * user buffer for @rule_locs on entry.  On return, @data is the size</span>
<span class="cm"> * of the rule table, @rule_cnt is the number of defined rules, and</span>
<span class="cm"> * @rule_locs contains the locations of the defined rules.  Drivers</span>
<span class="cm"> * must use the second parameter to get_rxnfc() instead of @rule_locs.</span>
<span class="cm"> *</span>
<span class="cm"> * For %ETHTOOL_SRXCLSRLINS, @fs specifies the rule to add or update.</span>
<span class="cm"> * @fs.@location either specifies the location to use or is a special</span>
<span class="cm"> * location value with %RX_CLS_LOC_SPECIAL flag set.  On return,</span>
<span class="cm"> * @fs.@location is the actual rule location.</span>
<span class="cm"> *</span>
<span class="cm"> * For %ETHTOOL_SRXCLSRLDEL, @fs.@location specifies the location of an</span>
<span class="cm"> * existing rule on entry.</span>
<span class="cm"> *</span>
<span class="cm"> * A driver supporting the special location values for</span>
<span class="cm"> * %ETHTOOL_SRXCLSRLINS may add the rule at any suitable unused</span>
<span class="cm"> * location, and may remove a rule at a later location (lower</span>
<span class="cm"> * priority) that matches exactly the same set of flows.  The special</span>
<span class="cm"> * values are: %RX_CLS_LOC_ANY, selecting any location;</span>
<span class="cm"> * %RX_CLS_LOC_FIRST, selecting the first suitable location (maximum</span>
<span class="cm"> * priority); and %RX_CLS_LOC_LAST, selecting the last suitable</span>
<span class="cm"> * location (minimum priority).  Additional special values may be</span>
<span class="cm"> * defined in future and drivers must return -%EINVAL for any</span>
<span class="cm"> * unrecognised value.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_rxnfc</span> <span class="p">{</span>
	<span class="n">__u32</span>				<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>				<span class="n">flow_type</span><span class="p">;</span>
	<span class="n">__u64</span>				<span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_rx_flow_spec</span>	<span class="n">fs</span><span class="p">;</span>
	<span class="n">__u32</span>				<span class="n">rule_cnt</span><span class="p">;</span>
	<span class="n">__u32</span>				<span class="n">rule_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>

<span class="k">struct</span> <span class="n">compat_ethtool_rx_flow_spec</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">flow_type</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ethtool_flow_union</span> <span class="n">h_u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_flow_ext</span> <span class="n">h_ext</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ethtool_flow_union</span> <span class="n">m_u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_flow_ext</span> <span class="n">m_ext</span><span class="p">;</span>
	<span class="n">compat_u64</span>	<span class="n">ring_cookie</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">location</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">compat_ethtool_rxnfc</span> <span class="p">{</span>
	<span class="n">u32</span>				<span class="n">cmd</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">flow_type</span><span class="p">;</span>
	<span class="n">compat_u64</span>			<span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_ethtool_rx_flow_spec</span> <span class="n">fs</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">rule_cnt</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">rule_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_COMPAT */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_rxfh_indir - command to get or set RX flow hash indirection</span>
<span class="cm"> * @cmd: Specific command number - %ETHTOOL_GRXFHINDIR or %ETHTOOL_SRXFHINDIR</span>
<span class="cm"> * @size: On entry, the array size of the user buffer, which may be zero.</span>
<span class="cm"> *	On return from %ETHTOOL_GRXFHINDIR, the array size of the hardware</span>
<span class="cm"> *	indirection table.</span>
<span class="cm"> * @ring_index: RX ring/queue index for each hash value</span>
<span class="cm"> *</span>
<span class="cm"> * For %ETHTOOL_GRXFHINDIR, a @size of zero means that only the size</span>
<span class="cm"> * should be returned.  For %ETHTOOL_SRXFHINDIR, a @size of zero means</span>
<span class="cm"> * the table should be reset to default values.  This last feature</span>
<span class="cm"> * is not supported by the original implementations.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_rxfh_indir</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">size</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">ring_index</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_rx_ntuple_flow_spec - specification for RX flow filter</span>
<span class="cm"> * @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW</span>
<span class="cm"> * @h_u: Flow field values to match (dependent on @flow_type)</span>
<span class="cm"> * @m_u: Masks for flow field value bits to be ignored</span>
<span class="cm"> * @vlan_tag: VLAN tag to match</span>
<span class="cm"> * @vlan_tag_mask: Mask for VLAN tag bits to be ignored</span>
<span class="cm"> * @data: Driver-dependent data to match</span>
<span class="cm"> * @data_mask: Mask for driver-dependent data bits to be ignored</span>
<span class="cm"> * @action: RX ring/queue index to deliver to (non-negative) or other action</span>
<span class="cm"> *	(negative, e.g. %ETHTOOL_RXNTUPLE_ACTION_DROP)</span>
<span class="cm"> *</span>
<span class="cm"> * For flow types %TCP_V4_FLOW, %UDP_V4_FLOW and %SCTP_V4_FLOW, where</span>
<span class="cm"> * a field value and mask are both zero this is treated as if all mask</span>
<span class="cm"> * bits are set i.e. the field is ignored.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_rx_ntuple_flow_spec</span> <span class="p">{</span>
	<span class="n">__u32</span>		 <span class="n">flow_type</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ethtool_tcpip4_spec</span>		<span class="n">tcp_ip4_spec</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ethtool_tcpip4_spec</span>		<span class="n">udp_ip4_spec</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ethtool_tcpip4_spec</span>		<span class="n">sctp_ip4_spec</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ethtool_ah_espip4_spec</span>		<span class="n">ah_ip4_spec</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ethtool_ah_espip4_spec</span>		<span class="n">esp_ip4_spec</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ethtool_usrip4_spec</span>		<span class="n">usr_ip4_spec</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ethhdr</span>				<span class="n">ether_spec</span><span class="p">;</span>
		<span class="n">__u8</span>					<span class="n">hdata</span><span class="p">[</span><span class="mi">72</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">h_u</span><span class="p">,</span> <span class="n">m_u</span><span class="p">;</span>

	<span class="n">__u16</span>	        <span class="n">vlan_tag</span><span class="p">;</span>
	<span class="n">__u16</span>	        <span class="n">vlan_tag_mask</span><span class="p">;</span>
	<span class="n">__u64</span>		<span class="n">data</span><span class="p">;</span>
	<span class="n">__u64</span>		<span class="n">data_mask</span><span class="p">;</span>

	<span class="n">__s32</span>		<span class="n">action</span><span class="p">;</span>
<span class="cp">#define ETHTOOL_RXNTUPLE_ACTION_DROP	(-1)	</span><span class="cm">/* drop packet */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_RXNTUPLE_ACTION_CLEAR	(-2)	</span><span class="cm">/* clear filter */</span><span class="cp"></span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_rx_ntuple - command to set or clear RX flow filter</span>
<span class="cm"> * @cmd: Command number - %ETHTOOL_SRXNTUPLE</span>
<span class="cm"> * @fs: Flow filter specification</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_rx_ntuple</span> <span class="p">{</span>
	<span class="n">__u32</span>					<span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_rx_ntuple_flow_spec</span>	<span class="n">fs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define ETHTOOL_FLASH_MAX_FILENAME	128</span>
<span class="k">enum</span> <span class="n">ethtool_flash_op_type</span> <span class="p">{</span>
	<span class="n">ETHTOOL_FLASH_ALL_REGIONS</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* for passing firmware flashing related parameters */</span>
<span class="k">struct</span> <span class="n">ethtool_flash</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">region</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">data</span><span class="p">[</span><span class="n">ETHTOOL_FLASH_MAX_FILENAME</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_dump - used for retrieving, setting device dump</span>
<span class="cm"> * @cmd: Command number - %ETHTOOL_GET_DUMP_FLAG, %ETHTOOL_GET_DUMP_DATA, or</span>
<span class="cm"> * 	%ETHTOOL_SET_DUMP</span>
<span class="cm"> * @version: FW version of the dump, filled in by driver</span>
<span class="cm"> * @flag: driver dependent flag for dump setting, filled in by driver during</span>
<span class="cm"> *        get and filled in by ethtool for set operation.</span>
<span class="cm"> *        flag must be initialized by macro ETH_FW_DUMP_DISABLE value when</span>
<span class="cm"> *        firmware dump is disabled.</span>
<span class="cm"> * @len: length of dump data, used as the length of the user buffer on entry to</span>
<span class="cm"> * 	 %ETHTOOL_GET_DUMP_DATA and this is returned as dump length by driver</span>
<span class="cm"> * 	 for %ETHTOOL_GET_DUMP_FLAG command</span>
<span class="cm"> * @data: data collected for get dump data operation</span>
<span class="cm"> */</span>

<span class="cp">#define ETH_FW_DUMP_DISABLE 0</span>

<span class="k">struct</span> <span class="n">ethtool_dump</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">version</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">flag</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">len</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* for returning and changing feature sets */</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_get_features_block - block with state of 32 features</span>
<span class="cm"> * @available: mask of changeable features</span>
<span class="cm"> * @requested: mask of features requested to be enabled if possible</span>
<span class="cm"> * @active: mask of currently enabled features</span>
<span class="cm"> * @never_changed: mask of features not changeable for any device</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_get_features_block</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">available</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">requested</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">active</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">never_changed</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_gfeatures - command to get state of device&#39;s features</span>
<span class="cm"> * @cmd: command number = %ETHTOOL_GFEATURES</span>
<span class="cm"> * @size: in: number of elements in the features[] array;</span>
<span class="cm"> *       out: number of elements in features[] needed to hold all features</span>
<span class="cm"> * @features: state of features</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_gfeatures</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_get_features_block</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_set_features_block - block with request for 32 features</span>
<span class="cm"> * @valid: mask of features to be changed</span>
<span class="cm"> * @requested: values of features to be changed</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_set_features_block</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">valid</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">requested</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_sfeatures - command to request change in device&#39;s features</span>
<span class="cm"> * @cmd: command number = %ETHTOOL_SFEATURES</span>
<span class="cm"> * @size: array size of the features[] array</span>
<span class="cm"> * @features: feature change masks</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_sfeatures</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_set_features_block</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_ts_info - holds a device&#39;s timestamping and PHC association</span>
<span class="cm"> * @cmd: command number = %ETHTOOL_GET_TS_INFO</span>
<span class="cm"> * @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags</span>
<span class="cm"> * @phc_index: device index of the associated PHC, or -1 if there is none</span>
<span class="cm"> * @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values</span>
<span class="cm"> * @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values</span>
<span class="cm"> *</span>
<span class="cm"> * The bits in the &#39;tx_types&#39; and &#39;rx_filters&#39; fields correspond to</span>
<span class="cm"> * the &#39;hwtstamp_tx_types&#39; and &#39;hwtstamp_rx_filters&#39; enumeration values,</span>
<span class="cm"> * respectively.  For example, if the device supports HWTSTAMP_TX_ON,</span>
<span class="cm"> * then (1 &lt;&lt; HWTSTAMP_TX_ON) in &#39;tx_types&#39; will be set.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_ts_info</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">so_timestamping</span><span class="p">;</span>
	<span class="n">__s32</span>	<span class="n">phc_index</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_types</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">tx_reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__u32</span>	<span class="n">rx_filters</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">rx_reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * %ETHTOOL_SFEATURES changes features present in features[].valid to the</span>
<span class="cm"> * values of corresponding bits in features[].requested. Bits in .requested</span>
<span class="cm"> * not set in .valid or not changeable are ignored.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %EINVAL when .valid contains undefined or never-changeable bits</span>
<span class="cm"> * or size is not equal to required number of features words (32-bit blocks).</span>
<span class="cm"> * Returns &gt;= 0 if request was completed; bits set in the value mean:</span>
<span class="cm"> *   %ETHTOOL_F_UNSUPPORTED - there were bits set in .valid that are not</span>
<span class="cm"> *	changeable (not present in %ETHTOOL_GFEATURES&#39; features[].available)</span>
<span class="cm"> *	those bits were ignored.</span>
<span class="cm"> *   %ETHTOOL_F_WISH - some or all changes requested were recorded but the</span>
<span class="cm"> *      resulting state of bits masked by .valid is not equal to .requested.</span>
<span class="cm"> *      Probably there are other device-specific constraints on some features</span>
<span class="cm"> *      in the set. When %ETHTOOL_F_UNSUPPORTED is set, .valid is considered</span>
<span class="cm"> *      here as though ignored bits were cleared.</span>
<span class="cm"> *   %ETHTOOL_F_COMPAT - some or all changes requested were made by calling</span>
<span class="cm"> *      compatibility functions. Requested offload state cannot be properly</span>
<span class="cm"> *      managed by kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Meaning of bits in the masks are obtained by %ETHTOOL_GSSET_INFO (number of</span>
<span class="cm"> * bits in the arrays - always multiple of 32) and %ETHTOOL_GSTRINGS commands</span>
<span class="cm"> * for ETH_SS_FEATURES string set. First entry in the table corresponds to least</span>
<span class="cm"> * significant bit in features[0] fields. Empty strings mark undefined features.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ethtool_sfeatures_retval_bits</span> <span class="p">{</span>
	<span class="n">ETHTOOL_F_UNSUPPORTED__BIT</span><span class="p">,</span>
	<span class="n">ETHTOOL_F_WISH__BIT</span><span class="p">,</span>
	<span class="n">ETHTOOL_F_COMPAT__BIT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define ETHTOOL_F_UNSUPPORTED   (1 &lt;&lt; ETHTOOL_F_UNSUPPORTED__BIT)</span>
<span class="cp">#define ETHTOOL_F_WISH          (1 &lt;&lt; ETHTOOL_F_WISH__BIT)</span>
<span class="cp">#define ETHTOOL_F_COMPAT        (1 &lt;&lt; ETHTOOL_F_COMPAT__BIT)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cp">#include &lt;linux/rculist.h&gt;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ethtool_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * enum ethtool_phys_id_state - indicator state for physical identification</span>
<span class="cm"> * @ETHTOOL_ID_INACTIVE: Physical ID indicator should be deactivated</span>
<span class="cm"> * @ETHTOOL_ID_ACTIVE: Physical ID indicator should be activated</span>
<span class="cm"> * @ETHTOOL_ID_ON: LED should be turned on (used iff %ETHTOOL_ID_ACTIVE</span>
<span class="cm"> *	is not supported)</span>
<span class="cm"> * @ETHTOOL_ID_OFF: LED should be turned off (used iff %ETHTOOL_ID_ACTIVE</span>
<span class="cm"> *	is not supported)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ethtool_phys_id_state</span> <span class="p">{</span>
	<span class="n">ETHTOOL_ID_INACTIVE</span><span class="p">,</span>
	<span class="n">ETHTOOL_ID_ACTIVE</span><span class="p">,</span>
	<span class="n">ETHTOOL_ID_ON</span><span class="p">,</span>
	<span class="n">ETHTOOL_ID_OFF</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">net_device</span><span class="p">;</span>

<span class="cm">/* Some generic methods drivers may use in their ethtool_ops */</span>
<span class="n">u32</span> <span class="n">ethtool_op_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ethtool_op_get_ts_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_ts_info</span> <span class="o">*</span><span class="n">eti</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ethtool_rxfh_indir_default - get default value for RX flow hash indirection</span>
<span class="cm"> * @index: Index in RX flow hash indirection table</span>
<span class="cm"> * @n_rx_rings: Number of RX rings to use</span>
<span class="cm"> *</span>
<span class="cm"> * This function provides the default policy for RX flow hash indirection.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ethtool_rxfh_indir_default</span><span class="p">(</span><span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">n_rx_rings</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">index</span> <span class="o">%</span> <span class="n">n_rx_rings</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct ethtool_ops - optional netdev operations</span>
<span class="cm"> * @get_settings: Get various device settings including Ethernet link</span>
<span class="cm"> *	settings. The @cmd parameter is expected to have been cleared</span>
<span class="cm"> *	before get_settings is called. Returns a negative error code or</span>
<span class="cm"> *	zero.</span>
<span class="cm"> * @set_settings: Set various device settings including Ethernet link</span>
<span class="cm"> *	settings.  Returns a negative error code or zero.</span>
<span class="cm"> * @get_drvinfo: Report driver/device information.  Should only set the</span>
<span class="cm"> *	@driver, @version, @fw_version and @bus_info fields.  If not</span>
<span class="cm"> *	implemented, the @driver and @bus_info fields will be filled in</span>
<span class="cm"> *	according to the netdev&#39;s parent device.</span>
<span class="cm"> * @get_regs_len: Get buffer length required for @get_regs</span>
<span class="cm"> * @get_regs: Get device registers</span>
<span class="cm"> * @get_wol: Report whether Wake-on-Lan is enabled</span>
<span class="cm"> * @set_wol: Turn Wake-on-Lan on or off.  Returns a negative error code</span>
<span class="cm"> *	or zero.</span>
<span class="cm"> * @get_msglevel: Report driver message level.  This should be the value</span>
<span class="cm"> *	of the @msg_enable field used by netif logging functions.</span>
<span class="cm"> * @set_msglevel: Set driver message level</span>
<span class="cm"> * @nway_reset: Restart autonegotiation.  Returns a negative error code</span>
<span class="cm"> *	or zero.</span>
<span class="cm"> * @get_link: Report whether physical link is up.  Will only be called if</span>
<span class="cm"> *	the netdev is up.  Should usually be set to ethtool_op_get_link(),</span>
<span class="cm"> *	which uses netif_carrier_ok().</span>
<span class="cm"> * @get_eeprom: Read data from the device EEPROM.</span>
<span class="cm"> *	Should fill in the magic field.  Don&#39;t need to check len for zero</span>
<span class="cm"> *	or wraparound.  Fill in the data argument with the eeprom values</span>
<span class="cm"> *	from offset to offset + len.  Update len to the amount read.</span>
<span class="cm"> *	Returns an error or zero.</span>
<span class="cm"> * @set_eeprom: Write data to the device EEPROM.</span>
<span class="cm"> *	Should validate the magic field.  Don&#39;t need to check len for zero</span>
<span class="cm"> *	or wraparound.  Update len to the amount written.  Returns an error</span>
<span class="cm"> *	or zero.</span>
<span class="cm"> * @get_coalesce: Get interrupt coalescing parameters.  Returns a negative</span>
<span class="cm"> *	error code or zero.</span>
<span class="cm"> * @set_coalesce: Set interrupt coalescing parameters.  Returns a negative</span>
<span class="cm"> *	error code or zero.</span>
<span class="cm"> * @get_ringparam: Report ring sizes</span>
<span class="cm"> * @set_ringparam: Set ring sizes.  Returns a negative error code or zero.</span>
<span class="cm"> * @get_pauseparam: Report pause parameters</span>
<span class="cm"> * @set_pauseparam: Set pause parameters.  Returns a negative error code</span>
<span class="cm"> *	or zero.</span>
<span class="cm"> * @self_test: Run specified self-tests</span>
<span class="cm"> * @get_strings: Return a set of strings that describe the requested objects</span>
<span class="cm"> * @set_phys_id: Identify the physical devices, e.g. by flashing an LED</span>
<span class="cm"> *	attached to it.  The implementation may update the indicator</span>
<span class="cm"> *	asynchronously or synchronously, but in either case it must return</span>
<span class="cm"> *	quickly.  It is initially called with the argument %ETHTOOL_ID_ACTIVE,</span>
<span class="cm"> *	and must either activate asynchronous updates and return zero, return</span>
<span class="cm"> *	a negative error or return a positive frequency for synchronous</span>
<span class="cm"> *	indication (e.g. 1 for one on/off cycle per second).  If it returns</span>
<span class="cm"> *	a frequency then it will be called again at intervals with the</span>
<span class="cm"> *	argument %ETHTOOL_ID_ON or %ETHTOOL_ID_OFF and should set the state of</span>
<span class="cm"> *	the indicator accordingly.  Finally, it is called with the argument</span>
<span class="cm"> *	%ETHTOOL_ID_INACTIVE and must deactivate the indicator.  Returns a</span>
<span class="cm"> *	negative error code or zero.</span>
<span class="cm"> * @get_ethtool_stats: Return extended statistics about the device.</span>
<span class="cm"> *	This is only useful if the device maintains statistics not</span>
<span class="cm"> *	included in &amp;struct rtnl_link_stats64.</span>
<span class="cm"> * @begin: Function to be called before any other operation.  Returns a</span>
<span class="cm"> *	negative error code or zero.</span>
<span class="cm"> * @complete: Function to be called after any other operation except</span>
<span class="cm"> *	@begin.  Will be called even if the other operation failed.</span>
<span class="cm"> * @get_priv_flags: Report driver-specific feature flags.</span>
<span class="cm"> * @set_priv_flags: Set driver-specific feature flags.  Returns a negative</span>
<span class="cm"> *	error code or zero.</span>
<span class="cm"> * @get_sset_count: Get number of strings that @get_strings will write.</span>
<span class="cm"> * @get_rxnfc: Get RX flow classification rules.  Returns a negative</span>
<span class="cm"> *	error code or zero.</span>
<span class="cm"> * @set_rxnfc: Set RX flow classification rules.  Returns a negative</span>
<span class="cm"> *	error code or zero.</span>
<span class="cm"> * @flash_device: Write a firmware image to device&#39;s flash memory.</span>
<span class="cm"> *	Returns a negative error code or zero.</span>
<span class="cm"> * @reset: Reset (part of) the device, as specified by a bitmask of</span>
<span class="cm"> *	flags from &amp;enum ethtool_reset_flags.  Returns a negative</span>
<span class="cm"> *	error code or zero.</span>
<span class="cm"> * @get_rxfh_indir_size: Get the size of the RX flow hash indirection table.</span>
<span class="cm"> *	Returns zero if not supported for this specific device.</span>
<span class="cm"> * @get_rxfh_indir: Get the contents of the RX flow hash indirection table.</span>
<span class="cm"> *	Will not be called if @get_rxfh_indir_size returns zero.</span>
<span class="cm"> *	Returns a negative error code or zero.</span>
<span class="cm"> * @set_rxfh_indir: Set the contents of the RX flow hash indirection table.</span>
<span class="cm"> *	Will not be called if @get_rxfh_indir_size returns zero.</span>
<span class="cm"> *	Returns a negative error code or zero.</span>
<span class="cm"> * @get_channels: Get number of channels.</span>
<span class="cm"> * @set_channels: Set number of channels.  Returns a negative error code or</span>
<span class="cm"> *	zero.</span>
<span class="cm"> * @get_dump_flag: Get dump flag indicating current dump length, version,</span>
<span class="cm"> * 		   and flag of the device.</span>
<span class="cm"> * @get_dump_data: Get dump data.</span>
<span class="cm"> * @set_dump: Set dump specific flags to the device.</span>
<span class="cm"> * @get_ts_info: Get the time stamping and PTP hardware clock capabilities.</span>
<span class="cm"> *	Drivers supporting transmit time stamps in software should set this to</span>
<span class="cm"> *	ethtool_op_get_ts_info().</span>
<span class="cm"> * @get_module_info: Get the size and type of the eeprom contained within</span>
<span class="cm"> *	a plug-in module.</span>
<span class="cm"> * @get_module_eeprom: Get the eeprom information from the plug-in module</span>
<span class="cm"> *</span>
<span class="cm"> * All operations are optional (i.e. the function pointer may be set</span>
<span class="cm"> * to %NULL) and callers must take this into account.  Callers must</span>
<span class="cm"> * hold the RTNL lock.</span>
<span class="cm"> *</span>
<span class="cm"> * See the structures used by these operations for further documentation.</span>
<span class="cm"> *</span>
<span class="cm"> * See &amp;struct net_device and &amp;struct net_device_ops for documentation</span>
<span class="cm"> * of the generic netdev features interface.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_settings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_settings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_drvinfo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_regs_len</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_regs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_wol</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_wol</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_wolinfo</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_msglevel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_msglevel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">nway_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_link</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_eeprom_len</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_eeprom</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_eeprom</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_coalesce</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_coalesce</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_coalesce</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_ringparam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_ringparam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ethtool_ringparam</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_pauseparam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ethtool_pauseparam</span><span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_pauseparam</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ethtool_pauseparam</span><span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">self_test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_test</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_strings</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stringset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_phys_id</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ethtool_phys_id_state</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_ethtool_stats</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">complete</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_priv_flags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_priv_flags</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_sset_count</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_rxnfc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ethtool_rxnfc</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">rule_locs</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_rxnfc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_rxnfc</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">flash_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_flash</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_rxfh_indir_size</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_rxfh_indir</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_rxfh_indir</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_channels</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_channels</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_channels</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_channels</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_dump_flag</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_dump</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_dump_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ethtool_dump</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">set_dump</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_dump</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_ts_info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_ts_info</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">get_module_info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ethtool_modinfo</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">get_module_eeprom</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>


<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cm">/* CMDs currently supported */</span>
<span class="cp">#define ETHTOOL_GSET		0x00000001 </span><span class="cm">/* Get settings. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SSET		0x00000002 </span><span class="cm">/* Set settings. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GDRVINFO	0x00000003 </span><span class="cm">/* Get driver info. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GREGS		0x00000004 </span><span class="cm">/* Get NIC registers. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GWOL		0x00000005 </span><span class="cm">/* Get wake-on-lan options. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SWOL		0x00000006 </span><span class="cm">/* Set wake-on-lan options. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GMSGLVL		0x00000007 </span><span class="cm">/* Get driver message level */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SMSGLVL		0x00000008 </span><span class="cm">/* Set driver msg level. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_NWAY_RST	0x00000009 </span><span class="cm">/* Restart autonegotiation. */</span><span class="cp"></span>
<span class="cm">/* Get link status for host, i.e. whether the interface *and* the</span>
<span class="cm"> * physical port (if there is one) are up (ethtool_value). */</span>
<span class="cp">#define ETHTOOL_GLINK		0x0000000a</span>
<span class="cp">#define ETHTOOL_GEEPROM		0x0000000b </span><span class="cm">/* Get EEPROM data */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SEEPROM		0x0000000c </span><span class="cm">/* Set EEPROM data. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GCOALESCE	0x0000000e </span><span class="cm">/* Get coalesce config */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SCOALESCE	0x0000000f </span><span class="cm">/* Set coalesce config. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GRINGPARAM	0x00000010 </span><span class="cm">/* Get ring parameters */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SRINGPARAM	0x00000011 </span><span class="cm">/* Set ring parameters. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GPAUSEPARAM	0x00000012 </span><span class="cm">/* Get pause parameters */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SPAUSEPARAM	0x00000013 </span><span class="cm">/* Set pause parameters. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GRXCSUM		0x00000014 </span><span class="cm">/* Get RX hw csum enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SRXCSUM		0x00000015 </span><span class="cm">/* Set RX hw csum enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GTXCSUM		0x00000016 </span><span class="cm">/* Get TX hw csum enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_STXCSUM		0x00000017 </span><span class="cm">/* Set TX hw csum enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GSG		0x00000018 </span><span class="cm">/* Get scatter-gather enable</span>
<span class="cm">					    * (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SSG		0x00000019 </span><span class="cm">/* Set scatter-gather enable</span>
<span class="cm">					    * (ethtool_value). */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_TEST		0x0000001a </span><span class="cm">/* execute NIC self-test. */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GSTRINGS	0x0000001b </span><span class="cm">/* get specified string set */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_PHYS_ID		0x0000001c </span><span class="cm">/* identify the NIC */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GSTATS		0x0000001d </span><span class="cm">/* get NIC-specific statistics */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GTSO		0x0000001e </span><span class="cm">/* Get TSO enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_STSO		0x0000001f </span><span class="cm">/* Set TSO enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GPERMADDR	0x00000020 </span><span class="cm">/* Get permanent hardware address */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GUFO		0x00000021 </span><span class="cm">/* Get UFO enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SUFO		0x00000022 </span><span class="cm">/* Set UFO enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GGSO		0x00000023 </span><span class="cm">/* Get GSO enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SGSO		0x00000024 </span><span class="cm">/* Set GSO enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GFLAGS		0x00000025 </span><span class="cm">/* Get flags bitmap(ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SFLAGS		0x00000026 </span><span class="cm">/* Set flags bitmap(ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GPFLAGS		0x00000027 </span><span class="cm">/* Get driver-private flags bitmap */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SPFLAGS		0x00000028 </span><span class="cm">/* Set driver-private flags bitmap */</span><span class="cp"></span>

<span class="cp">#define ETHTOOL_GRXFH		0x00000029 </span><span class="cm">/* Get RX flow hash configuration */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SRXFH		0x0000002a </span><span class="cm">/* Set RX flow hash configuration */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GGRO		0x0000002b </span><span class="cm">/* Get GRO enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SGRO		0x0000002c </span><span class="cm">/* Set GRO enable (ethtool_value) */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GRXRINGS	0x0000002d </span><span class="cm">/* Get RX rings available for LB */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GRXCLSRLCNT	0x0000002e </span><span class="cm">/* Get RX class rule count */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GRXCLSRULE	0x0000002f </span><span class="cm">/* Get RX classification rule */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GRXCLSRLALL	0x00000030 </span><span class="cm">/* Get all RX classification rule */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SRXCLSRLDEL	0x00000031 </span><span class="cm">/* Delete RX classification rule */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SRXCLSRLINS	0x00000032 </span><span class="cm">/* Insert RX classification rule */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_FLASHDEV	0x00000033 </span><span class="cm">/* Flash firmware to device */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_RESET		0x00000034 </span><span class="cm">/* Reset hardware */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SRXNTUPLE	0x00000035 </span><span class="cm">/* Add an n-tuple filter to device */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GRXNTUPLE	0x00000036 </span><span class="cm">/* deprecated */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GSSET_INFO	0x00000037 </span><span class="cm">/* Get string set info */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GRXFHINDIR	0x00000038 </span><span class="cm">/* Get RX flow hash indir&#39;n table */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SRXFHINDIR	0x00000039 </span><span class="cm">/* Set RX flow hash indir&#39;n table */</span><span class="cp"></span>

<span class="cp">#define ETHTOOL_GFEATURES	0x0000003a </span><span class="cm">/* Get device offload settings */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SFEATURES	0x0000003b </span><span class="cm">/* Change device offload settings */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GCHANNELS	0x0000003c </span><span class="cm">/* Get no of channels */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SCHANNELS	0x0000003d </span><span class="cm">/* Set no of channels */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_SET_DUMP	0x0000003e </span><span class="cm">/* Set dump settings */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GET_DUMP_FLAG	0x0000003f </span><span class="cm">/* Get dump settings */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GET_DUMP_DATA	0x00000040 </span><span class="cm">/* Get dump data */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GET_TS_INFO	0x00000041 </span><span class="cm">/* Get time stamping and PHC info */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GMODULEINFO	0x00000042 </span><span class="cm">/* Get plug-in module information */</span><span class="cp"></span>
<span class="cp">#define ETHTOOL_GMODULEEEPROM	0x00000043 </span><span class="cm">/* Get plug-in module eeprom */</span><span class="cp"></span>

<span class="cm">/* compatibility with older code */</span>
<span class="cp">#define SPARC_ETH_GSET		ETHTOOL_GSET</span>
<span class="cp">#define SPARC_ETH_SSET		ETHTOOL_SSET</span>

<span class="cm">/* Indicates what features are supported by the interface. */</span>
<span class="cp">#define SUPPORTED_10baseT_Half		(1 &lt;&lt; 0)</span>
<span class="cp">#define SUPPORTED_10baseT_Full		(1 &lt;&lt; 1)</span>
<span class="cp">#define SUPPORTED_100baseT_Half		(1 &lt;&lt; 2)</span>
<span class="cp">#define SUPPORTED_100baseT_Full		(1 &lt;&lt; 3)</span>
<span class="cp">#define SUPPORTED_1000baseT_Half	(1 &lt;&lt; 4)</span>
<span class="cp">#define SUPPORTED_1000baseT_Full	(1 &lt;&lt; 5)</span>
<span class="cp">#define SUPPORTED_Autoneg		(1 &lt;&lt; 6)</span>
<span class="cp">#define SUPPORTED_TP			(1 &lt;&lt; 7)</span>
<span class="cp">#define SUPPORTED_AUI			(1 &lt;&lt; 8)</span>
<span class="cp">#define SUPPORTED_MII			(1 &lt;&lt; 9)</span>
<span class="cp">#define SUPPORTED_FIBRE			(1 &lt;&lt; 10)</span>
<span class="cp">#define SUPPORTED_BNC			(1 &lt;&lt; 11)</span>
<span class="cp">#define SUPPORTED_10000baseT_Full	(1 &lt;&lt; 12)</span>
<span class="cp">#define SUPPORTED_Pause			(1 &lt;&lt; 13)</span>
<span class="cp">#define SUPPORTED_Asym_Pause		(1 &lt;&lt; 14)</span>
<span class="cp">#define SUPPORTED_2500baseX_Full	(1 &lt;&lt; 15)</span>
<span class="cp">#define SUPPORTED_Backplane		(1 &lt;&lt; 16)</span>
<span class="cp">#define SUPPORTED_1000baseKX_Full	(1 &lt;&lt; 17)</span>
<span class="cp">#define SUPPORTED_10000baseKX4_Full	(1 &lt;&lt; 18)</span>
<span class="cp">#define SUPPORTED_10000baseKR_Full	(1 &lt;&lt; 19)</span>
<span class="cp">#define SUPPORTED_10000baseR_FEC	(1 &lt;&lt; 20)</span>
<span class="cp">#define SUPPORTED_20000baseMLD2_Full	(1 &lt;&lt; 21)</span>
<span class="cp">#define SUPPORTED_20000baseKR2_Full	(1 &lt;&lt; 22)</span>

<span class="cm">/* Indicates what features are advertised by the interface. */</span>
<span class="cp">#define ADVERTISED_10baseT_Half		(1 &lt;&lt; 0)</span>
<span class="cp">#define ADVERTISED_10baseT_Full		(1 &lt;&lt; 1)</span>
<span class="cp">#define ADVERTISED_100baseT_Half	(1 &lt;&lt; 2)</span>
<span class="cp">#define ADVERTISED_100baseT_Full	(1 &lt;&lt; 3)</span>
<span class="cp">#define ADVERTISED_1000baseT_Half	(1 &lt;&lt; 4)</span>
<span class="cp">#define ADVERTISED_1000baseT_Full	(1 &lt;&lt; 5)</span>
<span class="cp">#define ADVERTISED_Autoneg		(1 &lt;&lt; 6)</span>
<span class="cp">#define ADVERTISED_TP			(1 &lt;&lt; 7)</span>
<span class="cp">#define ADVERTISED_AUI			(1 &lt;&lt; 8)</span>
<span class="cp">#define ADVERTISED_MII			(1 &lt;&lt; 9)</span>
<span class="cp">#define ADVERTISED_FIBRE		(1 &lt;&lt; 10)</span>
<span class="cp">#define ADVERTISED_BNC			(1 &lt;&lt; 11)</span>
<span class="cp">#define ADVERTISED_10000baseT_Full	(1 &lt;&lt; 12)</span>
<span class="cp">#define ADVERTISED_Pause		(1 &lt;&lt; 13)</span>
<span class="cp">#define ADVERTISED_Asym_Pause		(1 &lt;&lt; 14)</span>
<span class="cp">#define ADVERTISED_2500baseX_Full	(1 &lt;&lt; 15)</span>
<span class="cp">#define ADVERTISED_Backplane		(1 &lt;&lt; 16)</span>
<span class="cp">#define ADVERTISED_1000baseKX_Full	(1 &lt;&lt; 17)</span>
<span class="cp">#define ADVERTISED_10000baseKX4_Full	(1 &lt;&lt; 18)</span>
<span class="cp">#define ADVERTISED_10000baseKR_Full	(1 &lt;&lt; 19)</span>
<span class="cp">#define ADVERTISED_10000baseR_FEC	(1 &lt;&lt; 20)</span>
<span class="cp">#define ADVERTISED_20000baseMLD2_Full	(1 &lt;&lt; 21)</span>
<span class="cp">#define ADVERTISED_20000baseKR2_Full	(1 &lt;&lt; 22)</span>

<span class="cm">/* The following are all involved in forcing a particular link</span>
<span class="cm"> * mode for the device for setting things.  When getting the</span>
<span class="cm"> * devices settings, these indicate the current mode and whether</span>
<span class="cm"> * it was forced up into this mode or autonegotiated.</span>
<span class="cm"> */</span>

<span class="cm">/* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb, 10GbE. */</span>
<span class="cp">#define SPEED_10		10</span>
<span class="cp">#define SPEED_100		100</span>
<span class="cp">#define SPEED_1000		1000</span>
<span class="cp">#define SPEED_2500		2500</span>
<span class="cp">#define SPEED_10000		10000</span>
<span class="cp">#define SPEED_UNKNOWN		-1</span>

<span class="cm">/* Duplex, half or full. */</span>
<span class="cp">#define DUPLEX_HALF		0x00</span>
<span class="cp">#define DUPLEX_FULL		0x01</span>
<span class="cp">#define DUPLEX_UNKNOWN		0xff</span>

<span class="cm">/* Which connector port. */</span>
<span class="cp">#define PORT_TP			0x00</span>
<span class="cp">#define PORT_AUI		0x01</span>
<span class="cp">#define PORT_MII		0x02</span>
<span class="cp">#define PORT_FIBRE		0x03</span>
<span class="cp">#define PORT_BNC		0x04</span>
<span class="cp">#define PORT_DA			0x05</span>
<span class="cp">#define PORT_NONE		0xef</span>
<span class="cp">#define PORT_OTHER		0xff</span>

<span class="cm">/* Which transceiver to use. */</span>
<span class="cp">#define XCVR_INTERNAL		0x00</span>
<span class="cp">#define XCVR_EXTERNAL		0x01</span>
<span class="cp">#define XCVR_DUMMY1		0x02</span>
<span class="cp">#define XCVR_DUMMY2		0x03</span>
<span class="cp">#define XCVR_DUMMY3		0x04</span>

<span class="cm">/* Enable or disable autonegotiation.  If this is set to enable,</span>
<span class="cm"> * the forced link modes above are completely ignored.</span>
<span class="cm"> */</span>
<span class="cp">#define AUTONEG_DISABLE		0x00</span>
<span class="cp">#define AUTONEG_ENABLE		0x01</span>

<span class="cm">/* Mode MDI or MDI-X */</span>
<span class="cp">#define ETH_TP_MDI_INVALID	0x00</span>
<span class="cp">#define ETH_TP_MDI		0x01</span>
<span class="cp">#define ETH_TP_MDI_X		0x02</span>

<span class="cm">/* Wake-On-Lan options. */</span>
<span class="cp">#define WAKE_PHY		(1 &lt;&lt; 0)</span>
<span class="cp">#define WAKE_UCAST		(1 &lt;&lt; 1)</span>
<span class="cp">#define WAKE_MCAST		(1 &lt;&lt; 2)</span>
<span class="cp">#define WAKE_BCAST		(1 &lt;&lt; 3)</span>
<span class="cp">#define WAKE_ARP		(1 &lt;&lt; 4)</span>
<span class="cp">#define WAKE_MAGIC		(1 &lt;&lt; 5)</span>
<span class="cp">#define WAKE_MAGICSECURE	(1 &lt;&lt; 6) </span><span class="cm">/* only meaningful if WAKE_MAGIC */</span><span class="cp"></span>

<span class="cm">/* L2-L4 network traffic flow types */</span>
<span class="cp">#define	TCP_V4_FLOW	0x01	</span><span class="cm">/* hash or spec (tcp_ip4_spec) */</span><span class="cp"></span>
<span class="cp">#define	UDP_V4_FLOW	0x02	</span><span class="cm">/* hash or spec (udp_ip4_spec) */</span><span class="cp"></span>
<span class="cp">#define	SCTP_V4_FLOW	0x03	</span><span class="cm">/* hash or spec (sctp_ip4_spec) */</span><span class="cp"></span>
<span class="cp">#define	AH_ESP_V4_FLOW	0x04	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	TCP_V6_FLOW	0x05	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	UDP_V6_FLOW	0x06	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	SCTP_V6_FLOW	0x07	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	AH_ESP_V6_FLOW	0x08	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	AH_V4_FLOW	0x09	</span><span class="cm">/* hash or spec (ah_ip4_spec) */</span><span class="cp"></span>
<span class="cp">#define	ESP_V4_FLOW	0x0a	</span><span class="cm">/* hash or spec (esp_ip4_spec) */</span><span class="cp"></span>
<span class="cp">#define	AH_V6_FLOW	0x0b	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	ESP_V6_FLOW	0x0c	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	IP_USER_FLOW	0x0d	</span><span class="cm">/* spec only (usr_ip4_spec) */</span><span class="cp"></span>
<span class="cp">#define	IPV4_FLOW	0x10	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	IPV6_FLOW	0x11	</span><span class="cm">/* hash only */</span><span class="cp"></span>
<span class="cp">#define	ETHER_FLOW	0x12	</span><span class="cm">/* spec only (ether_spec) */</span><span class="cp"></span>
<span class="cm">/* Flag to enable additional fields in struct ethtool_rx_flow_spec */</span>
<span class="cp">#define	FLOW_EXT	0x80000000</span>

<span class="cm">/* L3-L4 network traffic flow hash options */</span>
<span class="cp">#define	RXH_L2DA	(1 &lt;&lt; 1)</span>
<span class="cp">#define	RXH_VLAN	(1 &lt;&lt; 2)</span>
<span class="cp">#define	RXH_L3_PROTO	(1 &lt;&lt; 3)</span>
<span class="cp">#define	RXH_IP_SRC	(1 &lt;&lt; 4)</span>
<span class="cp">#define	RXH_IP_DST	(1 &lt;&lt; 5)</span>
<span class="cp">#define	RXH_L4_B_0_1	(1 &lt;&lt; 6) </span><span class="cm">/* src port in case of TCP/UDP/SCTP */</span><span class="cp"></span>
<span class="cp">#define	RXH_L4_B_2_3	(1 &lt;&lt; 7) </span><span class="cm">/* dst port in case of TCP/UDP/SCTP */</span><span class="cp"></span>
<span class="cp">#define	RXH_DISCARD	(1 &lt;&lt; 31)</span>

<span class="cp">#define	RX_CLS_FLOW_DISC	0xffffffffffffffffULL</span>

<span class="cm">/* Special RX classification rule insert location values */</span>
<span class="cp">#define RX_CLS_LOC_SPECIAL	0x80000000	</span><span class="cm">/* flag */</span><span class="cp"></span>
<span class="cp">#define RX_CLS_LOC_ANY		0xffffffff</span>
<span class="cp">#define RX_CLS_LOC_FIRST	0xfffffffe</span>
<span class="cp">#define RX_CLS_LOC_LAST		0xfffffffd</span>

<span class="cm">/* EEPROM Standards for plug in modules */</span>
<span class="cp">#define ETH_MODULE_SFF_8079		0x1</span>
<span class="cp">#define ETH_MODULE_SFF_8079_LEN		256</span>
<span class="cp">#define ETH_MODULE_SFF_8472		0x2</span>
<span class="cp">#define ETH_MODULE_SFF_8472_LEN		512</span>

<span class="cm">/* Reset flags */</span>
<span class="cm">/* The reset() operation must clear the flags for the components which</span>
<span class="cm"> * were actually reset.  On successful return, the flags indicate the</span>
<span class="cm"> * components which were not reset, either because they do not exist</span>
<span class="cm"> * in the hardware or because they cannot be reset independently.  The</span>
<span class="cm"> * driver must never reset any components that were not requested.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ethtool_reset_flags</span> <span class="p">{</span>
	<span class="cm">/* These flags represent components dedicated to the interface</span>
<span class="cm">	 * the command is addressed to.  Shift any flag left by</span>
<span class="cm">	 * ETH_RESET_SHARED_SHIFT to reset a shared component of the</span>
<span class="cm">	 * same type.</span>
<span class="cm">	 */</span>
	<span class="n">ETH_RESET_MGMT</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Management processor */</span>
	<span class="n">ETH_RESET_IRQ</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Interrupt requester */</span>
	<span class="n">ETH_RESET_DMA</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* DMA engine */</span>
	<span class="n">ETH_RESET_FILTER</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* Filtering/flow direction */</span>
	<span class="n">ETH_RESET_OFFLOAD</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* Protocol offload */</span>
	<span class="n">ETH_RESET_MAC</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* Media access controller */</span>
	<span class="n">ETH_RESET_PHY</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* Transceiver/PHY */</span>
	<span class="n">ETH_RESET_RAM</span>		<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* RAM shared between</span>
<span class="cm">						 * multiple components */</span>

	<span class="n">ETH_RESET_DEDICATED</span>	<span class="o">=</span> <span class="mh">0x0000ffff</span><span class="p">,</span>	<span class="cm">/* All components dedicated to</span>
<span class="cm">						 * this interface */</span>
	<span class="n">ETH_RESET_ALL</span>		<span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">,</span>	<span class="cm">/* All components used by this</span>
<span class="cm">						 * interface, even if shared */</span>
<span class="p">};</span>
<span class="cp">#define ETH_RESET_SHARED_SHIFT	16</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_ETHTOOL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
