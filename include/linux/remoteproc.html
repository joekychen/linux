<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › remoteproc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>remoteproc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Remote Processor Framework</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright(c) 2011 Texas Instruments, Inc.</span>
<span class="cm"> * Copyright(c) 2011 Google, Inc.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> * * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *   notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *   notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *   the documentation and/or other materials provided with the</span>
<span class="cm"> *   distribution.</span>
<span class="cm"> * * Neither the name Texas Instruments nor the names of its</span>
<span class="cm"> *   contributors may be used to endorse or promote products derived</span>
<span class="cm"> *   from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef REMOTEPROC_H</span>
<span class="cp">#define REMOTEPROC_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/klist.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/virtio.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * struct resource_table - firmware resource table header</span>
<span class="cm"> * @ver: version number</span>
<span class="cm"> * @num: number of resource entries</span>
<span class="cm"> * @reserved: reserved (must be zero)</span>
<span class="cm"> * @offset: array of offsets pointing at the various resource entries</span>
<span class="cm"> *</span>
<span class="cm"> * A resource table is essentially a list of system resources required</span>
<span class="cm"> * by the remote processor. It may also include configuration entries.</span>
<span class="cm"> * If needed, the remote processor firmware should contain this table</span>
<span class="cm"> * as a dedicated &quot;.resource_table&quot; ELF section.</span>
<span class="cm"> *</span>
<span class="cm"> * Some resources entries are mere announcements, where the host is informed</span>
<span class="cm"> * of specific remoteproc configuration. Other entries require the host to</span>
<span class="cm"> * do something (e.g. allocate a system resource). Sometimes a negotiation</span>
<span class="cm"> * is expected, where the firmware requests a resource, and once allocated,</span>
<span class="cm"> * the host should provide back its details (e.g. address of an allocated</span>
<span class="cm"> * memory region).</span>
<span class="cm"> *</span>
<span class="cm"> * The header of the resource table, as expressed by this structure,</span>
<span class="cm"> * contains a version number (should we need to change this format in the</span>
<span class="cm"> * future), the number of available resource entries, and their offsets</span>
<span class="cm"> * in the table.</span>
<span class="cm"> *</span>
<span class="cm"> * Immediately following this header are the resource entries themselves,</span>
<span class="cm"> * each of which begins with a resource entry header (as described below).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">resource_table</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">ver</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_rsc_hdr - firmware resource entry header</span>
<span class="cm"> * @type: resource type</span>
<span class="cm"> * @data: resource data</span>
<span class="cm"> *</span>
<span class="cm"> * Every resource entry begins with a &#39;struct fw_rsc_hdr&#39; header providing</span>
<span class="cm"> * its @type. The content of the entry itself will immediately follow</span>
<span class="cm"> * this header, and it should be parsed according to the resource type.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_rsc_hdr</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * enum fw_resource_type - types of resource entries</span>
<span class="cm"> *</span>
<span class="cm"> * @RSC_CARVEOUT:   request for allocation of a physically contiguous</span>
<span class="cm"> *		    memory region.</span>
<span class="cm"> * @RSC_DEVMEM:     request to iommu_map a memory-based peripheral.</span>
<span class="cm"> * @RSC_TRACE:	    announces the availability of a trace buffer into which</span>
<span class="cm"> *		    the remote processor will be writing logs.</span>
<span class="cm"> * @RSC_VDEV:       declare support for a virtio device, and serve as its</span>
<span class="cm"> *		    virtio header.</span>
<span class="cm"> * @RSC_LAST:       just keep this one at the end</span>
<span class="cm"> *</span>
<span class="cm"> * For more details regarding a specific resource type, please see its</span>
<span class="cm"> * dedicated structure below.</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that these values are used as indices to the rproc_handle_rsc</span>
<span class="cm"> * lookup table, so please keep them sane. Moreover, @RSC_LAST is used to</span>
<span class="cm"> * check the validity of an index before the lookup table is accessed, so</span>
<span class="cm"> * please update it as needed.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">fw_resource_type</span> <span class="p">{</span>
	<span class="n">RSC_CARVEOUT</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RSC_DEVMEM</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RSC_TRACE</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">RSC_VDEV</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RSC_LAST</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define FW_RSC_ADDR_ANY (0xFFFFFFFFFFFFFFFF)</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_rsc_carveout - physically contiguous memory request</span>
<span class="cm"> * @da: device address</span>
<span class="cm"> * @pa: physical address</span>
<span class="cm"> * @len: length (in bytes)</span>
<span class="cm"> * @flags: iommu protection flags</span>
<span class="cm"> * @reserved: reserved (must be zero)</span>
<span class="cm"> * @name: human-readable name of the requested memory region</span>
<span class="cm"> *</span>
<span class="cm"> * This resource entry requests the host to allocate a physically contiguous</span>
<span class="cm"> * memory region.</span>
<span class="cm"> *</span>
<span class="cm"> * These request entries should precede other firmware resource entries,</span>
<span class="cm"> * as other entries might request placing other data objects inside</span>
<span class="cm"> * these memory regions (e.g. data/code segments, trace resource entries, ...).</span>
<span class="cm"> *</span>
<span class="cm"> * Allocating memory this way helps utilizing the reserved physical memory</span>
<span class="cm"> * (e.g. CMA) more efficiently, and also minimizes the number of TLB entries</span>
<span class="cm"> * needed to map it (in case @rproc is using an IOMMU). Reducing the TLB</span>
<span class="cm"> * pressure is important; it may have a substantial impact on performance.</span>
<span class="cm"> *</span>
<span class="cm"> * If the firmware is compiled with static addresses, then @da should specify</span>
<span class="cm"> * the expected device address of this memory region. If @da is set to</span>
<span class="cm"> * FW_RSC_ADDR_ANY, then the host will dynamically allocate it, and then</span>
<span class="cm"> * overwrite @da with the dynamically allocated address.</span>
<span class="cm"> *</span>
<span class="cm"> * We will always use @da to negotiate the device addresses, even if it</span>
<span class="cm"> * isn&#39;t using an iommu. In that case, though, it will obviously contain</span>
<span class="cm"> * physical addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * Some remote processors needs to know the allocated physical address</span>
<span class="cm"> * even if they do use an iommu. This is needed, e.g., if they control</span>
<span class="cm"> * hardware accelerators which access the physical memory directly (this</span>
<span class="cm"> * is the case with OMAP4 for instance). In that case, the host will</span>
<span class="cm"> * overwrite @pa with the dynamically allocated physical address.</span>
<span class="cm"> * Generally we don&#39;t want to expose physical addresses if we don&#39;t have to</span>
<span class="cm"> * (remote processors are generally _not_ trusted), so we might want to</span>
<span class="cm"> * change this to happen _only_ when explicitly required by the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> * @flags is used to provide IOMMU protection flags, and @name should</span>
<span class="cm"> * (optionally) contain a human readable name of this carveout region</span>
<span class="cm"> * (mainly for debugging purposes).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_rsc_carveout</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">da</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_rsc_devmem - iommu mapping request</span>
<span class="cm"> * @da: device address</span>
<span class="cm"> * @pa: physical address</span>
<span class="cm"> * @len: length (in bytes)</span>
<span class="cm"> * @flags: iommu protection flags</span>
<span class="cm"> * @reserved: reserved (must be zero)</span>
<span class="cm"> * @name: human-readable name of the requested region to be mapped</span>
<span class="cm"> *</span>
<span class="cm"> * This resource entry requests the host to iommu map a physically contiguous</span>
<span class="cm"> * memory region. This is needed in case the remote processor requires</span>
<span class="cm"> * access to certain memory-based peripherals; _never_ use it to access</span>
<span class="cm"> * regular memory.</span>
<span class="cm"> *</span>
<span class="cm"> * This is obviously only needed if the remote processor is accessing memory</span>
<span class="cm"> * via an iommu.</span>
<span class="cm"> *</span>
<span class="cm"> * @da should specify the required device address, @pa should specify</span>
<span class="cm"> * the physical address we want to map, @len should specify the size of</span>
<span class="cm"> * the mapping and @flags is the IOMMU protection flags. As always, @name may</span>
<span class="cm"> * (optionally) contain a human readable name of this mapping (mainly for</span>
<span class="cm"> * debugging purposes).</span>
<span class="cm"> *</span>
<span class="cm"> * Note: at this point we just &quot;trust&quot; those devmem entries to contain valid</span>
<span class="cm"> * physical addresses, but this isn&#39;t safe and will be changed: eventually we</span>
<span class="cm"> * want remoteproc implementations to provide us ranges of physical addresses</span>
<span class="cm"> * the firmware is allowed to request, and not allow firmwares to request</span>
<span class="cm"> * access to physical addresses that are outside those ranges.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_rsc_devmem</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">da</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pa</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_rsc_trace - trace buffer declaration</span>
<span class="cm"> * @da: device address</span>
<span class="cm"> * @len: length (in bytes)</span>
<span class="cm"> * @reserved: reserved (must be zero)</span>
<span class="cm"> * @name: human-readable name of the trace buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This resource entry provides the host information about a trace buffer</span>
<span class="cm"> * into which the remote processor will write log messages.</span>
<span class="cm"> *</span>
<span class="cm"> * @da specifies the device address of the buffer, @len specifies</span>
<span class="cm"> * its size, and @name may contain a human readable name of the trace buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * After booting the remote processor, the trace buffers are exposed to the</span>
<span class="cm"> * user via debugfs entries (called trace0, trace1, etc..).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_rsc_trace</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">da</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_rsc_vdev_vring - vring descriptor entry</span>
<span class="cm"> * @da: device address</span>
<span class="cm"> * @align: the alignment between the consumer and producer parts of the vring</span>
<span class="cm"> * @num: num of buffers supported by this vring (must be power of two)</span>
<span class="cm"> * @notifyid is a unique rproc-wide notify index for this vring. This notify</span>
<span class="cm"> * index is used when kicking a remote processor, to let it know that this</span>
<span class="cm"> * vring is triggered.</span>
<span class="cm"> * @reserved: reserved (must be zero)</span>
<span class="cm"> *</span>
<span class="cm"> * This descriptor is not a resource entry by itself; it is part of the</span>
<span class="cm"> * vdev resource type (see below).</span>
<span class="cm"> *</span>
<span class="cm"> * Note that @da should either contain the device address where</span>
<span class="cm"> * the remote processor is expecting the vring, or indicate that</span>
<span class="cm"> * dynamically allocation of the vring&#39;s device address is supported.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_rsc_vdev_vring</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">da</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">align</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">notifyid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct fw_rsc_vdev - virtio device header</span>
<span class="cm"> * @id: virtio device id (as in virtio_ids.h)</span>
<span class="cm"> * @notifyid is a unique rproc-wide notify index for this vdev. This notify</span>
<span class="cm"> * index is used when kicking a remote processor, to let it know that the</span>
<span class="cm"> * status/features of this vdev have changes.</span>
<span class="cm"> * @dfeatures specifies the virtio device features supported by the firmware</span>
<span class="cm"> * @gfeatures is a place holder used by the host to write back the</span>
<span class="cm"> * negotiated features that are supported by both sides.</span>
<span class="cm"> * @config_len is the size of the virtio config space of this vdev. The config</span>
<span class="cm"> * space lies in the resource table immediate after this vdev header.</span>
<span class="cm"> * @status is a place holder where the host will indicate its virtio progress.</span>
<span class="cm"> * @num_of_vrings indicates how many vrings are described in this vdev header</span>
<span class="cm"> * @reserved: reserved (must be zero)</span>
<span class="cm"> * @vring is an array of @num_of_vrings entries of &#39;struct fw_rsc_vdev_vring&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * This resource is a virtio device header: it provides information about</span>
<span class="cm"> * the vdev, and is then used by the host and its peer remote processors</span>
<span class="cm"> * to negotiate and share certain virtio properties.</span>
<span class="cm"> *</span>
<span class="cm"> * By providing this resource entry, the firmware essentially asks remoteproc</span>
<span class="cm"> * to statically allocate a vdev upon registration of the rproc (dynamic vdev</span>
<span class="cm"> * allocation is not yet supported).</span>
<span class="cm"> *</span>
<span class="cm"> * Note: unlike virtualization systems, the term &#39;host&#39; here means</span>
<span class="cm"> * the Linux side which is running remoteproc to control the remote</span>
<span class="cm"> * processors. We use the name &#39;gfeatures&#39; to comply with virtio&#39;s terms,</span>
<span class="cm"> * though there isn&#39;t really any virtualized guest OS here: it&#39;s the host</span>
<span class="cm"> * which is responsible for negotiating the final features.</span>
<span class="cm"> * Yeah, it&#39;s a bit confusing.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: immediately following this structure is the virtio config space for</span>
<span class="cm"> * this vdev (which is specific to the vdev; for more info, read the virtio</span>
<span class="cm"> * spec). the size of the config space is specified by @config_len.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fw_rsc_vdev</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">notifyid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dfeatures</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gfeatures</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">config_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_of_vrings</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">fw_rsc_vdev_vring</span> <span class="n">vring</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct rproc_mem_entry - memory entry descriptor</span>
<span class="cm"> * @va:	virtual address</span>
<span class="cm"> * @dma: dma address</span>
<span class="cm"> * @len: length, in bytes</span>
<span class="cm"> * @da: device address</span>
<span class="cm"> * @priv: associated data</span>
<span class="cm"> * @node: list node</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rproc_mem_entry</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">da</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rproc</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct rproc_ops - platform-specific device handlers</span>
<span class="cm"> * @start:	power on the device and boot it</span>
<span class="cm"> * @stop:	power off the device</span>
<span class="cm"> * @kick:	kick a virtqueue (virtqueue id given as a parameter)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rproc_ops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kick</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vqid</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * enum rproc_state - remote processor states</span>
<span class="cm"> * @RPROC_OFFLINE:	device is powered off</span>
<span class="cm"> * @RPROC_SUSPENDED:	device is suspended; needs to be woken up to receive</span>
<span class="cm"> *			a message.</span>
<span class="cm"> * @RPROC_RUNNING:	device is up and running</span>
<span class="cm"> * @RPROC_CRASHED:	device has crashed; need to start recovery</span>
<span class="cm"> * @RPROC_LAST:		just keep this one at the end</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that the values of these states are used as indices</span>
<span class="cm"> * to rproc_state_string, a state-to-name lookup table,</span>
<span class="cm"> * so please keep the two synchronized. @RPROC_LAST is used to check</span>
<span class="cm"> * the validity of an index before the lookup table is accessed, so</span>
<span class="cm"> * please update it as needed too.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">rproc_state</span> <span class="p">{</span>
	<span class="n">RPROC_OFFLINE</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RPROC_SUSPENDED</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RPROC_RUNNING</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">RPROC_CRASHED</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">RPROC_LAST</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rproc - represents a physical remote processor device</span>
<span class="cm"> * @node: klist node of this rproc object</span>
<span class="cm"> * @domain: iommu domain</span>
<span class="cm"> * @name: human readable name of the rproc</span>
<span class="cm"> * @firmware: name of firmware file to be loaded</span>
<span class="cm"> * @priv: private data which belongs to the platform-specific rproc module</span>
<span class="cm"> * @ops: platform-specific start/stop rproc handlers</span>
<span class="cm"> * @dev: underlying device</span>
<span class="cm"> * @refcount: refcount of users that have a valid pointer to this rproc</span>
<span class="cm"> * @power: refcount of users who need this rproc powered up</span>
<span class="cm"> * @state: state of the device</span>
<span class="cm"> * @lock: lock which protects concurrent manipulations of the rproc</span>
<span class="cm"> * @dbg_dir: debugfs directory of this rproc device</span>
<span class="cm"> * @traces: list of trace buffers</span>
<span class="cm"> * @num_traces: number of trace buffers</span>
<span class="cm"> * @carveouts: list of physically contiguous memory allocations</span>
<span class="cm"> * @mappings: list of iommu mappings we initiated, needed on shutdown</span>
<span class="cm"> * @firmware_loading_complete: marks e/o asynchronous firmware loading</span>
<span class="cm"> * @bootaddr: address of first instruction to boot rproc with (optional)</span>
<span class="cm"> * @rvdevs: list of remote virtio devices</span>
<span class="cm"> * @notifyids: idr for dynamically assigning rproc-wide unique notify ids</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rproc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">klist_node</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iommu_domain</span> <span class="o">*</span><span class="n">domain</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">firmware</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rproc_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">refcount</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">power</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dbg_dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">traces</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_traces</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">carveouts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mappings</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">firmware_loading_complete</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bootaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rvdevs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idr</span> <span class="n">notifyids</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* we currently support only two vrings per rvdev */</span>
<span class="cp">#define RVDEV_NUM_VRINGS 2</span>

<span class="cm">/**</span>
<span class="cm"> * struct rproc_vring - remoteproc vring state</span>
<span class="cm"> * @va:	virtual address</span>
<span class="cm"> * @dma: dma address</span>
<span class="cm"> * @len: length, in bytes</span>
<span class="cm"> * @da: device address</span>
<span class="cm"> * @align: vring alignment</span>
<span class="cm"> * @notifyid: rproc-specific unique vring index</span>
<span class="cm"> * @rvdev: remote vdev</span>
<span class="cm"> * @vq: the virtqueue of this vring</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rproc_vring</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">da</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">align</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">notifyid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="o">*</span><span class="n">rvdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtqueue</span> <span class="o">*</span><span class="n">vq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rproc_vdev - remoteproc state for a supported virtio device</span>
<span class="cm"> * @node: list node</span>
<span class="cm"> * @rproc: the rproc handle</span>
<span class="cm"> * @vdev: the virio device</span>
<span class="cm"> * @vring: the vrings for this vdev</span>
<span class="cm"> * @dfeatures: virtio device features</span>
<span class="cm"> * @gfeatures: virtio guest features</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_device</span> <span class="n">vdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rproc_vring</span> <span class="n">vring</span><span class="p">[</span><span class="n">RVDEV_NUM_VRINGS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dfeatures</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gfeatures</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc_get_by_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rproc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">rproc_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">firmware</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rproc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rproc_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">rproc_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">rproc_boot</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rproc_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="n">rproc</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="o">*</span><span class="nf">vdev_to_rvdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rproc_vdev</span><span class="p">,</span> <span class="n">vdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rproc</span> <span class="o">*</span><span class="nf">vdev_to_rproc</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_device</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rproc_vdev</span> <span class="o">*</span><span class="n">rvdev</span> <span class="o">=</span> <span class="n">vdev_to_rvdev</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rvdev</span><span class="o">-&gt;</span><span class="n">rproc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* REMOTEPROC_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
