<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mtd › bbm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bbm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/include/linux/mtd/bbm.h</span>
<span class="cm"> *</span>
<span class="cm"> *  NAND family Bad Block Management (BBM) header file</span>
<span class="cm"> *    - Bad Block Table (BBT) implementation</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright © 2005 Samsung Electronics</span>
<span class="cm"> *  Kyungmin Park &lt;kyungmin.park@samsung.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright © 2000-2005</span>
<span class="cm"> *  Thomas Gleixner &lt;tglx@linuxtronix.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LINUX_MTD_BBM_H</span>
<span class="cp">#define __LINUX_MTD_BBM_H</span>

<span class="cm">/* The maximum number of NAND chips in an array */</span>
<span class="cp">#define NAND_MAX_CHIPS		8</span>

<span class="cm">/**</span>
<span class="cm"> * struct nand_bbt_descr - bad block table descriptor</span>
<span class="cm"> * @options:	options for this descriptor</span>
<span class="cm"> * @pages:	the page(s) where we find the bbt, used with option BBT_ABSPAGE</span>
<span class="cm"> *		when bbt is searched, then we store the found bbts pages here.</span>
<span class="cm"> *		Its an array and supports up to 8 chips now</span>
<span class="cm"> * @offs:	offset of the pattern in the oob area of the page</span>
<span class="cm"> * @veroffs:	offset of the bbt version counter in the oob are of the page</span>
<span class="cm"> * @version:	version read from the bbt page during scan</span>
<span class="cm"> * @len:	length of the pattern, if 0 no pattern check is performed</span>
<span class="cm"> * @maxblocks:	maximum number of blocks to search for a bbt. This number of</span>
<span class="cm"> *		blocks is reserved at the end of the device where the tables are</span>
<span class="cm"> *		written.</span>
<span class="cm"> * @reserved_block_code: if non-0, this pattern denotes a reserved (rather than</span>
<span class="cm"> *              bad) block in the stored bbt</span>
<span class="cm"> * @pattern:	pattern to identify bad block table or factory marked good /</span>
<span class="cm"> *		bad blocks, can be NULL, if len = 0</span>
<span class="cm"> *</span>
<span class="cm"> * Descriptor for the bad block table marker and the descriptor for the</span>
<span class="cm"> * pattern which identifies good and bad blocks. The assumption is made</span>
<span class="cm"> * that the pattern and the version count are always located in the oob area</span>
<span class="cm"> * of the first block.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">options</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pages</span><span class="p">[</span><span class="n">NAND_MAX_CHIPS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">veroffs</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">version</span><span class="p">[</span><span class="n">NAND_MAX_CHIPS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxblocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reserved_block_code</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pattern</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Options for the bad block table descriptors */</span>

<span class="cm">/* The number of bits used per block in the bbt on the device */</span>
<span class="cp">#define NAND_BBT_NRBITS_MSK	0x0000000F</span>
<span class="cp">#define NAND_BBT_1BIT		0x00000001</span>
<span class="cp">#define NAND_BBT_2BIT		0x00000002</span>
<span class="cp">#define NAND_BBT_4BIT		0x00000004</span>
<span class="cp">#define NAND_BBT_8BIT		0x00000008</span>
<span class="cm">/* The bad block table is in the last good block of the device */</span>
<span class="cp">#define NAND_BBT_LASTBLOCK	0x00000010</span>
<span class="cm">/* The bbt is at the given page, else we must scan for the bbt */</span>
<span class="cp">#define NAND_BBT_ABSPAGE	0x00000020</span>
<span class="cm">/* The bbt is at the given page, else we must scan for the bbt */</span>
<span class="cp">#define NAND_BBT_SEARCH		0x00000040</span>
<span class="cm">/* bbt is stored per chip on multichip devices */</span>
<span class="cp">#define NAND_BBT_PERCHIP	0x00000080</span>
<span class="cm">/* bbt has a version counter at offset veroffs */</span>
<span class="cp">#define NAND_BBT_VERSION	0x00000100</span>
<span class="cm">/* Create a bbt if none exists */</span>
<span class="cp">#define NAND_BBT_CREATE		0x00000200</span>
<span class="cm">/*</span>
<span class="cm"> * Create an empty BBT with no vendor information. Vendor&#39;s information may be</span>
<span class="cm"> * unavailable, for example, if the NAND controller has a different data and OOB</span>
<span class="cm"> * layout or if this information is already purged. Must be used in conjunction</span>
<span class="cm"> * with NAND_BBT_CREATE.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_BBT_CREATE_EMPTY	0x00000400</span>
<span class="cm">/* Search good / bad pattern through all pages of a block */</span>
<span class="cp">#define NAND_BBT_SCANALLPAGES	0x00000800</span>
<span class="cm">/* Scan block empty during good / bad block scan */</span>
<span class="cp">#define NAND_BBT_SCANEMPTY	0x00001000</span>
<span class="cm">/* Write bbt if neccecary */</span>
<span class="cp">#define NAND_BBT_WRITE		0x00002000</span>
<span class="cm">/* Read and write back block contents when writing bbt */</span>
<span class="cp">#define NAND_BBT_SAVECONTENT	0x00004000</span>
<span class="cm">/* Search good / bad pattern on the first and the second page */</span>
<span class="cp">#define NAND_BBT_SCAN2NDPAGE	0x00008000</span>
<span class="cm">/* Search good / bad pattern on the last page of the eraseblock */</span>
<span class="cp">#define NAND_BBT_SCANLASTPAGE	0x00010000</span>
<span class="cm">/*</span>
<span class="cm"> * Use a flash based bad block table. By default, OOB identifier is saved in</span>
<span class="cm"> * OOB area. This option is passed to the default bad block table function.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_BBT_USE_FLASH	0x00020000</span>
<span class="cm">/* Do not store flash based bad block table in OOB area; store it in-band */</span>
<span class="cp">#define NAND_BBT_NO_OOB		0x00040000</span>
<span class="cm">/*</span>
<span class="cm"> * Do not write new bad block markers to OOB; useful, e.g., when ECC covers</span>
<span class="cm"> * entire spare area. Must be used with NAND_BBT_USE_FLASH.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_BBT_NO_OOB_BBM	0x00080000</span>

<span class="cm">/*</span>
<span class="cm"> * Flag set by nand_create_default_bbt_descr(), marking that the nand_bbt_descr</span>
<span class="cm"> * was allocated dynamicaly and must be freed in nand_release(). Has no meaning</span>
<span class="cm"> * in nand_chip.bbt_options.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_BBT_DYNAMICSTRUCT	0x80000000</span>

<span class="cm">/* The maximum number of blocks to scan for a bbt */</span>
<span class="cp">#define NAND_BBT_SCAN_MAXBLOCKS	4</span>

<span class="cm">/*</span>
<span class="cm"> * Constants for oob configuration</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_SMALL_BADBLOCK_POS		5</span>
<span class="cp">#define NAND_LARGE_BADBLOCK_POS		0</span>
<span class="cp">#define ONENAND_BADBLOCK_POS		0</span>

<span class="cm">/*</span>
<span class="cm"> * Bad block scanning errors</span>
<span class="cm"> */</span>
<span class="cp">#define ONENAND_BBT_READ_ERROR		1</span>
<span class="cp">#define ONENAND_BBT_READ_ECC_ERROR	2</span>
<span class="cp">#define ONENAND_BBT_READ_FATAL_ERROR	4</span>

<span class="cm">/**</span>
<span class="cm"> * struct bbm_info - [GENERIC] Bad Block Table data structure</span>
<span class="cm"> * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry</span>
<span class="cm"> * @badblockpos:	[INTERN] position of the bad block marker in the oob area</span>
<span class="cm"> * @options:		options for this descriptor</span>
<span class="cm"> * @bbt:		[INTERN] bad block table pointer</span>
<span class="cm"> * @isbad_bbt:		function to determine if a block is bad</span>
<span class="cm"> * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for</span>
<span class="cm"> *			initial bad block scan</span>
<span class="cm"> * @priv:		[OPTIONAL] pointer to private bbm date</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bbm_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">bbt_erase_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">badblockpos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">options</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bbt</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">isbad_bbt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">allowbbt</span><span class="p">);</span>

	<span class="cm">/* TODO Add more NAND specific fileds */</span>
	<span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="o">*</span><span class="n">badblock_pattern</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* OneNAND BBT interface */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">onenand_scan_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="o">*</span><span class="n">bd</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">onenand_default_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* __LINUX_MTD_BBM_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
