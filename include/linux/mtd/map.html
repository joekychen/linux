<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mtd › map.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>map.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright © 2000-2010 David Woodhouse &lt;dwmw2@infradead.org&gt; et al.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/* Overhauled routines for dealing with different mmap regions of flash */</span>

<span class="cp">#ifndef __LINUX_MTD_MAP_H__</span>
<span class="cp">#define __LINUX_MTD_MAP_H__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/bug.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/barrier.h&gt;</span>

<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_1</span>
<span class="cp">#define map_bankwidth(map) 1</span>
<span class="cp">#define map_bankwidth_is_1(map) (map_bankwidth(map) == 1)</span>
<span class="cp">#define map_bankwidth_is_large(map) (0)</span>
<span class="cp">#define map_words(map) (1)</span>
<span class="cp">#define MAX_MAP_BANKWIDTH 1</span>
<span class="cp">#else</span>
<span class="cp">#define map_bankwidth_is_1(map) (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_2</span>
<span class="cp"># ifdef map_bankwidth</span>
<span class="cp">#  undef map_bankwidth</span>
<span class="cp">#  define map_bankwidth(map) ((map)-&gt;bankwidth)</span>
<span class="cp"># else</span>
<span class="cp">#  define map_bankwidth(map) 2</span>
<span class="cp">#  define map_bankwidth_is_large(map) (0)</span>
<span class="cp">#  define map_words(map) (1)</span>
<span class="cp"># endif</span>
<span class="cp">#define map_bankwidth_is_2(map) (map_bankwidth(map) == 2)</span>
<span class="cp">#undef MAX_MAP_BANKWIDTH</span>
<span class="cp">#define MAX_MAP_BANKWIDTH 2</span>
<span class="cp">#else</span>
<span class="cp">#define map_bankwidth_is_2(map) (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_4</span>
<span class="cp"># ifdef map_bankwidth</span>
<span class="cp">#  undef map_bankwidth</span>
<span class="cp">#  define map_bankwidth(map) ((map)-&gt;bankwidth)</span>
<span class="cp"># else</span>
<span class="cp">#  define map_bankwidth(map) 4</span>
<span class="cp">#  define map_bankwidth_is_large(map) (0)</span>
<span class="cp">#  define map_words(map) (1)</span>
<span class="cp"># endif</span>
<span class="cp">#define map_bankwidth_is_4(map) (map_bankwidth(map) == 4)</span>
<span class="cp">#undef MAX_MAP_BANKWIDTH</span>
<span class="cp">#define MAX_MAP_BANKWIDTH 4</span>
<span class="cp">#else</span>
<span class="cp">#define map_bankwidth_is_4(map) (0)</span>
<span class="cp">#endif</span>

<span class="cm">/* ensure we never evaluate anything shorted than an unsigned long</span>
<span class="cm"> * to zero, and ensure we&#39;ll never miss the end of an comparison (bjd) */</span>

<span class="cp">#define map_calc_words(map) ((map_bankwidth(map) + (sizeof(unsigned long)-1))/ sizeof(unsigned long))</span>

<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_8</span>
<span class="cp"># ifdef map_bankwidth</span>
<span class="cp">#  undef map_bankwidth</span>
<span class="cp">#  define map_bankwidth(map) ((map)-&gt;bankwidth)</span>
<span class="cp">#  if BITS_PER_LONG &lt; 64</span>
<span class="cp">#   undef map_bankwidth_is_large</span>
<span class="cp">#   define map_bankwidth_is_large(map) (map_bankwidth(map) &gt; BITS_PER_LONG/8)</span>
<span class="cp">#   undef map_words</span>
<span class="cp">#   define map_words(map) map_calc_words(map)</span>
<span class="cp">#  endif</span>
<span class="cp"># else</span>
<span class="cp">#  define map_bankwidth(map) 8</span>
<span class="cp">#  define map_bankwidth_is_large(map) (BITS_PER_LONG &lt; 64)</span>
<span class="cp">#  define map_words(map) map_calc_words(map)</span>
<span class="cp"># endif</span>
<span class="cp">#define map_bankwidth_is_8(map) (map_bankwidth(map) == 8)</span>
<span class="cp">#undef MAX_MAP_BANKWIDTH</span>
<span class="cp">#define MAX_MAP_BANKWIDTH 8</span>
<span class="cp">#else</span>
<span class="cp">#define map_bankwidth_is_8(map) (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_16</span>
<span class="cp"># ifdef map_bankwidth</span>
<span class="cp">#  undef map_bankwidth</span>
<span class="cp">#  define map_bankwidth(map) ((map)-&gt;bankwidth)</span>
<span class="cp">#  undef map_bankwidth_is_large</span>
<span class="cp">#  define map_bankwidth_is_large(map) (map_bankwidth(map) &gt; BITS_PER_LONG/8)</span>
<span class="cp">#  undef map_words</span>
<span class="cp">#  define map_words(map) map_calc_words(map)</span>
<span class="cp"># else</span>
<span class="cp">#  define map_bankwidth(map) 16</span>
<span class="cp">#  define map_bankwidth_is_large(map) (1)</span>
<span class="cp">#  define map_words(map) map_calc_words(map)</span>
<span class="cp"># endif</span>
<span class="cp">#define map_bankwidth_is_16(map) (map_bankwidth(map) == 16)</span>
<span class="cp">#undef MAX_MAP_BANKWIDTH</span>
<span class="cp">#define MAX_MAP_BANKWIDTH 16</span>
<span class="cp">#else</span>
<span class="cp">#define map_bankwidth_is_16(map) (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_32</span>
<span class="cp"># ifdef map_bankwidth</span>
<span class="cp">#  undef map_bankwidth</span>
<span class="cp">#  define map_bankwidth(map) ((map)-&gt;bankwidth)</span>
<span class="cp">#  undef map_bankwidth_is_large</span>
<span class="cp">#  define map_bankwidth_is_large(map) (map_bankwidth(map) &gt; BITS_PER_LONG/8)</span>
<span class="cp">#  undef map_words</span>
<span class="cp">#  define map_words(map) map_calc_words(map)</span>
<span class="cp"># else</span>
<span class="cp">#  define map_bankwidth(map) 32</span>
<span class="cp">#  define map_bankwidth_is_large(map) (1)</span>
<span class="cp">#  define map_words(map) map_calc_words(map)</span>
<span class="cp"># endif</span>
<span class="cp">#define map_bankwidth_is_32(map) (map_bankwidth(map) == 32)</span>
<span class="cp">#undef MAX_MAP_BANKWIDTH</span>
<span class="cp">#define MAX_MAP_BANKWIDTH 32</span>
<span class="cp">#else</span>
<span class="cp">#define map_bankwidth_is_32(map) (0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef map_bankwidth</span>
<span class="cp">#warning &quot;No CONFIG_MTD_MAP_BANK_WIDTH_xx selected. No NOR chip support can work&quot;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">map_bankwidth</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define map_bankwidth_is_large(map) (0)</span>
<span class="cp">#define map_words(map) (0)</span>
<span class="cp">#define MAX_MAP_BANKWIDTH 1</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">map_bankwidth_supported</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_1</span>
	<span class="k">case</span> <span class="mi">1</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_2</span>
	<span class="k">case</span> <span class="mi">2</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_4</span>
	<span class="k">case</span> <span class="mi">4</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_8</span>
	<span class="k">case</span> <span class="mi">8</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_16</span>
	<span class="k">case</span> <span class="mi">16</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_MTD_MAP_BANK_WIDTH_32</span>
	<span class="k">case</span> <span class="mi">32</span>:
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define MAX_MAP_LONGS ( ((MAX_MAP_BANKWIDTH*8) + BITS_PER_LONG - 1) / BITS_PER_LONG )</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">[</span><span class="n">MAX_MAP_LONGS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">map_word</span><span class="p">;</span>

<span class="cm">/* The map stuff is very simple. You fill in your struct map_info with</span>
<span class="cm">   a handful of routines for accessing the device, making sure they handle</span>
<span class="cm">   paging etc. correctly if your device needs it. Then you pass it off</span>
<span class="cm">   to a chip probe routine -- either JEDEC or CFI probe or both -- via</span>
<span class="cm">   do_map_probe(). If a chip is recognised, the probe code will invoke the</span>
<span class="cm">   appropriate chip driver (if present) and return a struct mtd_info.</span>
<span class="cm">   At which point, you fill in the mtd-&gt;module with your own module</span>
<span class="cm">   address, and register it with the MTD core code. Or you could partition</span>
<span class="cm">   it and register the partitions instead, or keep it for your own private</span>
<span class="cm">   use; whatever.</span>

<span class="cm">   The mtd-&gt;priv field will point to the struct map_info, and any further</span>
<span class="cm">   private data required by the chip driver is linked from the</span>
<span class="cm">   mtd-&gt;priv-&gt;fldrv_priv field. This allows the map driver to get at</span>
<span class="cm">   the destructor function map-&gt;fldrv_destroy() when it&#39;s tired</span>
<span class="cm">   of living.</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="n">map_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">phys</span><span class="p">;</span>
<span class="cp">#define NO_XIP (-1UL)</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">virt</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cached</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">swap</span><span class="p">;</span> <span class="cm">/* this mapping&#39;s byte-swapping requirement */</span>
	<span class="kt">int</span> <span class="n">bankwidth</span><span class="p">;</span> <span class="cm">/* in octets. This isn&#39;t necessarily the width</span>
<span class="cm">		       of actual bus cycles -- it&#39;s the repeat interval</span>
<span class="cm">		      in bytes, before you are talking to the first chip again.</span>
<span class="cm">		      */</span>

<span class="cp">#ifdef CONFIG_MTD_COMPLEX_MAPPINGS</span>
	<span class="n">map_word</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy_from</span><span class="p">)(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">ssize_t</span><span class="p">);</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">map_word</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy_to</span><span class="p">)(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">ssize_t</span><span class="p">);</span>

	<span class="cm">/* We can perhaps put in &#39;point&#39; and &#39;unpoint&#39; methods, if we really</span>
<span class="cm">	   want to enable XIP for non-linear mappings. Not yet though. */</span>
<span class="cp">#endif</span>
	<span class="cm">/* It&#39;s possible for the map driver to use cached memory in its</span>
<span class="cm">	   copy_from implementation (and _only_ with copy_from).  However,</span>
<span class="cm">	   when the chip driver knows some flash area has changed contents,</span>
<span class="cm">	   it will signal it to the map driver through this routine to let</span>
<span class="cm">	   the map driver invalidate the corresponding cache as needed.</span>
<span class="cm">	   If there is no cache to care about this can be set to NULL. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">inval_cache</span><span class="p">)(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">ssize_t</span><span class="p">);</span>

	<span class="cm">/* set_vpp() must handle being reentered -- enable, enable, disable</span>
<span class="cm">	   must leave it enabled. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_vpp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfow_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">map_priv_1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">map_priv_2</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_chip_driver</span> <span class="o">*</span><span class="n">fldrv</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mtd_chip_driver</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">register_mtd_chip_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_chip_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">unregister_mtd_chip_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_chip_driver</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">do_map_probe</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">map_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">);</span>

<span class="cp">#define ENABLE_VPP(map) do { if(map-&gt;set_vpp) map-&gt;set_vpp(map, 1); } while(0)</span>
<span class="cp">#define DISABLE_VPP(map) do { if(map-&gt;set_vpp) map-&gt;set_vpp(map, 0); } while(0)</span>

<span class="cp">#define INVALIDATE_CACHED_RANGE(map, from, size) \</span>
<span class="cp">	do { if(map-&gt;inval_cache) map-&gt;inval_cache(map, from, size); } while(0)</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">map_word_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val1</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">map_words</span><span class="p">(</span><span class="n">map</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val1</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">val2</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">map_word</span> <span class="nf">map_word_and</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val1</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_word</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">map_words</span><span class="p">(</span><span class="n">map</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">val2</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">map_word</span> <span class="nf">map_word_clr</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val1</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_word</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">map_words</span><span class="p">(</span><span class="n">map</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">val2</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">map_word</span> <span class="nf">map_word_or</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val1</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_word</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">map_words</span><span class="p">(</span><span class="n">map</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">val2</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define map_word_andequal(m, a, b, z) map_word_equal(m, z, map_word_and(m, a, b))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">map_word_bitsset</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val1</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">val2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">map_words</span><span class="p">(</span><span class="n">map</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val1</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">val2</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">map_word</span> <span class="nf">map_word_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_word</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_1</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_2</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_4</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
<span class="cp">#if BITS_PER_LONG &gt;= 64</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_8</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_unaligned</span><span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_large</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">bankwidth</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">map_word</span> <span class="nf">map_word_load_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">orig</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_large</span><span class="p">(</span><span class="n">map</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">orig</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="o">+</span><span class="n">start</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">start</span><span class="o">+</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">bitpos</span><span class="p">;</span>
<span class="cp">#ifdef __LITTLE_ENDIAN</span>
			<span class="n">bitpos</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
<span class="cp">#else </span><span class="cm">/* __BIG_ENDIAN */</span><span class="cp"></span>
			<span class="n">bitpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="n">orig</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xff</span> <span class="o">&lt;&lt;</span> <span class="n">bitpos</span><span class="p">);</span>
			<span class="n">orig</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">bitpos</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">orig</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if BITS_PER_LONG &lt; 64</span>
<span class="cp">#define MAP_FF_LIMIT 4</span>
<span class="cp">#else</span>
<span class="cp">#define MAP_FF_LIMIT 8</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">map_word</span> <span class="nf">map_word_ff</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_word</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAP_FF_LIMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bw</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bw</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">map_words</span><span class="p">(</span><span class="n">map</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">map_word</span> <span class="nf">inline_map_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_word</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_1</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readb</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_2</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readw</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_4</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="cp">#if BITS_PER_LONG &gt;= 64</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_8</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__raw_readq</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_large</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span><span class="o">+</span><span class="n">ofs</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">bankwidth</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inline_map_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="n">map_word</span> <span class="n">datum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_1</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">__raw_writeb</span><span class="p">(</span><span class="n">datum</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_2</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">__raw_writew</span><span class="p">(</span><span class="n">datum</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_4</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">__raw_writel</span><span class="p">(</span><span class="n">datum</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="cp">#if BITS_PER_LONG &gt;= 64</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_8</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">__raw_writeq</span><span class="p">(</span><span class="n">datum</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map_bankwidth_is_large</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span><span class="o">+</span><span class="n">ofs</span><span class="p">,</span> <span class="n">datum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">bankwidth</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inline_map_copy_from</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">+</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inline_map_copy_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MTD_COMPLEX_MAPPINGS</span>
<span class="cp">#define map_read(map, ofs) (map)-&gt;read(map, ofs)</span>
<span class="cp">#define map_copy_from(map, to, from, len) (map)-&gt;copy_from(map, to, from, len)</span>
<span class="cp">#define map_write(map, datum, ofs) (map)-&gt;write(map, datum, ofs)</span>
<span class="cp">#define map_copy_to(map, to, from, len) (map)-&gt;copy_to(map, to, from, len)</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">simple_map_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#define map_is_linear(map) (map-&gt;phys != NO_XIP)</span>

<span class="cp">#else</span>
<span class="cp">#define map_read(map, ofs) inline_map_read(map, ofs)</span>
<span class="cp">#define map_copy_from(map, to, from, len) inline_map_copy_from(map, to, from, len)</span>
<span class="cp">#define map_write(map, datum, ofs) inline_map_write(map, datum, ofs)</span>
<span class="cp">#define map_copy_to(map, to, from, len) inline_map_copy_to(map, to, from, len)</span>


<span class="cp">#define simple_map_init(map) BUG_ON(!map_bankwidth_supported((map)-&gt;bankwidth))</span>
<span class="cp">#define map_is_linear(map) ({ (void)(map); 1; })</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_MTD_COMPLEX_MAPPINGS */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* __LINUX_MTD_MAP_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
