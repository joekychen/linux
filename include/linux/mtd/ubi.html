<!DOCTYPE html>
<html><head><title>joekychen/linux » include › linux › mtd › ubi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ubi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) International Business Machines Corp., 2006</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __LINUX_UBI_H__</span>
<span class="cp">#define __LINUX_UBI_H__</span>

<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;mtd/ubi-user.h&gt;</span>

<span class="cm">/* All voumes/LEBs */</span>
<span class="cp">#define UBI_ALL -1</span>

<span class="cm">/*</span>
<span class="cm"> * enum ubi_open_mode - UBI volume open mode constants.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI_READONLY: read-only mode</span>
<span class="cm"> * UBI_READWRITE: read-write mode</span>
<span class="cm"> * UBI_EXCLUSIVE: exclusive mode</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBI_READONLY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">UBI_READWRITE</span><span class="p">,</span>
	<span class="n">UBI_EXCLUSIVE</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_volume_info - UBI volume description data structure.</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @ubi_num: UBI device number this volume belongs to</span>
<span class="cm"> * @size: how many physical eraseblocks are reserved for this volume</span>
<span class="cm"> * @used_bytes: how many bytes of data this volume contains</span>
<span class="cm"> * @used_ebs: how many physical eraseblocks of this volume actually contain any</span>
<span class="cm"> *            data</span>
<span class="cm"> * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)</span>
<span class="cm"> * @corrupted: non-zero if the volume is corrupted (static volumes only)</span>
<span class="cm"> * @upd_marker: non-zero if the volume has update marker set</span>
<span class="cm"> * @alignment: volume alignment</span>
<span class="cm"> * @usable_leb_size: how many bytes are available in logical eraseblocks of</span>
<span class="cm"> *                   this volume</span>
<span class="cm"> * @name_len: volume name length</span>
<span class="cm"> * @name: volume name</span>
<span class="cm"> * @cdev: UBI volume character device major and minor numbers</span>
<span class="cm"> *</span>
<span class="cm"> * The @corrupted flag is only relevant to static volumes and is always zero</span>
<span class="cm"> * for dynamic ones. This is because UBI does not care about dynamic volume</span>
<span class="cm"> * data protection and only cares about protecting static volume data.</span>
<span class="cm"> *</span>
<span class="cm"> * The @upd_marker flag is set if the volume update operation was interrupted.</span>
<span class="cm"> * Before touching the volume data during the update operation, UBI first sets</span>
<span class="cm"> * the update marker flag for this volume. If the volume update operation was</span>
<span class="cm"> * further interrupted, the update marker indicates this. If the update marker</span>
<span class="cm"> * is set, the contents of the volume is certainly damaged and a new volume</span>
<span class="cm"> * update operation has to be started.</span>
<span class="cm"> *</span>
<span class="cm"> * To put it differently, @corrupted and @upd_marker fields have different</span>
<span class="cm"> * semantics:</span>
<span class="cm"> *     o the @corrupted flag means that this static volume is corrupted for some</span>
<span class="cm"> *       reasons, but not because an interrupted volume update</span>
<span class="cm"> *     o the @upd_marker field means that the volume is damaged because of an</span>
<span class="cm"> *       interrupted update operation.</span>
<span class="cm"> *</span>
<span class="cm"> * I.e., the @corrupted flag is never set if the @upd_marker flag is set.</span>
<span class="cm"> *</span>
<span class="cm"> * The @used_bytes and @used_ebs fields are only really needed for static</span>
<span class="cm"> * volumes and contain the number of bytes stored in this static volume and how</span>
<span class="cm"> * many eraseblock this data occupies. In case of dynamic volumes, the</span>
<span class="cm"> * @used_bytes field is equivalent to @size*@usable_leb_size, and the @used_ebs</span>
<span class="cm"> * field is equivalent to @size.</span>
<span class="cm"> *</span>
<span class="cm"> * In general, logical eraseblock size is a property of the UBI device, not</span>
<span class="cm"> * of the UBI volume. Indeed, the logical eraseblock size depends on the</span>
<span class="cm"> * physical eraseblock size and on how much bytes UBI headers consume. But</span>
<span class="cm"> * because of the volume alignment (@alignment), the usable size of logical</span>
<span class="cm"> * eraseblocks if a volume may be less. The following equation is true:</span>
<span class="cm"> *	@usable_leb_size = LEB size - (LEB size mod @alignment),</span>
<span class="cm"> * where LEB size is the logical eraseblock size defined by the UBI device.</span>
<span class="cm"> *</span>
<span class="cm"> * The alignment is multiple to the minimal flash input/output unit size or %1</span>
<span class="cm"> * if all the available space is used.</span>
<span class="cm"> *</span>
<span class="cm"> * To put this differently, alignment may be considered is a way to change</span>
<span class="cm"> * volume logical eraseblock sizes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_volume_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">ubi_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">used_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used_ebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">corrupted</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">upd_marker</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alignment</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">usable_leb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">cdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_device_info - UBI device description data structure.</span>
<span class="cm"> * @ubi_num: ubi device number</span>
<span class="cm"> * @leb_size: logical eraseblock size on this UBI device</span>
<span class="cm"> * @leb_start: starting offset of logical eraseblocks within physical</span>
<span class="cm"> *             eraseblocks</span>
<span class="cm"> * @min_io_size: minimal I/O unit size</span>
<span class="cm"> * @max_write_size: maximum amount of bytes the underlying flash can write at a</span>
<span class="cm"> *                  time (MTD write buffer size)</span>
<span class="cm"> * @ro_mode: if this device is in read-only mode</span>
<span class="cm"> * @cdev: UBI character device major and minor numbers</span>
<span class="cm"> *</span>
<span class="cm"> * Note, @leb_size is the logical eraseblock size offered by the UBI device.</span>
<span class="cm"> * Volumes of this UBI device may have smaller logical eraseblock size if their</span>
<span class="cm"> * alignment is not equivalent to %1.</span>
<span class="cm"> *</span>
<span class="cm"> * The @max_write_size field describes flash write maximum write unit. For</span>
<span class="cm"> * example, NOR flash allows for changing individual bytes, so @min_io_size is</span>
<span class="cm"> * %1. However, it does not mean than NOR flash has to write data byte-by-byte.</span>
<span class="cm"> * Instead, CFI NOR flashes have a write-buffer of, e.g., 64 bytes, and when</span>
<span class="cm"> * writing large chunks of data, they write 64-bytes at a time. Obviously, this</span>
<span class="cm"> * improves write throughput.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, the MTD device may have N interleaved (striped) flash chips</span>
<span class="cm"> * underneath, in which case @min_io_size can be physical min. I/O size of</span>
<span class="cm"> * single flash chip, while @max_write_size can be N * @min_io_size.</span>
<span class="cm"> *</span>
<span class="cm"> * The @max_write_size field is always greater or equivalent to @min_io_size.</span>
<span class="cm"> * E.g., some NOR flashes may have (@min_io_size = 1, @max_write_size = 64). In</span>
<span class="cm"> * contrast, NAND flashes usually have @min_io_size = @max_write_size = NAND</span>
<span class="cm"> * page size.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_device_info</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">ubi_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leb_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_io_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_write_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ro_mode</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">cdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Volume notification types.</span>
<span class="cm"> * @UBI_VOLUME_ADDED: a volume has been added (an UBI device was attached or a</span>
<span class="cm"> *                    volume was created)</span>
<span class="cm"> * @UBI_VOLUME_REMOVED: a volume has been removed (an UBI device was detached</span>
<span class="cm"> *			or a volume was removed)</span>
<span class="cm"> * @UBI_VOLUME_RESIZED: a volume has been re-sized</span>
<span class="cm"> * @UBI_VOLUME_RENAMED: a volume has been re-named</span>
<span class="cm"> * @UBI_VOLUME_UPDATED: data has been written to a volume</span>
<span class="cm"> *</span>
<span class="cm"> * These constants define which type of event has happened when a volume</span>
<span class="cm"> * notification function is invoked.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBI_VOLUME_ADDED</span><span class="p">,</span>
	<span class="n">UBI_VOLUME_REMOVED</span><span class="p">,</span>
	<span class="n">UBI_VOLUME_RESIZED</span><span class="p">,</span>
	<span class="n">UBI_VOLUME_RENAMED</span><span class="p">,</span>
	<span class="n">UBI_VOLUME_UPDATED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct ubi_notification - UBI notification description structure.</span>
<span class="cm"> * @di: UBI device description object</span>
<span class="cm"> * @vi: UBI volume description object</span>
<span class="cm"> *</span>
<span class="cm"> * UBI notifiers are called with a pointer to an object of this type. The</span>
<span class="cm"> * object describes the notification. Namely, it provides a description of the</span>
<span class="cm"> * UBI device and UBI volume the notification informs about.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_notification</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_device_info</span> <span class="n">di</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume_info</span> <span class="n">vi</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* UBI descriptor given to users when they open UBI volumes */</span>
<span class="k">struct</span> <span class="n">ubi_volume_desc</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">ubi_get_device_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_device_info</span> <span class="o">*</span><span class="n">di</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_get_volume_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ubi_volume_info</span> <span class="o">*</span><span class="n">vi</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">ubi_open_volume</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">ubi_open_volume_nm</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">ubi_open_volume_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ubi_register_volume_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">ignore_existing</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_unregister_volume_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ubi_close_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_leb_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_leb_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_leb_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_leb_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_leb_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_leb_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_is_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_sync</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_flush</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This function is the same as the &#39;ubi_leb_read()&#39; function, but it does not</span>
<span class="cm"> * provide the checking capability.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ubi_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ubi_leb_read</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* !__LINUX_UBI_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
